import json os
from sys import exit

resources = f"{os.environ["HOME"]}/system/etc/nixos/resources"

import os
import re
import readline

COMMANDS = ['extra', 'extension', 'stuff', 'errors',
            'email', 'foobar', 'foo']
RE_SPACE = re.compile('.*\s+$', re.M)

class Completer(object):

    def _listdir(self, root):
        "List directory 'root' appending the path separator to subdirs."
        res = []
        for name in os.listdir(root):
            path = os.path.join(root, name)
            if os.path.isdir(path):
                name += os.sep
            res.append(name)
        return res

    def _complete_path(self, path=None):
        "Perform completion of filesystem path."
        if not path:
            return self._listdir('.')
        dirname, rest = os.path.split(path)
        tmp = dirname if dirname else '.'
        res = [os.path.join(dirname, p)
                for p in self._listdir(tmp) if p.startswith(rest)]
        # more than one match, or single match which does not exist (typo)
        if len(res) > 1 or not os.path.exists(path):
            return res
        # resolved to a single directory, so return list of files below it
        if os.path.isdir(path):
            return [os.path.join(path, p) for p in self._listdir(path)]
        # exact file match terminates this completion
        return [path + ' ']

    def complete_extra(self, args):
        "Completions for the 'extra' command."
        if not args:
            return self._complete_path('.')
        # treat the last arg as a path and complete it
        return self._complete_path(args[-1])

    def complete(self, text, state):
        "Generic readline completion entry point."
        buffer = readline.get_line_buffer()
        line = readline.get_line_buffer().split()
        # show all commands
        if not line:
            return [c + ' ' for c in COMMANDS][state]
        # account for last argument ending in a space
        if RE_SPACE.match(buffer):
            line.append('')
        # resolve command to the implementation function
        cmd = line[0].strip()
        if cmd in COMMANDS:
            impl = getattr(self, 'complete_%s' % cmd)
            args = line[1:]
            if args:
                return (impl(args) + [None])[state]
            return [cmd + ' '][state]
        results = [c + ' ' for c in COMMANDS if c.startswith(cmd)] + [None]
        return results[state]

comp = Completer()
# we want to treat '/' as part of a word, so override the delimiters
readline.set_completer_delims(' \t\n;')
readline.parse_and_bind("tab: complete")
readline.set_completer(comp.complete)

print('''
    Create a new ZFS device:         c
    Mount a ZFS device:              m
    Update:                          u
            Files:                           f
            Pool:                            p
            Go back:                         g
    Generate nixos config:           g
    Include boostrap config:         b
    One-Stop Install:                a
    Rsync over bootstrap config:     r
    Begin install:                   i
    Show this help text:             h
    Setup:                           s
    Quit:                            q
    Install and Set Up Home-Manager: H
    \n\n
''')

def xrun(command):
    @(command.split())

xrun("nix-env -i sd rsync")

try:

    while true:
        pool_name = raw_input("What's the pool name?\n\t")
        if pool_name == "":
            print("Wait a minute... That's not a valid pool name! Try again, please!\n")
        elif pool_name == "quit bootstrap":
            print("Catch ya' later!")
            exit(0)
        else:
            print("Alright; let's get crackin'!\n\n")
            encrypted = raw_input('''
                Is this pool [to be] encrypted?
                    y | n\n\t
            ''') == "y"
            break

    while true:
        input = input or raw_input("Pick an option, any option! :D\n\t")
        saved_input = [c for c in input]
        input = ""
        for c in saved_input:
            if c == "c":
                if raw_input('THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\n\t') == "ZFS CREATE":

                    

                else:
                    print("Sorry; not continuing!\n\n")
            elif c == "m":

                from collections import namedtuple
                from functools import partial
                from os import path as osPath
                from subprocess import DEVNULL
                
                for dataset in $(zfs list).split("\n"):
                    if pool_name in dataset:
                        break
                else:
                    xrun(f"zpool import -f {pool_name}")
                
                if encrypted:
                    xrun(f"zfs load-key {pool_name}")
                
                if osPath.isdir("/mnt"):
                    xrun("umount -R /mnt")
                else:
                    xrun("mkdir /mnt")
                
                xrun(f"mount -t zfs {pool_name}/system/root /mnt")
                
                with open(f"{resources}/datasets.nix") as datasets:
                    for dataset in datasets.readlines()[1:-1]:
                        dataset = dataset.strip().strip('"')
                
                        r = f"{pool_name}/"
                        sr = r + "system/"
                        _mount = dataset.replace(
                            sr if sr in dataset else r,
                            '',
                            1
                        )
                
                        if not osPath.isdir(mount := f"/mnt/{_mount}"):
                            xrun(f"mkdir -p {mount}")
                        xrun(f"mount -t zfs {dataset} {mount}")
                
                if not osPath.isdir(boot := "/mnt/boot/efi"):
                    xrun(f"mkdir -p {boot}")
                
                boot_device = raw_input("Please enter the boot device:\n\t")
                xrun(f"mount {boot_device} {boot}")
                
                if (swap := (raw_input('''
                    Does this pool use SWAP?
                        y | n\n\t
                ''') == "y")):
                    xrun(f"swapon /dev/zvol/{pool_name}/swap")

            elif c == "u":
                while true:
                    input2 = raw_input('''
                        Would you like to update the resource files, or the pool?
                            f | p | [g]o back\n\t
                    ''')
                    for cc in input2:
                        if cc == "f":

                            snapDir = [ "snapdir=visible" ]
                            extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
                            cache = [ "sync=disabled" ]
                            ml = "mountpoint=legacy"
                            dd = {  }
                            ddd = { "datasets": {  }}
                            d = "datasets"
                            s = "system"
                            
                            datasets = json.loads('''
                                {
                                    "base": {  },
                                    "hold": {  },
                                    "omniverse": {  },
                                    "reserved": {  },
                                    "system": {
                                        "datasets": {
                                            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                            "nix": {  },
                                            "persist": {
                                                "datasets": {
                                                    "cache": {
                                                        "datasets": { "root": {  }},
                                                        "options": [ "sync=disabled" ]
                                                    },
                                                    "home": { "datasets": { "root": {  }}}
                                                }
                                            },
                                            "root": {  },
                                            "tmp": { "options": [ "sync=disabled" ] }
                                        },
                                        "options": [ "mountpoint=legacy" ]
                                    },
                                    "virt": {
                                        "datasets": {
                                            "docker": {  },
                                            "kvm": {  },
                                            "podman": { "datasets": {  }},
                                            "qemu": {  },
                                            "vagrant": {  },
                                            "xen": {  }
                                        },
                                        "options": [ "mountpoint=legacy", "refreservation=none" ],
                                        "mountpoint": "/var/lib"
                                    }
                                }
                            '''.strip())
                            
                            dsd = datasets[s][d]
                            
                            datasets[args.pool_name] = {
                                "datasets": {
                                    "b": {
                                        "datasets": {
                                            "a": dd,
                                            "cc": { "options": snapDir },
                                            "cl": dd,
                                            "cj": { "datasets": {
                                                "cc": { "options": extraCopies },
                                                "m": { "options": snapDir }
                                            }},
                                            "eb": { "options": extraCopies },
                                            "oreo": { "option": snapDir },
                                            "p": { "options": snapDir }
                                        },
                                    },
                                    "borg": { "datasets": { "cache": { "options": cache }}},
                                    "jails": { "datasets": { "base": dd}},
                                    "las": {
                                        "datasets": {
                                            "dreadnought": ddd,
                                            "redstone": ddd,
                                            "sinnoh": ddd
                                        }
                                    },
                                    "y": dd,
                                    "z": dd
                                },
                                "options": [ ml ]
                            }
                            
                            users = json.loads('''
                                {
                                    "primary": "shadowrylander",
                                    "secondary": "frost",
                                    "nightingale": "curtis"
                                }
                            '''.strip())
                            
                            for user in users.values():
                                dsd["home"][d][user] = dd
                                datasets["virt"][d]["podman"][d][user] = dd
                                for dataset in (persist := dsd["persist"][d]).keys():
                                    persist[dataset][d][user] = dd
                            
                            for backup in (las := datasets[pool_name][d]["las"][d]).keys():
                                for zz in [ "zpax", "zsyncs" ]:
                                    las[backup][d][zz] = dd
                            
                            with open(f"{resources}/datasets.nix", "w+") as dnix:
                            
                                dnix.write("host: {\n")
                            
                                def recurse(ddict, dname, droot, mountpoint = ""):
                            
                                    _dataset = f"{droot}/{dname}"
                            
                                    # cc: clone or create
                                    # son: snapshot or none
                                    if (dname != "base") and (encrypted and dedup):
                                        cc = "clone"
                                        son = f"{pool_name}/base@root"
                                    else:
                                        cc = "create"
                                        son = ""
                            
                                    _doptions = ddict.get("options", [])
                                    if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
                                        "system",
                                        "system/root",
                                        "swap",
                                        "base",
                                        "hold",
                                        "omniverse",
                                        "reserved",
                                    )):
                                        pn1 = pool_name
                                        pn2 = f"{pn1}/{pn1}"
                            
                                        # TODO: Make this such that the current dataset directory
                                        #       is placed under the parent directory's mountpoint
                                        if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                                            if mountpoint = "":
                                                _mountpoint = _dataset.replace(
                                                    pn2 if pn2 in _dataset else pn1
                                                    "${host}",
                                                    1
                                                )
                                            else:
                                                mountpoint = _mountpoint = f"{mountpoint}/{dname}"
                            
                                        dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                                    doptions = " -o ".join(_doptions)
                            
                            
                            
                                for dataset in (ddictd := ddict.get(
                                    d,
                                    dd
                                )):
                                    recurse(ddictd[dataset], dataset, _dataset, mountpoint)
                            
                            for dataset in datasets:
                                recurse(datasets[dataset], dataset, pool_name)
                            
                            dnix.write("}")
                            

                        elif cc == "p":

                            snapDir = [ "snapdir=visible" ]
                            extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
                            cache = [ "sync=disabled" ]
                            ml = "mountpoint=legacy"
                            dd = {  }
                            ddd = { "datasets": {  }}
                            d = "datasets"
                            s = "system"
                            
                            datasets = json.loads('''
                                {
                                    "base": {  },
                                    "hold": {  },
                                    "omniverse": {  },
                                    "reserved": {  },
                                    "system": {
                                        "datasets": {
                                            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                            "nix": {  },
                                            "persist": {
                                                "datasets": {
                                                    "cache": {
                                                        "datasets": { "root": {  }},
                                                        "options": [ "sync=disabled" ]
                                                    },
                                                    "home": { "datasets": { "root": {  }}}
                                                }
                                            },
                                            "root": {  },
                                            "tmp": { "options": [ "sync=disabled" ] }
                                        },
                                        "options": [ "mountpoint=legacy" ]
                                    },
                                    "virt": {
                                        "datasets": {
                                            "docker": {  },
                                            "kvm": {  },
                                            "podman": { "datasets": {  }},
                                            "qemu": {  },
                                            "vagrant": {  },
                                            "xen": {  }
                                        },
                                        "options": [ "mountpoint=legacy", "refreservation=none" ],
                                        "mountpoint": "/var/lib"
                                    }
                                }
                            '''.strip())
                            
                            dsd = datasets[s][d]
                            
                            datasets[args.pool_name] = {
                                "datasets": {
                                    "b": {
                                        "datasets": {
                                            "a": dd,
                                            "cc": { "options": snapDir },
                                            "cl": dd,
                                            "cj": { "datasets": {
                                                "cc": { "options": extraCopies },
                                                "m": { "options": snapDir }
                                            }},
                                            "eb": { "options": extraCopies },
                                            "oreo": { "option": snapDir },
                                            "p": { "options": snapDir }
                                        },
                                    },
                                    "borg": { "datasets": { "cache": { "options": cache }}},
                                    "jails": { "datasets": { "base": dd}},
                                    "las": {
                                        "datasets": {
                                            "dreadnought": ddd,
                                            "redstone": ddd,
                                            "sinnoh": ddd
                                        }
                                    },
                                    "y": dd,
                                    "z": dd
                                },
                                "options": [ ml ]
                            }
                            
                            users = json.loads('''
                                {
                                    "primary": "shadowrylander",
                                    "secondary": "frost",
                                    "nightingale": "curtis"
                                }
                            '''.strip())
                            
                            for user in users.values():
                                dsd["home"][d][user] = dd
                                datasets["virt"][d]["podman"][d][user] = dd
                                for dataset in (persist := dsd["persist"][d]).keys():
                                    persist[dataset][d][user] = dd
                            
                            for backup in (las := datasets[pool_name][d]["las"][d]).keys():
                                for zz in [ "zpax", "zsyncs" ]:
                                    las[backup][d][zz] = dd
                            
                            with open(f"{resources}/datasets.nix", "w+") as dnix:
                            
                                dnix.write("host: {\n")
                            
                                def recurse(ddict, dname, droot, mountpoint = ""):
                            
                                    _dataset = f"{droot}/{dname}"
                            
                                    # cc: clone or create
                                    # son: snapshot or none
                                    if (dname != "base") and (encrypted and dedup):
                                        cc = "clone"
                                        son = f"{pool_name}/base@root"
                                    else:
                                        cc = "create"
                                        son = ""
                            
                                    _doptions = ddict.get("options", [])
                                    if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
                                        "system",
                                        "system/root",
                                        "swap",
                                        "base",
                                        "hold",
                                        "omniverse",
                                        "reserved",
                                    )):
                                        pn1 = pool_name
                                        pn2 = f"{pn1}/{pn1}"
                            
                                        # TODO: Make this such that the current dataset directory
                                        #       is placed under the parent directory's mountpoint
                                        if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                                            if mountpoint = "":
                                                _mountpoint = _dataset.replace(
                                                    pn2 if pn2 in _dataset else pn1
                                                    "${host}",
                                                    1
                                                )
                                            else:
                                                mountpoint = _mountpoint = f"{mountpoint}/{dname}"
                            
                                        dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                                    doptions = " -o ".join(_doptions)
                            
                            
                            
                            xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
                            xrun(f"zfs snapshot -r {_dataset}@root")
                            
                                for dataset in (ddictd := ddict.get(
                                    d,
                                    dd
                                )):
                                    recurse(ddictd[dataset], dataset, _dataset, mountpoint)
                            
                            for dataset in datasets:
                                recurse(datasets[dataset], dataset, pool_name)
                            
                            dnix.write("}")
                            
                            pool_size_plus_metric = $(zpool get -H size @(pool_name)).split()[2]
                            pool_size = round(float(pool_size_plus_metric[:-1]), 2)
                            pool_metric = pool_size_plus_metric[-1]
                            
                            def pool_percentage_value(percentage):
                                return (
                                    str(
                                        round(
                                            (
                                                (float(percentage) / 100)
                                                * pool_size
                                            ),
                                            2,
                                        )
                                    )
                                    + pool_metric
                                )
                            
                            # Apparently, if python internal keywords exist in the argument, such as "set", etc.
                            # the command errors out; perhaps something to raise an issue of.
                            # This seems to work as an alternative.
                            xrun(f"zfs set refreservation={pool_percentage_value(15)} {pool_name}/reserved")
                            
                            if (swap := (raw_input('''
                                Will this pool use SWAP?
                                    y | n\n\t
                            ''') == "y")):
                                _swoptions = [
                                    "com.sun:auto-snapshot=false",
                                    "compression=zle",
                                    "logbias=throughput",
                                    "primarycache=metadata",
                                    "secondarycache=none"
                                    "sync=standard",
                                ]
                                swoptions = " -o ".join(_swoptions)
                            
                                ps = $(getconf PAGESIZE)
                                swap_size = int(raw_input("Please enter the (integer) SWAP size in GiB:\n\t"))
                                xrun(f"zfs create -V {2**swap_size}G -b {ps} -o {swoptions} {pool_name}/swap")
                            
                                xrun(f"mkswap -f /dev/zvol/{pool_name}/swap")
                            

                        elif cc == "g":
                            print("Goin' back!\n\n")
                            break
                        else:
                            print("Wait a minute... That's not a valid option! Try again, please!\n\n")
            elif c == "g":
                if raw_input('''
                    Would you like to generate a nixos "[hardware-]configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-generate-config")

            # TODO
            elif c == "b":
                if raw_input('''
                    Would you like to include the bootstrap file in the nixos "configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun('sd "./hardware-configuration.nix" "./bootstrap.nix" /mnt/etc/nixos/configuration.nix')

            # TODO: Also include a one-stop-install, mounting, generating, copying, etc. all in one go
            elif c == "a":
                input = ""
                break

            elif c == "r":
                if raw_input('''
                    Would you like to rsync over the bootstrap files to "/mnt"?
                        y | n\n\t
                ''') == "y":
                    xrun("rsync -avvczz ../../ /mnt/")
            elif c == "i":
                if raw_input('''
                    Would you like to begin the NixOS bootstrap installation?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-install --show-trace")
            elif c == "h":

                print('''
                    Create a new ZFS device:         c
                    Mount a ZFS device:              m
                    Update:                          u
                            Files:                           f
                            Pool:                            p
                            Go back:                         g
                    Generate nixos config:           g
                    Include boostrap config:         b
                    One-Stop Install:                a
                    Rsync over bootstrap config:     r
                    Begin install:                   i
                    Show this help text:             h
                    Setup:                           s
                    Quit:                            q
                    Install and Set Up Home-Manager: H
                    \n\n
                ''')

            elif c == "s":

                while true:
                    pool_name = raw_input("What's the pool name?\n\t")
                    if pool_name == "":
                        print("Wait a minute... That's not a valid pool name! Try again, please!\n")
                    elif pool_name == "quit bootstrap":
                        print("Catch ya' later!")
                        exit(0)
                    else:
                        print("Alright; let's get crackin'!\n\n")
                        encrypted = raw_input('''
                            Is this pool [to be] encrypted?
                                y | n\n\t
                        ''') == "y"
                        break

            elif c == "H":

                

            elif c == "q":
                print("Catch ya' later!")
                break
            else:
                print(f'Wait a minute... The value "{c}" is not a valid option! Try again, please!\n\n')
                break

finally:
    xrun(f"zpool export {pool_name} &> /dev/null")
    exit(0)
