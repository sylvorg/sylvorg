#+setupfile: ./README.org
#+include: ./README.org

This is used to hold larger files for =./oreo.aiern.org=.

* lib
** strings.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220321926742900

#+name: 20210601220321926742900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; strings.el --- Miscellaneous string functions.
;;
;; Filename: strings.el
;; Description: Miscellaneous string functions.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2021, Drew Adams, all rights reserved.
;; Created: Tue Mar  5 17:09:08 1996
;; Version: 0
;; Package-Requires: ()
;;; Last-Updated: Wed Mar 17 13:45:17 2021 (-0700)
;;           By: dradams
;;     Update #: 579
;; URL: https://www.emacswiki.org/emacs/download/strings.el
;; Keywords: internal, strings, text
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `misc-fns', `thingatpt', `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;        Miscellaneous string functions.
;;
;;  You may want to put this in your `~/.emacs' file, to erase the
;;  minibuffer when it is inactive and `minibuffer-empty-p':
;;
;;   (require 'strings)
;;   (add-hook 'pre-command-hook 'erase-nonempty-inactive-minibuffer))
;;
;;
;;  Functions defined here:
;;
;;    `absdiff', `buffer-alist', `concat-w-faces',
;;    `current-d-m-y-string', `current-line-string',
;;    `display-in-minibuffer', `display-lines-containing',
;;    `echo-in-buffer', `empty-name-p', `erase-inactive-minibuffer',
;;    `erase-nonempty-inactive-minibuffer', `fill-string',
;;    `frame-alist', `insert-in-minibuffer', `insert-string' (Emacs
;;    26+), `minibuffer-empty-p', `non-empty-name-p',
;;    `ordinal-suffix', `pick-some-words', `read-any-variable',
;;    `read-number', `region-description', `set-minibuffer-empty-p',
;;    `string-w-face', `symbol-name-before-point',
;;    `word-before-point'.
;;
;;  Variables defined here:
;;
;;    `minibuffer-empty-p'.
;;
;;
;;  ***** NOTE: These EMACS PRIMITIVES have been REDEFINED HERE:
;;
;;  `read-buffer'   - Uses `completing-read'.
;;  `read-variable' - Uses `symbol-nearest-point' & `completing-read'
;;                    to get the default.
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/03/17 dadams
;;      Use buffer-string, not buffer-substring, for whole buffer.
;; 2020/11/06 dadams
;;     Removed: (non-)empty-name-p.
;; 2019/04/21 dadams
;;     Added insert-string for Emacs 26+ (Emacs removed it).
;;     read-buffer: Added optional arg PREDICATE, like recent vanilla Emacs.
;;     buffer-alist: Use dolist, not mapcar.
;; 2017/02/10 dadams
;;     display-lines-containing: Quote minibuffer-history.
;;     frame-alist: Use code for get-frame-name, not the function (in frame-fns.el).
;;     Thx to Rubikitch.
;; 2105/08/05 dadams
;;     read-any-variable:
;;       Ensure SYMB is not just the symbol nil for default value to completing-read.
;; 2012/09/07 dadams
;;     read-buffer: Use nil for INHERIT-INPUT-METHOD arg to completing-read.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;; 2012/04/16 dadams
;;     Added: fill-string.
;; 2011/12/12 dadams
;;     read-buffer: Use internal-complete-buffer for Emacs 22+.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive functions.
;; 2010/06/28 dadams
;;     read-buffer: Don't provide a default if none given, unless interactive.
;; 2010/02/22 dadams
;;     read-buffer: Update for Emacs 23 (pretest):
;;       Handle read-buffer-function and read-buffer-completion-ignore-case.
;; 2010/01/12 dadams
;;     current-line-string, minibuffer-empty-p, erase-inactive-minibuffer:
;;       save-excursion + set-buffer -> with-current-buffer.
;;     insert-in-minibuffer: set-buffer -> with-current-buffer.
;; 2009/09/09 dadams
;;     (non-)empty-name-p: Got rid of old-style backquote syntax.
;; 2008/05/12 dadams
;;     read-buffer: Don't use (buffer-alist t) - don't exclude hidden buffers.
;; 2007/04/20 dadams
;;     read-number: Updated for Emacs 22.
;; 2006/08/22 dadams
;;     buffer-alist: Added nospacep arg.  Use t for it in read-buffer.
;; 2005/10/31 dadams
;;     Added: read-any-variable.
;;     Use nil as init-value arg in calls to completing-read, everywhere.
;; 2005/07/31 dadams
;;     Protected read-number with fboundp.
;; 2005/07/28 dadams
;;     concat-w-faces: Mention in doc string that it is now obsolete.
;; 2005/05/28 dadams
;;     read-buffer: Use other-buffer, if another-buffer is not available.
;; 2004/09/21 dadams
;;     Added buffer-alist (from elect-mbuf.el), so file would be standalone.
;;     Removed require of elect-mbuf.el (circular dependency).
;; 1999/03/17 dadams
;;     Added: read-buffer, read-number, read-variable, frame-alist.
;; 1996/03/26 dadams
;;     1. Added string-w-face, concat-w-faces.
;;     2. insert-in-minibuffer: Use concat-w-faces.
;; 1996/03/19 dadams
;;     Added current-d-m-y-string.
;; 1996/03/15 dadams
;;     minibuffer-empty-p, erase-inactive-minibuffer, insert-in-minibuffer:
;;       Use minibuffer-window, not minibuffer-frame.
;; 1996/03/12 dadams
;;     1. Added: minibuffer-empty-p, set-minibuffer-empty-p,
;;               erase-nonempty-inactive-minibuffer, erase-inactive-minibuffer.
;;     2. insert-in-minibuffer: Reset set-minibuffer-empty-p to nil.
;; 1996/02/22 dadams
;;     insert-in-minibuffer: Protect against read-from-string error.
;; 1996/02/22 dadams
;;     Added display-lines-containing.
;; 1996/02/14 dadams
;;     insert-in-minibuffer: Corrected bug when `"' in string itself.
;; 1996/02/13 dadams
;;     symbol-name-before-point: Skip non-symbol, non-word syntax at end of name too.
;;     (Was not removing  "',"  in  "`toto',")
;; 1996/01/08 dadams
;;     Added insert-in-minibuffer, erase-inactive-minibuffer, display-in-minibuffer.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (require 'cl-lib)) ;; psetq

(require 'thingatpt nil t) ;; (no error if not found): symbol-at-point
(when (and (require 'thingatpt+ nil t);; (no error if not found)
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))
 ;; symbol-nearest-point

(require 'misc-fns nil t) ;; (no error if not found): another-buffer


(defvar read-buffer-completion-ignore-case) ; Quiet the byte-compiler.

;;;;;;;;;;;;;;;;;;;;;;;


;; Taken from `wimpy-del.el'.
(defsubst absdiff (m n)
  "Absolute value of the difference between two numbers.
M and N are the numbers."
  (if (< m n) (- n m) (- m n)))

;; Stolen from `diary.el' (`diary-ordinal-suffix').
(defun ordinal-suffix (n)
  "Ordinal suffix for N.  That is, `st', `nd', `rd', or `th', as appropriate."
  (if (or (memq (% n 100) '(11 12 13)) (< 3 (% n 10)))
      "th"
    (aref ["th" "st" "nd" "rd"] (% n 10))))

;; Stolen from `wimpy-del.el'.
(defun pick-some-words (pos direction limit)
  "Get string from buffer of at most LIMIT chars, with one end at position POS.
Tries to fit as many words into the string as possible.  If it cannot fit even
one word, it will get LIMIT characters.  DIRECTION = nil for forward, non-nil
for backward."
  (save-excursion
    (goto-char pos)
    (let (p q)
      (if direction
          (backward-word 1)
        (forward-word 1))
      (if (> (absdiff (point) pos) limit)
          (buffer-substring pos (+ (if direction (- limit) limit) pos))
        (setq p (point) q t)
        (while (and q (not (eobp)) (not (bobp)))
          (if direction
              (backward-word 1)
            (forward-word 1))
          (if (<= (absdiff (point) pos) limit)
              (setq p (point))
            (goto-char p)
            (setq q nil)))
        (buffer-substring pos (point))))))

;; Stolen from `wimpy-del.el'
(defun region-description (width &optional prefix suffix begin end)
  "Return a string containing a one-line description of the region.
WIDTH arg is max length of string (must be at least 20 chars).
Optional args PREFIX and SUFFIX are strings (default: \"\") added to msg ends.
They count towards its length.
Optional args BEGIN and END delimit the region to use."
  (unless prefix (setq prefix ""))
  (unless suffix (setq suffix ""))
  (when (and begin (not end)) (setq end (point)))
  (cond (begin ;; Use arg-supplied region
         (psetq begin (min begin end)
                end   (max begin end)))
        (t ;; Use current region.
         (setq begin (min (point) (mark)))
         (setq end   (max (point) (mark)))))
  ;;(message "%d `%s' `%s' %d %d" width prefix suffix begin end)
  (cond ((< (- end begin) (- width 2))
         (concat "\"" (buffer-substring begin end) "\""))
        (t
         (let* ((chars-string (format "     (%d chars)" (- end begin)))
                (space-for-messages (+ (length prefix) (length suffix)
                                       (length chars-string)))
                (space-for-quote (/ (max 0 (- width space-for-messages)) 2))
                (beg-words (pick-some-words begin nil space-for-quote))
                (end-words (pick-some-words end   t   space-for-quote)))
           (concat prefix beg-words "   ...   "
                   end-words suffix chars-string)))))

;; From `header2.el'.
(defun current-d-m-y-string ()
  "Return string of current day, month, and year, in form \"dd-mon-year\"."
  (let ((str (current-time-string)))
    (concat (if (equal ?\  (aref str 8))
                (substring str 9 10)
              (substring str 8 10))
            "-" (substring str 4 7) "-" (substring str 20 24))))

;; Adapted from file `intes.el.2'.
(defun current-line-string (&optional buffer)
  "Return current line of text in BUFFER as a string."
  (setq buffer (or buffer (current-buffer)))
  (with-current-buffer buffer
    (buffer-substring (progn (end-of-line 1) (point))
                      (progn (beginning-of-line 1) (point)))))

;;;###autoload
(defun display-lines-containing (buffer string &optional flush-p)
  "Display in BUFFER the lines of `current-buffer' containing STRING.
See also command `occur' which does this and much more.  As this does
less, it can be useful if you intend to manipulate the contents of
BUFFER, not just use it to find things in the `current-buffer'.

BUFFER is a buffer or its name (a string).  STRING is a string.
Optional third argument FLUSH-P, if non-nil, means to display lines of
`current-buffer' that do *not* contain STRING.
Interactively:
  BUFFER defaults to buffer \"*Lines Containing*\".
  STRING is read in the minibuffer, and defaults to `current-line-string'.
  FLUSH-P is the prefix argument."
  (interactive
   (list (get-buffer-create "*Lines Containing*")
         (read-from-minibuffer "Lines containing: "
                               (current-line-string) nil nil
                               (cons 'minibuffer-history 1))
         current-prefix-arg))
  (setq buffer (get-buffer-create buffer)) ; Convert possible string to buffer.
  (let ((bufstring (buffer-string)))
    (switch-to-buffer-other-window buffer)
    (erase-buffer)
    (insert bufstring)
    (goto-char (point-min))
    (if flush-p
        (flush-lines string)
      (keep-lines string))
    (set-buffer-modified-p nil)))

(defun word-before-point ()
  "Return the word at (or before) the cursor, as a string.
\"Word\" is as defined by `forward-word'.
Note: It is possible for the symbol found to be on a previous line.

Some related functions (defined in `thingatpt+.el'):
  `non-nil-symbol-name-nearest-point' returns the name of the non-nil
    `symbol-nearest-point' as a string, or nil if none.
  `symbol-name-before-point'  returns the string naming the symbol at or
    before the cursor (even if it is on a previous line), or nil if none.
  `symbol-at-point' returns the symbol under the cursor, or nil if none.
  `symbol-nearest-point' returns the symbol nearest to the cursor, or nil.
Note that these last two functions return symbols, not strings."
  (save-excursion
    (let (beg)
      (unless (looking-at "\\<") (forward-word -1))
      (setq beg (point))
      (forward-word 1)
      (buffer-substring beg (point)))))

(defun symbol-name-before-point ()
  "Return the name of the symbol at (or before) the cursor, as a string.
If no symbol is found, returns the empty string, \"\".
Note: It is possible for the symbol found to be on a previous line.

Some related functions (defined in `thingatpt+.el'):
  `non-nil-symbol-name-nearest-point' returns the name of the non-nil
    `symbol-nearest-point' as a string, or nil if none.
  `word-before-point' returns the word at or before the cursor as a string.
  `symbol-at-point' returns the symbol under the cursor, or nil if none.
  `symbol-nearest-point' returns the symbol nearest to the cursor, or nil.
Note that these last two functions return symbols, not strings."
  (save-excursion
    (if (and (not (looking-at "\\s_\\|\\sw")) ; Not in a symbol and no symbol
             (not (re-search-backward "\\s_\\|\\sw" nil t))) ; in previous sexp
        ""
      (buffer-substring
       (progn (forward-sexp 1)
              (while (not (looking-at "\\s_\\|\\sw")) (backward-char 1))
              (forward-char 1) (point))
       (progn (backward-sexp 1)
              (while (not (looking-at "\\s_\\|\\sw")) (forward-char 1))
              (point))))))

;; Stolen from `sql-mode.el'.
(defun echo-in-buffer (buffer-name string &optional force-display-p)
  "Display string STRING in buffer BUFFER-NAME, creating buffer if needed.
FORCE-DISPLAY-P non-nil means buffer is displayed."
  (let ((buffer (get-buffer-create buffer-name)))
    (when force-display-p (display-buffer buffer))
    ;; There is probably a better way to do this.
    (set-buffer buffer)
    (goto-char (point-max))
    (insert string)
    (when force-display-p
      (set-window-point (get-buffer-window buffer-name) (point-max)))))

(defvar minibuffer-empty-p t "Non-nil iff minibuffer is empty (not guaranteed).
This flag is not guaranteed to represent the state of the minibuffer,
but only the memorized state.  Use the function of the same name to be sure.")

(defun set-minibuffer-empty-p (flag)
  "Set value of variable `set-minibuffer-empty-p' to FLAG."
  (setq minibuffer-empty-p flag))

(defun minibuffer-empty-p ()
  "Return non-nil iff minibuffer is empty.
Sets variable `minibuffer-empty-p' to returned value."
  (save-window-excursion
    (with-current-buffer (window-buffer (minibuffer-window))
      (set-minibuffer-empty-p (= 0 (buffer-size))))))

;;;###autoload
(defun erase-nonempty-inactive-minibuffer ()
  "Erase the minibuffer, if inactive and not `minibuffer-empty-p'.
To do this at each user input event:
   (add-hook 'pre-command-hook 'erase-nonempty-inactive-minibuffer).

Note that `minibuffer-empty-p' is not infallible.  To make sure the
minibuffer is emptied, you can use the surer, though slower, function
`erase-inactive-minibuffer'."
  (interactive) (or minibuffer-empty-p (erase-inactive-minibuffer)))

;;;###autoload
(defun erase-inactive-minibuffer ()
  "Erase the minibuffer (remove its contents), provided it is inactive.
To ensure that the minibuffer is erased at each user input, do this:
   (add-hook 'pre-command-hook 'erase-inactive-minibuffer).
This is generally costly, however.  For a faster, though less sure,
alternative, see `erase-nonempty-inactive-minibuffer'."
  (interactive)
  (let ((win (minibuffer-window)))
    (unless (minibuffer-window-active-p win)
      (message nil)                     ; Clear any messages to show minibuf.
      (save-window-excursion
        (with-current-buffer (window-buffer win)
          (erase-buffer)
          (set-minibuffer-empty-p t)))
      (message nil))))                  ; Clear any messages to show minibuf.

(defun fill-string (string &optional justify nosqueeze to-eop)
  "Return a copy of STRING, but filled.
Arguments are those for `fill-region' with the same names.
`fill-region' is used.  See it for the behavior, including the
variables that are respected."
  (with-temp-buffer
    (insert string)
    (fill-region (point-min) (point-max))
    (setq string  (buffer-string)))
  string)

;; Emacs removed this starting with Emacs 26.  Put it back.
;;
(unless (fboundp 'insert-string)
  (defun insert-string (&rest args)
    "Mocklisp-compatibility insert function.
Like the function `insert' except that any argument that is a number
is converted into a string by expressing it in decimal."
    (dolist (el args)
      (insert (if (integerp el) (number-to-string el) el)))))

(defun string-w-face (arg)
  "Convert ARG (of form (FACE OBJECT)) to a string with face FACE.
If ARG is already a string, any text (face) properties are preserved.

ARG may be a string or a number (see `insert-string'), or nil
\(ignored).  As a special case, it may also be a list of the form
\(FACE OBJECT), where OBJECT is an object to be converted to a string
via (format \"%s\"), and FACE is the face in which to display the
resulting string.  If OBJECT is a string, any text properties
belonging to it are ignored.

NOTE: For versions of Emacs that do not have faces, a list of
      (FACE OBJECT) is simply treated as the string resulting from
      (format \"%s\" OBJECT)."
  (when (consp arg)
    (let ((strg (format "%s" (cadr arg)))) ; Convert to plain string.
      (when (fboundp 'set-face-foreground) ; E.g. not Emacs 19.
        (setq arg                     ; Error if, e.g., `"' in string.
              (condition-case nil
                  (car (read-from-string
                        (format "#%s"
                                (cons (concat "\"" strg "\"")
                                      (list 0 (length strg)
                                            (list 'face (car arg)))))))
                (error nil))))
      (unless (stringp arg) (setq arg strg)))) ; Use uncolored string.
  arg)

;;;###autoload
(defun concat-w-faces (&rest arguments)
  "Return the string that is the concatenation of all ARGUMENTS.
Text (face) properties of any string arguments are preserved.

This is obsolete.  Use `concat' with `put-text-property' or
`propertize' now.

Items in arg list may be strings or numbers (see `insert-string'), or
nil (ignored).  As a special case, they may also be lists of the form
\(FACE OBJECT), where OBJECT is an object to be converted to a string
via (format \"%s\"), and FACE is the face in which to display the
resulting string.  If OBJECT is a string, any text properties
belonging to it are ignored.

NOTE: For versions of Emacs that do not have faces, a list of
      (FACE OBJECT) is simply treated as the string resulting from
      (format \"%s\" OBJECT)."
  (interactive "sString: ") (mapconcat 'string-w-face arguments ""))

;;;###autoload
(defun insert-in-minibuffer (&rest arguments)
  "Insert ARGUMENTS in minibuffer, indefinitely, preserving faces.
The minibuffer is not erased before display.  If you want to ensure
that the minibuffer is erased at each user input event, then do this:
    (add-hook 'pre-command-hook 'erase-inactive-minibuffer)
or  (add-hook 'pre-command-hook 'erase-nonempty-inactive-minibuffer)

Text (face) properties of string arguments are preserved.

Items in arg list may be strings or numbers (see `insert-string'), or
nil (ignored).  As a special case, they may also be lists of the form
\(FACE OBJECT), where OBJECT is an object to be converted to a string
via (format \"%s\"), and FACE is the face in which to display the
resulting string.  If OBJECT is a string, any text properties
belonging to it are ignored.

NOTE: For versions of Emacs that do not have faces, a list of
      (FACE OBJECT) is simply treated as the string resulting from
      (format \"%s\" OBJECT)."
  (interactive "sString: ")
  (message nil)                         ; Clear any messages to show minibuf.
  (save-excursion
    (save-window-excursion
      (with-current-buffer (window-buffer (minibuffer-window))
        (goto-char (point-max))
        (insert-string (apply 'concat-w-faces arguments)))))
  (when arguments (set-minibuffer-empty-p nil))
  (message nil) (sit-for 0))            ; Clear any messages & show minibuf.


;; REPLACE ORIGINAL `read-buffer' (built-in).
;;
;; 1. Interactively, uses `another-buffer' or `other-buffer' if no default.
;; 2. Emacs 23+ compatible: handles `read-buffer-function'
;;    and `read-buffer-completion-ignore-case'.
;;
(defun read-buffer (prompt &optional default require-match predicate)
  "Read the name of a buffer and return it as a string.
Prompt with first arg, PROMPT (a string).

If user input is empty (just `RET') then return the default value,
which is:

 - optional second arg DEFAULT, if non-nil
 - `another-buffer' or `other-buffer', otherwise.

If `another-buffer' is undefined, then use `other-buffer'.

Starting with Emacs 23, DEFAULT can be a list of names (strings), in
which case the first name in the list is returned on empty input.

Non-nil REQUIRE-MATCH means to allow only names of existing buffers.
It is the same as for `completing-read'.

Non-nil PREDICATE is a function that accepts a completion candidate (a
cons whose car is a buffer name) as its first arg.  Candidates for
which PREDICATE returns nil are excluded as completion candidates.

Case sensitivity is determined by
`read-buffer-completion-ignore-case', if defined, or
`completion-ignore-case' otherwise."
  (if (and (boundp 'read-buffer-function) read-buffer-function)
      (funcall read-buffer-function prompt)
    (when (interactive-p)
      (setq default (or default (if (fboundp 'another-buffer) ; In `misc-fns.el'.
                                    (another-buffer nil t)
                                  (other-buffer (current-buffer))))))
    ;; Need a string as default.
    (when (bufferp default) (setq default  (buffer-name default)))
    (let ((completion-ignore-case  (if (boundp 'read-buffer-completion-ignore-case)
                                       read-buffer-completion-ignore-case
                                     completion-ignore-case)))
      (completing-read
       prompt (if (fboundp 'internal-complete-buffer)
                  'internal-complete-buffer ; Emacs 22+
                (mapcar (lambda (b) (and (buffer-live-p b) (list (buffer-name b))))
                        (buffer-list)))
       predicate require-match nil 'buffer-name-history default nil))))

(defun buffer-alist (&optional nospacep)
  "Alist of (BUF-NAME . BUF) items, where BUF-NAME (a string) names BUF,
which is in (buffer-list).  Non-nil NOSPACEP means do not include
buffers whose names start with SPACE."
  (let (bn-alist bn)
    (dolist (buf  (buffer-list))
      (setq bn  (buffer-name buf))
      (unless (and nospacep  (equal " " (substring bn 0 1)))
        (push (cons bn buf) bn-alist)))
    (reverse bn-alist)))

;; Same as Emacs 22 standard definition, except:
;;  1. Allow for `replace-regexp-in-string' not being defined.
;;  2. Allow for error reading input.
;;  3. Call `ding' if not a number, and don't redisplay for `sit-for'.
(unless (fboundp 'read-number)          ; Defined in `subr.el' in Emacs 22+.
  (defun read-number (prompt &optional default)
    "Read a number in the minibuffer, prompting with arg PROMPT.
PROMPT is a string.
DEFAULT is returned if the user hits `RET' without typing anything."
    (let ((num nil))
      (when default
        (setq prompt
              (cond ((string-match "\\(\\):[ \t]*\\'" prompt)
                     (replace-match (format " (default %s)" default) t t prompt 1))
                    ((fboundp 'replace-regexp-in-string)
                     (replace-regexp-in-string "[ \t]*\\'"
                                               (format " (default %s) " default)
                                               prompt t t))
                    (t prompt))))
      (while
          (progn
            (let ((str (read-from-minibuffer
                        prompt nil nil nil nil (and default
                                                    (number-to-string default)))))
              (setq num (cond ((zerop (length str)) default)
                              ((stringp str)
                               (condition-case nil (read str) (error nil))))))
            (unless (numberp num)
              (ding) (message "Not a number.  Try again.") (sit-for 1 nil t)
              t)))
      num)))


;; REPLACES ORIGINAL (built-in):
;; Uses `symbol-nearest-point' and `completing-read' to get default.
;;      `symbol-nearest-point' is defined in `thingatpt+.el'.
;;      `symbol-at-point' is defined in `thingatpt.el'.
(defun read-variable (prompt &optional default-value)
  "Read name of a user variable (an option) and return it as a symbol.
Prompt with string PROMPT.  By default, return DEFAULT-VALUE if
non-nil.  If DEFAULT-VALUE is nil and the nearest symbol to the cursor
is a variable, then return that by default.
A user variable is one for which `user-variable-p' returns non-nil."
  (let ((symb                          (cond ((fboundp 'symbol-nearest-point)
                                              (symbol-nearest-point))
                                             ((fboundp 'symbol-at-point)
                                              (symbol-at-point))
                                             (t nil)))
        (enable-recursive-minibuffers  t))
    (when (and default-value  (symbolp default-value))
      (setq default-value  (symbol-name default-value)))
    (intern (completing-read prompt obarray 'user-variable-p t
                             nil 'minibuffer-history
                             (or default-value
                                 (and (user-variable-p symb)  (symbol-name symb)))
                             t))))

(defun read-any-variable (prompt &optional default-value)
  "Read name of a variable and return it as a symbol.
Unlike `read-variable', which reads only user options, this reads the
name of any variable.

Prompts with arg string PROMPT.  By default, return DEFAULT-VALUE if
non-nil.  If DEFAULT-VALUE is nil and the nearest symbol to the cursor
is a variable, then return that by default."
  (let ((symb                          (cond ((fboundp 'symbol-nearest-point)
                                              (symbol-nearest-point))
                                             ((fboundp 'symbol-at-point)
                                              (symbol-at-point))
                                             (t nil)))
        (enable-recursive-minibuffers  t))
    (when (and default-value  (symbolp default-value))
      (setq default-value  (symbol-name default-value)))
    (intern (completing-read prompt obarray 'boundp t nil 'minibuffer-history
                             (or default-value
                                 (and symb  (boundp symb)  (symbol-name symb)))
                             t))))

;;; See also `make-frame-names-alist', defined in `frame.el'.
(defun frame-alist ()
  "Alist of (FR-NAME . FR) items.  FR-NAME names FR in `frame-list'.
FR-NAME is a string.  The alist is sorted by ASCII code in reverse
alphabetical order, and with case ignored."
  (sort (mapcar (function (lambda (fr) (cons (frame-parameter fr 'name) fr)))
                (frame-list))
        (function
         (lambda (f1f1n f2f2n)
           (not (string< (downcase (car f1f1n)) (downcase (car f2f2n))))))))


;; This is not so useful anymore.
;; With Emacs 21+ you can instead use `message' with face-property strings.
;;
;;;###autoload
(defun display-in-minibuffer (option &rest arguments)
  "Display ARGUMENTS in minibuffer, preserving their face properties.
This function essentially allows you to display messages with faces.

First arg OPTION determines the display behavior, as follows:

 OPTION values `event', `new', and a `natnump' erase the minibuffer
 before displaying.  Other values do not.  They are intended for later
 use to add to the contents of the minibuffer.

 OPTION values `event', `more-event' and an `integerp' are guaranteed
 to erase the minibuffer at some time after displaying.  Other values
 do not erase it afterward.  They allow you to later add more to the
 current contents of the minibuffer.  Remember that they leave the
 minibuffer with text in it.  They should therefore at some point be
 followed by something that erases the contents, such as
 `erase-inactive-minibuffer'.

 OPTION values `event' and a `natnump' are common, one-shot affairs.
 The other values are only used when you need to combine several
 submessages via separate calls.

 OPTION values `event' and `more-event' block Emacs execution until
 the next user event.  This means, among other things, that such a
 call should always be the last of a sequence of calls to
 `display-in-minibuffer'.

 Here are all the OPTION values:

 If a number: ARGS are displayed for that many seconds (`sit-for'),
      then the minibuffer is erased.  The minibuffer is also
      erased before the display of ARGS, iff the number is >= 0.
 If `event': ARGS are displayed until the next user event, after
      erasing the minibuffer.  (If ARGS = nil, this just affects
      the duration of the current minibuffer contents.)
 If `more-event': ARGS displayed until next user event, without
      first erasing minibuffer.  (If ARGS = nil, this just affects
      the duration of the current minibuffer contents.)
 If `new': ARGS displayed indefinitely, after erasing minibuffer.
      (If ARGS = nil, then this just erases the minibuffer.)
 Else (e.g. `more'): ARGS displayed indefinitely, without first
      erasing minibuffer.  (If ARGS = nil, then this is a no-op.)

If you cannot (or do not want to) explicitly program the ultimate
erasure of the minibuffer, and yet you do not want to block program
execution by waiting for a time elapse or a user input, you may still
ensure that the minibuffer is always erased at the next user input,
by doing either of these (the first is surer, but slower):
    (add-hook 'pre-command-hook 'erase-inactive-minibuffer)
or  (add-hook 'pre-command-hook 'erase-nonempty-inactive-minibuffer)

This can be a good thing to do (but it can also slow things down
considerably).  You may then freely use OPTION values other than
numbers, `event' and `more-event' (e.g.  `new' and `more'), without
fear of indefinite display.  However, user input between `new' and
`more' will then interfere with incremental display.  If you do arm
`pre-command-hook' this way, you can always inhibit erasure
temporarily by rebinding `pre-command-hook' to nil.


The remaining arguments, besides OPTION, may be strings or numbers
\(see `insert-string'), or nil (ignored).

As a special case, they (items in the ARGS list) may also be lists of
the form (FACE STRING), where STRING is a string and FACE is the face
in which it is to be displayed.  In this case, any text properties
belonging to STRING itself are ignored.


EXAMPLE (one-shot, without `sit-for', erasure upon user event):
  (display-in-minibuffer 'event \"a\" \"b\") ; Erase, then display until event.
  ...                                        ;  --> ab

EXAMPLE (multiple calls, without `sit-for', erasure upon user event):
  (display-in-minibuffer 'new \"a\" \"b\")  ; Erase, then display.
  ...                                       ;  --> ab
  (display-in-minibuffer 'more \"cd\")      ; Display (no erase).
  ...                                       ;  --> abcd
  (display-in-minibuffer 'more-event \"ef\"); Display until user event.
  ...                                       ;  --> abcdef

EXAMPLE (without `sit-for', explicit erasure later):

  (display-in-minibuffer 'new \"ab\")     ; Erase, then display.
  ...                                     ;  --> ab
  (display-in-minibuffer 'more \"cd\")    ; Display (no erase).
  ...                                     ;  --> abcd
  (display-in-minibuffer 'new)            ; Erase---same as
                                          ; (erase-inactive-minibuffer).
  ...                                     ;  -->

EXAMPLE (with positive `sit-for'):
  (display-in-minibuffer 3 \"abc\" \"def\") ; Erase, display 3 sec, erase.

EXAMPLE (with negative `sit-for'):
  (display-in-minibuffer new \"abc\" \"def\") ; Erase, then display.
  ...
  (display-in-minibuffer -3 \"gh\")         ; Display (\"abcdefgh\") 3 sec.


NOTE:
 This function is not very useful interactively, especially as regards
 different values of OPTION.  Interactive calls in fact always erase
 the minibuffer first.
 Regardless of this, if interactive, then OPTION is the numeric value
 of the prefix arg, if any.  If there is no prefix arg, behavior is as
 if OPTION were `event': display contents until the next user event."
  (interactive "P\nsString: ")
  (when (interactive-p)
    (if option
        (setq option (prefix-numeric-value option))
      (setq option 'event)))
  (when (or (natnump option) (memq option '(event new)))
    (erase-inactive-minibuffer))
  (apply (function insert-in-minibuffer) arguments)
  (cond ((integerp option) (sit-for (abs option)) (erase-inactive-minibuffer))
        ((memq option '(event more-event))
         (while (not (input-pending-p)) (sit-for 0))
         (erase-inactive-minibuffer))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'strings)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; strings.el ends here
#+end_src

** eyedropper.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220323739799100

#+name: 20210601220323739799100
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; eyedropper.el --- Pick foreground and background colors at cursor or pointer.
;;
;; Filename: eyedropper.el
;; Description: Pick foreground and background colors at cursor or pointer.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2006-2018, Drew Adams, all rights reserved.
;; Created: Fri Jun 23 08:07:15 2006
;; Version: 0
;; Package-Requires: ((hexrgb "0"))
;; Last-Updated: Mon Jan  1 11:15:31 2018 (-0800)
;;           By: dradams
;;     Update #: 200
;; URL: https://www.emacswiki.org/emacs/download/eyedropper.el
;; Doc URL: https://www.emacswiki.org/emacs/CustomizingFaces
;; Keywords: color, rgb, hsv, hexadecimal, face, frame
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `hexrgb'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Use the commands defined here to examine or save the background or
;;  foreground color at the text cursor or the mouse pointer.
;;
;;  After using commands `eyedrop-pick-background-*' or
;;  `eyedrop-pick-foreground-*', the picked color is saved in variable
;;  `eyedrop-picked-background' or `eyedrop-picked-foreground',
;;  respectively.
;;
;;  If you have Emacs 22 or later, all of the functionality provided
;;  here, and much more, is provided in library `palette.el'.  Use
;;  library `eyedropper' instead of `palette.el' if either of these
;;  applies:
;;
;;  * You do not want to use the color palette itself.  You want only
;;    the functionality provided by `eyedropper.el'.
;;
;;  * Your Emacs version is older than Emacs 22 (`palette.el' requires
;;    22 or later).
;;
;;  If you load `palette.el', there is no reason to also load
;;  `eyedropper.el'.  However, if for some reason you do load both
;;  `palette.el' and `eyedropper.el' then load `palette.el' second, so
;;  that its definitions will override those provided in
;;  `eyedropper.el', providing additional functionality for the color
;;  palette.
;;
;;  To use this library:
;;
;;    Add this to your initialization file (~/.emacs or ~/_emacs):
;;
;;      (require 'eyedropper) ; Load this library.
;;
;;    You will also need my library `hexrgb.el'; it is loaded
;;    automatically by `eyedropper.el'.  Get it here:
;;    https://www.emacswiki.org/emacs/download/hexrgb.el.
;;
;;  Commands defined here:
;;
;;    `background-color', `eyedrop-background-at-mouse',
;;    `eyedrop-background-at-point', `eyedrop-foreground-at-mouse',
;;    `eyedrop-foreground-at-point', `eyedropper-background',
;;    `eyedropper-foreground', `eyedrop-pick-background-at-mouse',
;;    `eyedrop-pick-background-at-point',
;;    `eyedrop-pick-foreground-at-mouse',
;;    `eyedrop-pick-foreground-at-point', `foreground-color',
;;    `pick-background-color', `pick-foreground-color'.
;;
;;  Non-interactive functions defined here:
;;
;;    `eyedrop-color-message', `eyedrop-face-at-point', `keywordp'.
;;
;;  Internal variables defined here:
;;
;;    `eyedrop-last-picked-color', `eyedrop-picked-background',
;;    `eyedrop-picked-foreground'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2015/05/09 dadams
;;     eyedrop-(background|foreground)-at-point: Reverse params to and in last let clause.
;; 2013/11/15 dadams
;;     eyedrop-(fore|back)ground-at-point: Return nil if unspecified-(fg|bg).
;; 2012/08/12 dadams
;;     eyedrop-(background|foreground)-at-mouse: Ignore a switch-frame event.
;; 2011/01/04 dadams
;;     Added autoload cookies for commands.
;; 2007/10/11 dadams
;;     eyedrop-(back|fore)ground-at-(mouse|point),
;;     eyedrop-pick-(back|fore)ground-at-(mouse|point), pick-(back|fore)ground-color:
;;       Added optional MSG-P arg (instead of interactive-p).
;; 2006/07/28 dadams
;;     eyedrop-face-at-point: Use car, not caar, for (*-color . "...") test.
;; 2006/06/25 dadams
;;     Added: eyedrop-last-picked-color.  Set it whenever set picked fg or bg.
;; 2006/06/24 dadams
;;     Added: keywordp (for Emacs 20), eyedrop-face-at-point.
;;     eyedrop-(back|fore)ground-at-point: Use eyedrop-face-at-point also.
;; 2006/06/23 dadams
;;     Created.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'hexrgb) ;; hexrgb-hex-to-rgb, hexrgb-rgb-to-hsv

;;;;;;;;;;;;;;;;;;;;;;;;;;

(defvar eyedrop-picked-background nil
  "Color last picked from a face or frame background.
You can use `eyedrop-pick-background-at-point' or
`eyedrop-pick-background-at-mouse' to pick the color.")

(defvar eyedrop-picked-foreground nil
  "Color last picked from a face or frame foreground.
You can use `eyedrop-pick-foreground-at-point' or
`eyedrop-pick-foreground-at-mouse' to pick the color.")

(defvar eyedrop-last-picked-color nil
  "Color last picked from a face or frame foreground or background.")

;; This is built-in in Emacs 21; not defined before Emacs 21.
(unless (fboundp 'keywordp)
  (defun keywordp (object)
    "Return t if OBJECT is a keyword.
This means that it is a symbol with a print name beginning with `:'
interned in the initial obarray."
    (and (symbolp object) (string-match "^:" (symbol-name object)) t)))

(defun eyedrop-color-message (color)
  "Display information about COLOR as a message."
  (let* ((rgb (hexrgb-hex-to-rgb color))
         (hsv (apply #'hexrgb-rgb-to-hsv rgb)))
    (message (format "Color: %s, RGB: %s, HSV: %s" color rgb hsv)))
  color)                                ; Return it.

;;;###autoload
(defun eyedrop-background-at-mouse (event &optional msg-p)
  "Return the background color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((bg (eyedrop-background-at-point)))
    (when msg-p (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;;;###autoload
(defun eyedrop-foreground-at-mouse (event &optional msg-p)
  "Return the foreground color under the mouse pointer.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  ;; Ignore `switch-frame' events.
  (when (and (consp event)  (eq (event-basic-type (car event)) 'switch-frame))
    (setq event  (read-event)))
  (set-buffer (window-buffer (posn-window (event-end event))))
  (mouse-set-point event)
  (let ((fg (eyedrop-foreground-at-point)))
    (when msg-p (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;; RMS added this function to Emacs (23) as `face-at-point'.
(defun eyedrop-face-at-point ()
  "Return the face under the text cursor.
If there is more than one face, return the first one.
Return nil if there is no face at point."
  (let* ((faceprop (or (get-char-property (point) 'read-face-name)
                       (get-char-property (point) 'face)
                       'default))
         (face (cond ((symbolp faceprop) faceprop)
                     ;; List of faces (don't treat an attribute spec).
                     ;; Just use the first face.
                     ((and (consp faceprop) (not (keywordp (car faceprop)))
                           (not (memq (car faceprop) '(foreground-color background-color))))
                      (car faceprop))
                     (t nil))))         ; Invalid face value.
    (if (facep face) face nil)))

;; RMS added this function to Emacs (23) as `background-color-at-point'.
;;;###autoload
(defalias 'background-color 'eyedrop-background-at-point)
;;;###autoload
(defun eyedrop-background-at-point (&optional msg-p)
  "Return the background color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (bg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-background face nil 'default) ; Emacs 22+.
                         (error (or (face-background face) ; Emacs 20
                                    (cdr (assq 'background-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'background-color face)
                              (cdr (memq 'background-color face)))
                             ((memq ':background face)
                              (cadr (memq ':background face)))))
                      (t nil)))         ; Invalid face value.
         (bg    (and (not (member bg '("unspecified-fg" "unspecified-bg")))  bg)))
    (when msg-p
      (if bg (eyedrop-color-message bg) (message "No background color here")))
    bg))

;; RMS added this function to Emacs (23) as `foreground-color-at-point'.
;;;###autoload
(defalias 'foreground-color 'eyedrop-foreground-at-point)
;;;###autoload
(defun eyedrop-foreground-at-point (&optional msg-p)
  "Return the foreground color under the text cursor.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  ;; `eyedrop-face-at-point' alone is not sufficient.  It only gets named faces.
  ;; Need also pick up any face properties that are not associated with named faces.
  (let* ((face  (or (eyedrop-face-at-point)
                    (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face)))
         (fg    (cond ((and face (symbolp face))
                       (condition-case nil
                           (face-foreground face nil 'default) ; Emacs 22+.
                         (error (or (face-foreground face) ; Emacs 20
                                    (cdr (assq 'foreground-color (frame-parameters)))))))
                      ((consp face)
                       (cond ((memq 'foreground-color face)
                              (cdr (memq 'foreground-color face)))
                             ((memq ':foreground face)
                              (cadr (memq ':foreground face)))))
                      (t nil)))         ; Invalid face value.
         (fg    (and (not (member fg '("unspecified-fg" "unspecified-bg")))  fg)))
    (when msg-p
      (if fg (eyedrop-color-message fg) (message "No foreground color here")))
    fg))

;;;###autoload
(defun eyedrop-pick-background-at-mouse (event &optional msg-p)
  "Pick background of face or frame at character under the mouse pointer.
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-background (eyedrop-background-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defun eyedrop-pick-foreground-at-mouse (event &optional msg-p)
  "Pick foreground of face or frame at character under the mouse pointer.
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "e\np")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-mouse event)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;###autoload
(defalias 'eyedropper-background 'eyedrop-pick-background-at-point)
;;;###autoload
(defalias 'pick-background-color 'eyedrop-pick-background-at-point)
;;;###autoload
(defun eyedrop-pick-background-at-point (&optional msg-p)
  "Pick background of face or frame at character at text cursor (point).
Save the background color in `eyedrop-picked-background' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-background (eyedrop-background-at-point)
        eyedrop-last-picked-color eyedrop-picked-background)
  (unless (stringp eyedrop-picked-background) (error "No background color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-background))
  eyedrop-picked-background)

;;;###autoload
(defalias 'eyedropper-foreground 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defalias 'pick-foreground-color 'eyedrop-pick-foreground-at-point)
;;;###autoload
(defun eyedrop-pick-foreground-at-point (&optional msg-p)
  "Pick foreground of face or frame at character at text cursor (point).
Save the foreground color in `eyedrop-picked-foreground' and
`eyedrop-last-picked-color'.  Return the picked color.
Non-nil optional arg MSG-P means display an informative message."
  (interactive "p")
  (setq eyedrop-picked-foreground (eyedrop-foreground-at-point)
        eyedrop-last-picked-color eyedrop-picked-foreground)
  (unless (stringp eyedrop-picked-foreground) (error "No foreground color here to pick"))
  (when msg-p (eyedrop-color-message eyedrop-picked-foreground))
  eyedrop-picked-foreground)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'eyedropper)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; eyedropper.el ends here
#+end_src

** naked.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220333046938600

#+name: 20210601220333046938600
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; naked.el --- Provide for naked key descriptions: no angle brackets.
;;
;; Filename: naked.el
;; Description: Provide for naked key descriptions: no angle brackets.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2011-2020, Drew Adams, all rights reserved.
;; Created: Fri Oct  7 13:12:52 2011 (-0700)
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Wed Oct 14 08:46:05 2020 (-0700)
;;           By: dradams
;;     Update #: 206
;; URL: https://www.emacswiki.org/emacs/download/naked.el
;; Doc URL: https://www.emacswiki.org/emacs/NaKeD
;; Keywords: lisp, key, print, format, help
;; Compatibility: GNU Emacs 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Lets you use key-sequence descriptions that do not bother with
;;  angle brackets: `<' and `>'.
;;
;;  Prior to Emacs 21, vanilla GNU Emacs did not bother with angle
;;  brackets either, but someone around the turn of the century got
;;  the idea that Emacs could not do without them.  So instead of the
;;  `delete' key we now have the `<delete>' key.  And instead of`C-x
;;  M-delete' we now have `C-x M-<delete>'.  "On n'arrete pas le
;;  progres !"
;;
;;  Angle brackets are not needed - why?  Because we already use
;;  spaces to separate keys in a key-sequence description (we use
;;  `SPC' to indicate the SPACE key).
;;
;;  To be fair, it is true that sometimes people have taken the
;;  shortcut when writing about user input of writing, e.g., `M-x
;;  forward-char RET' instead of writing `M-x f o r w a r d - c h a
;;  r'. And if you write `forward' that way to stand for an input
;;  sequence of seven chars, then you cannot also expect `forward' to
;;  stand for a function key named `forward', can you?
;;
;;  Well, yes you can, if the context makes things clear enough.  And
;;  I for one find `C-M-<insert>' butt-ugly (likewise `<C-M-insert>')
;;  - and, more importantly, insulting to Occam and his razor.
;;
;;  So go ahead and go NaKeD - shed your angles.
;;
;;  Here's what you need.  It won't completely purge Emacs from
;;  insulting you with the occasional pair of angle brackets, but it
;;  at least lets you DTRT in code that you write:
;;
;;  * Use function `naked-key-description' instead of
;;    `key-description'.
;;
;;    The former outputs naked key descriptions: no angle brackets
;;    around function keys.  E.g., if KEY is the sequence of events
;;    produced by holding the Shift key while hitting the Insert key,
;;    then `(naked-key-description KEY)' returns "S-insert" (and not
;;    "S-<insert>").  (Internally, this sequence of events is the
;;    vector [S-insert].)
;;
;;  * Use function `naked' instead of `kbd' (which is a function
;;    starting with Emacs 24.3 and a macro before then).
;;
;;    The former allows its argument key-sequence description to use
;;    naked keys, not clothed in angle brackets.  E.g., (naked
;;    "C-M-delete") has the same effect as (kbd "C-M-<delete>").
;;
;;  * Use command `naked-read-kbd-macro' instead of `read-kbd-macro'.
;;
;;  * Use function `naked-edmacro-parse-keys' instead of
;;    `edmacro-parse-keys' (if you happen to use that lower-level
;;    function).
;;
;;  But you can also have it both ways if or when you might need to:
;;  All of these accept an optional argument ANGLES which, if
;;  non-`nil', returns the behavior to the vanilla one, expecting
;;  function keys to be fully clothed in angle brackets.  E.g.: (naked
;;  "C-M-<delete>" t).
;;
;;  In addition, even without an non-nil ANGLES argument, function
;;  `naked' does the right thing for keys expressed using angle
;;  brackets.  IOW, (naked "M-<foobar>") returns the same thing that
;;  (naked "M-foobar") does: [M-foobar].
;;
;;  Enjoy!
;;
;;
;;  Command defined here:
;;
;;    `naked-read-kbd-macro'.
;;
;;  Non-interactive functions defined here:
;;
;;    `naked', `naked-edmacro-parse-keys', `naked-key-description',
;;    `naked-read-kbd-macro', `naked-string-match-p'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2020/10/13 dadams
;;     Added: naked-string-match-p.
;;     naked-edmacro-parse-keys: Use naked-string-match-p when don't need to set match data.
;;     naked-read-kbd-macro: Fixed typo: \P -> \nP.
;; 2017/04/18 dadams
;;     Added forgotten compile-time require of cl.el, for macro cl-loop.
;; 2013/02/26 dadams
;;     Added (put 'naked 'pure t)
;; 2012/12/01 dadams
;;     Change naked from a macro to a function (like Emacs 24.3).
;; 2012/09/28 dadams
;;     naked-edmacro-parse-keys:
;;       Better fix for M-TAB.  Do not assume that function keys are lowercase.
;;       Handle angle brackets even if ANGLES is nil.  But keep vanilla bug #12535 if non-nil.
;; 2012/09/27 dadams
;;     naked-edmacro-parse-keys: Fix handling of M-TAB.  Function keys are lowercase.
;;                               So M-TAB returns [134217737], but M-tab returns [M-tab].
;; 2011/10/07 dadams
;;     Created.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (require 'cl-lib)) ;; cl-loop

;;;;;;;;;;;;;;;;;;;;;;;;;

(if (fboundp 'string-match-p)
    (defalias 'naked-string-match-p 'string-match-p) ; Emacs 23+
  (defun naked-string-match-p (regexp string &optional start)
    "Like `string-match', but this saves and restores the match data."
    (save-match-data (string-match regexp string start))))

;; Same as `icicle-key-description' in `icicles-fn.el'.
(defun naked-key-description (keys &optional prefix angles)
  "Like `key-description', but does not use angle brackets, by default.
Non-nil optional arg ANGLES means use angle brackets."
  (let ((result  (if (< emacs-major-version 22)
                     (key-description keys)
                   (key-description keys prefix))))
    (unless angles                      ; Assume that spaces separate function keys.
      (setq result  (replace-regexp-in-string "<\\([^>]+\\)>" "\\1" result 'fixed-case)))
    result))

;; Same as `icicle-edmacro-parse-keys' in `icicles-mac.el'.
;; Based on `edmacro-parse-keys' in standard library `edmacro.el'
;; Differences are:
;;
;; 1. Addition of optional arg ANGLES.
;; 2. Ensure same behavior as `edmacro-parse-keys', if ANGLES is non-nil.
;; 2. Handle angle brackets, whether ANGLES is nil or non-nil.
;; 3. Handle `TAB' correctly, if ANGLES is nil.
;; 4. Handle names without angle brackets, if ANGLES is nil.
;; 5. Works for all Emacs versions.
;;
(defun naked-edmacro-parse-keys (string &optional need-vector angles)
  "Like `edmacro-parse-keys', but does not use angle brackets, by default.
Non-nil optional arg ANGLES means to use angle brackets, exactly like
`edmacro-parse-keys'.  See `naked-read-kbd-macro' for more about
ANGLES."
  (let ((case-fold-search  nil)
    (len               (length string)) ; We won't alter string in the cl-loop below.
        (pos               0)
        (res               []))
    (while (and (< pos len)  (string-match "[^ \t\n\f]+" string pos))
      (let* ((word-beg  (match-beginning 0))
         (word-end  (match-end 0))
         (word      (substring string word-beg len))
         (times     1)
             (key       nil))
    ;; Try to catch events of the form "<as df>".
        (if (string-match "\\`<[^ <>\t\n\f][^>\t\n\f]*>" word)
            (setq word  (match-string 0 word)
                  pos   (+ word-beg (match-end 0)))
          (setq word  (substring string word-beg word-end)
                pos   word-end))
        (when (string-match "\\([0-9]+\\)\\*." word)
          (setq times  (string-to-number (substring word 0 (match-end 1)))
                word   (substring word (1+ (match-end 1)))))
        (cond ((naked-string-match-p "^<<.+>>$" word)
               (setq key  (vconcat (if (eq (key-binding [?\M-x]) 'execute-extended-command)
                                       [?\M-x]
                                     (or (car (where-is-internal 'execute-extended-command))  [?\M-x]))
                                   (substring word 2 -2) "\r")))

              ;; Must test this before [ACHMsS]- etc., to prevent match.
              ((or (equal word "REM")  (naked-string-match-p "^;;" word))
               (setq pos  (naked-string-match-p "$" string pos)))

              ;; Straight `edmacro-parse-keys' case - ensure same behavior.
              ;; Includes same bugged handling of `TAB'.  That is Emacs bug #12535.
              ;; The bug fix is to add `TAB' to the list in this clause.
          ((and angles
                    (string-match "^\\(\\([ACHMsS]-\\)*\\)<\\(.+\\)>$" word)
            (progn
              (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
              (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\)$" word))))
           (setq key  (list (intern word))))

              ;; NaKeD handling of <...>.  Recognize it anyway, even without non-nil ANGLES.
              ;; But unlike `edmacro-parse-keys', include <TAB>, to handle it correctly.
              ((and (string-match "^\\(\\([ACHMsS]-\\)*\\)<\\(..+\\)>$" word)
                    (progn
                      (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
                      (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\|TAB\\)$" word))))
               (setq key  (list (intern word))))

              ;; NaKeD handling of names without <...>.
              ((and (not angles)
                    (string-match "^\\(\\([ACHMsS]-\\)*\\)\\([^ \t\f\n][^ \t\f\n]+\\)$" word)
                    ;; Do not count `C-' etc. when at end of string.
                    (not (naked-string-match-p "\\([ACHMsS]-.\\)+$" word))
                    (progn
                      (setq word  (concat (substring word (match-beginning 1) (match-end 1))
                                          (substring word (match-beginning 3) (match-end 3))))
                      (not (naked-string-match-p "\\<\\(NUL\\|RET\\|LFD\\|ESC\\|SPC\\|DEL\\|TAB\\)$" word))))
               (setq key  (list (intern word))))

              (t
               (let ((orig-word  word)
                     (prefix     0)
                     (bits       0))
                 (while (naked-string-match-p "^[ACHMsS]-." word)
                   (cl-incf bits (cdr (assq (aref word 0) '((?A . ?\A-\^@) (?C . ?\C-\^@)
                                                         (?H . ?\H-\^@) (?M . ?\M-\^@)
                                                         (?s . ?\s-\^@) (?S . ?\S-\^@)))))
                   (cl-incf prefix 2)
                   (cl-callf substring word 2))
                 (when (naked-string-match-p "^\\^.$" word)
                   (cl-incf bits ?\C-\^@)
                   (cl-incf prefix)
                   (cl-callf substring word 1))
                 (let ((found  (assoc word '(("NUL" . "\0") ("RET" . "\r") ("LFD" . "\n")
                                             ("ESC" . "\e") ("SPC" . " ") ("DEL" . "\177")
                                             ("TAB" . "\t")))))
                   (when found (setq word  (cdr found))))
                 (when (naked-string-match-p "^\\\\[0-7]+$" word)
                   (cl-loop for ch across word
                         for n = 0 then (+ (* n 8) ch -48)
                         finally do (setq word  (vector n))))
                 (cond ((= bits 0) (setq key  word))
                       ((and (= bits ?\M-\^@)
                             (stringp word)
                             (naked-string-match-p "^-?[0-9]+$" word))
                        (setq key  (cl-loop for x across word collect (+ x bits))))
                       ((/= (length word) 1)
                        (error "%s must prefix a single character, not %s"
                               (substring orig-word 0 prefix) word))
                       ((and (/= (logand bits ?\C-\^@) 0)
                             (stringp word)
                             ;; Used to accept `.' and `?' here, but `.' is simply wrong,
                             ;; and `C-?' is not used (so use `DEL' instead).
                             (naked-string-match-p "[@-_a-z]" word))
                        (setq key  (list (+ bits (- ?\C-\^@) (logand (aref word 0) 31)))))
                       (t
                        (setq key  (list (+ bits (aref word 0)))))))))
        (when key (cl-loop repeat times do (cl-callf vconcat res key)))))
    (when (and (>= (length res) 4)  (eq (aref res 0) ?\C-x)  (eq (aref res 1) ?\()
               (eq (aref res (- (length res) 2)) ?\C-x)  (eq (aref res (- (length res) 1)) ?\)))
      (setq res  (edmacro-subseq res 2 -2)))
    (if (and (not need-vector)
         (cl-loop for ch across res
           always (and (if (fboundp 'characterp) (characterp ch) (char-valid-p ch))
                   (let ((ch2  (logand ch (lognot ?\M-\^@))))
                 (and (>= ch2 0)  (<= ch2 127))))))
    (concat (cl-loop for ch across res collect (if (= (logand ch ?\M-\^@) 0)  ch  (+ ch 128))))
      res)))

;; Same as `icicle-read-kbd-macro' in `icicles-mac.el'.
;;;###autoload
(defun naked-read-kbd-macro (start &optional end angles)
  "Read the region as a keyboard macro definition.
Like `read-kbd-macro', but does not use angle brackets, by default.

With a prefix arg use angle brackets, exactly like `read-kbd-macro'.
That is, with non-nil arg ANGLES, expect key descriptions to use angle
brackets (<...>).  Otherwise, expect key descriptions not to use angle
brackets.  For example:

 (naked-read-kbd-macro  \"mode-line\"  t)   returns [mode-line]
 (naked-read-kbd-macro \"<mode-line>\" t t) returns [mode-line]"
  (interactive "r\nP")
  (if (stringp start)
      (naked-edmacro-parse-keys start end angles)
    (setq last-kbd-macro  (naked-edmacro-parse-keys (buffer-substring start end) nil angles))))

(put 'naked 'pure t)
;; Same as `icicle-kbd' in `icicles-opt.el'.
(defun naked (keys &optional angles)
  "Like `kbd', but does not use angle brackets, by default.
With non-nil optional arg ANGLES, expect key descriptions to use angle
brackets (<...>), exactly like `kbd'.  Otherwise, expect key
descriptions not to use angle brackets.  For example:

 (naked \"mode-line\")     returns [mode-line]
 (naked \"<mode-line>\" t) returns [mode-line]

The default behavior lets you use, e.g., \"C-x delete\" and \"C-delete\"
instead of \"C-x <delete>\" and \"C-<delete>\"."
  (naked-read-kbd-macro keys nil angles))

;;;;;;;;;;;;;;;;;

(provide 'naked)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; naked.el ends here
#+end_src



** escreen.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220338361638300

#+name: 20210601220338361638300
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; escreen.el --- emacs window session manager

;; Author: Noah Friedman <friedman@splode.com>
;; Created: 1992-03-23
;; Public domain

;;; $Id: escreen.el,v 1.20 2017/06/05 18:13:00 friedman Exp $

;;; Commentary:

;; To install, put this file in your load-path, byte-compile it, and add
;; the following to your .emacs:
;;
;;   (load "escreen")
;;   (escreen-install)

;; Inspired by:
;;   * wicos.el, written by Heikki Suopanki <suopanki@phoenix.oulu.fi>
;;   * `screen', written by Oliver Laumann, Juergen Weigert,
;;     and Michael Schroeder.

;; Todo:
;;   * make escreen-menu display list of screens for all frames
;;   * ability to lock window configurations against change or deletion
;;   * ability to renumber screens
;;   * symbolic names for screens (a la wicos.el); partly started
;;   * switching active screen from pull-down menu from menubar
;;   * switching active screen from escreen menu
;;   * persistance of screens across instances of emacs
;;     [look at johnw's work on this; depends on additional non-standard
;;     packages but perhaps those parts can be reimplemented inline.]

;;; Code:

;; Variable declarations -- can be set by user

(defgroup escreen nil
  "Window configuration management"
  :group 'escreen
  :group 'extensions)

(defcustom escreen-max-screens 10
  "*Maximum number of screens that may be created."
  :type 'integer
  :group 'escreen)

(defcustom escreen-new-screen-default-buffer "*scratch*"
  "*Default buffer to display in newly-created screens."
  :type 'string
  :group 'escreen)

(defcustom escreen-restore-killed-buffers nil
  "*If non-nil, automatically revisit files if they have been killed.
That is, if a buffer was killed while in another screen session,
recreate them, visiting whatever file they were visiting."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-preserve-buffer-list-order t
  "*If non-nil, preserve buffer list for each screen when switching.
When returning to a previously-saved screen, the buffer list order is
restored.  Buffers which have been created since the saved screen was last
visited, are put at the end of the list but the relative order is preserved.

This buffer list order is returned by the function `buffer-list' and
affects the behavior of `other-buffer', etc.

In Emacs 20 and later, each frame has its own ordered buffer list.
Switching screen sessions affects the selected frame's buffer list only."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-number-mode t
  "*If non-nil, display current escreen number in mode line."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-install-number-mode-format t
  "*If non-nil, install `escreen-mode-line-format' on `global-mode-string'.
This is performed by `escreen-install'."
  :type 'boolean
  :group 'escreen)

(defcustom escreen-goto-screen-before-hook nil
  "*Hook to run in `escreen-goto-screen' before anything else."
  :type 'hook
  :group 'escreen)

(defcustom escreen-goto-screen-hook nil
  "*Hook to run after `escreen-goto-screen' completes.
An example function that can make use of this hook is
`escreen-enable-number-mode-if-more-than-one-screen'."
  :type 'hook
  :group 'escreen)

(defcustom escreen-menu-mode-hook nil
  "*Hook to run by `escreen-menu' after everything else."
  :type 'hook
  :group 'escreen)


;; Keybindings

(defcustom escreen-prefix-char "\C-\\"
  "*Character prefixing escreen commands.
If you wish to change this, you must also do

   (global-set-key escreen-prefix-char 'escreen-prefix)

to update the prefix in the global keymap."
  :type 'string
  :group 'escreen)

(defvar escreen-map nil
  "*Keymap for escreen commands.")
(cond
 ((null escreen-map)
  (setq escreen-map (make-sparse-keymap))
  (define-key escreen-map escreen-prefix-char 'escreen-goto-last-screen)
  (define-key escreen-map "0"    'escreen-goto-screen-0)
  (define-key escreen-map "1"    'escreen-goto-screen-1)
  (define-key escreen-map "2"    'escreen-goto-screen-2)
  (define-key escreen-map "3"    'escreen-goto-screen-3)
  (define-key escreen-map "4"    'escreen-goto-screen-4)
  (define-key escreen-map "5"    'escreen-goto-screen-5)
  (define-key escreen-map "6"    'escreen-goto-screen-6)
  (define-key escreen-map "7"    'escreen-goto-screen-7)
  (define-key escreen-map "8"    'escreen-goto-screen-8)
  (define-key escreen-map "9"    'escreen-goto-screen-9)
  (define-key escreen-map "?"    'escreen-help)
  (define-key escreen-map "\C-b" 'escreen-menu)
  (define-key escreen-map "a"    'escreen-get-active-screen-numbers)
  (define-key escreen-map "b"    'escreen-get-current-screen-number)
  (define-key escreen-map "c"    'escreen-create-screen)
  (define-key escreen-map "g"    'escreen-goto-screen)
  (define-key escreen-map "k"    'escreen-kill-screen)
  (define-key escreen-map "n"    'escreen-goto-next-screen)
  (define-key escreen-map "p"    'escreen-goto-prev-screen)))

(defalias 'escreen-prefix escreen-map)


;;; Internal variables.  Do not set these yourself.

;; This should not be modified by the user.  The information it provides is
;; critical and the calling conventions are different than for
;; escreen-map-data-format.  The order here is important too.
;; Do not change this data structure without also changing the
;; escreen-configuration-data-map-critical-* accessors.
(defvar escreen-map-critical-data-format
  (list 'current-buffer
        (lambda () (buffer-name))
        'buffer-file-name))

;; If you want to add or change this list, it's best to set
;; escreen-configuration-alist to nil and run escreen-install afterward.
;; Otherwise, the new table will be used with old data and may cause errors.
;;
;; Note that resetting escreen in this way loses all but the current
;; window configuration.
(defvar escreen-map-data-format
  '((escreen-map-save-window-start    . escreen-map-restore-window-start)
    (mark-marker                      . escreen-map-restore-mark-marker)
    (escreen-map-save-point           . escreen-map-restore-point)
    (escreen-map-save-narrowed-region . escreen-map-restore-narrowed-region)
    (escreen-map-save-truncate-lines  . escreen-map-restore-truncate-lines)
    (escreen-map-save-mode-line-face  . escreen-map-restore-mode-line-face)
    (escreen-map-save-menu-bar-mode   . escreen-map-restore-menu-bar-mode)
    (buffer-list                      . escreen-map-restore-buffer-list)))

;; It's ok to change this, but it makes use of internal variables
(defconst escreen-mode-line-format
  '(:eval (if (escreen-one-screen-p)
              ""
            (format "S%d " (escreen-current-screen-number)))))
;; This property required or redisplay won't evaluate this variable.
(put 'escreen-mode-line-format 'risky-local-variable t)

(eval-and-compile


;; Starting with Emacs 22, frame-local variables are deprecated and their
;; functionality has been progressively reduced with every major release.
;; As of Emacs 26, they are gone completely.  You can still create new
;; elements in the frame's parameter list, but you have to modify and
;; retrieve them explicitly using normal lisp calls.
;;
;; It's still useful to keep frame-specific values in the parameter alist
;; rather than maintaining a separate alist because this way they will
;; automatically be garbage collected when a frame is deleted.

;; Frame-specific parameters:
;;
;; * escreen-configuration-alist
;;   Keeps track of escreen state (window config, buffers, etc.)
;;   The structure of each elt is
;;
;;    (screen-number screen-name
;;                   #<window-configuration>
;;                   (((critical-data-buffer-1) user-data-buffer-1 ...)
;;                    ((critical-data-buffer-2) user-data-buffer-2 ...)
;;                    ...)
;;                   selected-window-number)
;;
;; * escreen-current-screen-number
;;   Current screen number on this frame.
;;   Smallest possible screen number is 0.
;;
;; * escreen-last-screen-number
;;   Last-visited screen number.
;;
;; * escreen-highest-screen-number-used
;;   Highest screen number currently in use on this frame.
;;
;; * escreen-one-screen-p
;;   `t' or nil depending on if there is more than one screen on this frame.
;;   This defaults to t since initially there is only one screen on a frame.
(defconst escreen-frame-default-values
  '((escreen-configuration-alist        . nil)
    (escreen-current-screen-number      . 0)
    (escreen-last-screen-number         . 0)
    (escreen-highest-screen-number-used . 0)
    (escreen-one-screen-p               . t)))

(defsubst escreen-get (var &optional frame)
  (let ((elt (assq var (frame-parameters frame))))
    (if elt
        (cdr elt)
      (cdr (assq var escreen-frame-default-values)))))

(defsubst escreen-set (var value &optional frame)
  (modify-frame-parameters frame (list (cons var value))))

;; Define getters and setters for each symbol that looks up or modifies
;; their frame-specific value.
(defmacro escreen-make-frame-specific-accessors (syms)
  (let ((fns nil)
        g s)
    (mapc (lambda (sym)
            (setq g `(defalias ',sym (lambda (&optional frame) (escreen-get ',sym frame)))
                  s `(defalias ',(intern (format "set-%s" sym))
                       (lambda (val &optional frame) (escreen-set ',sym val frame)))
                  fns (cons g (cons s fns))))
      (eval syms))
    (cons 'progn fns)))

(escreen-make-frame-specific-accessors (mapcar 'car escreen-frame-default-values))

) ;;eval-and-compile


(defmacro escreen-save-current-frame (&rest body)
  "Execute BODY, saving and restoring the selected frame."
  (declare (indent 0))
  (let ((orig-frame (make-symbol "orig-frame")))
    `(let ((,orig-frame (selected-frame)))
       (unwind-protect
           (progn ,@body)
         (when (frame-live-p ,orig-frame)
           (select-frame ,orig-frame))))))

;; Older versions of Emacs did not have window-pixel-edges
;; Older versions of XEmacs did not have window-edges
(defalias 'escreen-window-edges
  (if (fboundp 'window-edges) 'window-edges 'window-pixel-edges))


(defun escreen-install ()
  (interactive)
  (global-set-key escreen-prefix-char 'escreen-prefix)

  ;; Install screen number on global-mode-string
  (and escreen-install-number-mode-format
       (let ((elt '("" escreen-mode-line-format)))
         (or (member elt global-mode-string)
             (setq global-mode-string
                   (cons elt global-mode-string)))))

  (if escreen-number-mode
      (escreen-number-mode 1))

  (add-hook 'after-make-frame-functions 'escreen-initialize-frame-variables)
  (mapc 'escreen-initialize-frame-variables (frame-list)))

(defun escreen-number-mode (&optional prefix)
  "*Toggle escreen-number-mode (see variable docstring).
If called with a positive prefix argument, always enable.
If called with a negative prefix argument, always disable.
If called with no prefix argument, toggle current state."
  (interactive "P")
  (setq escreen-number-mode
        (cond ((null prefix)
               (not escreen-number-mode))
              (t
               (>= (prefix-numeric-value prefix) 0)))))


(defun escreen-create-screen ()
  "Create a new screen and switch to it.
New screen will display one window with the buffer specified by
`escreen-new-screen-default-buffer'."
  (interactive)
  (let ((new-screen-number (escreen-first-unused-screen-number)))
    (or new-screen-number
        (error "escreen: No more screens (see \"escreen-max-screens\")"))

    ;; Save window configuration before switching to a new one.
    (escreen-save-current-screen-configuration)
    (and (> new-screen-number (escreen-highest-screen-number-used))
         (set-escreen-highest-screen-number-used new-screen-number))
    (set-escreen-last-screen-number (escreen-current-screen-number))
    (set-escreen-current-screen-number new-screen-number)

    ;; Don't reuse any of the previous screen's window objects; settings
    ;; like window-dedicated-p, window display tables, etc. will just cause
    ;; grief.
    ;;
    ;; Modify the frame so there is only one window; this insures that we
    ;; have room to split to a second window.  Select new window, then
    ;; delete the previous one.  We now start the new screen with a totally
    ;; new window (the previous window is still saved in the window
    ;; configuration, so its settings are not lost).
    (delete-other-windows)
    (select-window (split-window))
    (delete-other-windows)

    ;; create a new window and switch to that, then delete the other window.
    ;; this is just
    (switch-to-buffer escreen-new-screen-default-buffer)
    ;; Save new window configuration so that it's in the alist.
    (escreen-save-current-screen-configuration))
  ;; We run this hook because, in a sense, we have gone to a new
  ;; screen. but we don't actually call escreen-goto-screen because of the
  ;; extra setup work here.
  (run-hooks 'escreen-goto-screen-hook))

(defun escreen-kill-screen (&optional number)
  "Kill current screen, or screen given by optional argument NUMBER.
No error occurs if the specified screen number doesn't exist.
You cannot kill the last existing screen.
Switch to previous screen if killing active one."
  (interactive)
  (let* ((screen-number (or number (escreen-current-screen-number)))
         (killing-current-screen-p (eq (escreen-current-screen-number)
                                       screen-number))
         (screen-data (escreen-configuration-escreen screen-number))
         previous-screen)
    (cond (screen-data
           (and killing-current-screen-p
                (escreen-configuration-one-screen-p)
                (error "escreen: only one screen, can't kill."))
           ;; Don't bother looking for previous screen number unless killing
           ;; current screen, because only then do we need to switch screens.
           (and killing-current-screen-p
                (setq previous-screen (escreen-get-prev-screen-number)))
           (escreen-configuration-escreen-delete screen-data)
           (and (eq screen-number (escreen-highest-screen-number-used))
                ;; We're killing the screen with the highest number.
                ;; Look for the next highest number.
                (set-escreen-highest-screen-number-used
                 (car (sort (escreen-configuration-screen-numbers) '>))))
           (and killing-current-screen-p
                (escreen-goto-screen previous-screen 'dont-update-current))))))

(defun escreen-initialize-frame-variables (&optional frame)
  (escreen-save-current-frame
    (select-frame frame)
    (set-escreen-configuration-alist nil)
    (escreen-save-current-screen-configuration)))


(defun escreen-goto-screen (number &optional dont-update-current)
  "Switch to screen number N.
Optional arg DONT-UPDATE-CURRENT means don't save the current screen
configuration, though this isn't intended to be used interactively."
  (interactive "NGo to escreen number: ")
  (run-hooks 'escreen-goto-screen-before-hook)
  (let ((screen-data (escreen-configuration-escreen number)))
    (or screen-data
        (error "escreen: %d: invalid screen number." number))
    (or dont-update-current
        (escreen-save-current-screen-configuration))
    (escreen-restore-screen-map screen-data)
    (or dont-update-current
        (set-escreen-last-screen-number (escreen-current-screen-number)))
    (set-escreen-current-screen-number number))
  (run-hooks 'escreen-goto-screen-hook))

(defun escreen-goto-last-screen ()
  "Switch to the last visited screen."
  (interactive)
  (let ((n (if (= (escreen-last-screen-number) (escreen-current-screen-number))
               (escreen-get-next-screen-number (escreen-last-screen-number))
             (escreen-last-screen-number))))
    (set-escreen-last-screen-number (escreen-current-screen-number))
    (escreen-goto-screen n)))

(defun escreen-goto-prev-screen (&optional n)
  "Switch to the previous screen.
This is the nearest lower-numbered existing screen from the current one,
wrapping around list of screens if necessary.
If prefix arg N given, jump to the Nth previous screen."
  (interactive "p")
  (if (< n 0)
      (escreen-goto-prev-or-next-screen-internal (- n) 'next)
    (escreen-goto-prev-or-next-screen-internal n 'prev)))

(defun escreen-goto-next-screen (&optional n)
  "Switch to the next screen.
This is the nearest greater-numbered existing screen from the current one,
wrapping around list of screens if necessary.
If prefix arg N given, jump to the Nth next screen."
  (interactive "p")
  (if (< n 0)
      (escreen-goto-prev-or-next-screen-internal (- n) 'prev)
    (escreen-goto-prev-or-next-screen-internal n 'next)))

(defun escreen-goto-prev-or-next-screen-internal (n prev-or-next)
  (let ((total (length (escreen-get-active-screen-numbers)))
        (func (if (eq prev-or-next 'next)
                  'escreen-get-next-screen-number
                'escreen-get-prev-screen-number))
        (i 0)
        (screen-number (escreen-current-screen-number)))
    (and (> n total)
         ;; Trim off excess amount so we do fewer iterations, since
         ;; wrapping over the total number of screens even once is
         ;; wasteful and slow.
         (setq n (- n (* (/ n total) total))))
    (while (< i n)
      (setq screen-number (funcall func screen-number)
            i (1+ i)))
    (escreen-goto-screen screen-number)))

(defun escreen-goto-screen-0 () (interactive) (escreen-goto-screen 0))
(defun escreen-goto-screen-1 () (interactive) (escreen-goto-screen 1))
(defun escreen-goto-screen-2 () (interactive) (escreen-goto-screen 2))
(defun escreen-goto-screen-3 () (interactive) (escreen-goto-screen 3))
(defun escreen-goto-screen-4 () (interactive) (escreen-goto-screen 4))
(defun escreen-goto-screen-5 () (interactive) (escreen-goto-screen 5))
(defun escreen-goto-screen-6 () (interactive) (escreen-goto-screen 6))
(defun escreen-goto-screen-7 () (interactive) (escreen-goto-screen 7))
(defun escreen-goto-screen-8 () (interactive) (escreen-goto-screen 8))
(defun escreen-goto-screen-9 () (interactive) (escreen-goto-screen 9))


(defun escreen-get-current-screen-number ()
  "Returns the currently selected screen number.
If called interactively, also print this result in the minibuffer."
  (interactive)
  (if (interactive-p)
      (message "escreen: current screen is number %d"
               (escreen-current-screen-number))
    (escreen-current-screen-number)))

(defun escreen-get-active-screen-numbers ()
  "Print a list of the active screen numbers in the echo area.
Returns a list of numbers which represent screen numbers presently in use."
  (interactive)
  (let ((screen-list (sort (escreen-configuration-screen-numbers) '<)))
    (if (interactive-p)
        (message "escreen: active screens: %s"
                 (mapconcat 'number-to-string screen-list " ")))
    screen-list))

(defun escreen-help ()
  "Display a short summary of escreen commands."
  (interactive)
  (if (string-lessp emacs-version "19")
      ;; emacs 18 couldn't list only bindings with a common prefix.
      (describe-bindings)
    ;; Emacs 19 can handle escreen-prefix-char (as a string) directly, but
    ;; for XEmacs, it must be converted to a vector.
    (describe-bindings (escreen-string-to-vector escreen-prefix-char))))

(defun escreen-string-to-vector (s)
  (let* ((l (length s))
         (v (make-vector l nil))
         (i 0))
    (while (< i l)
      (aset v i (aref s i))
      (setq i (1+ i)))
    v))


;; Return the first unused number available for designation as a screen
;; number, or nil if  escreen-max-screens  screens are already in use.
(defun escreen-first-unused-screen-number ()
  (let ((number 0))
    (while (and (< number escreen-max-screens)
                (escreen-configuration-escreen number))
      (setq number (1+ number)))
    (and (< number escreen-max-screens) number)))

;; Save window configuration, buffer configuration, and current marks and
;; point for each displayed buffer for the current screen.
(defun escreen-save-current-screen-configuration ()
  (let ((screen-data (escreen-screen-defined))
        (new-alist-member nil))
    (if screen-data
        (setcdr (cdr screen-data) (escreen-save-screen-map))
      (setq new-alist-member (cons (escreen-current-screen-number)
                                   (cons nil (escreen-save-screen-map))))
      (set-escreen-configuration-alist
       (cons new-alist-member (escreen-configuration-alist))))))

;; Return attributes for screen N, or nil if it doesn't exist.
(defun escreen-screen-defined (&optional n)
  (escreen-configuration-escreen (or n (escreen-current-screen-number))))

;; Return nearest number less than current screen number that is
;; an active screen, wrapping around end of screen list if necessary.
(defun escreen-get-prev-screen-number (&optional current-screen-number)
  (or current-screen-number
      (setq current-screen-number (escreen-current-screen-number)))
  (if (eq 0 (escreen-highest-screen-number-used))
      0
    ;; Decrement/wrap current screen number
    (setq current-screen-number (1- current-screen-number))
    (and (< current-screen-number 0)
         (setq current-screen-number (escreen-highest-screen-number-used)))
    (while (not (assq current-screen-number (escreen-configuration-alist)))
      ;; Decrement/wrap current screen number
      (setq current-screen-number (1- current-screen-number))
      (and (< current-screen-number 0)
           (setq current-screen-number (escreen-highest-screen-number-used))))
    current-screen-number))

;; Return nearest number greater than current screen number that is
;; an active screen, wrapping around end of screen list if necessary.
(defun escreen-get-next-screen-number (&optional current-screen-number)
  (or current-screen-number
      (setq current-screen-number (escreen-current-screen-number)))
  (let ((highest (escreen-highest-screen-number-used))
        (config-alist (escreen-configuration-alist)))
    (if (eq 0 highest)
        0
      ;; Increment/wrap current screen number
      (setq current-screen-number (1+ current-screen-number))
      (if (> current-screen-number highest)
          (setq current-screen-number 0))
      (while (not (assq current-screen-number config-alist))
        ;; Increment/wrap current screen number
        (setq current-screen-number (1+ current-screen-number))
        (if (> current-screen-number highest)
            (setq current-screen-number 0)))
      current-screen-number)))


;;; Primitive accessors for escreen-configuration-alist
;;;
;;; These could be made into macros or defsubsts, but it would make
;;; debugging more difficult and they are not critical for speed.

(defun escreen-configuration-escreen (number)
  (assq number (escreen-configuration-alist)))

(defun escreen-configuration-escreen-delete (data)
  (set-escreen-configuration-alist
   (delq (if (numberp data)
             (escreen-configuration-escreen data)
           data)
         (escreen-configuration-alist))))

(defun escreen-configuration-screen-numbers ()
  (mapcar 'car (escreen-configuration-alist)))

(defun escreen-configuration-one-screen-p ()
  (>= 1 (length (escreen-configuration-alist))))

;; Sort the alist so that they are in order numerically.
(defun escreen-configuration-alist-sort-by-number ()
  (set-escreen-configuration-alist
   (sort (escreen-configuration-alist)
         (lambda (a b)
           (< (car a) (car b))))))

;;; map-data sub-accessors

(defun escreen-configuration-screen-number (l)
  (nth 0 l))

(defun escreen-configuration-screen-name (l)
  (nth 1 l))

(defun escreen-configuration-window-data-configuration (l)
  (nth 2 l))

(defun escreen-configuration-data-map (l)
  (nth 3 l))

(defun escreen-configuration-selected-window-count (l)
  (nth 4 l))

;;; screen map data accessors

(defun escreen-configuration-data-map-critical (data)
  (car data))

(defun escreen-configuration-data-map-user (data)
  (cdr data))

;;; critical map data accessors

(defun escreen-configuration-data-map-critical-buffer (crit-map)
  (nth 0 crit-map))

(defun escreen-configuration-data-map-critical-buffer-name (crit-map)
  (nth 1 crit-map))

(defun escreen-configuration-data-map-critical-buffer-file-name (crit-map)
  (nth 2 crit-map))


(defun escreen-save-screen-map ()
  (let ((config (current-window-configuration))
        (win-data nil)
        (sel-win-count 0)
        (sel-window (selected-window))
        (first-window (escreen-first-window))
        (window nil))
    (save-excursion
      (save-window-excursion
        (select-window first-window)
        (while (not (eq window first-window))
          (cond ((null sel-window))
                ((eq (selected-window) sel-window)
                 (setq sel-window nil))
                (t
                 (setq sel-win-count (1+ sel-win-count))))
          (setq win-data
                (cons (cons (escreen-save-critical-data)
                            (escreen-save-user-data))
                      win-data))
          (setq window (select-window (next-window)))
          (set-buffer (window-buffer (selected-window))))))
    (list config (nreverse win-data) sel-win-count)))

(defun escreen-restore-screen-map (map)
  (let ((config (escreen-configuration-window-data-configuration map))
        (map (escreen-configuration-data-map map))
        (sel-win-number (escreen-configuration-selected-window-count map))
        (win-count 0)
        (sel-win nil))
    (set-window-configuration config)
    (select-window (escreen-first-window))
    (while map
      (and (= win-count sel-win-number)
           (setq sel-win (selected-window)))
      (setq win-count (1+ win-count))

      (escreen-restore-critical-data
       (escreen-configuration-data-map-critical (car map)))
      (widen)
      (escreen-restore-user-data
       (escreen-configuration-data-map-user (car map)))
      (select-window (next-window))
      (setq map (cdr map)))
    (select-window (or sel-win (escreen-first-window)))))

(defun escreen-save-critical-data ()
  (mapcar 'funcall escreen-map-critical-data-format))

(defun escreen-restore-critical-data (data)
  (let ((buffer (escreen-configuration-data-map-critical-buffer data))
        (buffer-name
         (escreen-configuration-data-map-critical-buffer-name data))
        (buf-file-name
         (escreen-configuration-data-map-critical-buffer-file-name data)))
    (cond ((escreen-killed-buffer-p buffer)
           (cond ((null escreen-restore-killed-buffers)
                  (set-window-buffer (selected-window)
                                     (get-buffer-create
                                      escreen-new-screen-default-buffer)))
                 ((stringp buf-file-name)
                  (setq buffer (find-file-noselect buf-file-name))
                  (set-window-buffer (selected-window) buffer)
                  (or (get-buffer buffer-name)
                      (rename-buffer buffer-name)))
                 (t
                  (set-window-buffer (selected-window)
                                     (get-buffer-create
                                      escreen-new-screen-default-buffer)))))
          (t
           (set-window-buffer (selected-window) buffer)))))

(defun escreen-save-user-data ()
  (mapcar (lambda (pair) (funcall (car pair)))
          escreen-map-data-format))

(defun escreen-restore-user-data (data)
  (let ((funlist escreen-map-data-format))
    (while (and data funlist)
      (funcall (cdr (car funlist)) (car data))
      (setq funlist (cdr funlist))
      (setq data (cdr data)))))


;; Functions used to save and restore screen configuration state.
;; These are mapped over via presence in escreen-map-data-format.

(defun escreen-map-save-window-start ()
  (escreen-make-marker (window-start)))

(defun escreen-map-restore-window-start (p)
  (and (escreen-position-valid-p p)
       (set-window-start (selected-window) p t)))

(defun escreen-map-restore-mark-marker (mark)
  (cond ((escreen-position-valid-p mark)
         (set-marker (or (mark-marker)
                         ;; when XEmacs zmacs-regions are set, mark-marker
                         ;; can return nil unless optional arg forcep is
                         ;; non-nil.
                         ;; In Emacs transient-mark-mode, mark-marker will
                         ;; still return a marker, so no magic needed.
                         (mark-marker t))
                     (marker-position mark)
                     (marker-buffer mark)))))

(defun escreen-map-save-point ()
  ;; If there is a process mark in the current buffer and point is at it,
  ;; then return the process mark also.  That way, when we return to this
  ;; screen, point will be at the end of the process output even if that
  ;; has advanced since then.  Otherwise, just use a before-insertion
  ;; marker (if supported).
  (let* ((point-mark (escreen-make-marker (point-marker) nil t))
         (proc (get-buffer-process (current-buffer)))
         (proc-mark (and proc (process-mark proc))))
    (if (and (escreen-position-valid-p proc-mark)
             (= proc-mark (point)))
        (cons proc-mark point-mark)
      point-mark)))

(defun escreen-map-restore-point (pos)
  (cond ((consp pos)
         (cond ((escreen-position-valid-p (car pos))
                (goto-char (car pos)))
               ((escreen-position-valid-p (cdr pos))
                (goto-char (cdr pos)))))
        (t
         (and (escreen-position-valid-p pos)
              (goto-char pos)))))

(defun escreen-map-save-narrowed-region ()
  (cons (and (> (point-min) 1)
             (escreen-make-marker (point-min)))
        (and (<= (point-max) (buffer-size))
             (escreen-make-marker (point-max) nil t))))

(defun escreen-map-restore-narrowed-region (reg)
  (let ((size (1+ (buffer-size)))
        (beg (or (car reg) (point-min)))
        (end (or (cdr reg) (point-max))))
    (and (escreen-position-valid-p beg)
         (escreen-position-valid-p end)
         (<= beg size)
         (<= end size)
         (narrow-to-region beg end))))

(defun escreen-map-save-truncate-lines ()
  truncate-lines)

(defun escreen-map-restore-truncate-lines (v)
  (setq truncate-lines v))

(defun escreen-map-save-mode-line-face ()
  (cond ((fboundp 'face-reverse-p)
         ;; XEmacs mode line face properties
         (list (face-reverse-p 'modeline)
               (face-background 'modeline)
               (face-foreground 'modeline)))
        ((boundp 'mode-line-inverse-video)
         mode-line-inverse-video)))

(defun escreen-map-restore-mode-line-face (v)
  (cond ((fboundp 'face-reverse-p)
         (set-face-reverse-p 'modeline (nth 0 v))
         (set-face-background 'modeline (nth 1 v))
         (set-face-foreground 'modeline (nth 2 v)))
        ((boundp 'mode-line-inverse-video)
         (setq mode-line-inverse-video v))))

;; Emacs 19.30 and beyond supports menu bars on ascii terminals, but beware
;; of turning them off or on once escreen is loaded; if a stored window
;; configuration was for a frame with a menu bar, but there is no menu bar
;; presently, that will crash emacs.  This fatal bug is present in all
;; versions of Emacs prior to 21.0.
(defun escreen-map-save-menu-bar-mode ()
  (and (boundp 'menu-bar-mode)
       menu-bar-mode))

(defun escreen-map-restore-menu-bar-mode (v)
  (cond ((fboundp 'menu-bar-mode)
         (if v
             (menu-bar-mode 1)
           (menu-bar-mode -1)))))

(defun escreen-map-restore-buffer-list (olist)
  (and escreen-preserve-buffer-list-order
       (escreen-set-buffer-list-order olist)))


(defun escreen-killed-buffer-p (buffer)
  (not (if (fboundp 'buffer-live-p)
           (buffer-live-p buffer)
         ;; Emacs 18 doesn't have buffer-live-p.
         ;; Killed buffers have no names.
         (buffer-name buffer))))

(defun escreen-position-valid-p (pos)
  (cond ((numberp pos)
         (<= pos (1+ (buffer-size))))
        ((markerp pos)
         (and (eq (marker-buffer pos) (current-buffer))
              (numberp (marker-position pos))
              (<= pos (1+ (buffer-size)))))
        (t nil)))

(defun escreen-set-buffer-list-order (olist)
  (let (firstbuf buf)
    (while olist
      (setq buf (car olist))
      (and (stringp buf)
           (setq buf (get-buffer buf)))
      (cond ((escreen-killed-buffer-p buf))
            (t
             (bury-buffer buf)
             (or firstbuf
                 (setq firstbuf buf))))
      (setq olist (cdr olist)))
    (setq olist (buffer-list))
    (while (not (eq (car olist) firstbuf))
      (bury-buffer (car olist))
      (setq olist (cdr olist)))))

;; Copy existing marker, or make a new one from point.
;; Emacs 19.30 and later can create markers which are advanced if text is
;; inserted before them, without needing to call insert-before-markers
;; explicitly.  This is useful for storing point, mark, etc. since the
;; buffer may be edited while we are in other escreens.
(defun escreen-make-marker (pos &optional buffer insertion-type)
  (let ((new-marker nil))
    (cond ((markerp pos)
           (setq new-marker (copy-marker pos))
           (and buffer
                (set-marker new-marker (marker-position pos) buffer)))
          (t
           (setq new-marker (make-marker))
           (set-marker new-marker pos buffer)))
    (and (fboundp 'set-marker-insertion-type)
         (set-marker-insertion-type new-marker insertion-type))
    new-marker))

(defun escreen-first-window ()
  (cond ((fboundp 'frame-highest-window)
         (funcall 'frame-highest-window))
        ((fboundp 'frame-first-window)
         (funcall 'frame-first-window))
        ((one-window-p)
         (selected-window))
        (t
         (let ((win (selected-window)))
           (while (not (escreen-first-window-p win))
             (setq win (next-window win)))
           win))))

(defun escreen-first-window-p (win)
  (let ((edges (escreen-window-edges win)))
    (and (= (nth 0 edges) 0)
         (= (nth 1 edges) 0))))


(defun escreen-menu ()
  (interactive)
  (escreen-configuration-alist-sort-by-number)
  (let ((escreen-menu-buffer (get-buffer-create "*Escreen List*"))
        alist data-map screen-number)
    ;; Display buffer now so update of screen cofiguration will be correct.
    (display-buffer escreen-menu-buffer)
    ;; Update escreen-configuration-alist to contain up-to-date information
    ;; on current screen, since we'll be displaying data about it.
    (escreen-save-current-screen-configuration)
    (setq alist (escreen-configuration-alist))
    (save-excursion
      (set-buffer escreen-menu-buffer)
      (setq buffer-read-only nil)
      (erase-buffer)
      (insert " Screen Buffers\n ------ -------\n")
      (while alist
        (setq screen-data (car alist))
        (setq alist (cdr alist))

        (setq screen-number (escreen-configuration-screen-number screen-data))
        (setq data-map (escreen-configuration-data-map screen-data))

        (if (= screen-number (escreen-current-screen-number))
            (insert (format "*%-6d " screen-number))
          (insert (format " %-6d " screen-number)))
        (while data-map
          (insert (if (> (current-column) 0) "" "        ")
                  (escreen-configuration-data-map-critical-buffer-name
                   (escreen-configuration-data-map-critical (car data-map)))
                  "\n")
          (setq data-map (cdr data-map)))
        (insert "\n"))
      (escreen-menu-mode))))

(defun escreen-menu-mode ()
  (fundamental-mode)
  (kill-all-local-variables)
  (setq buffer-undo-list t)
  (setq truncate-lines t)
  (setq buffer-read-only t)
  (setq major-mode 'escreen-menu-mode)
  (setq mode-name "Escreen Menu")
  (run-hooks 'escreen-menu-mode-hook))


;; Install this by doing
;;
;;    (add-hook 'escreen-goto-screen-hook
;;              'escreen-enable-number-mode-if-more-than-one-screen)
;;
;; By doing so, escreen-number-mode is disabled whenever only a single
;; escreen is in use.  The only reason for doing this, however, is to save
;; valuable mode line real estate.
(defun escreen-enable-number-mode-if-more-than-one-screen ()
  (set-escreen-one-screen-p
   (null (cdr (escreen-get-active-screen-numbers))))
  (force-mode-line-update t))

(provide 'escreen)

;;; escreen.el ends here
#+end_src

** oneonone.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220342869843300

#+name: 20210601220342869843300
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; oneonone.el --- Frame configuration that uses one frame per window.
;;
;; Filename: oneonone.el
;; Description: Frame configuration that uses one frame per window.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2018, Drew Adams, all rights reserved.
;; Created: Fri Apr  2 12:34:20 1999
;; Version: 0
;; Package-Requires: ((hexrgb "0"))
;; Last-Updated: Wed Nov 11 10:42:05 2020 (-0800)
;;           By: dradams
;;     Update #: 3222
;; URL: https://www.emacswiki.org/emacs/download/oneonone.el
;; Doc URL: https://emacswiki.org/emacs/OneOnOneEmacs
;; Keywords: local, frames
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `backquote', `bytecomp', `cconv', `cl-lib',
;;   `frame-cmds', `frame-fns', `hexrgb', `macroexp', `misc-fns',
;;   `oneonone', `strings', `thingatpt', `thingatpt+', `zoom-frm'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Frame configuration that uses one frame per window.
;;
;;  This library is part of One-on-One Emacs, a collection of
;;  libraries that try to make Emacs more frame-oriented and less
;;  window-oriented.
;;
;;  This library sets up Emacs to use multiple frames: individual
;;  frames are used, by default, instead of Emacs windows.  That is,
;;  the default is to use a frame for each Emacs window: one window on
;;  one frame.
;;
;;  You can configure each of the frames defined here.
;;
;;  Default properties are defined here for normal frames and
;;  "special" frames, which show "special-display buffers" (see Emacs
;;  manual for info on such frames).
;;
;;  In addition, these user options control the creation of three
;;  separate, specialized frames:
;;
;;    - `1on1-*Help*-frame-flag' - `*Help*' buffer frame
;;    - `1on1-*Completions*-frame-flag' - `*Completions*' buffer frame
;;    - `1on1-minibuffer-frame-flag' - minibuffer frame
;;
;;  Buffers `*Help*' and `*Completions*' are always displayed in their
;;  own frames.  In addition, if `1on1-*Help*-frame-flag' or
;;  `1on1-*Completions*-frame-flag' is non-nil, then the `*Help*' or
;;  `*Completions*' frame has a special (customizable) appearance.
;;
;;  If `1on1-minibuffer-frame-flag' is non-nil (the default value),
;;  then the minibuffer is shown in its own frame,
;;  `1on1-minibuffer-frame'; this is the only frame to have a
;;  minibuffer.  If you customize `1on1-minibuffer-frame-flag' to nil,
;;  then each frame will have its own minibuffer, as usual, and there
;;  will be no standalone minibuffer frame.
;;
;;  By default, if you use a standalone minibuffer frame, it is
;;  automatically sized to the full width of your display and placed
;;  at the bottom of the display.
;;
;;  If you use a standalone minibuffer frame then option
;;  `minibuffer-auto-raise' can make a difference.  This library does
;;  not change the option value.  A value of nil can make sense for
;;  some window managers that force the refocusing of a frame whenever
;;  it is raised.  If you use MS Windows then this is not a problem:
;;  command `1on1-emacs' sets the Windows-specific option
;;  `w32-grab-focus-on-raise' to nil, so that frame raising and
;;  focusing are decoupled.  So on MS Windows, at least, a non-nil
;;  value for `minibuffer-auto-raise' can make sense.
;;
;;  If `1on1-fit-minibuffer-frame-flag' is non-nil,
;;  `1on1-minibuffer-frame-flag' is non-nil, and you also use library
;;  `fit-frame.el', then, whenever the minibuffer is active, the
;;  minibuffer frame height is automatically adjusted to fit its
;;  content after each command or user event (e.g. each key press).
;;  Options `1on1-fit-minibuffer-frame-max-height' and
;;  `1on1-fit-minibuffer-frame-max-height-percent' define the maximum
;;  possible height for this behavior.  In addition, if you bind
;;  `1on1-fit-minibuffer-frame' to a key (I use `M-up'), then you can
;;  use that key repeatedly to increase the height by one line, even
;;  beyond the maximum.
;;
;;  To help you perceive changes to different minibuffer recursion
;;  levels, the background color of the minibuffer frame is changed
;;  slightly with each recursion-depth change.
;;
;;  If `1on1-minibuffer-frame-flag' is non-nil then you can have the
;;  standalone minibuffer frame be automatically repositioned near the
;;  cursor (point).  To do that, customize option
;;  `1on1-move-minibuffer-frame-near-point'.  Available only for Emacs
;;  24 and later.  For best results use this feature with Icicles.
;;
;;  This library is especially useful if used in combination with
;;  One-on-One Emacs libraries `autofit-frame.el', which automatically
;;  fits frames to their sole window, and `fit-frame.el', which lets
;;  you fit a frame to its selected window manually.  Library
;;  `autofit-frame.el' uses library `fit-frame.el'.
;;
;;  Because Emacs is not really designed to be frame-oriented, there
;;  are many built-in and standard functions that produce
;;  less-than-optimal results when frames, instead of windows, are the
;;  default.  In other One-on-One Emacs libraries, I have fixed most
;;  of these built-in functions to play well with frames.
;;
;;  For more information on One-on-One Emacs see
;;  https://www.emacswiki.org/emacs/OneOnOneEmacs.
;;
;;  To use this library, put the following at the *END* of your init
;;  file, `.emacs' (or `_emacs').  In particular, if your init file
;;  contains a `custom-set-variables' expression, then the following
;;  must appear *AFTER* that expression, in order for this to take
;;  into account your customizations of any `1on1-' user options.
;;
;;    (require 'oneonone)
;;    (1on1-emacs)
;;
;;  Initial frame: By default, the initial Emacs frame is like all
;;  other normal (non-special-display) frames; that is,
;;  `initial-frame-alist' effectively uses the frame properties
;;  defined in `default-frame-alist'.  If you would like the initial
;;  frame to be different, set `default-frame-alist' to nil after
;;  requiring `oneonone.el' but before executing `1on1-emacs':
;;
;;    (require 'oneonone)
;;    (setq default-frame-alist  nil)
;;    (setq initial-frame-alist  '((background-color . "White"))); e.g.
;;    (1on1-emacs)
;;
;;  If you want the text cursor to change to a box when Emacs is idle,
;;  then add this line also to your init file:
;;
;;    (toggle-box-cursor-when-idle 1) ; Turn on box cursor when idle.
;;
;;  Info and Customize frames: I recommend that you put the following
;;  code in your init file, so that Info and Customize buffers will
;;  display in their own frames.  Which code to use depends on your
;;  version of GNU Emacs.
;;
;;    (cond
;;     ((< emacs-major-version 21)
;;      (remove-hook 'same-window-buffer-names "*info*"))
;;     ((= emacs-major-version 21)
;;      (remove-hook 'same-window-buffer-names "*info*")
;;      (remove-hook 'same-window-regexps "\\`\\*Customiz.*\\*\\'"))
;;     (t
;;      (remove-hook 'same-window-regexps "\\*info\\*\\(\\|<[0-9]+>\\)")
;;      (remove-hook 'same-window-regexps "\\`\\*Customiz.*\\*\\'")))
;;
;;  Recommended `M-up' key bindings (requires library `fit-frame.el').
;;  (The reason for the conditionals is to handle all Emacs versions.)
;;
;;    (define-key minibuffer-local-map
;;                [(meta up)] '1on1-fit-minibuffer-frame)
;;    (unless (eq minibuffer-local-map
;;                (keymap-parent minibuffer-local-completion-map))
;;      (define-key minibuffer-local-must-match-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame)
;;      (define-key minibuffer-local-completion-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame))
;;    (when (boundp 'minibuffer-local-filename-completion-map)
;;      (define-key minibuffer-local-filename-completion-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame))
;;    (when (boundp 'minibuffer-local-must-match-filename-map)
;;      (define-key minibuffer-local-must-match-filename-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame))
;;    (when (boundp 'minibuffer-local-filename-must-match-map)
;;      (define-key minibuffer-local-filename-must-match-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame))
;;    (when (boundp 'minibuffer-local-isearch-map)
;;      (unless (eq minibuffer-local-map
;;                  (keymap-parent minibuffer-local-isearch-map))
;;        (define-key minibuffer-local-isearch-map
;;                    [(meta up)] '1on1-fit-minibuffer-frame)))
;;    (when (boundp 'minibuffer-local-shell-command-map)
;;      (unless (eq minibuffer-local-map
;;                  (keymap-parent minibuffer-local-shell-command-map))
;;        (define-key minibuffer-local-shell-command-map
;;                    [(meta up)] '1on1-fit-minibuffer-frame)))
;;    (when (boundp 'minibuffer-inactive-mode-map)
;;      (define-key minibuffer-inactive-mode-map
;;                  [(meta up)] '1on1-fit-minibuffer-frame))))
;;
;;  By default, `oneonone.el' sets the width of the bottom and right
;;  dividers, which separate Emacs windows, to 2 instead of 0.  This
;;  lets you more easily notice where to drag with your mouse, to
;;  resize windows.  If you use Emacs 24.4 or later then I also
;;  recommend that you consider customizing face `window-divider', to
;;  further highlight the dividers.
;;
;;
;;  Notes on user options defined here:
;;  ---------------------------------
;;
;;  Some non-option variables are used here only as conveniences to
;;  define frame-parameter alists.  They are defined using `defvar',
;;  not `defcustom', because you cannot use Customize to define them
;;  independently of the alist user options they help to define.  The
;;  alists themselves are the variables to customize.  If you want to
;;  change the `defvar' variables individually and then use them to
;;  set the alist variables, then use `setq', not Customize, to change
;;  them, and restart Emacs for their changes to take effect.
;;
;;  Changes to any user options defined here take effect as soon as
;;  `1on1-emacs' is executed, so you can do `M-x 1on1-emacs' to see
;;  their changes (no need to restart Emacs).
;;
;;  User options `1on1-color-minibuffer-frame-on-setup-increment' and
;;  `1on1-color-minibuffer-frame-on-exit-increment' determine how much
;;  to change the color of the minibuffer frame when the minibuffer is
;;  entered and exited.  They are hue increments, and should be
;;  opposite in sign.
;;
;;  They should cancel each other out, so that the color returns to
;;  what it was initially at any given minibuffer depth.  However,
;;  because of the way HSV and RGB color-component conversion works,
;;  the best cancellation does not necessarily occur when these
;;  options have the same absolute value.  And how much their absolute
;;  values should differ depends on that magnitude.  It is best to
;;  just set one of these to an increment you like, and then fiddle
;;  with the other until they more or less cancel.
;;
;;
;;  Commands defined here:
;;
;;    `1on1-emacs', `1on1-fit-minibuffer-frame',
;;    `1on1-ORIG-abort-recursive-edit', `1on1-ORIG-top-level',
;;    `1on1-ORIG-y-or-n-p', `1on1-other-frame',
;;    `1on1-set-box-cursor-when-idle-interval',
;;    `1on1-set-cursor-type', `1on1-toggle-box-cursor-when-idle'.
;;
;;  User options defined here:
;;
;;    `1on1-*Completions*-frame-flag',
;;    `1on1-*Completions*-frame-at-right-flag',
;;    `1on1-*Help*-frame-flag',
;;    `1on1-active-minibuffer-frame-background',
;;    `1on1-active-mode-line-background',
;;    `1on1-change-cursor-on-input-method-flag',
;;    `1on1-change-cursor-on-overwrite/read-only-flag',
;;    `1on1-color-minibuffer-frame-on-exit-increment',
;;    `1on1-color-minibuffer-frame-on-setup-increment',
;;    `1on1-color-mode-line-flag',
;;    `1on1-completions-frame-background',
;;    `1on1-completions-frame-mouse+cursor-color',
;;    `1on1-completions-frame-width',
;;    `1on1-completions-frame-zoom-font-difference',
;;    `1on1-default-frame-cursor-color',
;;    `1on1-default-frame-cursor-color-input-method',
;;    `1on1-default-frame-cursor-type',
;;    `1on1-default-frame-cursor-type-overwrite/read-only',
;;    `1on1-default-frame-alist', `1on1-help-frame-background',
;;    `1on1-help-frame-mouse+cursor-color',
;;    `1on1-inactive-minibuffer-frame-background',
;;    `1on1-inactive-mode-line-background',
;;    `isearch-minibuffer-frame-background',
;;    `1on1-minibuffer-frame-alist', `1on1-minibuffer-frame-flag',
;;    `1on1-minibuffer-frame-left',
;;    `1on1-minibuffer-frame-top/bottom',
;;    `1on1-minibuffer-frame-width',
;;    `1on1-minibuffer-frame-width-percent',
;;    `1on1-move-minibuffer-frame-near-point' (Emacs 24+),
;;    `1on1-remap-other-frame-command-flag',
;;    `1on1-special-display-frame-alist', `1on1-task-bar-height'
;;    (Emacs < 24.4).
;;
;;  Non-interactive functions defined here:
;;
;;    `1on1-box-cursor-when-idle',
;;    `1on1-change-cursor-on-input-method',
;;    `1on1-change-cursor-on-overwrite/read-only',
;;    `1on1-color-minibuffer-frame-on-exit',
;;    `1on1-color-minibuffer-frame-on-setup',
;;    `1on1-color-isearch-minibuffer-frame',
;;    `1on1-display-*Completions*-frame', `1on1-display-*Help*-frame',
;;    `1on1-filter-no-default-minibuffer',
;;    `1on1-flash-ding-minibuffer-frame',
;;    `1on1-last-non-minibuffer-buffer', `1on1-minibuffer-prompt-end',
;;    `1on1-reset-minibuffer-frame', `1on1-remove-if',
;;    `1on1-reposition-minibuffer-frame' (Emacs 24+),
;;    `1on1-set-minibuffer-frame-top/bottom',
;;    `1on1-set-minibuffer-frame-width',
;;    `1on1-setup-minibuffer-frame-coloring', `1on1-setup-mode-line'.
;;
;;  Non-option variables defined here:
;;
;;    `1on1-box-cursor-when-idle-p',
;;    `1on1-box-cursor-when-idle-interval',
;;    `1on1-box-cursor-when-idle-timer',
;;    `1on1-default-frame-background', `1on1-default-frame-font',
;;    `1on1-default-frame-foreground',
;;    `1on1-default-frame-menu-bar-lines',
;;    `1on1-default-frame-mouse-color', `1on1-default-frame-size',
;;    `1on1-default-frame-upper-left-corner', `1on1-divider-width',
;;    `1on1-last-cursor-type', `1on1-minibuffer-frame',
;;    `1on1-minibuffer-frame-background',
;;    `1on1-minibuffer-frame-bottom-offset',
;;    `1on1-minibuffer-frame-cursor-color',
;;    `1on1-minibuffer-frame-font',
;;    `1on1-minibuffer-frame-foreground',
;;    `1on1-minibuffer-frame-height',
;;    `1on1-minibuffer-frame-mouse-color',
;;    `1on1-move-minibuffer-frame-max-left-top' (Emacs 24+),
;;    `1on1-special-frame-background',
;;    `1on1-special-frame-cursor-color', `1on1-special-frame-font',
;;    `1on1-special-frame-foreground',
;;    `1on1-special-frame-menu-bar-lines',
;;    `1on1-special-frame-mouse-color', `1on1-special-frame-size',
;;    `1on1-special-frame-upper-left-corner'.
;;
;;
;;  ***** NOTE: These EMACS PRIMITIVES have been REDEFINED HERE:
;;
;;  `abort-recursive-edit', `top-level' -
;;               Reset color of minibuffer frame to "inactive" color.
;;
;;  `y-or-n-p' - Temporarily color minibuffer frame to "active" color.
;;
;;
;;  Acknowledgements:
;;
;;  The cursor-changing on input method and read-only was inspired by
;;  Juri Linkov <juri@jurta.org>.  Joe Casadonte <joc@netaxs.com>
;;  wrote a similar hook (`joc-cursor-type-set-hook'), which he got
;;  from Steve Kemp...
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;; Change Log:
;;
;; 2020/11/11 dadams
;;     1on1-fit-minibuffer-frame: Invoke raise-frame at the end.
;;     Updated commentary/doc to suggest using M-up, not C-o, for 1on1-fit-minibuffer-frame.
;; 2019/09/19 dadams
;;     1on1-move-minibuffer-frame-near-point, 1on1-reposition-minibuffer-frame:
;;       Allow just vertical offset too.
;; 2019/08/09 dadams
;;     y-or-n-p: Updated doc string per vanilla Emacs (26.2).
;; 2019/06/15 dadams
;;     Added, for Emacs 24+:
;;       1on1-move-minibuffer-frame-near-point, 1on1-move-minibuffer-frame-max-left-top,
;;       1on1-last-non-minibuffer-buffer, 1on1-reposition-minibuffer-frame (and put it on
;;       minibuffer-setup-hook).
;;     1on1-fit-minibuffer-frame: Removed 1on1-set-minibuffer-frame-top/bottom from default
;;       cond clause - interfered with *-move-minibuffer-frame-near-point and seems unnecessary.
;;     1on1-reset-minibuffer-frame: No-op if minibuffer-depth is not 1.
;;     1on1-set-minibuffer-frame-top/bottom: Added `(left 0) to params, to keep it at the left.
;; 2017/11/20 dadams
;;     1on1-change-cursor-on-input-method: Use color from 1on1-minibuffer-frame-alist before
;;                                         that or 1on1-minibuffer-frame-cursor-color.
;; 2016/12/30 dadams
;;     y-or-n-p: Return to Isearch color if searching.
;; 2015/08/21 dadams
;;     1on1-display-*Completions*-frame: Use icicle-mru-window-for-buffer (Emacs 24+).
;; 2015/08/20 dadams
;;     1on1-display-*Completions*-frame: Use face-remap-add-relative instead of set-face-*.
;; 2015/04/11 dadams
;;     1on1-display-*Completions*-frame: If minibuf is active, redirect to minibuf frame.
;;       And if not, do not redirect if completion-reference-buffer is *Completions*.
;; 2015/01/26 dadams
;;     1on1-display-*Completions*-frame: Use completion-reference-buffer, if displayed.
;; 2014/12/01 dadams
;;     1on1-emacs: Do not set minibuffer-auto-raise to nil.  Let user do it based on window mgr.
;;     1on1-default-frame-cursor-type(-overwrite/read-only), 1on1-emacs,
;;       1on1-change-cursor-on-overwrite/read-only:
;;         Ensure that cursor type cannot be set to nil.
;;     1on1-change-cursor-on-input-method:
;;       Do not set it if there is no setting based on null entry in default-frame-alist.
;; 2014/11/30 dadams
;;     1on1-emacs, 1on1-change-cursor-on-overwrite/read-only:
;;       Use cursor-type setting in default-frame-alist, not 1on1-default-frame-cursor-type.
;;     1on1-change-cursor-on-input-method:
;;       Use cursor-color setting in default-frame-alist, not 1on1-default-frame-cursor-color.
;; 2014/11/27 dadams
;;     Added: 1on1-task-bar-height, 1on1-minibuffer-frame-bottom-offset.
;;     1on1-emacs: Set 1on1-minibuffer-frame-bottom-offset (Emacs 24.4+ only).
;;     1on1-set-minibuffer-frame-top/bottom:
;;       Use *-minibuffer-frame-bottom-offset (or *-task-bar-height) instead of 2 * char height.
;;     1on1-set-minibuffer-frame-width: Use monitor width instead of x-display-pixel-width.
;; 2014/09/03 dadams
;;     1on1-minibuffer-frame-alist: No horizontal scroll bars.
;; 2014/08/28 dadams
;;     1on1-emacs: Removed vestigial defadvice of y-or-n-p.
;;     y-or-n-p: Fix regexp: [\n], not \n. Do not resize for Emacs 20 (it shows newlines as \n).
;; 2014/08/27 dadams
;;     y-or-n-p: Resize frame to fit PROMPT.  See Emacs bug #18340.
;;     1on1-default-frame-alist, 1on1-special-display-frame-alist: No horizontal scroll bars.
;; 2014/02/11 dadams
;;     1on1-color-minibuffer-frame-on-(exit|setup)-increment: Change type: number, not integer.
;; 2014/01/30 dadams
;;     Added: 1on1-divider-width.
;;     Renamed: 1on1-default-special-frame* to 1on1-special-frame*.
;;              This is an *incompatible change*: If you customized options with the old names
;;              then you will need recustomize using the new names.
;;     1on1-(default|special)-frame-alist: Use 1on1-divider-width.
;; 2013/12/21 dadams
;;     Removed autoload cookie: *-frame-alist.
;;     1on1-(in)active-mode-line-background: Use constant default, so can have autoload cookie.
;; 2013/08/12 dadams
;;     Added: 1on1-filter-no-default-minibuffer.
;;     1on1-minibuffer-frame-alist: Added: (cons 'desktop-dont-save t).
;;     frameset-filter-alist:  Add 1on1-filter-no-default-minibuffer and null name entries.
;; 2013/07/08 dadams
;;     1on1-color-minibuffer-frame-on-exit-increment: Set default value to 0.10.
;;     1on1-color-minibuffer-frame-on-exit:
;;       If level is 2 then set to 1on1-active-minibuffer-frame-background.
;;     1on1-setup-minibuffer-frame-coloring: Do not redefine abort-recursive-edit.
;;     y-or-n-p: Do not handle (> minibuffer-depth 0) case differently.
;; 2013/06/05 dadams
;;     *-frame-font: Changed sizes other than pixels to *, to work around an Emacs 20 bug with
;;                   x-list-fonts' on Windows 7.  See:
;;                   https://lists.gnu.org/archive/html/help-emacs-windows/2013-06/msg00009.html
;; 2013/01/18 dadams
;;     Removed: 1on1-increment-color-hue - use hexrgb-increment-hue.
;;     1on1-color-minibuffer-frame-on-(setup|exit)-increment: Divided increment by 100.
;;     1on1-color-minibuffer-frame-on-(setup|exit): use hexrgb-increment-hue.
;; 2013/01/02 dadams
;;     Added: 1on1-remap-other-frame-command-flag, 1on1-other-frame.
;; 2012/10/02 dadams
;;     Handle obsolescence of face modeline.
;; 2012/08/14 dadams
;;     1on1-fit-minibuffer-frame:
;;       Simplify by using window-frame and frame-first-window.  Thx to Martin Rudalics.
;;       Added optional arg RESETP (prefix arg), to reset to default height and position.
;; 2012/08/13 dadams
;;     Fixes to prevent losing input focus to *Completions* frame:
;;       1on1-fit-minibuffer-frame:
;;         Use save-window-excursion, not save-selected-window (2 places).
;;       1on1-set-minibuffer-frame-top/bottom: Use force-mode-line-update, not redisplay.
;; 2012/08/06 dadams
;;     Renamed: old-* to 1on1-ORIG-*:
;;       1on1-ORIG-abort-recursive-edit, 1on1-ORIG-top-level, 1on1-ORIG-y-or-n-p,
;; 2012/07/16 dadams
;;     1on1-fit-minibuffer-frame:
;;       Do nothing if last-event-frame is not the minibuffer frame.  Alternatively we could do
;;       nothing if this-command is handle-switch-frame.  Or we could just call
;;       select-frame-set-input-focus at its end to ensure minibuffer frame still has the focus.
;; 2012/03/31 dadams
;;     Wrap count-screen-lines with with-current buffer.  Fixes bug: M in Dired pops up and
;;      selects frame listing marked files - and that frame's screen lines were being used.
;; 2012/03/20 dadams
;;     1on1-fit-minibuffer-frame: Use count-screen-lines only for Emacs 23+ - see comment.
;; 2012/03/17 dadams
;;     1on1-fit-minibuffer-frame:
;;       Use count-screen-lines to get the Icomplete overlay height, to fix part of bug #11035.
;; 2012/03/02 dadams
;;     Added 1on1-remove-if: to avoid runtime load of cl.el.
;;     1on1-emacs: Use 1on1-remove-if, not remove-if.
;; 2011/10/05 dadams
;;     1on1-display-*Completions*-frame:
;;       Use same font family, not same font, as orig buff.  Only for Emacs 23+.
;; 2011/10/02 dadams
;;     1on1-display-*Completions*-frame:
;;       If using Icicles, use same font as frame that set up minibuffer.
;; 2011/08/19 dadams
;;     1on1-fit-minibuffer-frame:
;;       Removed the scroll-down because it interfered with doing stuff at eob.
;; 2011/06/15 dadams
;;     Removed soft require of files+.el (switch-to-buffer-other-frame no longer used).
;; 2011/01/04 dadams
;;     Added autoload cookies for defgroup, defcustom, and commands.
;; 2010/11/30 dadams
;;     1on1-minibuffer-frame-alist: Change fallback value from nil to 0 (Emacs bug #1077).
;; 2010/10/27 dadams
;;     1on1-default-frame-alist:
;;       Put back setting of tool-bar-lines for Emacs 24.  Emacs 24 bug was fixed.
;; 2010/07/09 dadams
;;     1on1-emacs: Soft-require fit-frame.el.
;; 2010/07/04 dadams
;;     1on1-default-frame-alist:
;;       Temp workaround: do not set tool-bar-lines for Emacs 24 (Emacs bug).
;; 2009/06/19 dadams
;;     1on1-completions-frame-zoom-font-difference: Supplied missing :type and :group.
;; 2009/05/15 dadams
;;     Added: 1on1-fit-minibuffer-frame-(flag|max-height(-percent)).
;;     1on1-emacs: Add/remove 1on1-fit-minibuffer-frame for post-command-hook (if *-flag).
;;     1on1-set-minibuffer-frame-top/bottom: Redisplay.
;;     1on1-fit-minibuffer-frame:
;;       Do nothing unless 1on1-fit-minibuffer-frame-flag.
;;       Test last-command vs 1on1-fit-minibuffer-frame, not vs this-command.
;;       Pass current frame width to fit-frame.
;;       Bind to the 1on1 minibuffer values for the call to fit-frame:
;;         fit-frame-max-height(-percent),(fit-frame|window)-min-height,fit-frame-empty-*.
;;       Don't bind: frame-width, fit-frame-(min|max)-width, window-min-width.
;;       Don't provide any extra height for Emacs 22+.
;; 2009/05/03 dadams
;;     Corrected commentary: some customizable vars were listed as non-customizable.
;; 2009/04/18 dadams
;;     1on1-emacs: Raise error if run without a graphics display.
;; 2009/04/10 dadams
;;     1on1-emacs: No menu bar or tool bar for *Completions* frame.
;; 2009/02/11 dadams
;;     1on1-display-*(Help|Completions)*-frame:
;;       Protect x-pointer-shape with boundp (Emacs 23 bug #2296 workaround).
;; 2009/01/13 dadams
;;     Added: 1on1-completions-frame-zoom-font-difference.
;;            Use in 1on1-display-*Completions*-frame.
;; 2009/01/01 dadams
;;     1on1-emacs: Removed assignment to pop-up-frame-alist.
;; 2008/09/08 dadams
;;     y-or-n-p: 1on1-color-minibuffer-frame-on-setup only if at top-level.
;; 2007/12/05 dadams
;;     1on1-minibuffer-frame-left: Added :type.
;;     1on1-color-mode-line-flag, 1on1-minibuffer-frame-flag: defvar -> defcustom.
;;     1on1-(minibuffer|(special-)default)-frame-*: Removed * doc-string prefix.
;; 2007/11/22 dadams
;;     Added: 1on1-reset-minibuffer-frame, 1on1-fit-minibuffer-frame,
;;            1on1-minibuffer-prompt-end.  Recommend C-o key binding.
;;     Use 1on1-reset-minibuffer-frame on minibuffer-exit-hook.
;; 2007/08/14 dadams
;;     1on1-emacs:
;;       Add *Completions* to special-display-buffer-names even if
;;         1on1-*Completions*-frame-flag is nil, so minibuffer gets focus.
;;       Set w(in)32-grab-focus-on-raise to nil.
;;     1on1-display-*Completions*-frame:
;;       Don't change mouse pointer unless 1on1-*Completions*-frame-flag.
;;     1on1-minibuffer-frame-background: Use std minibuffer-frame-alist bg, if defined.
;; 2007/05/28 dadams
;;     1on1-display-*Completions*-frame:
;;       Wrap zoom-frm-out in condition-case (hack for Emacs 23 problem changing size).
;; 2007/03/10 dadams
;;     Added: 1on1-completions-frame-width.  Use it in 1on1-emacs.
;; 2007/02/08 dadams
;;     Removed: ^L-appearance-vector.
;;     1on1-emacs: No longer change ^L appearance - use my library pp-c-l.el to do that.
;; 2007/02/04 dadams
;;     1on1-emacs:
;;       Initialize standard-display-table if nil (default is nil!).  Thx to FidelSalas.
;; 2006/12/27 dadams
;;     1on1-change-cursor-on-input-method: Respect 1on1-change-cursor-on-input-method-flag
;; 2006/12/12 dadams
;;     Added: 1on1-^L-appearance-vector.
;;     1on1-emacs: Use 1on1-^L-appearance-vector to set ^L appearance.
;; 2006/12/11 dadams
;;     1on1-set-minibuffer-frame-top/bottom: 2 chars up, not 1, to fit Emacs 22 better.
;; 2006/10/28 dadams
;;     1on1-(in)active-minibuffer-frame-background,
;;     1on1-isearch-minibuffer-frame-background, 1on1-(in)active-mode-line-background,
;;     1on1-(help|completions)-frame-background,
;;     1on1-(help|completions)-frame-mouse+cursor-color,
;;     1on1-default-frame-cursor-color(-input-method):
;;         Changed :type to 'color for Emacs 21+.
;; 2006/09/14 dadams
;;     Removed mode-line position enhancements - use new library modeline-posn.el.
;;       Removed: 1on1-color-mode-line-column-flag, 1on1-mode-line-column-limit.
;; 2006/09/04 dadams
;;     1on1-box-cursor-when-idle-timer: Cancel beforehand, and cancel after defining.
;;     1on1-toggle-box-cursor-when-idle:
;;       Use 1on1-box-cursor-when-idle-off on pre-command-hook.
;;       Don't read an event; just turn it on.
;;     Added: 1on1-box-cursor-when-idle-off.
;; 2006/09/02 dadams
;;      1on1-toggle-box-cursor-when-idle: Corrected.
;; 2006/08/27 dadams
;;      Added: 1on1-box-cursor-when-idle(-p|-interval|-timer), 1on1-last-cursor-type,
;;             (1on1-)toggle-box-cursor-when-idle, 1on1-set-box-cursor-when-idle-interval.
;; 2006/08/13 dadams
;;      defalias set-cursor-type to 1on1-set-cursor-type.
;; 2006/07/25 dadams
;;      Added: 1on1-minibuffer-frame-left.  Use in 1on1-minibuffer-frame-alist.
;; 2006/03/31 dadams
;;      1on1-default-frame-alist:
;;        Changed (left|right)-fringe code, to reflect Emacs 22 change.
;; 2006/03/17 dadams
;;      Renamed:
;;        1on1-color-active-minibuffer-frame to 1on1-color-minibuffer-frame-on-setup,
;;        1on1-color-inactive-minibuffer-frame to 1on1-color-minibuffer-frame-on-exit.
;;      1on1-color-minibuffer-frame-on-setup:
;;        Redefined so hue depends on minibuffer-depth.
;; 2006/03/14 dadams
;;      1on1-color-(in)active-minibuffer-frame: Change hue for each minibuffer recursion.
;;      Added: 1on1-increment-color-hue.
;;      Require hexrgb.el
;; 2006/03/13 dadams
;;      1on1-color-inactive-minibuffer-frame:
;;        Change color only when not in recursive minibuffer.
;;      abort-recursive-edit: Change minibuffer color after, not before, abort.
;; 2006/01/07 dadams
;;      Added :link
;; 2005/12/14 dadams
;;     Added: 1on1-*Completions*-frame-at-right-flag.
;;            Use in 1on1-display-*Completions*-frame.
;; 2005/11/28 dadams
;;     Added: 1on1-change-cursor-on-overwrite-flag,
;;            1on1-change-cursor-on-input-method-flag, 1on1-default-frame-cursor-type,
;;            1on1-default-frame-cursor-type-overwrite, 1on1-default-frame-cursor-color,
;;            1on1-default-frame-cursor-color-input-mode, 1on1-change-cursor-on-overwrite,
;;            1on1-change-cursor-on-insert-mode, 1on1-set-cursor-type (thanks to
;;            Juri Linkov for the last three).
;;     1on1-emacs: Use 1on1-change-cursor-* in post-command-hook.
;;     1on1-mode-line-column-limit: Corrected custom group.
;; 2005/11/22 dadams
;;     Added: 1on1-setup-mode-line, 1on1-mode-line-column-limit,
;;            1on1-color-mode-line(-column)-flag, 1on1-(in)active-mode-line-background.
;; 2005/10/28 dadams
;;     1on1-display-*Completions*-frame: Zoom to smaller font.
;; 2005/07/31 dadams
;;     1on1-emacs: Do not set initial-frame-alist to default-frame-alist (D. Reitter).
;; 2005/07/25 dadams
;;     Added :prefix to defgroup.
;; 2005/07/17 dadams
;;     Switched default colors for 1on1-(in)active-minibuffer-frame-background,
;;       so active is the brighter color.  Change inactive to LightBlue.
;; 2005/06/01 dadams
;;     Corrected typo that gave minibuffer frame a vertical scroll bar.
;; 2005/05/29 dadams
;;     *-alist: Use values from standard alist variables, if available (that is,
;;       don't override user settings.)
;; 2005/05/28 dadams
;;     Renamed: 1on1-separate-minibuffer-frame-flag -> 1on1-minibuffer-frame-flag,
;;       1on1-separate-*Help*-frame-flag -> 1on1-*Help*-frame-flag,
;;       1on1-separate-*Completions*-frame-flag -> 1on1-*Completions*-frame-flag.
;;     Added: setup-minibuffer-frame-coloring.
;;     Added info in doc strings about use of each variable (restart/1on1-emacs).
;;     Corrected 1on1-minibuffer-frame-alist and 1on1-special-display-frame-alist
;;       for menu-bar-lines (nil).
;;     1on1-set-minibuffer-frame-top/bottom: Rewrote with modify-frame-parameters.
;;     1on1-emacs:
;;       Make sensitive to any changes to 1on1-*[Help|Completions]*-frame-flag.
;;       Move defcustom's, defvar's, and defun's outside 1on1-emacs.
;;       If 1on1-minibuffer-frame already exists, just modify it.
;;       Don't step on other parameters in standard alists; just append new values.
;; 2005/05/23 dadams
;;     Changed some individual frame-parameter variables from defcustom to defvar.
;;       Left them as user options, however, so you can change them with
;;       set-variable before loading oneonone.el.
;;     Renamed:
;;       1on1-upper-left-frame-corner-default ->
;;          1on1-default-frame-upper-left-corner
;;       1on1-default-special-display-frame-size ->
;;          1on1-default-special-frame-size
;;       1on1-upper-left-special-display-frame-corner-default ->
;;          1on1-default-special-frame-upper-left-corner
;;     Split 1on1-menu-bar-lines into: 1on1-default-special-frame-menu-bar-lines,
;;          1on1-default-frame-menu-bar-lines
;; 2005/05/18 dadams
;;     Fixed typo: "oneoneone" -> "oneonone".
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2005/05/09 dadams
;;     Major reorganization/rewrite.  Created, from previous version setup-frames.el.
;;       Added prefix "1on1-".
;;       Encapsulated stuff in new command 1on1-emacs.
;; 2005/01/29 dadams
;;     1on1-default-frame-font: Fixed bug - misplaced parens, so no good if not Windows.
;; 2005/01/19 dadams
;;     Use defcustom now.
;;     Removed (put ... 'variable-interactive...).
;;     1on1-minibuffer-frame-top/bottom: Must be an integer (for set-frame-position).
;; 2004/12/18 dadams
;;     Bind after-make-frame-functions to nil when create 1on1-minibuffer-frame.
;; 2004/11/26 dadams
;;     Removed ;;;###autoload's.
;; 2004/11/20 dadams
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/10/01 dadams
;;     Ensure loaded before compile.
;;     No fringe.
;;     Remove *info* and *Customiz.* buffers from `same-window-regexps'
;; 2004/09/21 dadams
;;     Updated to work with Emacs 21 (and Emacs 20).
;; 2004/03/19 dadams
;;     1on1-minibuffer-frame-width -> 1on1-set-minibuffer-frame-width.
;;     added 1on1-set-minibuffer-frame-top/bottom.
;; 2001/01/05 dadams
;;     1. 1on1-minibuffer-frame-width: Use 1on1-minibuffer-frame arg for frame-char-width.
;;     2. Don't define width when initially set 1on1-minibuffer-frame-alist.  Instead,
;;        use set-frame-width afterward, so 1on1-minibuffer-frame-width uses correct
;;        character size.
;; 2001/01/05 dadams
;;     1. These vars no longer user options (interactively changeable):
;;        1on1-completions-frame-background, 1on1-completions-frame-mouse+cursor-color,
;;        1on1-help-frame-background, 1on1-help-frame-mouse+cursor-color,
;;        1on1-minibuffer-frame-cursor-color, 1on1-minibuffer-frame-font,
;;        1on1-minibuffer-frame-foreground, 1on1-minibuffer-frame-height,
;;        1on1-minibuffer-frame-mouse-color, 1on1-minibuffer-frame-top/bottom,
;;        1on1-minibuffer-frame-width.
;;     2. Added: 1on1-minibuffer-frame-width (function),
;;               1on1-minibuffer-frame-width-percent (var).
;;     3. Changed var 1on1-minibuffer-frame-width to nil default (now use *-percent).
;; 2000/09/27 dadams
;;     1. Added: 1on1-display-*Completions*-frame, 1on1-display-*Help*-frame.
;;     2. *Help* & *Completions* frames not created here.  Instead, use
;;        special-display-buffer-names & display-*-frame fns to define them.
;;     3. Added: top-level, abort-recursive-edit.
;; 1999/08/24 dadams
;;     1. Windows: win32-grab-focus-on-raise = nil.
;;     2. 1on1-default-frame-font different if Windows.
;;     3. Added: 1on1-separate-minibuffer-frame-flag, 1on1-menu-bar-lines,
;;        1on1-upper-left-frame-corner-default, 1on1-default-frame-size,
;;        1on1-upper-left-special-display-frame-corner-default,
;;        1on1-default-special-display-frame-size, 1on1-default-special-frame-foreground,
;;        1on1-default-special-frame-background, 1on1-default-special-frame-font,
;;        1on1-default-special-frame-mouse-color, 1on1-default-special-frame-cursor-color.
;;     4. Use new vars to define default-frame-alist, special-display-frame-alist.
;;     5. Only create built-in frames if 1on1-separate-minibuffer-frame-flag.
;;     6. Protected refs to x-* vars.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:


(eval-when-compile (when (< emacs-major-version 21) (require 'cl-lib))) ;; dolist, push

(require 'frame-cmds nil t) ;; (no error if not found): rename-frame
(require 'zoom-frm nil t) ;; (no error if not found):
                          ;; frame-zoom-font-difference, zoom-frm-out
(require 'hexrgb) ;; hexrgb-increment-hue


;; Ensure that this is loaded before compiling it.
(provide 'oneonone)
(require 'oneonone)


;; Quiet the byte compiler.
(defvar 1on1-move-minibuffer-frame-near-point) ; Here, Emacs 24+
(defvar 1on1-move-minibuffer-frame-max-left-top) ; Here, Emacs 24+
(defvar frameset-filter-alist)          ; In `frameset.el', Emacs 24.4+
(defvar x-pointer-box-spiral)
(defvar x-pointer-xterm)

;;;;;;;;;;;;;;;;;;;;;;;;

;;;###autoload
(defgroup One-On-One nil
  "Options to define initial frame configuration."
  :prefix "1on1-" :group 'frames
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=oneonone.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download" "https://www.emacswiki.org/emacs/download/oneonone.el")
  :link '(url-link :tag "Description"
          "https://www.emacswiki.org/emacs/OneOnOneEmacs")
  :link '(emacs-commentary-link :tag "Commentary" "oneonone"))

(defvar 1on1-divider-width 2
  "Default `bottom-divider-width' and `right-divider-width'.
This is used only to define the standard value of
`1on1-default-frame-alist' and `1on1-special-display-frame-alist'.
Customize those options, not this variable.  If you change this
variable, you will need to restart Emacs for it to take effect.")

;;; Minibuffer frame: ********************************
;;;
(defvar 1on1-minibuffer-frame nil
  "Minibuffer-only frame used by One-on-One Emacs.
Note: This is not used if `1on1-minibuffer-frame-flag' is nil.")

;;;###autoload
(defcustom 1on1-minibuffer-frame-flag t
  "*Non-nil means use a separate, specialized frame for the minibuffer.
Note that a non-nil value for this option also causes option
`pop-up-frames' to be set to `t'.  That is, it causes `display-buffer'
to generally use a separate frame.

If you change this variable, you will need to restart Emacs for it to
take effect."
  :type 'boolean :group 'One-On-One)

(unless (fboundp 'display-monitor-attributes-list) ; Emacs < 24.4.
  (defcustom 1on1-task-bar-height 28
    "Height of area at screen bottom that is not available for Emacs.
Space reserved for the MS Windows task bar, for example.
Not used for Emacs release 24.4 or later. "
    :type 'integer :group 'One-On-One))

(defvar 1on1-minibuffer-frame-bottom-offset nil
  "Offset for bottom of minibuffer frame, from monitor bottom.
The value is negative, and measured in pixels.")

;;;###autoload
(defcustom 1on1-remap-other-frame-command-flag (> emacs-major-version 23)
  "*Non-nil means rebind keys for `other-frame' to `1on1-other-frame'.
This has no effect unless `1on1-minibuffer-frame' is a frame, which
means that `1on1-minibuffer-frame-flag' is non-nil.
A non-nil value can be useful for Emacs starting with version 24,
because an inactive minibuffer has its own keymap."
  :type 'boolean :group 'One-On-One)

(defvar 1on1-minibuffer-frame-foreground "Red"
  "Default foreground color for the minibuffer frame.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-minibuffer-frame-background
  (or (cdr (assq 'background-color minibuffer-frame-alist)) "LightBlue")
  "Initial color of the `1on1-minibuffer-frame' background.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

;;;###autoload
(defcustom 1on1-active-minibuffer-frame-background "PaleGoldenrod"
  "*The color of the `1on1-minibuffer-frame' when it is active.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-inactive-minibuffer-frame-background "LightBlue"
  "*The color of the `1on1-minibuffer-frame' when it is inactive.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-isearch-minibuffer-frame-background "bisque"
  "*Color of the `1on1-minibuffer-frame' when `isearch' is active.
See `1on1-color-isearch-minibuffer-frame'.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-color-mode-line-flag t
  "*Non-nil means use `1on1-(in)active-mode-line-background'.
If you change this variable, you will need to restart Emacs for it to
take effect."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-color-minibuffer-frame-on-exit-increment 0.10
  "*Increment to change minibuffer-frame hue when minibuffer is exited.
This should be opposite in sign to
`1on1-color-minibuffer-frame-on-setup-increment.'"
  :type 'number :group 'One-On-One)

;;;###autoload
(defcustom 1on1-color-minibuffer-frame-on-setup-increment -0.10
  "*Increment to change minibuffer-frame hue when minibuffer is entered.
This should be opposite in sign to
`1on1-color-minibuffer-frame-on-exit-increment.'"
  :type 'number :group 'One-On-One)

;;;###autoload
(defcustom 1on1-active-mode-line-background "PaleGoldenrod"
  "*The color of the mode-line when it is active.
Note: This is not used if `1on1-color-mode-line-flag' is nil."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-inactive-mode-line-background "LightGray"
  "*The color of the mode-line when it is inactive.
Note: This is not used if `1on1-color-mode-line-flag' is nil."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

(defvar 1on1-minibuffer-frame-font
  (if (eq system-type 'windows-nt)
      ;;; "-*-Lucida Console-normal-r-*-*-14-112-96-96-c-*-iso8859-1"
      "-*-Lucida Console-normal-r-*-*-14-*-*-*-c-*-iso8859-1"
      ;;;;;;;"-*-Lucida Console-normal-r-*-*-15-*-*-*-c-*-*-ansi-"
    ;;; "-Misc-Fixed-Medium-R-Normal--15-140-75-75-C-90-ISO8859-1")
    "-Misc-Fixed-Medium-R-Normal--15-*-*-*-C-90-ISO8859-1")
  "Default font for the minibuffer frame.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-minibuffer-frame-mouse-color "Black"
  "Default mouse color for the minibuffer frame.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-minibuffer-frame-cursor-color "Black"
  "Default text cursor color for the minibuffer frame.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-minibuffer-frame-height 2
  "Height of minibuffer frame, in characters.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

This is used only to define the standard value of
`1on1-minibuffer-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

;;;###autoload
(defcustom 1on1-minibuffer-frame-left 0
  "*Position of left edge of minibuffer frame, in pixels.
An integer.  If negative, then the position is that of the frame
bottom relative to the screen right (not left) edge.

See `default-frame-alist' for an explanation of frame parameters.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'integer :group 'One-On-One)

;;;###autoload
(defcustom 1on1-minibuffer-frame-top/bottom nil
  "*Position of top (or bottom) of minibuffer frame, in pixels.
If nil, function `1on1-set-minibuffer-frame-top/bottom' will position
minibuffer at bottom of display.

An integer.  If negative, then the position is that of the frame
bottom relative to the screen bottom.

See `default-frame-alist' for an explanation of frame parameters.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type '(choice (const :tag "Use function `1on1-set-minibuffer-frame-top/bottom'" nil)
                 (integer :tag "Pixels from top (>= 0) or bottom (< 0)" :value 0))
  :group 'One-On-One)

;;;###autoload
(defcustom 1on1-minibuffer-frame-width nil
  "*Width, in characters, for minibuffer frame.
If nil, then function `1on1-set-minibuffer-frame-width' is used instead.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type '(choice (const :tag "Use function `1on1-set-minibuffer-frame-width'" nil)
                 (integer :tag "Width, in characters, for minibuffer frame" :value 0))
  :group 'One-On-One)

;;;###autoload
(defcustom 1on1-minibuffer-frame-width-percent 100
  "*Max percent of the total display width to give to minibuffer frame.
See function `1on1-set-minibuffer-frame-width'.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'integer :group 'One-On-One)

;; Use values from the standard list, when available.  However, we have no way of
;; distinguishing values predefined in vanilla Emacs from user settings.
(defcustom 1on1-minibuffer-frame-alist
  (list
   (or (assq 'foreground-color minibuffer-frame-alist)
       (cons 'foreground-color 1on1-minibuffer-frame-foreground))
   (or (assq 'background-color minibuffer-frame-alist)
       (cons 'background-color 1on1-minibuffer-frame-background))
   (or (assq 'font minibuffer-frame-alist)
       (cons 'font 1on1-minibuffer-frame-font))
   (or (assq 'mouse-color minibuffer-frame-alist)
       (cons 'mouse-color 1on1-minibuffer-frame-mouse-color))
   (or (assq 'cursor-color minibuffer-frame-alist)
       (cons 'cursor-color 1on1-minibuffer-frame-cursor-color))
   (or (assq 'menu-bar-lines minibuffer-frame-alist)
       (cons 'menu-bar-lines 0))
   (or (assq 'left minibuffer-frame-alist)
       (cons 'left 1on1-minibuffer-frame-left))
   (or (assq 'height minibuffer-frame-alist)
       (cons 'height 1on1-minibuffer-frame-height))
   (or (assq 'icon-type minibuffer-frame-alist)
       (cons 'icon-type (< emacs-major-version 21))) ; `t' for Emacs 21 too?
   (or (assq 'minibuffer minibuffer-frame-alist)
       (cons 'minibuffer 'only))
   (or (assq 'user-position minibuffer-frame-alist)
       (cons 'user-position t))
   (or (assq 'horizontal-scroll-bars minibuffer-frame-alist)
       (cons 'horizontal-scroll-bars nil)) ; No horizontal scroll bars by default.
   (or (assq 'vertical-scroll-bars minibuffer-frame-alist) ;  No scroll bar.
       (cons 'vertical-scroll-bars nil))
   (or (assq 'name minibuffer-frame-alist)
       (cons 'name "Emacs Minibuffer"))
   (or (assq 'desktop-dont-save minibuffer-frame-alist)
       (cons 'desktop-dont-save t)))
  "*Frame-parameter alist for the standalone minibuffer frame
`1on1-minibuffer-frame'.

Note: This is not used if `1on1-minibuffer-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  ;; If we didn't need Emacs 20 compatibility, this could be:
  ;; :type '(alist :key-type symbol :value-type sexp)
  :type '(repeat (cons :format "%v" (symbol :tag "Frame Parameter") (sexp :tag "Value")))
  :group 'One-On-One)

;;;###autoload
(defcustom 1on1-fit-minibuffer-frame-flag t
  "*Non-nil means adjust `1on1-minibuffer-frame' height to fit content.
This is done after each command or user event (e.g. each key press)
when the minibuffer is active.
This option has no effect if `1on1-minibuffer-frame-flag' is nil."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-fit-minibuffer-frame-max-height nil
  "*Maximum height, in lines, that `fit-frame' gives to `1on1-minibuffer-frame'.
If nil, then function `fit-frame-max-height' is used instead,
respecting `1on1-fit-minibuffer-frame-max-height-percent'.
This has no effect if you do not use library `fit-frame.el'."
  :type '(choice
          (const :tag "Use `1on1-fit-minibuffer-frame-max-height-percent'" nil)
          integer)
  :group 'One-On-One)

;;;###autoload
(defcustom 1on1-fit-minibuffer-frame-max-height-percent 10
  "*Max percent that `fit-frame' gives to `1on1-minibuffer-frame'.
This is a percentage of the display height.
Not used unless `1on1-fit-minibuffer-frame-max-height' is nil.
This has no effect if you do not use library `fit-frame.el'."
  :type 'integer :group 'One-On-One)

(when (boundp 'frameset-filter-alist)  ; Emacs 24.4+

  (defun 1on1-filter-no-default-minibuffer (current  _filtered  _parameters  saving)
    "Do not replace existing minibuffer frame when restoring a frameset."
    (or saving  (not (equal current '(frameset--mini t . t)))  '(frameset--mini t . nil)))

  (push '(frameset--mini . 1on1-filter-no-default-minibuffer) frameset-filter-alist)

  ;; Also, keep frame names when restoring a frameset.
  (push '(name . nil) frameset-filter-alist))



;;; *Help* frame: ********************************
;;;   Display of *Help* buffer in custom frame.
;;;   Background, height, cursor and pointer colors.
;;;
;;;###autoload
(defcustom 1on1-*Help*-frame-flag t
  "*Non-nil means use a special appearance for the *Help* frame.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-help-frame-background "Thistle"
  "*Default background color for the *Help* buffer's frame.

Note: This is not used if `1on1-*Help*-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-help-frame-mouse+cursor-color "Blue Violet"
  "*Default color for cursor & pointer of *Help* frame.

Note: This is not used if `1on1-*Help*-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;; *Completions* frame: ********************************
;;;   Display of *Completion* buffer in custom frame.
;;;   Background, height, cursor and pointer colors.
;;;
;;;###autoload
(defcustom 1on1-*Completions*-frame-flag t
  "*Non-nil means use a special appearance for the *Completions* frame.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-*Completions*-frame-at-right-flag nil
  "*Non-nil means place *Completions* frame at right edge of display.
This can be useful to make *Completions* more visible.
This has no effect if `1on1-*Completions*-frame-flag' is nil."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-completions-frame-background "LavenderBlush2"
  "*Default background color for the *Completions* buffer's frame.

Note: This is not used if `1on1-*Completions*-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-completions-frame-mouse+cursor-color "VioletRed"
  "*Default color for cursor & pointer of *Completions* frame.

Note: This is not used if `1on1-*Completions*-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-completions-frame-width 100
  "*Width, in characters, for *Completions* frame.
If this is nil, then the pertinent default frame width is used.

Note: This is not used if `1on1-*Completions*-frame-flag' is nil.

If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'integer :group 'One-On-One)

;;;###autoload
(defcustom 1on1-completions-frame-zoom-font-difference
  (or (and (require 'zoom-frm 'nil t)  (* 2 frame-zoom-font-difference))
      2)
  "*Number of points to reduce the *Completions* frame font size.
This must be less than the current default font size, since the new
font size cannot be less than 1 point.
A value of zero or nil means the *Completions* frame is not zoomed."
  :type '(restricted-sexp :match-alternatives (integerp null)) :group 'One-On-One)

;;; Default for normal frames: `1on1-default-frame-alist' **************************
;;;
(defvar 1on1-default-frame-foreground "Black"
  "Default foreground color for non-special frames.
This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-default-frame-background "LightBlue"
  "Default background color for non-special frames.
This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-default-frame-font
  (if (eq system-type 'windows-nt)
      ;;; "-*-Lucida Console-normal-r-*-*-14-112-96-96-c-*-iso8859-1"
      "-*-Lucida Console-normal-r-*-*-14-*-*-*-c-*-iso8859-1"
      ;;;;;;"-*-Lucida Console-normal-r-*-*-15-*-*-*-c-*-*-ansi-"
    ;;; "-Misc-Fixed-Medium-R-Normal--15-140-75-75-C-90-ISO8859-1")
    "-Misc-Fixed-Medium-R-Normal--15-*-*-*-C-90-ISO8859-1")
  "Default font for non-special frames.
This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-default-frame-mouse-color "Red"
  "Default mouse-pointer color for non-special frames.
This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

;;;###autoload
(defcustom 1on1-change-cursor-on-input-method-flag t
  "*Non-nil means to use a different cursor when using an input method.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-default-frame-cursor-color "Red"
  "*Default text cursor color for non-special frames.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect.  Furthermore, if
`1on1-change-cursor-on-input-method-flag' is nil when you rerun
`1on1-emacs', you will need to toggle that variable to non-nil (and
back to nil, if that's the value you want).  Otherwise, the new value
will take effect only after you restart Emacs."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-default-frame-cursor-color-input-method "Orange"
  "*Default cursor color for non-special frames if using an input method.
This has no effect if `1on1-change-cursor-on-input-method-flag' is nil.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type (if (>= emacs-major-version 21) 'color 'string) :group 'One-On-One)

;;;###autoload
(defcustom 1on1-change-cursor-on-overwrite/read-only-flag t
  "*Non-nil means use a different cursor when overwrite mode or read-only.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  :type 'boolean :group 'One-On-One)

;;;###autoload
(defcustom 1on1-default-frame-cursor-type 'bar
  "*Default text cursor type for non-special frames.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect.  Furthermore, if
`1on1-change-cursor-on-overwrite/read-only-flag' is nil when you rerun
`1on1-emacs', you will need to toggle that variable to non-nil (and
back to nil, if that's the value you want).  Otherwise, the new value
will take effect only after you restart Emacs."
  ;; Ensure that it cannot be set to `nil'.
  :type '(restricted-sexp :match-alternatives ((lambda (x) (and x  (symbolp x)))) :value bar)
  :group 'One-On-One)

(defvar 1on1-last-cursor-type 1on1-default-frame-cursor-type "Saved last cursor type.")

;;;###autoload
(defcustom 1on1-default-frame-cursor-type-overwrite/read-only 'box
  "*Default text cursor type for overwrite mode or read-only buffer.
This applies only to non-special frames.  This has no effect if
`1on1-change-cursor-on-overwrite/read-only-flag' is nil.  If you
customize this variable, you will need to rerun `1on1-emacs' for the
new value to take effect."
  ;; Ensure that it cannot be set to `nil'.
  :type '(restricted-sexp :match-alternatives ((lambda (x) (and x  (symbolp x)))) :value box)
  :group 'One-On-One)

(defvar 1on1-box-cursor-when-idle-p t
  "Non-nil means to use a box cursor whenever Emacs is idle.
Do NOT change this yourself; instead, use `\\[toggle-box-cursor-when-idle]'.")

(defvar 1on1-box-cursor-when-idle-interval 2
  "Number of seconds to wait before changing cursor type to box.
Do NOT change this yourself to change the wait period; instead, use
`\\[1on1-set-box-cursor-when-idle-interval]'.")

(defvar 1on1-box-cursor-when-idle-timer
  (progn                                ; Cancel to prevent duplication.
    (when (boundp '1on1-box-cursor-when-idle-timer)
      (cancel-timer 1on1-box-cursor-when-idle-timer))
    (run-with-idle-timer 1on1-box-cursor-when-idle-interval t '1on1-box-cursor-when-idle))
  "Timer used to change the cursor to a box cursor when Emacs is idle.")

;; Turn it off, by default.  You must use `toggle-box-cursor-when-idle' to turn it on.
(cancel-timer 1on1-box-cursor-when-idle-timer)

(defvar 1on1-default-frame-menu-bar-lines 1
  "Number of lines used for the menu bar in non-special frames.
This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-default-frame-upper-left-corner '(0 . 0)
  "Position of upper left frame corner.
A cons whose car is the distance from the top in pixels
and whose cdr is the distance from the left in pixels.

This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

(defvar 1on1-default-frame-size '(80 . 35)
  "Default frame size.

A cons whose car is the frame width in characters and whose cdr is the
frame height in characters.

This is used only to define the standard value of
`1on1-default-frame-alist'.  Customize that variable, not this one.
If you change this variable, you will need to restart Emacs for it to
take effect.")

;; Use values from the standard list, when available.  However, we have no way of
;; distinguishing values predefined in vanilla Emacs from user settings.
(defcustom 1on1-default-frame-alist
  (list
   (or (assq 'foreground-color default-frame-alist)
       (cons 'foreground-color 1on1-default-frame-foreground))
   (or (assq 'background-color default-frame-alist)
       (cons 'background-color 1on1-default-frame-background))
   (or (assq 'font default-frame-alist)
       (cons 'font 1on1-default-frame-font))
   (or (assq 'mouse-color default-frame-alist)
       (cons 'mouse-color 1on1-default-frame-mouse-color))
   (or (assq 'cursor-color default-frame-alist)
       (cons 'cursor-color 1on1-default-frame-cursor-color))
   (or (assq 'cursor-type default-frame-alist)
       (cons 'cursor-type 1on1-default-frame-cursor-type))
   (or (assq 'menu-bar-lines default-frame-alist)
       (cons 'menu-bar-lines 1on1-default-frame-menu-bar-lines))
   (or (assq 'bottom-divider-width default-frame-alist)
       (cons 'bottom-divider-width 1on1-divider-width))
   (or (assq 'right-divider-width default-frame-alist)
       (cons 'right-divider-width 1on1-divider-width))
   (or (assq 'top default-frame-alist)
       (cons 'top (car 1on1-default-frame-upper-left-corner)))
   (or (assq 'left default-frame-alist)
       (cons 'left (cdr 1on1-default-frame-upper-left-corner)))
   (or (assq 'width default-frame-alist)
       (cons 'width (car 1on1-default-frame-size)))
   (or (assq 'height default-frame-alist)
       (cons 'height (cdr 1on1-default-frame-size)))
   (or (assq 'minibuffer default-frame-alist)
       (cons 'minibuffer (not 1on1-minibuffer-frame-flag)))
   (or (assq 'user-position default-frame-alist)
       (cons 'user-position t))
   (or (assq 'horizontal-scroll-bars default-frame-alist)
       (cons 'horizontal-scroll-bars nil)) ; No horizontal scroll bars by default.
   (or (assq 'vertical-scroll-bars default-frame-alist)
       (cons 'vertical-scroll-bars 'right))
   (or (assq 'icon-type default-frame-alist)
       (cons 'icon-type (< emacs-major-version 21))) ; `t' for Emacs 21 too?
   (or (assq 'tool-bar-lines default-frame-alist)
       (cons 'tool-bar-lines 1))        ; Emacs 21+
   (if (cdr (assq 'left-fringe default-frame-alist))
       (assq 'left-fringe default-frame-alist)
     (cons 'left-fringe 0))             ; Emacs 21+
   (if (cdr (assq 'right-fringe default-frame-alist))
       (assq 'right-fringe default-frame-alist)
     (cons 'right-fringe 0))            ; Emacs 21+
   (or (assq 'fringe default-frame-alist)
       (cons 'fringe 0)))               ; Emacs 21, but not 21.3.50 - REMOVE after 22.x
  "*Properties to be used for One-on-One Emacs `default-frame-alist'.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  ;; If we didn't need Emacs 20 compatibility, this could be:
  ;; :type '(alist :key-type symbol :value-type sexp)
  :type '(repeat (cons :format "%v" (symbol :tag "Frame Parameter") (sexp :tag "Value")))
  :group 'One-On-One)

;;; Special-display frames: `1on1-special-display-frame-alist' ************************
;;;
(defvar 1on1-special-frame-foreground "Black"
  "Default foreground color for special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-background "LightSteelBlue"
  "Default background color for special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-font
  (if (eq system-type 'windows-nt)
      ;;; "-*-Lucida Console-normal-r-*-*-14-112-96-96-c-*-iso8859-1"
      "-*-Lucida Console-normal-r-*-*-14-*-*-*-c-*-iso8859-1"
      ;;;;;;;;"-*-Lucida Console-normal-r-*-*-15-*-*-*-c-*-*-ansi-"
    ;;; "-Misc-Fixed-Medium-R-Normal--15-140-75-75-C-90-ISO8859-1")
    "-Misc-Fixed-Medium-R-Normal--15-*-*-*-C-90-ISO8859-1")
  "Default font for special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-mouse-color "Yellow"
  "Default mouse color for special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-cursor-color "Yellow"
  "Default text cursor color for special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-menu-bar-lines 1
  "Number of lines used for the menu bar of special display frames.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-upper-left-corner '(0 . 0)
  "Position of upper left corner of special display frames.
A cons whose car is the distance from the top in pixels
and whose cdr is the distance from the left in pixels.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

(defvar 1on1-special-frame-size '(80 . 20)
  "Default size of special display frames.
A cons whose car is the frame width in characters and whose cdr is the
frame height in characters.

This is used only to define the standard value of
`1on1-special-display-frame-alist'.  Customize that variable, not this
one.  If you change this variable, you will need to restart Emacs for
it to take effect.")

;; Use values from the standard list, when available.  However, we have no way of
;; distinguishing values predefined in vanilla Emacs from user settings.
(defcustom 1on1-special-display-frame-alist
  (list
   (or (assq 'font special-display-frame-alist)
       (cons 'font 1on1-special-frame-font))
   (or (assq 'width special-display-frame-alist)
       (cons 'width (car 1on1-special-frame-size)))
   (or (assq 'height special-display-frame-alist)
       (cons 'height (cdr 1on1-special-frame-size)))
   (or (assq 'mouse-color special-display-frame-alist)
       (cons 'mouse-color 1on1-special-frame-mouse-color))
   (or (assq 'cursor-color special-display-frame-alist)
       (cons 'cursor-color 1on1-special-frame-cursor-color))
   (or (assq 'menu-bar-lines special-display-frame-alist)
       (cons 'menu-bar-lines 1on1-special-frame-menu-bar-lines))
   (or (assq 'bottom-divider-width special-display-frame-alist)
       (cons 'bottom-divider-width 1on1-divider-width))
   (or (assq 'right-divider-width special-display-frame-alist)
       (cons 'right-divider-width 1on1-divider-width))
   (or (assq 'foreground-color special-display-frame-alist)
       (cons 'foreground-color 1on1-special-frame-foreground))
   (or (assq 'background-color special-display-frame-alist)
       (cons 'background-color 1on1-special-frame-background))
   (or (assq 'top special-display-frame-alist)
       (cons 'top (car 1on1-special-frame-upper-left-corner)))
   (or (assq 'left special-display-frame-alist)
       (cons 'left (cdr 1on1-special-frame-upper-left-corner)))
   (or (assq 'unsplittable special-display-frame-alist)
       (cons 'unsplittable t))
   (or (assq 'user-position special-display-frame-alist)
       (cons 'user-position t))
   (or (assq 'horizontal-scroll-bars special-display-frame-alist)
       (cons 'horizontal-scroll-bars nil)) ; No horizontal scroll bars by default.
   (or (assq 'vertical-scroll-bars special-display-frame-alist)
       (cons 'vertical-scroll-bars 'right)))
  "Properties to be used for One-on-One `special-display-frame-alist'.
If you customize this variable, you will need to rerun `1on1-emacs'
for the new value to take effect."
  ;; If we didn't need Emacs 20 compatibility, this could be:
  ;; :type '(alist :key-type symbol :value-type sexp)
  :type '(repeat (cons :format "%v" (symbol :tag "Frame Parameter") (sexp :tag "Value")))
  :group 'One-On-One)

;;; Main command ***************************************
;;;
;;;###autoload
(defun 1on1-emacs ()
  "One-on-One Emacs setup.
Use `1on1-default-frame-alist' and `1on1-special-display-frame-alist'.

If `1on1-minibuffer-frame-flag' is non-nil, then create
   minibuffer-only frame, `1on1-minibuffer-frame', using
   `1on1-minibuffer-frame-alist'.

If `1on1-*Help*-frame-flag' is non-nil, then use special frame for
   ,*Help* buffer.

If `1on1-*Completions*-frame-flag' is non-nil, then use special frame
   for *Completions* buffer."
  (interactive)
  (unless (if (fboundp 'display-graphic-p) (display-graphic-p) window-system)
    (error "Use `1on1-emacs' only with a graphics display, not with a text terminal"))
  (setq default-frame-alist          (append 1on1-default-frame-alist default-frame-alist)
        special-display-frame-alist  (append 1on1-special-display-frame-alist
                                             special-display-frame-alist))

  ;; `*Help*' frame
  (if 1on1-*Help*-frame-flag
      (add-to-list
       'special-display-buffer-names
       (list "*Help*" '1on1-display-*Help*-frame
             (list (cons 'background-color 1on1-help-frame-background)
                   (cons 'mouse-color 1on1-help-frame-mouse+cursor-color)
                   (cons 'cursor-color 1on1-help-frame-mouse+cursor-color)
                   '(height . 40))))
    (setq special-display-buffer-names  (1on1-remove-if (lambda (elt)
                                                          (equal "*Help*" (car elt)))
                                                        special-display-buffer-names)))

  ;; `*Completions*' frame
  ;; If `1on1-minibuffer-frame-flag' is non-nil, then *Completions* frame must be treated
  ;; specially, so that it gets focus from the minibuffer frame.  This is so, even if
  ;; `1on1-*Completions*-frame-flag' is nil.
  (if  1on1-minibuffer-frame-flag
       (if 1on1-*Completions*-frame-flag
           (add-to-list
            'special-display-buffer-names
            `("*Completions*" 1on1-display-*Completions*-frame
              ((background-color ,@1on1-completions-frame-background)
               (mouse-color      ,@1on1-completions-frame-mouse+cursor-color)
               (cursor-color     ,@1on1-completions-frame-mouse+cursor-color)
               (menu-bar-lines . 0) (tool-bar-lines . 0) ; No menu bar or tool bar.
               ,@(and 1on1-completions-frame-width
                      `((width   ,@1on1-completions-frame-width))))))
         (add-to-list 'special-display-buffer-names
                      `("*Completions*" 1on1-display-*Completions*-frame)))
    (setq special-display-buffer-names  (1on1-remove-if (lambda (elt)
                                                          (equal "*Completions*" (car elt)))
                                                        special-display-buffer-names)))

  ;; Minibuffer frame
  (when 1on1-minibuffer-frame-flag
    ;; `display-buffer' (& `*-other-window' fns) will use separate frames.
    (setq pop-up-frames  t)

    ;; Set up `1on1-minibuffer-frame'.
    (setq minibuffer-frame-alist  (append 1on1-minibuffer-frame-alist minibuffer-frame-alist))
    (if 1on1-minibuffer-frame
        (modify-frame-parameters 1on1-minibuffer-frame 1on1-minibuffer-frame-alist)
      (setq 1on1-minibuffer-frame
            (let ((after-make-frame-functions  ())) ; E.g. inhibit `fit-frame'.
              (make-frame 1on1-minibuffer-frame-alist))))

    ;; Set `1on1-minibuffer-frame-bottom-offset' (Emacs 24.4+ only).
    (when (and (not 1on1-minibuffer-frame-bottom-offset)
               (fboundp 'display-monitor-attributes-list))
      (catch '1on1-emacs
        (dolist (attr  (display-monitor-attributes-list))
          (when (memq 1on1-minibuffer-frame (cdr (assoc 'frames attr)))
            (setq 1on1-minibuffer-frame-bottom-offset
                  (- (nth 4 (assoc 'workarea attr))
                     (nth 4 (assoc 'geometry attr))
                     (or (- (frame-parameter 1on1-minibuffer-frame 'border-width))  0)))
            (throw '1on1-emacs nil)))
        ;; Fallback - should not happen.  No monitor has minibuffer frame.
        (setq 1on1-minibuffer-frame-bottom-offset
              (- (nth 4 (assoc 'workarea (car (display-monitor-attributes-list))))
                 (nth 4 (assoc 'geometry (car (display-monitor-attributes-list))))
                 (or (- (frame-parameter 1on1-minibuffer-frame 'border-width))  0)))))

    ;; Resize and reposition frame.  If variable `1on1-minibuffer-frame-width'
    ;; or `1on1-minibuffer-frame-top/bottom' is nil, calculate automatically.
    (1on1-set-minibuffer-frame-width)
    (1on1-set-minibuffer-frame-top/bottom)

    ;; Rename minibuffer frame. (`rename-frame' is defined in `frame-cmds.el'.)
    (when (fboundp 'rename-frame)
      (rename-frame 1on1-minibuffer-frame "Emacs minibuffer                         \
show/hide: hold CTRL + click in window"))
    ;; (setq minibuffer-auto-raise  t) ; $$$$$$$ Let user decide, based on window mgr behavior.
    ;; Background colors of minibuffer frame: 3 states
    (add-hook 'isearch-mode-hook '1on1-color-isearch-minibuffer-frame)
    (add-hook 'isearch-mode-end-hook '1on1-color-minibuffer-frame-on-exit)
    (add-hook 'minibuffer-setup-hook '1on1-color-minibuffer-frame-on-setup)
    (add-hook 'minibuffer-exit-hook '1on1-color-minibuffer-frame-on-exit)
    ;; Redefine built-in fns so they color minibuffer frame.
    (1on1-setup-minibuffer-frame-coloring)
    (when 1on1-remap-other-frame-command-flag
      (substitute-key-definition 'other-frame '1on1-other-frame global-map)))

  ;; Hooks.
  (if (and 1on1-fit-minibuffer-frame-flag (require 'fit-frame nil t))
      (add-hook 'post-command-hook '1on1-fit-minibuffer-frame)
    (remove-hook 'post-command-hook '1on1-fit-minibuffer-frame))
  (if 1on1-change-cursor-on-overwrite/read-only-flag
      (add-hook 'post-command-hook '1on1-change-cursor-on-overwrite/read-only)
    (let ((deflt-ctype  (cdr (assq 'cursor-type default-frame-alist))))
      (when deflt-ctype (1on1-set-cursor-type deflt-ctype)))
    (remove-hook 'post-command-hook '1on1-change-cursor-on-overwrite/read-only))
  (if 1on1-change-cursor-on-input-method-flag
      (add-hook 'post-command-hook '1on1-change-cursor-on-input-method)
    (setq current-input-method  nil)
    (1on1-change-cursor-on-input-method)
    (remove-hook 'post-command-hook '1on1-change-cursor-on-input-method))
  (add-hook 'minibuffer-exit-hook '1on1-reset-minibuffer-frame)

  (setq w32-grab-focus-on-raise    nil
        win32-grab-focus-on-raise  nil) ; older name
  (1on1-setup-mode-line))

;; Define this to avoid requiring `cl.el' at runtime.
;; Same as in `icicle-remove-if' in `icicles-fn.el'.
(defun 1on1-remove-if (pred xs)
  "A copy of list XS with no elements that satisfy predicate PRED."
  (let ((result  ()))
    (dolist (x  xs) (unless (funcall pred x) (push x result)))
    (nreverse result)))

;; Same as `icicle-last-non-minibuffer-buffer' in `icicles-mode.el'.
(defun 1on1-last-non-minibuffer-buffer ()
  "Return the most recently used non-minibuffer live buffer."
  (let ((live-bufs  (1on1-remove-if (lambda (buf) (not (buffer-live-p buf))) (buffer-list))))
    (if (fboundp 'minibufferp)          ; Emacs 22+
        (let ((bufs  (1on1-remove-if 'minibufferp live-bufs)))
          (or (car bufs)  (car live-bufs)))
      (cadr live-bufs)))) ; Punt - but could be just a higher-level minibuffer.

;; This is inspired by code from Juri Linkov <juri@jurta.org>.
(defun 1on1-change-cursor-on-input-method ()
  "Set cursor color, depending on whether an input method is used or not."
  (when 1on1-change-cursor-on-input-method-flag
    (if current-input-method
        (set-cursor-color 1on1-default-frame-cursor-color-input-method)
      (let ((bufname  (buffer-name (current-buffer))))
        (cond ((string= "*Help*" bufname)
               (set-cursor-color 1on1-help-frame-mouse+cursor-color))
              ((string= "*Completions*" bufname)
               (set-cursor-color 1on1-completions-frame-mouse+cursor-color))
              ((eq 1on1-minibuffer-frame (selected-frame))
               (or (cdr (assq 'cursor-color 1on1-minibuffer-frame-alist))
                   1on1-minibuffer-frame-cursor-color))
              ((special-display-p bufname)
               (set-cursor-color 1on1-special-frame-cursor-color))
              ;; Do not set it if there is no setting for it in `default-frame-alist'.
              ((cdr (assq 'cursor-color default-frame-alist))
               (set-cursor-color (cdr (assq 'cursor-color default-frame-alist)))))))))

;; This is from Juri Linkov <juri@jurta.org>, with read-only added.
(defun 1on1-change-cursor-on-overwrite/read-only ()
  "Set cursor type differently for overwrite mode and read-only buffer.
That is, use one cursor type for overwrite mode and read-only buffers,
and another cursor type otherwise."
  (let ((deflt-ctype  (cdr (assq 'cursor-type default-frame-alist))))
    (when (or buffer-read-only  overwrite-mode  deflt-ctype)
      (1on1-set-cursor-type (if (or buffer-read-only  overwrite-mode)
                                1on1-default-frame-cursor-type-overwrite/read-only
                              deflt-ctype)))))

(unless (fboundp 'set-cursor-type) (defalias 'set-cursor-type '1on1-set-cursor-type))
;; This is essentially from Juri Linkov <juri@jurta.org>.
;;;###autoload
(defun 1on1-set-cursor-type (cursor-type)
  "Set the cursor type of the selected frame to CURSOR-TYPE.
When called interactively, prompt for the type to use.
To get the frame's current cursor type, use `frame-parameters'."
  (interactive
   (list (intern (completing-read "Cursor type: "
                                  (mapcar 'list '("box" "hollow" "bar" "hbar" nil))))))
  (modify-frame-parameters (selected-frame) (list (cons 'cursor-type cursor-type))))

(defun 1on1-box-cursor-when-idle ()
  "Change the cursor to a box cursor when Emacs is idle."
  (let ((type  (cdr (assoc 'cursor-type (frame-parameters)))))
    (unless (eq type 'box)
      (setq 1on1-last-cursor-type  type)
      (1on1-set-cursor-type 'box))))

(defun 1on1-box-cursor-when-idle-off ()
  "Turn off changing the cursor to a box cursor when Emacs is idle."
  (when 1on1-last-cursor-type (1on1-set-cursor-type 1on1-last-cursor-type)))

;;;###autoload
(defalias 'toggle-box-cursor-when-idle '1on1-toggle-box-cursor-when-idle)
;;;###autoload
(defun 1on1-toggle-box-cursor-when-idle (&optional arg)
  "Turn on or off automatically changing to a box cursor when idle.
When on, the cursor is changed to a box whenever Emacs is idle.
With prefix argument, turn on if ARG > 0; else turn off."
  (interactive "P")
  (setq 1on1-box-cursor-when-idle-p  (if arg
                                         (> (prefix-numeric-value arg) 0)
                                       (not 1on1-box-cursor-when-idle-p)))
  (cond (1on1-box-cursor-when-idle-p
         (timer-activate-when-idle 1on1-box-cursor-when-idle-timer)
         (add-hook 'pre-command-hook '1on1-box-cursor-when-idle-off)
         (message "Turned ON making cursor a box when Emacs is idle."))
        (t
         (cancel-timer 1on1-box-cursor-when-idle-timer)
         (remove-hook 'pre-command-hook '1on1-box-cursor-when-idle-off)
         (message "Turned OFF making cursor a box when Emacs is idle."))))

;;;###autoload
(defun 1on1-set-box-cursor-when-idle-interval (secs)
  "Set wait until automatically change to a box cursor when Emacs is idle.
Whenever Emacs is idle for this many seconds it will change the cursor
to a box.

To turn on or off automatically changing to a box cursor when idle,
use `\\[toggle-box-cursor-when-idle]."
  (interactive
   "nSeconds to idle, before changing to a box cursor: ")
  (timer-set-idle-time 1on1-box-cursor-when-idle-timer
                       (setq 1on1-box-cursor-when-idle-interval  secs)
                       t))

;;;###autoload
(defun 1on1-other-frame (arg)
  "Same as `other-frame', except include frame `1on1-minibuffer-frame'.
If `1on1-minibuffer-frame' is non-nil then it is a standalone
minibuffer frame.  In this case, include it as well as all other
visible or iconified frames as candidates.

Select the ARGth different visible frame on current display, and raise it.
Select the frame ARG steps away in the sequence of frames.
A negative ARG moves in the opposite direction.

To make this command work properly, you must tell Emacs
how the system (or the window manager) generally handles
focus-switching between windows.  If moving the mouse onto a window
selects it (gives it focus), set `focus-follows-mouse' to t.
Otherwise, that variable should be nil."
  (interactive "p")
  (let ((frame  (selected-frame)))
    (while (> arg 0)
      (setq frame  (next-frame frame 0))
      (while (not (eq t (frame-visible-p frame)))
        (setq frame  (next-frame frame 0)))
      (setq arg  (1- arg)))
    (while (< arg 0)
      (setq frame  (previous-frame frame 0))
      (while (not (eq t (frame-visible-p frame)))
        (setq frame  (previous-frame frame 0)))
      (setq arg  (1+ arg)))
    (select-frame-set-input-focus frame)))

(defun 1on1-display-*Help*-frame (buf &optional args)
  "Display *Help* buffer in its own frame.
`special-display-function' is used to do the actual displaying.
BUF and ARGS are the arguments to `special-display-function'."
  (let ((old-ptr-shape  (and (boundp 'x-pointer-shape) x-pointer-shape))
        return-window)
    (when (boundp 'x-pointer-xterm) (setq x-pointer-shape  x-pointer-xterm))
    (setq return-window  (select-window (funcall special-display-function buf args)))
    (raise-frame)
    (setq x-pointer-shape  old-ptr-shape)
    return-window))

(defun 1on1-display-*Completions*-frame (buf &optional args)
  "Display *Completions* buffer in its own frame.
`special-display-function' is used to do the actual displaying.
Completion input events are redirected to `1on1-minibuffer-frame'.
BUF and ARGS are the arguments to `special-display-function'.

If Icicles is used, then give `*Completions*' frame the same font as
the frame that set up the minibuffer.

If `zoom-frm.el' is used, then shrink the text according to
`1on1-completions-frame-zoom-font-difference'."
  (let ((old-ptr-shape  (and (boundp 'x-pointer-shape) x-pointer-shape))
        return-window)
    (when (and 1on1-*Completions*-frame-flag (boundp 'x-pointer-box-spiral))
      (setq x-pointer-shape  x-pointer-box-spiral))
    (setq return-window  (select-window (funcall special-display-function buf args)))

    ;; In Icicles, use the font family of the original window.  This is particularly for
    ;; picking up the proper font for Unicode chars in `*Completions*'.  Emacs 23+ only.
    (when (and (boundp 'icicle-mode) icicle-mode
               icicle-pre-minibuffer-buffer
               (> emacs-major-version 22))
      ;; Prior to Emacs 24, dunno how to get last-used window showing
      ;; `icicle-pre-minibuffer-buffer'.  This only gets some window showing it - not TRT.
      ;; (This code is similar to what is in `icicle-display-candidates-in-Completions'.)
      (let* ((orig-win       (if (not (fboundp 'icicle-mru-window-for-buffer))
                                 (get-buffer-window icicle-pre-minibuffer-buffer 'visible)
                               (icicle-mru-window-for-buffer icicle-pre-minibuffer-buffer
                                                             'NOMINI 0)))
             (orig-font-fam  (and (window-live-p orig-win)
                                  (save-window-excursion (select-window orig-win)
                                                         (face-attribute 'default :family)))))
        ;; $$$$$$$$?? (when (and orig-font-fam  (not (eq orig-win return-window)))
        ;;
        ;; We do not save the cookie from this, as we do not have a function that removes it.
        (when orig-font-fam (face-remap-add-relative 'default :family orig-font-fam))))

    ;; Zoom text by `1on1-completions-frame-zoom-font-difference'.
    (when (and (fboundp 'zoom-frm-out) 1on1-completions-frame-zoom-font-difference)
      (condition-case nil
          (let ((frame-zoom-font-difference  1on1-completions-frame-zoom-font-difference))
            (zoom-frm-out))             ; In `zoom-frm.el'.
        (error nil)))

    ;; We reposition frame this way, instead of binding `special-display-frame-alist'
    ;; with this value, because `after-make-frame-functions' might resize frame.
    (when 1on1-*Completions*-frame-at-right-flag
      (modify-frame-parameters
       (selected-frame)                 ; Hard-code 7 here - what does it depend on?
       `((left . ,(- (x-display-pixel-width) (+ (frame-pixel-width) 7))))))
    (raise-frame)
    (let ((redirect  (if (active-minibuffer-window)
                         1on1-minibuffer-frame
                       (and completion-reference-buffer
                            (get-buffer-window completion-reference-buffer 'visible)
                            (not (eq (get-buffer "*Completions*") completion-reference-buffer))
                            (window-frame (get-buffer-window completion-reference-buffer t))))))
      (when redirect
        (redirect-frame-focus (selected-frame) redirect)))
    ;; $$$$$$$ (when 1on1-minibuffer-frame (redirect-frame-focus (selected-frame)
    ;;                                                           1on1-minibuffer-frame))
    (when (and 1on1-*Completions*-frame-flag (boundp 'x-pointer-box-spiral))
      (setq x-pointer-shape  old-ptr-shape))
    return-window))

(defun 1on1-color-minibuffer-frame-on-setup ()
  "Change background of minibuffer frame to reflect the minibuffer depth.
Use this when increasing the minibuffer recursion depth."
  (when 1on1-minibuffer-frame
    (save-window-excursion
      (select-frame 1on1-minibuffer-frame)
      (set-background-color 1on1-active-minibuffer-frame-background)
      (let ((count  (minibuffer-depth)))
        (while (> count 1)
          (set-background-color (hexrgb-increment-hue ; Change bg hue slightly.
                                 (frame-parameter nil 'background-color)
                                 1on1-color-minibuffer-frame-on-setup-increment))
          (setq count  (1- count)))))))

(defun 1on1-color-minibuffer-frame-on-exit ()
  "Change background of minibuffer frame to reflect the minibuffer depth.
Use this when reducing the minibuffer recursion depth."
  (when 1on1-minibuffer-frame
    (save-window-excursion
      (select-frame 1on1-minibuffer-frame)
      (cond ((= (minibuffer-depth) 2)
             (set-background-color 1on1-active-minibuffer-frame-background))
            ((< (minibuffer-depth) 2)
             (set-background-color 1on1-inactive-minibuffer-frame-background))
            (t
             (set-background-color (hexrgb-increment-hue ; Change bg hue slightly.
                                    (frame-parameter nil 'background-color)
                                    1on1-color-minibuffer-frame-on-exit-increment)))))))

(defun 1on1-color-isearch-minibuffer-frame ()
  "Use `1on1-isearch-minibuffer-frame-background' for minibuffer."
  (and 1on1-minibuffer-frame
       (save-window-excursion
         (select-frame 1on1-minibuffer-frame)
         (set-background-color
          ;; Can also try `x-defined-colors', defined in `x-win.el'.
          ;; It contains all colors currently supported by X windows.
          (if (x-color-defined-p 1on1-isearch-minibuffer-frame-background)
              1on1-isearch-minibuffer-frame-background
            "white")))))

(defun 1on1-flash-ding-minibuffer-frame (&optional do-not-terminate)
  "Ring bell (`ding'), after flashing minibuffer frame, if relevant.
Terminates any keyboard macro executing, unless arg DO-NOT-TERMINATE non-nil."
  (flash-ding do-not-terminate 1on1-minibuffer-frame))

(defun 1on1-setup-minibuffer-frame-coloring ()
  "Redefine some built-in functions so they color the minibuffer frame.
Functions redefined: `y-or-n-p', `top-level'."


  (or (fboundp '1on1-ORIG-y-or-n-p)
      (fset '1on1-ORIG-y-or-n-p (symbol-function 'y-or-n-p)))

  ;; REPLACES ORIGINAL (built-in function):
  ;; Temporarily colors minibuffer frame to "active" color if at top-level.
  ;;
  (defun y-or-n-p (prompt)
    "Ask user a \"y or n\" question.
Return t if answer is \"y\" and nil if it is \"n\".

PROMPT is the string to display to ask the question.  It should end in
a space; `y-or-n-p' adds \"(y or n) \" to it.

No confirmation of the answer is requested; a single character is
enough.  SPC also means yes, and DEL means no.


This function translates user input into responses by consulting the
bindings in ‘query-replace-map’ (which see).  For this, the useful
bindings are ‘act’, ‘skip’, ‘recenter’, ‘scroll-up’, ‘scroll-down’,
and ‘quit’.

An ‘act’ response means yes, and a ‘skip’ response means no.  A ‘quit’
response means invoke ‘keyboard-quit’.  If the response is ‘recenter’,
‘scroll-up’, or ‘scroll-down’ then perform the requested window
recentering or scrolling action and ask again.

Under a windowing system a dialog box is used if ‘last-nonmenu-event’
is nil and ‘use-dialog-box’ is non-nil."
    (1on1-color-minibuffer-frame-on-setup)
    ;; Resize echo area if necessary, to show `y-or-n-p' prompt.  Compensates for functions
    ;; like `find-file-literally' that pass multi-line PROMPT args to it.  See Emacs bug #18340.
    ;; (Do not do it for Emacs 20, because it shows newlines as two ordinary chars, `\n'.)
    (when (and 1on1-fit-minibuffer-frame-flag  (> emacs-major-version 20))
      (let ((nlines  (length (split-string prompt "[\n]"))))
        (set-frame-height (window-frame (minibuffer-window)) (1+ nlines))
        (1on1-set-minibuffer-frame-top/bottom)))
    (let ((result  (1on1-ORIG-y-or-n-p prompt)))
      (when (and 1on1-fit-minibuffer-frame-flag  (> emacs-major-version 20))
        (1on1-reset-minibuffer-frame))  ; Restore frame.
      (if isearch-mode
          (1on1-color-isearch-minibuffer-frame) ; Return to Isearch color.
        (1on1-color-minibuffer-frame-on-exit))
      result))


  (or (fboundp '1on1-ORIG-top-level)
      (fset '1on1-ORIG-top-level (symbol-function 'top-level)))

  ;; REPLACES ORIGINAL (built-in function):
  ;; Resets color of minibuffer frame to "inactive" color.
  ;;
  (defun top-level ()
    "Exit all recursive editing levels."
    (interactive)
    (1on1-color-minibuffer-frame-on-exit)
    (1on1-ORIG-top-level)))


;;; $$$$$ Do not do this.  `1on1-color-minibuffer-frame-on-exit' will be called anyway,
;;;       by `minibuffer-exit-hook'.

;;;   (or (fboundp '1on1-ORIG-abort-recursive-edit)
;;;       (fset '1on1-ORIG-abort-recursive-edit (symbol-function 'abort-recursive-edit)))

;;;   ;; REPLACES ORIGINAL (built-in function):
;;;   ;; Resets color of minibuffer frame to "inactive" color.
;;;   ;;
;;;   (defun abort-recursive-edit ()
;;;     "Abort command that requested this recursive edit or minibuffer input."
;;;     (interactive)
;;;     (1on1-color-minibuffer-frame-on-exit)
;;;     (1on1-ORIG-abort-recursive-edit))



(defun 1on1-setup-mode-line ()
  "Set up mode-line faces."
  (when 1on1-color-mode-line-flag
    (set-face-background (if (facep 'modeline) 'modeline 'mode-line)
                         1on1-active-mode-line-background)
    (when (facep 'mode-line-inactive)   ; Emacs 22
      (set-face-background 'mode-line-inactive 1on1-inactive-mode-line-background))))

(defun 1on1-reset-minibuffer-frame ()   ; On `minibuffer-exit-hook'.
  "Reset frame `1on1-minibuffer-frame' to its normal size and position."
  (when (and 1on1-minibuffer-frame  (= (minibuffer-depth) 1))
    (set-frame-size 1on1-minibuffer-frame
                    (frame-width 1on1-minibuffer-frame)
                    1on1-minibuffer-frame-height)
    (1on1-set-minibuffer-frame-top/bottom)))

(defun 1on1-set-minibuffer-frame-top/bottom ()
  "Set position of minibuffer frame.
Use `1on1-minibuffer-frame-top/bottom' if non-nil.
Else, place minibuffer at bottom of display."
  (when 1on1-minibuffer-frame
    (condition-case nil
        (if nil ;; $$$$$$ (fboundp 'redisplay)
            (redisplay t)
          (force-mode-line-update t))
      (error nil))         ; Ignore errors from, e.g., killed buffers.
    (modify-frame-parameters
     1on1-minibuffer-frame
     `((top ,@ (or 1on1-minibuffer-frame-top/bottom
                   (if (not (fboundp 'display-monitor-attributes-list))
                       (- 1on1-task-bar-height)
                     1on1-minibuffer-frame-bottom-offset)))
       (left 0)))))

(defun 1on1-set-minibuffer-frame-width ()
  "Set width of minibuffer frame, in characters.
Use `1on1-minibuffer-frame-width' if not nil.
Else, set width relative to character size of `1on1-minibuffer-frame'
and display monitor size, and depending on
`1on1-minibuffer-frame-width-percent'."
  (when 1on1-minibuffer-frame
    (set-frame-width
     1on1-minibuffer-frame
     (or 1on1-minibuffer-frame-width
         (/ (* 1on1-minibuffer-frame-width-percent
               (if (not (fboundp 'display-monitor-attributes-list))
                   (x-display-pixel-width)
                 (catch '1on1-set-minibuffer-frame-width
                   (dolist (attr  (display-monitor-attributes-list))
                     (when (memq 1on1-minibuffer-frame (cdr (assoc 'frames attr)))
                       (throw '1on1-set-minibuffer-frame-width (nth 3 (assoc 'geometry attr)))))
                   ;; Fallback - should not happen.  No monitor has minibuffer frame.
                   (nth 3 (assoc 'geometry (car (display-monitor-attributes-list)))))))
            (* 100 (frame-char-width 1on1-minibuffer-frame)))))))

;;;###autoload
(defun 1on1-fit-minibuffer-frame (&optional resetp)
  "Fit the standalone minibuffer frame height to its contents.
Repeat to increase the height by 1.
With a prefix arg, reset the frame to its default position and height.
Bind this in minibuffer keymaps to a key such as `M-up' that you can
use during minibuffer input.
This command requires library `fit-frame.el'."
  (interactive "P")
  (unless (require 'fit-frame nil t)
    (error "You need to load library `fit-frame.el' to use this command"))
  ;; We could assume the minibuffer frame is `1on1-minibuffer-frame', but we do not.
  (when (and 1on1-fit-minibuffer-frame-flag
             (active-minibuffer-window)
             ;; Do this because this command is on `post-command-hook', and an event such as
             ;; `handle-switch-frame' might have changed the selected frame.
             (eq last-event-frame (window-frame (minibuffer-window)))
             (eq (frame-first-window last-event-frame) (minibuffer-window)))

             ;; $$$$$$ Previous sexp replaces this, which should do the same thing:
             ;; (one-window-p nil (window-frame (minibuffer-window)))
             ;;
             ;; And that replaces this, which, again, should do the same thing:
             ;; (save-window-excursion
             ;;  (select-window (minibuffer-window))
             ;;  ;; We should be able to use just (one-window-p),
             ;;  ;; but an Emacs bug means we need this:
             ;;  (one-window-p nil 'selected-frame))

    (let* ((frame         (window-frame (minibuffer-window)))
           (frame-height  (frame-height frame)))
      (cond
       (resetp
        (set-frame-height frame 1on1-minibuffer-frame-height) ; Reset to default.
        (1on1-set-minibuffer-frame-top/bottom))
       ((eq last-command '1on1-fit-minibuffer-frame)
        (set-frame-height frame (1+ (frame-height frame)))
        (1on1-set-minibuffer-frame-top/bottom))
        ;; $$$$$$ This interfered with `C-e' and inserting text at end.
        ;; (condition-case nil (scroll-down (frame-height frame)) (error nil))

       (t
        (let* ((beg                                     (1on1-minibuffer-prompt-end))
               (fit-frame-max-height                    1on1-fit-minibuffer-frame-max-height)
               (fit-frame-max-height-percent
                1on1-fit-minibuffer-frame-max-height-percent)
               (fit-frame-min-height                    1on1-minibuffer-frame-height)
               (window-min-height                       1on1-minibuffer-frame-height)
               (fit-frame-empty-height                  1on1-minibuffer-frame-height)
               (fit-frame-empty-special-display-height  1on1-minibuffer-frame-height))
          (if (> emacs-major-version 22)
              ;; In principle, that test could have been (fboundp 'count-screen-lines), which
              ;; is defined for Emacs 21+.  But doing that makes the frame jump up and down
              ;; inappropriately in Emacs 21-22.  So do it only for Emacs 23+.

              ;; The reason for the different code for Emacs 23+:
              ;; For `icomplete.el', Emacs 23+ uses an overlay instead of inserting text into
              ;; the buffer.  `fit-frame' cannot take the height of that overlay into account.
              ;; So we use `count-screen-lines' to get the height.
              (fit-frame frame (frame-width frame)
                         ;; Need to be sure to use the right buffer.  Some commands etc. can
                         ;; pop up a frame and select it, or otherwise change the selected buf.
                         (with-current-buffer (or (window-buffer (active-minibuffer-window))
                                                  (current-buffer))
                           (1+ (count-screen-lines))))
            (fit-frame frame (frame-width frame)))))))
          ;; $$$$       (when (>= emacs-major-version 21)
          ;;              (set-frame-height frame (1+ (frame-height frame)))) ; A little extra.

          ;; Removed this because it does not seem needed and it interfered with
          ;;`1on1-move-minibuffer-frame-near-point'.
          ;; $$$$$$$$ (1on1-set-minibuffer-frame-top/bottom)

          ;; $$$$$$ This interfered with `C-e' and inserting text at end.
          ;; (condition-case nil (scroll-down (frame-height frame)) (error nil))

    (raise-frame)))

(defun 1on1-minibuffer-prompt-end ()
  "Version of `minibuffer-prompt-end' that works for Emacs 20 and later."
  (if (fboundp 'minibuffer-prompt-end) (minibuffer-prompt-end) (point-min)))

(when (fboundp 'window-inside-absolute-pixel-edges) ; Emacs 24+

  (defcustom 1on1-move-minibuffer-frame-near-point nil
    "Whether to move `1on1-minibuffer-frame' near point, and just where.
,* nil means do not move it.

,* A single whole number, Y, means offset `top' by Y pixels from point.
  The `left' frame position is unchanged.  As always, positive is
  down (below point), negative is up (above point).

,* A cons of two whole numbers, (X . Y), means offset `left' by X and
  `top' by Y pixels from point.

  For example, (-200 . 30) moves the top left frame corner 200 pixels
  to the left and 30 pixels below point.  This option has no effect if
  `1on1-minibuffer-frame' is nil."
    :group 'One-On-One
    :type '(choice
            (const   :tag "Do not move frame" nil)
            (integer :tag "Offset frame Y pixels below point (above, if negative)" :value 50)
            (cons    :tag "Offset frame (X . Y) pixels from point"
                     (integer :tag "X" :value -200) (integer :tag "Y" :value 50))))

  (defvar 1on1-move-minibuffer-frame-max-left-top '(500 . 100)
    "Cons (LEFT . TOP) of maximum `left' and `top' positions for frame.")

  (defun 1on1-reposition-minibuffer-frame (&optional position delta-x delta-y)
    "Move `1on1-minibuffer-frame' to POSITION (default: point).
The top left corner of the frame is offset from POSITION according to
`1on1-move-minibuffer-frame-near-point'."
    (when (and (= (minibuffer-depth) 1)  1on1-move-minibuffer-frame-near-point
               (frame-live-p 1on1-minibuffer-frame))
      (let* ((buf  (1on1-last-non-minibuffer-buffer))
             (both (consp 1on1-move-minibuffer-frame-near-point))
             (dx   (or delta-x
                       (and both  (car 1on1-move-minibuffer-frame-near-point))
                       0))
             (dy   (or delta-y
                       (if both
                           (cdr 1on1-move-minibuffer-frame-near-point)
                         1on1-move-minibuffer-frame-near-point)
                       0)))
        (when buf
          (with-current-buffer buf
            (setq position  (or position  (point)))
            (let* ((win   (get-buffer-window buf t))
                   (posn  (posn-at-point position win)))
              (when posn
                (let* ((x-y        (posn-x-y posn))
                       (win-edges  (window-inside-absolute-pixel-edges win))
                       (left       (if both
                                       (min (max 0 (+ (car x-y) (car win-edges) dx))
                                            (- (x-display-pixel-width) dx))
                                     0))
                       (top        (min (max 0 (+ (cdr x-y) (cadr win-edges) dy))
                                        (- (x-display-pixel-height) dy))))
                  (modify-frame-parameters 1on1-minibuffer-frame
                                           `((left . ,left) (top . ,top)))))))))))

  (add-hook 'minibuffer-setup-hook '1on1-reposition-minibuffer-frame))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; oneonone.el ends here
#+end_src


** frame-cmds.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220346323117100

#+name: 20210601220346323117100
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; frame-cmds.el --- Frame and window commands (interactive functions).
;;
;; Filename: frame-cmds.el
;; Description: Frame and window commands (interactive functions).
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2021, Drew Adams, all rights reserved.
;; Created: Tue Mar  5 16:30:45 1996
;; Version: 0
;; Package-Requires: ((frame-fns "0"))
;; Last-Updated: Thu Apr 22 09:05:03 2021 (-0700)
;;           By: dradams
;;     Update #: 3188
;; URL: https://www.emacswiki.org/emacs/download/frame-cmds.el
;; Doc URL: https://emacswiki.org/emacs/FrameModes
;; Doc URL: https://www.emacswiki.org/emacs/OneOnOneEmacs
;; Doc URL: https://www.emacswiki.org/emacs/Frame_Tiling_Commands
;; Keywords: internal, extensions, mouse, frames, windows, convenience
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `backquote', `bytecomp', `cconv', `cl-lib',
;;   `frame-fns', `macroexp', `misc-fns', `strings', `thingatpt',
;;   `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Frame and window commands (interactive functions).
;;
;;
;;  Summary:
;;
;;    Load this library from your init file (~/.emacs or _emacs).
;;    Add the suggested key bindings (below) to  your init file.
;;    Use `M-up|down|left|right' to move frames around incrementally.
;;    Use `C-S-v', `M-S-v', `C-S-next', `C-S-prior' to move frames to
;;        screen edges.
;;    Use `C-M-up|down|left|right' to resize frames incrementally.
;;    Use `C-x {', `C-x }', `C-x ^', and `C-u C-x ^' to resize windows
;;        incrementally.
;;    Use `C-M-z' or `C-x C-z' to iconify/hide all frames.
;;    Use `C-M-z' in a lone frame to restore all frames.
;;    Use `C-mouse-1' in the minibuffer to restore all frames.
;;    Use `C-mouse-1' in Dired to mark/unmark a file.
;;    Use `C-mouse-3' on the mode line to remove window from frame.
;;    Use `tile-frames-horizontally', `-vertically' to tile frames.
;;    Use `C-x o' to select `other-window' or `other-frame'.
;;
;;  Commands to incrementally resize frames are `enlarge-frame' and
;;  `enlarge-frame-horizontally'.  Sarir Khamsi
;;  [sarir.khamsi@raytheon.com] originally wrote `enlarge-frame',
;;  which he called `sk-grow-frame'.
;;
;;  Note on saving changes made with the commands defined here:
;;
;;    Some of the commands defined here change frame properties.
;;    You can save any changes you have made, by using Customize.
;;    To visit a Customize buffer of all unsaved changes you have
;;    made, use command `customize-customized'.
;;
;;    Frame parameter changes, such as background color, can be saved
;;    for future use by all frames or all frames of a certain
;;    kind.  For that, you must change the frame parameters of the
;;    corresponding frame-alist variable.
;;
;;    There is no single variable for saving changes to parameters of
;;    the current frame.  Instead, there are several different
;;    frame-alist variables, which you can use to define different
;;    kinds of frames.  These include: `default-frame-alist',
;;    `initial-frame-alist', and `special-display-frame-alist'.  The
;;    complete list of such frame alist variables is available using
;;    function `frcmds-frame-alist-var-names', defined here.
;;
;;    Example: Suppose you change the background color of a frame and
;;    want to make that the default background color for new frames in
;;    the future.  You will need to update the value of variable
;;    `default-frame-alist' to use the `background-color' parameter
;;    setting of the changed frame.
;;
;;    You can easily copy one or all parameter values from any given
;;    frame to any frame alist (such as `default-frame-alist'), by
;;    using the commands `set-frame-alist-parameter-from-frame' and
;;    `set-all-frame-alist-parameters-from-frame'.  Those commands are
;;    defined here.
;;
;;  NOTE: If you also use library `fit-frame.el', and you are on MS
;;  Windows, then load that library before `frame-cmds.el'.  The
;;  commands `maximize-frame' and `restore-frame' defined here are
;;  more general and non-Windows-specific than the commands of the
;;  same name defined in `fit-frame.el'.
;;
;;
;;  User options defined here:
;;
;;    `available-screen-pixel-bounds', `clone-frame-parameters',
;;    `enlarge-font-tries', `frame-config-register',
;;    `frame-parameters-to-exclude',
;;    `move-frame-wrap-within-display-flag'
;;    `rename-frame-when-iconify-flag', `show-hide-show-function',
;;    `window-mgr-title-bar-pixel-height'.
;;
;;  Commands defined here:
;;
;;    `clone-frame', `create-frame-tiled-horizontally',
;;    `create-frame-tiled-vertically', `decrease-frame-transparency'
;;    (Emacs 23+), `delete-1-window-frames-on',
;;    `delete/iconify-window', `delete/iconify-windows-on',
;;    `delete-other-frames', `delete-windows-for', `enlarge-font',
;;    `enlarge-frame', `enlarge-frame-horizontally',
;;    `enlarge/shrink-window', `enlarge/shrink-window-repeat',
;;    `enlarge-window-repeat', `hide-everything', `hide-frame',
;;    `iconify-everything', `iconify/map-frame', `iconify/show-frame',
;;    `increase-frame-transparency' (Emacs 23+),
;;    `jump-to-frame-config-register', `maximize-frame',
;;    `maximize-frame-horizontally', `maximize-frame-vertically',
;;    `mouse-iconify/map-frame', `mouse-iconify/show-frame',
;;    `mouse-remove-window', `mouse-show-hide-mark-unmark',
;;    `move-frame-down', `move-frame-left', `move-frame-right',
;;    `move-frame-to-screen-bottom', `move-frame-to-screen-left',
;;    `move-frame-to-screen-right', `move-frame-to-screen-top',
;;    `move-frame-to-screen-top-left', `move-frame-up',
;;    `name-all-frames-numerically', `name-frame-numerically',
;;    `other-window-or-frame', `remove-window', `remove-windows-on',
;;    `rename-frame', `rename-non-minibuffer-frame', `restore-frame',
;;    `restore-frame-horizontally', `restore-frame-vertically',
;;    `save-frame-config',
;;    `set-all-frame-alist-parameters-from-frame',
;;    `set-frame-alist-parameter-from-frame', `show-*Help*-buffer',
;;    `show-a-frame-on', `show-buffer-menu', `show-frame',
;;    `show-hide', `shrink-frame', `shrink-frame-horizontally',
;;    `split-frame-horizontally', `split-frame-vertically',
;;    `shrink-window-horizontally-repeat', `shrink-window-repeat',
;;    `tell-customize-var-has-changed', `tile-frames',
;;    `tile-frames-horizontally', `tile-frames-side-by-side',
;;    `tile-frames-top-to-bottom', `tile-frames-vertically',
;;    `toggle-max-frame', `toggle-max-frame-horizontally',
;;    `toggle-max-frame-vertically', `toggle-menu-bar-for-frame'.
;;
;;  Non-interactive functions defined here:
;;
;;    `assq-delete-all' (Emacs 20), `butlast' (Emacs 20),
;;    `frcmds-available-screen-pixel-bounds',
;;    `frcmds-available-screen-pixel-height',
;;    `frcmds-available-screen-pixel-width',
;;    `frcmds-effective-screen-pixel-bounds',
;;    `frcmds-enlarged-font-name', `frcmds-extra-pixels-width',
;;    `frcmds-extra-pixels-height', `frcmds-frame-alist-var-names',
;;    `frcmds-frame-parameter-names', `frcmds-frame-iconified-p',
;;    `frcmds-frame-number', `frcmds-new-frame-position',
;;    `frcmds-read-args-for-tiling',
;;    `frcmds-read-buffer-for-delete-windows',
;;    `frcmds-repeat-command', `frcmds-set-difference',
;;    `frcmds-smart-tool-bar-pixel-height', `frcmds-split-frame-1',
;;    `frcmds-tile-frames', `nbutlast' (Emacs 20).
;;
;;  Error symbols defined here:
;;
;;    `font-too-small', `font-size'.
;;
;;
;;  ***** NOTE: The following EMACS PRIMITIVE has been ADVISED HERE:
;;
;;  `delete-window' - If only one window in frame, `delete-frame'.
;;
;;
;;  ***** NOTE: The following EMACS PRIMITIVE has been REDEFINED HERE:
;;
;;  `delete-windows-on' -
;;     1) Reads buffer differently.  Only buffers showing windows are candidates.
;;     2) Calls `delete-window', so this also deletes frames where
;;        window showing the BUFFER is the only window.
;;        (That's true also for vanilla Emacs 23+, but not before.)
;;
;;
;;  Suggested key bindings:
;;
;;   (global-set-key [(meta up)]                    'move-frame-up)
;;   (global-set-key [(meta down)]                  'move-frame-down)
;;   (global-set-key [(meta left)]                  'move-frame-left)
;;   (global-set-key [(meta right)]                 'move-frame-right)
;;   (global-set-key [(meta shift ?v)]              'move-frame-to-screen-top)      ; like `M-v'
;;   (global-set-key [(control shift ?v)]           'move-frame-to-screen-bottom)   ; like `C-v'
;;   (global-set-key [(control shift prior)]        'move-frame-to-screen-left)     ; like `C-prior'
;;   (global-set-key [(control shift next)]         'move-frame-to-screen-right)    ; like `C-next'
;;   (global-set-key [(control shift home)]         'move-frame-to-screen-top-left)
;;   (global-set-key [(control meta down)]          'enlarge-frame)
;;   (global-set-key [(control meta right)]         'enlarge-frame-horizontally)
;;   (global-set-key [(control meta up)]            'shrink-frame)
;;   (global-set-key [(control meta left)]          'shrink-frame-horizontally)
;;   (global-set-key [remap enlarge-window-horizontally] 'enlarge-window-horizontally-repeat)
;;   (global-set-key [remap shrink-window-horizontally]  'shrink-window-horizontally-repeat)
;;   (global-set-key [remap enlarge-window]         'enlarge/shrink-window-repeat)
;;   (global-set-key (kbd "C-M-S-<down>")           'increase-frame-transparency)
;;   (global-set-key (kbd "C-M-S-<up>")             'decrease-frame-transparency)
;;   (global-set-key [(control ?x) (control ?z)]    'iconify-everything)
;;   (global-set-key [vertical-line S-down-mouse-1] 'iconify-everything)
;;   (global-set-key [(control ?z)]                 'iconify/show-frame)
;;   (global-set-key [mode-line mouse-3]            'mouse-iconify/show-frame)
;;   (global-set-key [mode-line C-mouse-3]          'mouse-remove-window)
;;   (global-set-key [(control meta ?z)]            'show-hide)
;;   (global-set-key [vertical-line C-down-mouse-1] 'show-hide)
;;   (global-set-key [C-down-mouse-1]               'mouse-show-hide-mark-unmark)
;;   (substitute-key-definition 'make-frame-command 'clone-frame   global-map)
;;   (substitute-key-definition 'delete-window      'remove-window global-map)
;;   (define-key ctl-x-map "o"                      'other-window-or-frame)
;;   (define-key ctl-x-4-map "1"                    'delete-other-frames)
;;   (define-key ctl-x-5-map "h"                    'show-*Help*-buffer)
;;   (substitute-key-definition 'delete-window      'delete-windows-for global-map)
;;   (define-key global-map "\C-xt."                'save-frame-config)
;;   (define-key ctl-x-map "o"                      'other-window-or-frame)
;;
;;   (defalias 'doremi-prefix (make-sparse-keymap))
;;   (defvar doremi-map (symbol-function 'doremi-prefix) "Keymap for Do Re Mi commands.")
;;   (define-key global-map "\C-xt" 'doremi-prefix)
;;   (define-key doremi-map "." 'save-frame-config)
;;
;;  Customize the menu.  Uncomment this to try it out.
;;
;;   (defvar menu-bar-frames-menu (make-sparse-keymap "Frames"))
;;   (define-key global-map [menu-bar frames]
;;     (cons "Frames" menu-bar-frames-menu)))
;;   (define-key menu-bar-frames-menu [set-all-params-from-frame]
;;     '(menu-item "Set All Frame Parameters from Frame" set-all-frame-alist-parameters-from-frame
;;       :help "Set frame parameters of a frame to their current values in frame"))
;;   (define-key menu-bar-frames-menu [set-params-from-frame]
;;     '(menu-item "Set Frame Parameter from Frame..." set-frame-alist-parameter-from-frame
;;       :help "Set parameter of a frame alist to its current value in frame"))
;;   (define-key menu-bar-frames-menu [separator-frame-1] '("--"))
;;   (define-key menu-bar-frames-menu [tile-frames-vertically]
;;     '(menu-item "Tile Frames Vertically..." tile-frames-vertically
;;       :help "Tile all visible frames vertically"))
;;   (define-key menu-bar-frames-menu [tile-frames-horizontally]
;;     '(menu-item "Tile Frames Horizontally..." tile-frames-horizontally
;;       :help "Tile all visible frames horizontally"))
;;   (define-key menu-bar-frames-menu [separator-frame-2] '("--"))
;;   (define-key menu-bar-frames-menu [toggle-max-frame-vertically]
;;     '(menu-item "Toggle Max Frame Vertically" toggle-max-frame-vertically
;;       :help "Maximize or restore the selected frame vertically"
;;       :enable (frame-parameter nil 'restore-height)))
;;   (define-key menu-bar-frames-menu [toggle-max-frame-horizontally]
;;     '(menu-item "Toggle Max Frame Horizontally" toggle-max-frame-horizontally
;;       :help "Maximize or restore the selected frame horizontally"
;;       :enable (frame-parameter nil 'restore-width)))
;;   (define-key menu-bar-frames-menu [toggle-max-frame]
;;     '(menu-item "Toggle Max Frame" toggle-max-frame
;;       :help "Maximize or restore the selected frame (in both directions)"
;;       :enable (or (frame-parameter nil 'restore-width) (frame-parameter nil 'restore-height))))
;;   (define-key menu-bar-frames-menu [maximize-frame-vertically]
;;     '(menu-item "Maximize Frame Vertically" maximize-frame-vertically
;;       :help "Maximize the selected frame vertically"))
;;   (define-key menu-bar-frames-menu [maximize-frame-horizontally]
;;     '(menu-item "Maximize Frame Horizontally" maximize-frame-horizontally
;;       :help "Maximize the selected frame horizontally"))
;;   (define-key menu-bar-frames-menu [maximize-frame]
;;     '(menu-item "Maximize Frame" maximize-frame
;;       :help "Maximize the selected frame (in both directions)"))
;;   (define-key menu-bar-frames-menu [separator-frame-3] '("--"))
;;   (define-key menu-bar-frames-menu [iconify-everything]
;;     '(menu-item "Iconify All Frames" iconify-everything
;;       :help "Iconify all frames of session at once"))
;;   (define-key menu-bar-frames-menu [show-hide]
;;     '(menu-item "Hide Frames / Show Buffers" show-hide
;;       :help "Show, if only one frame visible; else hide.")))
;;
;;   (defvar menu-bar-doremi-menu (make-sparse-keymap "Do Re Mi"))
;;   (define-key global-map [menu-bar doremi]
;;     (cons "Do Re Mi" menu-bar-doremi-menu))
;;   (define-key menu-bar-doremi-menu [doremi-push-current-frame-config]
;;     '("Save Frame Configuration" . save-frame-config))
;;
;;  See also these files for other frame commands:
;;
;;     `autofit-frame.el' - Automatically fit each frame to its
;;                          selected window.  Uses `fit-frame.el'.
;;
;;     `fit-frame.el'     - 1) Fit a frame to its selected window.
;;                          2) Incrementally resize a frame.
;;
;;     `doremi-frm.el'    - Incrementally adjust frame properties
;;                          using arrow keys and/or mouse wheel.
;;
;;     `thumb-frm.el'     - Shrink frames to a thumbnail size and
;;                          restore them again.
;;
;;     `zoom-frm.el'      - Zoom a frame or buffer, so that its text
;;                          appears larger or smaller.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2020/09/13 dadams
;;     Added: toggle-menu-bar-for-frame.
;; 2019/12/13 dadams
;;     Added: frcmds-repeat-command, (enlarge|shrink)-window(-horizontally)-repeat,
;;            enlarge/shrink-window(-repeat).
;; 2019/03/18 dadams
;;     clone-frame: Use frame-geom-value-numeric.
;; 2019/03/03 dadams
;;     Added: clone-frame-parameters.
;;     clone-frame: Always select new frame.  Augment current params with clone-frame-parameters.
;; 2019/03/02 dadama
;;     clone-frame: Bind fit-frame-inhibit-fitting-flag to preserve current frame dimensions.
;;                  Return the new frame.
;; 2018/09/22 dadams
;;     Moved to mouse+.el: tear-off-window(-if-not-alone).
;; 2018/09/21 dadams
;;     tear-off-window: Use pop-to-buffer-same-window, not switch-to-buffer.
;; 2018/09/14 dadams
;;     Added: clone-frame.
;; 2018/01/05 dadams
;;     frcmds-available-screen-pixel-bounds:
;;       Use display-monitor-attributes-list to compute, if option is nil.
;;     frcmds-new-frame-position: Correct for use with multiple monitors.
;; 2018/01/02 dadams
;;     available-screen-pixel-bounds: Change :type to allow nil.
;; 2017/10/22 dadams
;;     remove-windows-on: Added optional arg ALL-FRAMES.
;;                        Just repeat get-buffer-window with ALL-FRAMES until no window.
;;     delete/iconify-windows-on: Removed second arg to frames-on.
;; 2017/08/19 dadams
;;     delete-window: Use with-selected-window for Emacs 22+.
;;     Updated Emacs-Wiki URLs.
;; 2017/05/06 dadams
;;     maximize-frame: Sidestep nil frame parameters.
;; 2017/02/07 dadams
;;     Added decrease-frame-transparency, increase-frame-transparency.  Suggest bind to C-M-up|down.
;; 2016/01/24 dadams
;;     Added: tear-off-window, tear-off-window-if-not-alone.
;; 2015/08/14 dadams
;;     tell-customize-var-has-changed: Use symbol-value, not eval.
;; 2014/12/09 dadams
;;     Added: frcmds-frame-pixel-height.
;;     frcmds-split-frame-1: Use frame-pixel-width and frcmds-frame-pixel-height, instead of working
;;                           with width and height frame parameters (char-based).
;;     frcmds-tile-frames:
;;       If Emacs 24.4+, use PIXELWISE arg with set-frame-size.
;;       Otherwise: * Always subtract frcmds-extra-pixels-width.
;;                  * Do not subtract borders.
;;                  * Increment origin by one border-width.
;; 2014/12/07 dadams
;;     Added: split-frame-horizontally, split-frame-vertically.
;;     frcmds-tile-frames: Added optional args, so can tile within a rectangle.
;;     create-frame-tiled-(horizontally|vertically): Keep same font size.
;; 2014/12/06 dadams
;;     Added: create-frame-tiled-horizontally, create-frame-tiled-vertically.
;;     Added aliases: tile-frames-side-by-side, tile-frames-top-to-bottom.
;;     window-mgr-title-bar-pixel-height: Changed default value for ns to 50.  Thx to Nate Eagleson.
;; 2014/10/15 dadams
;;     window-mgr-title-bar-pixel-height: Added default value for ns (Next).  Thx to Nate Eagleson.
;; 2014/10/13 dadams
;;     Removed extra, empty Package-Requires.
;; 2014/07/21 dadams
;;     Do not redefine delete-window - just advise it.
;;     delete/iconify-window: Just use delete-window, not old-delete-window.
;; 2014/04/19 dadams
;;     Added: frcmds-frame-number, name-all-frames-numerically, name-frame-numerically.
;;     Renamed: available-screen-pixel-*       to frcmds-available-screen-pixel-*,
;;              enlarged-font-name             to frcmds-enlarged-font-name,
;;              extra-pixels-*                 to frcmds-extra-pixels-*,
;;              frame-alist-var-names          to frcmds-frame-alist-var-names,
;;              frame-parameter-names          to frcmds-frame-parameter-names,
;;              frame-iconified-p              to frcmds-frame-iconified-p,
;;              new-frame-position             to frcmds-new-frame-position,
;;              read-args-for-tile-frames      to frcmds-read-args-for-tiling,
;;              read-buffer-for-delete-windows to frcmds-read-buffer-for-delete-windows,
;;              frame-cmds-set-difference      to frcmds-set-difference,
;;              smart-tool-bar-pixel-height    to frcmds-smart-tool-bar-pixel-height,
;;              tile-frames                    to frcmds-tile-frames.
;;     rename-non-minibuffer-frame: Pass OLD-NAME and NEW-NAME to rename-frame.
;;     Group Frame-Commands: Added :prefix frcmds-.
;;
;; 2014/02/24 dadams
;;     rename-frame, rename-non-minibuffer-frame: Fixed default buffer name for non-interactive.
;; 2013/09/21 dadams
;;     maximize-frame: Apply frame-geom-value-numeric to new-* also.  Bug report thx: Mike Fitzgerald.
;; 2013/07/21 dadams
;;     Added Package-Requires to header, at least temporarily, but should not need to specify version.
;; 2013/07/12 dadams
;;     set-frame-alist-parameter-from-frame: Use lax completion, so do not limit to known parameters.
;;     frame-parameter-names: Updated for Emacs 24.
;; 2013/07/05 dadams
;;     Added: move-frame-to-screen-top-left.
;;     move-frame-to-screen-*: Read FRAME name in interactive spec.
;; 2013/07/04 dadams
;;     show-hide-show-function: Use function-item instead of const for jump-to-frame-config-register.
;; 2013/05/15 dadams
;;     Added error symbols font-too-small and font-size.
;;     enlarged-font-name: Signal font-too-small error.
;; 2013/04/29 dadams
;;     Added: deiconify-everything, (mouse-)iconify/show-frame (renamed (mouse-)iconify/map-frame).
;;     iconify/show-frame: Negative prefix arg now deiconifies all.
;; 2013/03/12 dadams
;;     maximize-frame: Corrected new-left, new-top.
;;                     Corrected arg to modify-frame-parameters - use frame-geom-value-numeric
;;     Do not alias if function name is already fboundp.
;;     toggle-max-frame-*: Use toggle-max-frame, not restore-frame (the alias).
;;     toggle-max-frame: If no restore-* parameter then first maximize.
;;                       Condition last four parameters on orig-*, not restore-*.
;; 2013/02/06 dadams
;;     move-frame-(up|down|left|right): Set N to 1 if nil.
;; 2013/01/17 dadams
;;     Added: move-frame-to-screen-(top|bottom|left|right).
;;     move-frame-(up|down|left|right): Redefined so prefix arg moves increments of char size.
;; 2012/02/29 dadams
;;     Added, for Emacs 20 only: nbutlast, butlast.  To avoid runtime load of cl.el.
;;     Added frame-cmds-set-difference, to avoid runtime load of cl.el.
;;     set-all-frame-alist-parameters-from-frame: Use frame-cmds-set-difference.
;; 2011/07/25 dadams
;;     save-frame-config: Use fboundp, not featurep.
;; 2011/01/04 dadams
;;     Removed autoload cookie from non-interactive function.
;; 2010/10/19 dadams
;;     enlarge-font: Only do frame-update-faces if Emacs 20 (obsolete in 21).
;; 2010/06/04 dadams
;;     Added: (toggle-max|restore)-frame(-horizontally|-vertically).  Thx to Uday Reddy for suggestion.
;;     Renamed max-frame to maximize-frame.
;;     maximize-frame: Save original location & position params for later restoration.
;; 2010/05/25 dadams
;;     Added: max-frame, maximize-frame-horizontally, maximize-frame-vertically.
;; 2009/10/02 dadams
;;     delete-windows-on: Return nil.  Make BUFFER optional: default is current buffer.
;; 2009/08/03 dadams
;;     delete-window: Wrap with save-current-buffer.  Thx to Larry Denenberg.
;; 2009/05/17 dadams
;;     Updated to reflect thumb-frm.el name changes.
;; 2009/01/30 dadams
;;     enlarge-font, enlarged-font-name, enlarge-font-tries:
;;       Removed temporary workaround - Emacs 23 bug #119 was finally fixed.
;; 2009/01/01 dadams
;;     Removed compile-time require of doremi-frm.el to avoid infinite recursion.
;; 2008/12/13 dadams
;;     enlarge-font: Redefined for Emacs 23 - just use :height face attribute.
;;     enlarge-font-tries, enlarged-font-name: Not used for Emacs 23.
;; 2008/10/31 dadams
;;     Updated frame-parameter-names for Emacs 23.
;; 2008/07/29 dadams
;;     Option available-screen-pixel-bounds: Use nil as default value.
;;     available-screen-pixel-bounds: Redefined as the code that defined the option's default value.
;;     Added: effective-screen-pixel-bounds - code taken from old available-screen-pixel-bounds,
;;            but also convert frame geom value to numeric.
;;     Everywhere:
;;       Use effective-screen-pixel-bounds in place of available-screen-pixel-bounds function.
;;       Use available-screen-pixel-bounds function instead of option.
;;     available-screen-pixel-(width|height): Added optional INCLUDE-MINI-P arg.
;;     new-frame-position: Call available-screen-pixel-(width|height) with arg.
;;     save-frame-config: push-current-frame-config -> doremi-push-current-frame-config.
;;     Soft-require doremi-frm.el when byte-compile.
;; 2008/06/02 dadams
;;     Added: available-screen-pixel-bounds (option and function).
;;     tile-frames, available-screen-pixel-(width|height):
;;       Redefined to use available-screen-pixel-bounds.  Thx to Nathaniel Cunningham for input.
;; 2008/05/29 dadams
;;     Fixes for macOS by Nathaniel Cunningham and David Reitter:
;;       window-mgr-title-bar-pixel-height, tile-frames, smart-tool-bar-pixel-height (added).
;; 2007/12/27 dadams
;;      tile-frames: Restored border calculation, but using only external border.
;;      Renamed window-mgr-*-width to window-mgr-*-height and changed default value from 32 to 27.
;; 2007/12/20 dadams
;;      Added: frame-extra-pixels(width|height).  Use in tile-frames.  Thx to David Reitter.
;;      frame-horizontal-extra-pixels: Changed default value from 30 to 32.
;; 2007/10/11 dadams
;;      Added: assq-delete-all (for Emacs 20).
;; 2007/09/02 dadams
;;      Added: available-screen-pixel-(width|height).  Use in tile-frames, new-frame-position.
;; 2007/06/12 dadams
;;      tile-frames: Corrected use of fboundp for thumbnail-frame-p.
;; 2007/05/27 dadams
;;      enlarged-font-name:
;;        Do nothing if null assq of ascii.  Not sure what this means, but gets around Emacs 23 bug.
;; 2006/08/22 dadams
;;      Added: delete-windows-for, read-buffer-for-delete-windows.
;;      delete-windows-on: Use read-buffer-for-delete-windows.
;;      Removed old-delete-windows-on (not used).
;; 2006/05/30 dadams
;;      delete-windows-on: Return nil if buffer arg is nil. Thanks to Slawomir Nowaczyk.
;; 2006/01/07 dadams
;;      Added :link for sending bug report.
;; 2006/01/06 dadams
;;      Renamed group.  Added :link.
;; 2006/01/04 dadams
;;     Added: other-window-or-frame.
;; 2005/12/29 dadams
;;     mouse-show-hide-mark-unmark: dired-mouse-mark/unmark -> diredp-mouse-mark/unmark.
;; 2005/12/13 dadams
;;     Added: delete-other-frames.
;; 2005/11/18 dadams
;;     enlarge-font: Try to increment or decrment further, testing for an existing font.
;;     Added: enlarge-font-tries, enlarged-font-name.
;; 2005/10/03 dadams
;;     Removed require of icomplete+.el (no longer redefines read-from-minibuffer).
;; 2005/07/03 dadams
;;     Renamed: args-for-tile-frames to read-args-for-tile-frames.
;; 2005/06/19 dadams
;;     tile-frames: Don't tile thumbnail frames.
;; 2005/05/29 dadams
;;     Moved here from frame+.el and fit-frame.el: enlarge-frame*, shrink-frame*.
;;     Added: move-frame-up|down|left|right, move-frame-wrap-within-display-flag,
;;            new-frame-position.
;; 2005/05/28 dadams
;;     show-a-frame-on: Use another-buffer as default for read-buffer, if available.
;; 2005/05/15 dadams
;;     Renamed: minibuffer-frame to 1on1-minibuffer-frame.
;; 2005/05/10 dadams
;;     remove-window: Removed definition; just defalias it to delete-window.
;;     delete-window: (one-window-p) -> (one-window-p t).
;;     set-frame-alist-parameter-from-frame: No longer use destructive fns.
;; 2005/01/19 dadams
;;     set-all-frame-alist-parameters-from-frame:
;;            Added really-all-p and use frame-parameters-to-exclude.
;;     Added: frame-parameters-to-exclude, tell-customize-var-has-changed.
;; 2005/01/18 dadams
;;     Added: set-all-frame-alist-parameters-from-frame, set-frame-alist-parameter-from-frame,
;;            frame-alist-var-names, frame-parameter-names.
;;     Added Note on saving changes.
;; 2005/01/08 dadams
;;     Moved enlarge-font here from doremi-frm.el, where it was called doremi-grow-font.
;; 2005/01/04 dadams
;;     Added rename-frame-when-iconify-flag.
;;       Use it in iconify-everything, (mouse-)iconify/map-frame.
;;     Added (defgroup frame-cmds).
;; 2004/12/23 dadams
;;     frame-config-register, show-hide-show-function, window-mgr-title-bar-pixel-width:
;;         Changed defvar to defcustom.
;; 2004/12/21 dadams
;;     hide-everything, iconify-everything: bind thumbify-instead-of-iconify-flag to nil.
;; 2004/12/10 dadams
;;     tile-frames: Change 15 to (frame-char-height fr) for scroll-bar-width.
;;     tile-frames-*: Corrected doc strings for non-interactive case.
;; 2004/12/09 dadams
;;     Changed compile-time require of strings to a soft require.
;; 2004/10/11 dadams
;;     args-for-tile-frames: Fixed bug when non-existent frame in name history.
;;     tile-frames: show-frame at end (for case where use prefix arg)
;; 2004/09/11 dadams
;;     Moved to doremi-frm.el: frame-config-ring*, frame-config-wo-parameters,
;;                             push-frame-config.
;; 2004/09/07 dadams
;;     Added: jump-to-frame-config-register, push-frame-config, save-frame-config.
;; 2004/09/01 dadams
;;     Added: frame-config-register, show-hide-show-function,
;;            jump-to-frame-config-register.
;;     Rewrote to record frame config: iconify-everything, hide-everything.
;;     Rewrote to use show-hide-show-function: show-hide.
;; 2004/03/22 dadams
;;     Added: tile-frames, tile-frames-vertically, args-for-tile-frames.
;;     Rewrote tile-frames-horizontally to use tile-frames.
;; 2004/03/19 dadams
;;     Added tile-frames-horizontally.
;; 2000/11/27 dadams
;;     hide-frame: fixed bug: Added get-a-frame for frame name read.
;; 2000/09/27 dadams
;;     1. Added: frame-iconified-p.
;;     2. remove-window: only make-frame-invisible if not iconified (HACK).
;; 1999/10/05 dadams
;;     rename-frame: fixed bug if only 1 frame and old-name was a frame.
;; 1999/08/25 dadams
;;     Added: hide-everything, show-buffer-menu, show-hide.
;; 1999/03/17 dadams
;;     delete-1-window-frames-on: ensure a buffer object (not a name).
;; 1996/04/26 dadams
;;     delete/iconify-windows-on, show-a-frame-on: Do nothing if null buffer.
;; 1996/03/12 dadams
;;     delete/iconify-window: Unless one-window-p, do old-delete-window outside of
;;                            save-window-excursion.
;; 1996/03/08 dadams
;;     1. delete-windows-on: a. Fixed incorrect interactive spec (bad paren).
;;                           b. Second arg FRAME also provided interactively now.
;;     2. Added: delete/iconify-window, delete/iconify-windows-on.
;; 1996/02/27 dadams
;;     show-frame: Call make-frame-visible.
;; 1996/02/09 dadams
;;     Added show-*Help*-buffer.
;; 1996/01/30 dadams
;;     1. show-frame: Don't make-frame-visible.  Done by raise-frame anyway.
;;     2. Added show-a-frame-on.
;; 1996/01/09 dadams
;;     Added delete-windows-on and made it interactive.
;; 1996/01/08 dadams
;;     Added rename-non-minibuffer-frame.  Use in iconify-everything,
;;           iconify/map-frame, mouse-iconify/map-frame.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (require 'cl-lib)) ;; case, cl-incf (plus, for Emacs 20: dolist, dotimes)
(require 'frame-fns) ;; frame-geom-value-cons, frame-geom-value-numeric, frames-on, get-frame-name,
                     ;; get-a-frame, read-frame
(require 'strings nil t) ;; (no error if not found) read-buffer
(require 'misc-fns nil t) ;; (no error if not found) another-buffer

;; Don't require even to byte-compile, because doremi-frm.el soft-requires frame-cmds.el
;; (eval-when-compile (require 'doremi-frm nil t)) ;; (no error if not found)
;;                                                 ;; doremi-push-current-frame-config

;; Not required here, because this library requires `frame-cmds.el': `thumb-frm.el'.
;; However, `frame-cmds.el' soft-uses `thumfr-thumbnail-frame-p', which is defined
;; in `thumb-frm.el'.

;; Quiet byte-compiler.
(defvar 1on1-minibuffer-frame)          ; In `oneonone.el'
(defvar frame-alpha-lower-limit)        ; Emacs 23+
(defvar mac-tool-bar-display-mode)

;;;;;;;;;;;;;;;;;;;;;;;




;;; USER OPTIONS (VARIABLES) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defgroup Frame-Commands nil
  "Miscellaneous frame and window commands."
  :group 'frames
  :prefix "frcmds-"
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
frame-cmds.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download"
          "https://www.emacswiki.org/emacs/download/frame-cmds.el")
  :link '(url-link :tag "Description - `delete-window'"
          "https://www.emacswiki.org/emacs/FrameModes")
  :link '(url-link :tag "Description - Frame Renaming"
          "https://www.emacswiki.org/emacs/FrameTitle")
  :link '(url-link :tag "Description - Frame Resizing"
          "https://www.emacswiki.org/emacs/Shrink-Wrapping_Frames")
  :link '(url-link :tag "Description - Frame Customization"
          "https://www.emacswiki.org/emacs/CustomizingAndSaving")
  :link '(url-link :tag "Description - Frame Tiling"
          "https://www.emacswiki.org/emacs/Frame_Tiling_Commands")
  :link '(url-link :tag "Description - General"
          "https://www.emacswiki.org/emacs/FrameModes")
  :link '(emacs-commentary-link :tag "Commentary" "frame-cmds"))

(defcustom clone-frame-parameters (cons 30 30)
  "Frame parameter settings that override those of the frame to clone.
The value can be an alist of frame parameters or a cons of two
integers, (LEFT-OFFSET . TOP-OFFSET).

The latter case sets parameters `left' and `top' of the new frame to
the `left' and `top' of the selected frame, offset by adding
LEFT-OFFSET and TOP-OFFSET to them, respectively."
  :type '(choice
          (cons :tag "Offset from current frame location"
                (integer :tag "Left")
                (integer :tag "Top"))
          (alist :tag "Parameters to augment/replace those of current frame"
                 :key-type (symbol :tag "Parameter")))
  :group 'Frame-Commands)

(defcustom rename-frame-when-iconify-flag t
  "*Non-nil means frames are renamed when iconified.
The new name is the name of the current buffer."
  :type 'boolean :group 'Frame-Commands)

(defcustom frame-config-register ?\C-l  ; Control-L is the name of the register.
  "*Character naming register for saving/restoring frame configuration."
  :type 'character :group 'Frame-Commands)

(defcustom show-hide-show-function 'jump-to-frame-config-register
  "*Function to show stuff that is hidden or iconified by `show-hide'.
Candidates include `jump-to-frame-config-register' and `show-buffer-menu'."
  :type '(choice (function-item :tag "Restore frame configuration" jump-to-frame-config-register)
                 (function :tag "Another function"))
  :group 'Frame-Commands)

;; Use `cond', not `case', for Emacs 20 byte-compiler.
(defcustom window-mgr-title-bar-pixel-height (cond ((eq window-system 'mac) 22)
                                                   ;; For older versions of macOS, 40 might be better.
                                                   ((eq window-system 'ns)  50)
                                                   (t  27))
  "*Height of frame title bar provided by the window manager, in pixels.
You might alternatively call this constant the title-bar \"width\" or
\"thickness\".  There is no way for Emacs to determine this, so you
must set it."
  :type 'integer :group 'Frame-Commands)

(defcustom enlarge-font-tries 100
  "*Number of times to try to change font-size, when looking for a font.
The font-size portion of a font name is incremented or decremented at
most this many times, before giving up and raising an error."
  :type 'integer :group 'Frame-Commands)

(defcustom frame-parameters-to-exclude '((window-id) (buffer-list) (name) (title) (icon-name))
  "*Parameters to exclude in `set-all-frame-alist-parameters-from-frame'.
An alist of the same form as that returned by `frame-parameters'.
The cdr of each alist element is ignored.
These frame parameters are not copied to the target alist."
  :type '(repeat (cons symbol sexp)) :group 'Frame-Commands)

(defcustom move-frame-wrap-within-display-flag t
  "*Non-nil means wrap frame movements within the display.
Commands `move-frame-up', `move-frame-down', `move-frame-left', and
`move-frame-right' then move the frame back onto the display when it
moves off of it.
If nil, you can move the frame as far off the display as you like."
  :type 'boolean :group 'Frame-Commands)

(defcustom available-screen-pixel-bounds nil
  "*Upper left and lower right of available screen space for tiling frames.
Integer list: (x0 y0 x1 y1), where (x0, y0) is the upper left position
and (x1, y1) is the lower right position.  Coordinates are in pixels,
measured from the screen absolute origin, (0, 0), at the upper left.

If this is nil, then the available space is calculated.  That should
give good results in most cases."
  :type '(choice
          (const :tag "Calculate automatically" nil)
          (list :tag "List of (x0 y0 x1 y1)"
           (integer :tag "X0 (upper left) - pixels from screen left")
           (integer :tag "Y0 (upper left) - pixels from screen top")
           (integer :tag "X1 (lower right) - pixels from screen left")
           (integer :tag "Y1 (lower right) - pixels from screen top")))
  :group 'Frame-Commands)



;;; FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;###autoload
(defun save-frame-config ()
  "Save current frame configuration.
You can restore it with \\[jump-to-frame-config-register]."
  (interactive)
  (frame-configuration-to-register frame-config-register)
  (when (fboundp 'doremi-push-current-frame-config) ; In `doremi-frm.el'.
    (doremi-push-current-frame-config))
  (message
   (substitute-command-keys
    (if (fboundp 'doremi-frame-configs) ; In `doremi-frm.el'.
        (format "Use `\\[jump-to-frame-config-register]' (`C-x r j %c') or \
`\\[doremi-frame-configs]' to restore frames as before (undo)." frame-config-register)
      "Use `\\[jump-to-frame-config-register]' to restore frames as before (undo)."))))

;;;###autoload
(defun jump-to-frame-config-register ()
  "Restore frame configuration saved in `frame-config-register'."
  (interactive)
  (jump-to-register frame-config-register))

;;;###autoload
(defun deiconify-everything ()
  "Deiconify any iconified frames."
  (interactive)
  (frame-configuration-to-register frame-config-register)
  (dolist (frame  (frame-list))
    (when (eq 'icon (frame-visible-p frame)) (make-frame-visible frame))))

;;;###autoload
(defun iconify-everything ()
  "Iconify all frames of session at once.
Remembers frame configuration in register `C-l' (Control-L).
To restore this frame configuration, use `\\[jump-to-register] C-l'."
  (interactive)
  (frame-configuration-to-register frame-config-register)
  (let ((thumfr-thumbify-dont-iconify-flag  nil)) ; Defined in `thumb-frm.el'.
    (dolist (frame  (visible-frame-list))
      (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame frame))
      (iconify-frame frame))))

;;;###autoload
(defun hide-everything ()
  "Hide all frames of session at once.
Iconify minibuffer frame; make all others invisible.
Remembers frame configuration in register `C-l' (Control-L).
To restore this frame configuration, use `\\[jump-to-register] C-l'."
  (interactive)
  (frame-configuration-to-register frame-config-register)
  (let ((minibuf-frame-name                 (and (boundp '1on1-minibuffer-frame)
                                                 (cdr (assq 'name (frame-parameters
                                                                   1on1-minibuffer-frame)))))
        (thumfr-thumbify-dont-iconify-flag  nil)) ; Defined in `thumb-frm.el'.
    (dolist (frame  (frame-list))
      (if (eq minibuf-frame-name (cdr (assq 'name (frame-parameters frame))))
          (iconify-frame frame)         ; minibuffer frame
        (make-frame-invisible frame t))))) ; other frames

;;;###autoload
(defun show-hide ()
  "1 frame visible: `show-hide-show-function'; else: `hide-everything'.
This acts as a toggle between showing all frames and showing only an
iconified minibuffer frame."
  (interactive)
  (if (< (length (visible-frame-list)) 2) (funcall show-hide-show-function) (hide-everything)))

;;;###autoload
(defun show-buffer-menu ()
  "Call `buffer-menu' after making all frames visible.
Useful after using `hide-everything' because of a Windows bug that
doesn't let you display frames that have been made visible after
being made invisible."
  (interactive)
  (let ((minibuf-frame-name  (and (boundp '1on1-minibuffer-frame)
                                  (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame))))))
    (dolist (frame  (frame-list))
      (if (eq minibuf-frame-name (cdr (assq 'name (frame-parameters frame))))
          (make-frame-visible frame)    ; minibuffer frame
        (iconify-frame frame)))         ; other frames
    (buffer-menu)))

;;;###autoload
(defun mouse-show-hide-mark-unmark (event)
  "In minibuffer: `show-hide'.  In dired: mark/unmark; else: buffer menu."
  (interactive "e")
  (if (window-minibuffer-p (posn-window (event-start event)))
      (show-hide)
    (or (and (memq major-mode '(dired-mode vc-dired-mode))
             (fboundp 'diredp-mouse-mark/unmark)
             (diredp-mouse-mark/unmark event)) ; Return nil if not on a file or dir.
        (mouse-buffer-menu event))))

;;;###autoload
(defalias 'iconify/map-frame 'iconify/show-frame) ; `.../map...' is the old name.
;;;###autoload
(defun iconify/show-frame (&optional all-action)
  "Iconify selected frame if now shown.  Show it if now iconified.
A non-negative prefix arg iconifies all shown frames.
A negative prefix arg deiconifies all iconified frames."
  (interactive "P")
  (cond ((not all-action)
         (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame))
         (iconify-or-deiconify-frame))
        ((natnump (prefix-numeric-value all-action))
         (iconify-everything))
        (t
         (deiconify-everything))))

;;;###autoload
(defalias 'mouse-iconify/map-frame 'mouse-iconify/show-frame) ; `.../map...' is the old name.
;;;###autoload
(defun mouse-iconify/show-frame (event)
  "Iconify frame you click, if now shown.  Show it if now iconified."
  (interactive "e")
  (select-window (posn-window (event-start event)))
  (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame))
  (iconify-or-deiconify-frame))

;;;###autoload
(defun toggle-menu-bar-for-frame (&optional frame)
  "Toggle showing the menu-bar for selected frame.
When called from Lisp, optional arg FRAME is used instead of the
selected frame."
  (interactive)
  (let ((now  (or (frame-parameter frame 'menu-bar-lines)  0)))
    (set-frame-parameter frame 'menu-bar-lines (if (zerop now) 1 0))))



;; ADVISE ORIGINAL (built-in):
;;
;; If WINDOW is the only one in its frame, `delete-frame'.
(defadvice delete-window (around delete-frame-if-one-win activate)
  "If WINDOW is the only one in its frame, then `delete-frame' too."
  (if (fboundp 'with-selected-window)   ; Emacs 22+
      (with-selected-window
          (or (ad-get-arg 0)  (selected-window))
        (if (one-window-p t) (delete-frame) ad-do-it))
    (save-current-buffer
      (select-window (or (ad-get-arg 0)  (selected-window)))
      (if (one-window-p t) (delete-frame) ad-do-it))))

;;;###autoload
(defun delete-windows-for (&optional buffer)
  "`delete-window' or prompt for buffer and delete its windows.
With no prefix arg, delete the selected window.
With a prefix arg, prompt for a buffer and delete all windows, on any
  frame, that show that buffer."
  (interactive (list (and current-prefix-arg  (frcmds-read-buffer-for-delete-windows))))
  (if buffer (delete-windows-on buffer) (delete-window)))



;; REPLACES ORIGINAL in `window.el' (built-in prior to Emacs 24.5):
;;
;; 1) Use `read-buffer' in interactive spec.
;; 2) Do not raise an error if BUFFER is a string that does not name a buffer.
;; 3) Call `delete-window', so if you use the advised `delete-window' here then this also deletes
;;    frames where window showing the BUFFER is the only window.
;;
;;;###autoload
(defun delete-windows-on (&optional buffer frame)
  "Delete windows showing BUFFER.
Optional arg BUFFER defaults to the current buffer.

Optional second arg FRAME controls which frames are considered.
  If nil or omitted, delete all windows showing BUFFER in any frame.
  If t, delete only windows showing BUFFER in the selected frame.
  If `visible', delete all windows showing BUFFER in any visible frame.
  If a frame, delete only windows showing BUFFER in that frame.

Interactively, FRAME depends on the prefix arg, as follows:
  Without a prefix arg (prefix = nil), FRAME is nil (all frames).
  With prefix arg >= 0, FRAME is t (this frame only).
  With prefix arg < 0,  FRAME is `visible' (all visible frames)."
  (interactive
   (list (frcmds-read-buffer-for-delete-windows)
         (and current-prefix-arg
              (or (natnump (prefix-numeric-value current-prefix-arg))  'visible))))
  (unless buffer (setq buffer  (current-buffer))) ; Like Emacs 23+ - unlike Emacs 21-22.

  ;; `get-buffer-window' interprets FRAME oppositely for t and nil, so switch.
  (setq frame  (if (eq t frame) nil (if (eq nil frame) t frame)))
  (let (win)
    ;; Vanilla Emacs version raises an error if BUFFER is a string that does not name a buffer.
    ;; We do not raise an error - we do nothing.
    (and (get-buffer buffer)
         (while (setq win  (get-buffer-window buffer frame)) (delete-window win))
         nil)))                         ; Return nil always, like vanilla Emacs.

(defun frcmds-read-buffer-for-delete-windows ()
  "Read buffer name for delete-windows commands.
Only displayed buffers are completion candidates."
  (completing-read "Delete windows on buffer: "
                   (let ((all-bufs   (buffer-list))
                         (cand-bufs  ()))
                     (dolist (buf  all-bufs)
                       (when (get-buffer-window buf t)
                         (push (list (buffer-name buf)) cand-bufs)))
                     cand-bufs)
                   nil t nil 'minibuffer-history (buffer-name (current-buffer)) t))

(defsubst frcmds-frame-iconified-p (frame)
  "Return non-nil if FRAME is `frame-live-p' and `frame-visible-p'."
  (and (frame-live-p frame)  (eq (frame-visible-p frame) 'icon)))

;; (defun remove-window (&optional window)
;;   "Remove WINDOW from the display.  Default is `selected-window'.
;; If WINDOW is the only one in its frame, then:
;;    If WINDOW is dedicated to its buffer, then make its frame invisible.
;;    Otherwise, delete its frame (as well as the window)."
;;   (interactive)
;;   (setq window  (or window  (selected-window)))
;;   (select-window window)
;;   (if (and (window-dedicated-p (selected-window))
;;            (one-window-p t))
;;       (let ((fr  (selected-frame)))
;;         ;; HACK because of Emacs bug: `raise-frame' won't raise a frame
;;         ;; that was first iconified and then made invisible.
;;         ;; So, here we don't make an iconified frame invisible.
;;         (unless (frcmds-frame-iconified-p fr)
;;           (make-frame-invisible fr)))
;;     (delete-window)))

;; REMOVED old definition, above, because of problems with invisible
;; *Completions* frame when use completion window with subsequent args
;; to a command.  Just use `delete-window' now, which deletes frame if
;; `one-window-p'.  Use a `defalias' because its easier than replacing
;; all my calls to `remove-window' with `delete-window'.
;;
;;;###autoload
(defalias 'remove-window 'delete-window)

;;;###autoload
(defun remove-windows-on (buffer &optional all-frames)
  "Remove all windows showing BUFFER.
This calls `remove-window' on each window showing BUFFER.

When called from Lisp, optional arg ALL-FRAMES controls which frames
are considered.  See `get-buffer-window' for its interpretation."
  (interactive
   (list (read-buffer "Remove all windows showing buffer: " (current-buffer) 'existing)
         t))
  (setq buffer  (get-buffer buffer))    ; Convert to buffer.
  (when buffer                          ; Do nothing if null BUFFER.
    (let (win) (while (setq win  (get-buffer-window buffer all-frames)) (remove-window win)))))

;;;###autoload
(defun mouse-remove-window (event)
  "Remove the window you click on.  (This calls `remove-window'.)
This command must be bound to a mouse click."
  (interactive "e")
  (mouse-minibuffer-check event)
  (remove-window (posn-window (event-start event))))

;;;###autoload
(defun delete/iconify-window (&optional window frame-p)
  "Delete or iconify WINDOW (default: `selected-window').
If WINDOW is the only one in its frame (`one-window-p'), then optional
arg FRAME-P determines the behavior regarding the frame, as follows:
  If FRAME-P is nil, then the frame is deleted (with the window).
  If FRAME-P is t, then the frame is iconified.
  If FRAME-P is a symbol naming a function, the function is applied
             to WINDOW as its only arg.
             If the result is nil, then the frame is deleted.
             If the result is non-nil, then the frame is iconified.
  If FRAME-P is anything else, then behavior is as if FRAME-P were the
             symbol `window-dedicated-p': the frame is iconified if
             WINDOW is dedicated, otherwise the frame is deleted.

Interactively, FRAME-P depends on the prefix arg, as follows:
  Without a prefix arg (prefix = nil), FRAME-P is `window-dedicated-p'.
  With prefix arg < 0, FRAME-P is t.  The frame is iconified.
  With prefix arg >= 0, FRAME-P is nil.  The frame is deleted."
  (interactive
   (list nil (if current-prefix-arg
                 (not (natnump (prefix-numeric-value current-prefix-arg)))
               'window-dedicated-p)))
  (setq window  (or window  (selected-window)))
  (let ((one-win-p  t))
    (save-window-excursion
      (select-window window)
      (if (one-window-p)
          (if frame-p
              (if (eq t frame-p)
                  (iconify-frame)
                (unless (and (symbolp frame-p)  (fboundp frame-p))
                  (setq frame-p  'window-dedicated-p))
                (if (funcall frame-p window) (iconify-frame) (delete-frame)))
            (delete-frame))             ; Default.
        (setq one-win-p  nil)))
    ;; Do this outside `save-window-excursion'.
    (unless one-win-p (delete-window window))))

;;;###autoload
(defun delete/iconify-windows-on (buffer &optional frame frame-p)
  "For each window showing BUFFER: delete it or iconify its frame.
\(This calls `delete/iconify-window' on each window showing BUFFER.)

Optional second arg FRAME controls which frames are considered.
  If nil or omitted, treat all windows showing BUFFER in any frame.
  If t, treat only windows showing BUFFER in the selected frame.
  If `visible', treat all windows showing BUFFER in any visible frame.
  If a frame, treat only windows showing BUFFER in that frame.

Optional third arg FRAME-P controls what to do with one-window frames.
  If FRAME-P is nil, then one-window frames showing BUFFER are deleted.
  If FRAME-P is t, then one-window frames are iconified.
  If FRAME-P is a symbol naming a function, the function is applied
             to each window showing buffer in a frame by itself.
             If the result is nil, then the frame is deleted.
             If the result is non-nil, then the frame is iconified.
  If FRAME-P is anything else, then behavior is as if FRAME-P were the
             symbol `window-dedicated-p': One-window frames are
             iconified if window is dedicated, else they are deleted.

Interactively, FRAME is nil, and FRAME-P depends on the prefix arg:
  Without a prefix arg (prefix = nil), FRAME-P is `window-dedicated-p'.
  With prefix arg < 0, FRAME-P is t.  The frame is iconified.
  With prefix arg >= 0, FRAME-P is nil.  The frame is deleted."
  (interactive
   (list (read-buffer "Delete windows on buffer: " (current-buffer) 'existing)
         nil
         (if current-prefix-arg
             (not (natnump (prefix-numeric-value current-prefix-arg)))
           'window-dedicated-p)))
  (setq buffer  (get-buffer buffer))     ; Convert to buffer.
  (when buffer                          ; Do nothing if null BUFFER.
    ;; `get-buffer-window' interprets FRAME oppositely for t and nil, so switch.
    (setq frame  (if (eq t frame) nil (if (eq nil frame) t frame)))
    (dolist (fr  (frames-on buffer))
      (delete/iconify-window (get-buffer-window buffer frame) frame-p))))

;;;###autoload
(defun clone-frame (&optional frame no-clone)
  "Make and select a new frame with the same parameters as FRAME.
With a prefix arg, don't clone - just call `make-frame-command'.
Return the new frame.

FRAME defaults to the selected frame.  The frame is created on the
same terminal as FRAME.  If the terminal is a text-only terminal then
also select the new frame."
  (interactive "i\nP")
  (if no-clone
      (make-frame-command)
    (let* ((fit-frame-inhibit-fitting-flag  t)
           (clone-frame-parameters          (if (and clone-frame-parameters
                                                     (not (consp (car clone-frame-parameters))))
                                                `((left . ,(+ (car clone-frame-parameters)
                                                              (or (frame-geom-value-numeric
                                                                   'left (frame-parameter frame 'left))
                                                                  0)))
                                                  (top  . ,(+ (cdr clone-frame-parameters)
                                                              (or (frame-geom-value-numeric
                                                                   'top (frame-parameter frame 'top))
                                                                  0))))
                                              clone-frame-parameters))
           (default-frame-alist             (append clone-frame-parameters (frame-parameters frame)))
           (new-fr                          (make-frame)))
      (select-frame new-fr)
      new-fr)))

;;;###autoload
(defun rename-frame (&optional old-name new-name all-named)
  "Rename a frame named OLD-NAME to NEW-NAME.
Prefix arg non-nil means rename all frames named OLD-NAME to NEWNAME.
OLD-NAME may be a frame, its name, or nil.  Default is `selected-frame'.
NEW-NAME is a string or nil.  Default NEW-NAME is current `buffer-name'."
  (interactive
   (list (read-frame (concat "Rename " (and current-prefix-arg  "all ")
                             "frame" (and current-prefix-arg  "s named") ": ")
                     nil t)             ; Default = selected.  Must exist.
         (read-from-minibuffer "Rename to (new name): " (cons (buffer-name) 1))
         current-prefix-arg))
  (setq old-name  (or old-name  (get-frame-name)) ; Batch defaults from current.
        new-name  (or new-name  (buffer-name (window-buffer (frame-selected-window)))))
  ;; Convert to frame if string.
  (let ((fr  (get-a-frame old-name)))
    (if all-named
        (while fr
          (modify-frame-parameters fr (list (cons 'name new-name)))
          (setq fr  (get-a-frame old-name))) ; Get another.
      (when (string= (get-frame-name fr) (get-frame-name))
        (setq fr  (selected-frame)))
      (modify-frame-parameters fr (list (cons 'name new-name))))))

;;;###autoload
(defun rename-non-minibuffer-frame (&optional old-name new-name all-named)
  "Unless OLD-NAME names the minibuffer frame, use `rename-frame'
to rename a frame named OLD-NAME to NEW-NAME.
Prefix arg non-nil means rename all frames named OLD-NAME to NEW-NAME.
OLD-NAME may be a frame, its name, or nil.  Default is `selected-frame'.
NEW-NAME is a string or nil.  Default NEW-NAME is current `buffer-name'."
  (interactive
   (list (read-frame (concat "Rename " (and current-prefix-arg  "all ")
                             "frame" (and current-prefix-arg  "s named") ": ")
                     nil t)             ; Default = selected.  Must exist.
         (read-from-minibuffer "Rename to (new name): " (cons (buffer-name) 1))
         current-prefix-arg))
  (setq old-name  (or old-name  (get-frame-name)) ; Batch defaults from current.
        new-name  (or new-name  (buffer-name (window-buffer (frame-selected-window)))))
  (let ((fr  (get-a-frame old-name)))   ; Convert to frame if string.
    (if (and (boundp '1on1-minibuffer-frame)
             (eq (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame)))
                 (cdr (assq 'name (frame-parameters fr)))))
        (and (interactive-p)
             (error "Use `rename-frame' if you really want to rename minibuffer frame"))
      (rename-frame old-name new-name))))

;;;###autoload
(defun name-all-frames-numerically (&optional startover)
  "Rename all frames to numerals in 1,2,3...
With optional arg STARTOVER (prefix arg, interactively), rename all
starting over from 1.  Otherwise, numbering continues from the highest
existing frame number."
  (interactive "P")
  (when startover
    (dolist (fr  (frame-list))
      (rename-non-minibuffer-frame fr (format "a%s" (frame-parameter fr 'name)))))
  (mapc #'name-frame-numerically (frame-list)))

;;;###autoload
(defun name-frame-numerically (&optional frame frames)
  "Name FRAME (default, selected frame) to a numeral in 1,2,3...
If FRAME's name is already such a numeral, do nothing.
Else:
 Rename it to a numeral one greater than the max numeric frame name.
 Rename any other frames to numerals also.

To automatically name new frames numerically, you can do this in your
init file:

  (add-hook 'after-make-frame-functions 'name-frame-numerically)"
  (interactive)
  (setq frame   (or frame   (selected-frame))
        frames  (or frames  (list frame)))
  (let ((onum  (frcmds-frame-number frame))
        onums max)
    (unless onum
      (dolist (fr  (frcmds-set-difference (frame-list) frames))
        (unless (eq fr frame)
          (name-frame-numerically fr (cons fr frames))))
      (setq onums  (delq nil (mapcar #'frcmds-frame-number (frame-list)))
            max    (if onums (apply #'max onums) 0))
      (rename-non-minibuffer-frame frame (number-to-string (1+ max))))))

(defun frcmds-frame-number (frame)
  "Return FRAME's number, or nil if its name is not a numeral 1,2,3..."
  (let ((num  (string-to-number (frame-parameter frame 'name))))
    (and (wholenump num)  (not (zerop num))  num)))

;;;###autoload
(defun show-frame (frame)
  "Make FRAME visible and raise it, without selecting it.
FRAME may be a frame or its name."
  (interactive (list (read-frame "Frame to make visible: ")))
  (setq frame  (get-a-frame frame))
  (make-frame-visible frame)
  (raise-frame frame))

;;;###autoload
(defun hide-frame (frame &optional prefix)
  "Make FRAME invisible.  Like `make-frame-invisible', but reads frame name.
Non-nil PREFIX makes it invisible even if all other frames are invisible."
  (interactive (list (read-frame "Frame to make invisible: ")))
  (make-frame-invisible (get-a-frame frame) prefix))

;;;###autoload
(defun show-a-frame-on (buffer)
  "Make visible and raise a frame showing BUFFER, if there is one.
Neither the frame nor the BUFFER are selected.
BUFFER may be a buffer or its name (a string)."
  (interactive
   (list (read-buffer "Show a frame showing buffer: "
                      (if (fboundp 'another-buffer) ; Defined in `misc-fns.el'.
                          (another-buffer nil t)
                        (other-buffer (current-buffer)))
                      'existing)))
  (when buffer                          ; Do nothing if null BUFFER.
    (let ((fr  (car (frames-on buffer)))) (when fr (show-frame fr)))))

;;;###autoload
(defun show-*Help*-buffer ()
  "Raise a frame showing buffer *Help*, without selecting it."
  (interactive) (show-a-frame-on "*Help*"))

;;;###autoload
(defun delete-1-window-frames-on (buffer)
  "Delete all visible 1-window frames showing BUFFER."
  (interactive
   (list (read-buffer "Delete all visible 1-window frames showing buffer: "
                      (current-buffer) 'existing)))
  (setq buffer  (get-buffer buffer))
  (save-excursion
    (when (buffer-live-p buffer)        ; Do nothing if dead buffer.
      (dolist (fr  (frames-on buffer))   ; Is it better to search through
        (save-window-excursion          ; `frames-on' or `get-buffer-window-list'?
          (select-frame fr)
          (when (one-window-p t fr) (delete-frame)))))))

;;;###autoload
(defun delete-other-frames (&optional frame)
  "Delete all frames except FRAME (default: selected frame).
Interactively, use a prefix arg (`\\[universal-argument]') to be prompted for FRAME."
  (interactive (list (if current-prefix-arg
                         (get-a-frame (read-frame "Frame to delete: "))
                       (selected-frame))))
  (when frame
    (dolist (fr  (frame-list))
      (unless (eq fr frame) (condition-case nil (delete-frame fr) (error nil))))))

;;;###autoload
(defun maximize-frame-horizontally (&optional frame)
  "Maximize selected frame horizontally."
  (interactive (list (selected-frame)))
  (maximize-frame 'horizontal frame))

;;;###autoload
(defun maximize-frame-vertically (&optional frame)
  "Maximize selected frame vertically."
  (interactive (list (selected-frame)))
  (maximize-frame 'vertical frame))

;;;###autoload
(defun maximize-frame (&optional direction frame)
  "Maximize selected frame horizontally, vertically, or both.
With no prefix arg, maximize both directions.
With a non-negative prefix arg, maximize vertically.
With a negative prefix arg, maximize horizontally.

In Lisp code:
 DIRECTION is the direction: `horizontal', `vertical', or `both'.
 FRAME is the frame to maximize."
  (interactive (list (if current-prefix-arg
                         (if (natnump (prefix-numeric-value current-prefix-arg))
                             'vertical
                           'horizontal)
                       'both)))
  (unless frame (setq frame  (selected-frame)))
  (unless direction (setq direction  'both))
  (let (;; Size of a frame that uses all of the available screen area,
        ;; but leaving room for a minibuffer frame at bottom of display.
        (fr-pixel-width   (frcmds-available-screen-pixel-width))
        (fr-pixel-height  (frcmds-available-screen-pixel-height))
        (fr-origin        (if (eq direction 'horizontal)
                              (car (frcmds-effective-screen-pixel-bounds))
                            (cadr (frcmds-effective-screen-pixel-bounds))))
        (orig-left        (or (frame-parameter frame 'left)  0))
        (orig-top         (or (frame-parameter frame 'top)  0))
        (orig-width       (or (frame-parameter frame 'width)  0))
        (orig-height      (or (frame-parameter frame 'height)  0)))
    (let* ((bord-width  (cdr (assq 'border-width (frame-parameters frame))))
           (borders     (if bord-width (* 2 bord-width) 0))
           (new-left    (if (memq direction '(horizontal both)) 0 orig-left))
           (new-top     (if (memq direction '(vertical   both)) 0 orig-top))
           ;; Subtract borders, scroll bars, & title bar, then convert pixel sizes to char sizes.
           (new-width   (if (memq direction '(horizontal both))
                            (/ (- fr-pixel-width borders (frcmds-extra-pixels-width frame))
                               (frame-char-width frame))
                          orig-width))
           (new-height  (if (memq direction '(vertical both))
                            (- (/ (- fr-pixel-height borders
                                     (frcmds-extra-pixels-height frame)
                                     window-mgr-title-bar-pixel-height
                                     (frcmds-smart-tool-bar-pixel-height))
                                  (frame-char-height frame))
                               ;; Subtract menu bar unless on Carbon Emacs (menu bar not in the frame).
                               (if (eq window-system 'mac)
                                   0
                                 (cdr (assq 'menu-bar-lines (frame-parameters frame)))))
                          orig-height)))
      (modify-frame-parameters
       frame
       `((left   . ,new-left)
         (width  . ,new-width)
         (top    . ,new-top)
         (height . ,new-height)
         ;; If we actually changed a parameter, record the old one for restoration.
         ,(and new-left
               (/= (frame-geom-value-numeric 'left orig-left)
                   (frame-geom-value-numeric 'left new-left))
               (cons 'restore-left   orig-left))
         ,(and new-top
               (/= (frame-geom-value-numeric 'top orig-top)
                   (frame-geom-value-numeric 'top new-top))
               (cons 'restore-top    orig-top))
         ,(and new-width
               (/= (frame-geom-value-numeric 'width orig-width)
                   (frame-geom-value-numeric 'width new-width))
               (cons 'restore-width  orig-width))
         ,(and new-height
               (/= (frame-geom-value-numeric 'height orig-height)
                   (frame-geom-value-numeric 'height new-height))
               (cons 'restore-height orig-height)))))
    (show-frame frame)
    (cl-incf fr-origin (if (eq direction 'horizontal) fr-pixel-width fr-pixel-height))))

;;;###autoload
(unless (fboundp 'restore-frame-horizontally)
  (defalias 'restore-frame-horizontally 'toggle-max-frame-horizontally))
;;;###autoload
(defun toggle-max-frame-horizontally (&optional frame)
  "Toggle maximization of FRAME horizontally.
If used once, this restores the frame.  If repeated, it maximizes.
This affects the `left' and `width' frame parameters.

FRAME defaults to the selected frame."
  (interactive (list (selected-frame)))
  (toggle-max-frame 'horizontal frame))

;;;###autoload
(unless (fboundp 'restore-frame-vertically)
  (defalias 'restore-frame-vertically 'toggle-max-frame-vertically))
;;;###autoload
(defun toggle-max-frame-vertically (&optional frame)
  "Toggle maximization of FRAME vertically.
If used once, this restores the frame.  If repeated, it maximizes.
This affects the `top' and `height' frame parameters.

FRAME defaults to the selected frame."
  (interactive (list (selected-frame)))
  (toggle-max-frame 'vertical frame))

;;;###autoload
(unless (fboundp 'restore-frame) (defalias 'restore-frame 'toggle-max-frame))
;;;###autoload
(defun toggle-max-frame (&optional direction frame)
  "Toggle maximization of FRAME horizontally, vertically, or both.
Reverses or (if restored) repeats the effect of the Emacs maximize
commands.  Does not restore from maximization effected outside Emacs.

With no prefix arg, toggle both directions.
With a non-negative prefix arg, toggle only vertically.
With a negative prefix arg, toggle horizontally.

When toggling both directions, each is toggled from its last maximize
or restore state.  This means that using this after
`maximize-frame-horizontally', `maximize-frame-vertically',
`toggle-max-frame-horizontally', or `toggle-max-frame-vertically' does
not necessarily just reverse the effect of that command.

In Lisp code:
 DIRECTION is the direction: `horizontal', `vertical', or `both'.
 FRAME is the frame to change.  It defaults to the selected frame."
  (interactive (list (if current-prefix-arg
                         (if (natnump (prefix-numeric-value current-prefix-arg))
                             'vertical
                           'horizontal)
                       'both)))
  (unless frame (setq frame  (selected-frame)))
  (unless direction (setq direction  'both))
  (let ((restore-left    (frame-parameter frame 'restore-left))
        (restore-top     (frame-parameter frame 'restore-top))
        (restore-width   (frame-parameter frame 'restore-width))
        (restore-height  (frame-parameter frame 'restore-height))
        (orig-left       (frame-parameter frame 'left))
        (orig-top        (frame-parameter frame 'top))
        (orig-width      (frame-parameter frame 'width))
        (orig-height     (frame-parameter frame 'height))
        (horiz           (memq direction '(horizontal both)))
        (vert            (memq direction '(vertical both))))
    (case direction
      (both        (unless (and restore-left  restore-width  restore-top  restore-height)
                     (maximize-frame 'both frame)))
      (vertical    (unless (and restore-top  restore-height) (maximize-frame-vertically frame)))
      (horizontal  (unless (and restore-left  restore-width) (maximize-frame-horizontally frame))))
    (modify-frame-parameters
     frame `(,(and horiz  restore-left    (cons 'left           restore-left))
             ,(and horiz  restore-width   (cons 'width          restore-width))
             ,(and vert   restore-top     (cons 'top            restore-top))
             ,(and vert   restore-height  (cons 'height         restore-height))
             ,(and horiz  orig-left       (cons 'restore-left   orig-left))
             ,(and horiz  orig-width      (cons 'restore-width  orig-width))
             ,(and vert   orig-top        (cons 'restore-top    orig-top))
             ,(and vert   orig-height     (cons 'restore-height orig-height)))))
  (show-frame frame))

;;;###autoload
(defalias 'tile-frames-side-by-side 'tile-frames-horizontally)
;;;###autoload
(defun tile-frames-horizontally (&optional frames)
  "Tile frames horizontally (side by side).
Interactively:
  With prefix arg, you are prompted for names of two frames to tile.
  With no prefix arg, all visible frames are tiled, except a
       standalone minibuffer frame, if any.
If called from a program, all frames in list FRAMES are tiled."
  (interactive (and current-prefix-arg  (frcmds-read-args-for-tiling)))
  (frcmds-tile-frames 'horizontal frames))

;;;###autoload
(defalias 'tile-frames-top-to-bottom 'tile-frames-vertically)
;;;###autoload
(defun tile-frames-vertically (&optional frames)
  "Tile frames vertically (stacking from the top of the screen downward).
Interactively:
  With prefix arg, you are prompted for names of two frames to tile.
  With no prefix arg, all visible frames are tiled, except a
       standalone minibuffer frame, if any.
If called from a program, all frames in list FRAMES are tiled."
  (interactive (and current-prefix-arg  (frcmds-read-args-for-tiling)))
  (frcmds-tile-frames 'vertical frames))

;;;###autoload
(defun create-frame-tiled-horizontally ()
  "Horizontally tile screen with selected frame and a copy.
The same character size is used for the new frame."
  (interactive)
  (let* ((fr1    (selected-frame))
         (font1  (frame-parameter fr1 'font))
         (fr2    (make-frame-command)))
    (save-selected-window (select-frame fr2) (set-frame-font font1))
    (frcmds-tile-frames 'horizontal (list fr1 fr2))))

;;;###autoload
(defun create-frame-tiled-vertically ()
  "Vertically tile screen with selected frame and a copy.
The same character size is used for the new frame."
  (interactive)
  (let* ((fr1    (selected-frame))
         (font1  (frame-parameter fr1 'font))
         (fr2    (make-frame-command)))
    (frcmds-tile-frames 'vertical (list fr1 fr2))))

;;;###autoload
(defun split-frame-horizontally (num)
  "Horizontally split the selected frame.
With a prefix arg, create that many new frames.
The same character size is used for the new frames."
  (interactive "p")
  (frcmds-split-frame-1 'horizontal num))

;;;###autoload
(defun split-frame-vertically (num)
  "Vertically split the selected frame.
With a prefix arg, create that many new frames.
The same character size is used for the new frames."
  (interactive "p")
  (frcmds-split-frame-1 'vertical num))

(defun frcmds-split-frame-1 (direction num)
  "Helper for `split-frame-horizontally' and `split-frame-vertically'.
DIRECTION is `horizontal' or `vertical'.
NUM is the desired number of new frames to create."
  (let* ((fr1     (selected-frame))
         (font1   (frame-parameter fr1 'font))
         (x-min   (frame-geom-value-numeric 'left (frame-parameter fr1 'left)))
         (y-min   (frame-geom-value-numeric 'top  (frame-parameter fr1 'top)))
         (wid     (frame-pixel-width fr1))
         (hght    (frcmds-frame-pixel-height fr1))
         (frames  (list fr1))
         fr)
    (dotimes (ii num)
      (setq fr  (make-frame-command))
      (save-selected-window (select-frame fr) (set-frame-font font1))
      (push fr frames))
    (frcmds-tile-frames direction frames x-min y-min wid hght)))

(defun frcmds-frame-pixel-height (frame)
  "Pixel height of FRAME, including the window-manager title bar and menu-bar.
For the title bar, `window-mgr-title-bar-pixel-height' is used.
For the menu-bar, the frame char size is multiplied by frame parameter
`menu-bar-lines'.  But that parameter does not take into account
menu-bar wrapping."
  (+ window-mgr-title-bar-pixel-height
     (frame-pixel-height frame)
     (if (not (eq window-system 'x))
         0
       (+ (* (frame-char-height frame)
             (cdr (assq 'menu-bar-lines (frame-parameters frame))))))))

(defun frcmds-tile-frames (direction frames &optional x-min-pix y-min-pix pix-width pix-height)
  "Tile visible frames horizontally or vertically, depending on DIRECTION.
Arg DIRECTION is `horizontal' or `vertical' (meaning side by side or
above and below, respectively).

Arg FRAMES is the list of frames to tile.  If nil, then tile all visible
frames (except a standalone minibuffer frame, if any).

The optional args cause tiling to be limited to the bounding rectangle
they specify.  X-MIN-PIX and Y-MIN-PIX are the `left' and `top' screen
pixel positions of the rectangle.  X-PIX-WIDTH and Y-PIX-HEIGHT are
the pixel width and height of the rectangle."
  (let ((visible-frames   (or frames
                              (filtered-frame-list ; Get visible frames, except minibuffer.
                               #'(lambda (fr)
                                   (and (eq t (frame-visible-p fr))
                                        (or (not (fboundp 'thumfr-thumbnail-frame-p))
                                            (not (thumfr-thumbnail-frame-p fr)))
                                        (or (not (boundp '1on1-minibuffer-frame))
                                            (not (eq (cdr (assq 'name (frame-parameters
                                                                       1on1-minibuffer-frame)))
                                                     (cdr (assq 'name (frame-parameters fr)))))))))))
        ;; Size of a frame that uses all of the available screen area,
        ;; but leaving room for a minibuffer frame at bottom of display.
        (fr-pixel-width   (or pix-width   (frcmds-available-screen-pixel-width)))
        (fr-pixel-height  (or pix-height  (frcmds-available-screen-pixel-height)))
        (fr-origin        (if (eq direction 'horizontal)
                              (or x-min-pix  (car (frcmds-effective-screen-pixel-bounds)))
                            (or y-min-pix  (cadr (frcmds-effective-screen-pixel-bounds))))))
    (case direction                     ; Size of frame in pixels.
      (horizontal  (setq fr-pixel-width   (/ fr-pixel-width  (length visible-frames))))
      (vertical    (setq fr-pixel-height  (/ fr-pixel-height (length visible-frames))))
      (otherwise   (error "`frcmds-tile-frames': DIRECTION must be `horizontal' or `vertical'")))
    (dolist (fr  visible-frames)
      (if (or (> emacs-major-version 24)
              (and (= emacs-major-version 24)  (> emacs-minor-version 3)))
          (let ((frame-resize-pixelwise  t))
            (set-frame-size
             fr
             ;; Subtract scroll bars, & title bar.
             (- fr-pixel-width (frcmds-extra-pixels-width fr))
             (- fr-pixel-height
                window-mgr-title-bar-pixel-height
                (if pix-height 0 (frcmds-smart-tool-bar-pixel-height fr))
                (if (not (eq window-system 'x)) ; Menu bar for X is not in the frame.
                    0
                  (* (frame-char-height fr) (cdr (assq 'menu-bar-lines (frame-parameters fr))))))
             'PIXELWISE))
        (set-frame-size
         fr
         ;; Subtract scroll bars, & title bar, then convert pixel sizes to char sizes.
         (/ (- fr-pixel-width
               (frcmds-extra-pixels-width fr))
            (frame-char-width fr))
         (/ (- fr-pixel-height
               (frcmds-extra-pixels-height fr)
               window-mgr-title-bar-pixel-height
               (if pix-height 0 (frcmds-smart-tool-bar-pixel-height fr))
               (if (not (eq window-system 'x)) ; Menu bar for X is not in the frame.
                   0
                 (* (frame-char-height fr) (cdr (assq 'menu-bar-lines (frame-parameters fr))))))
            (frame-char-height fr))))
      (set-frame-position fr
                          (if (eq direction 'horizontal) fr-origin (or x-min-pix  0))
                          (if (eq direction 'horizontal) (or y-min-pix  0) fr-origin))
      (show-frame fr)
      ;; Move over the width or height of one frame, and add one border width.
      (cl-incf fr-origin (+ (or (cdr (assq 'border-width (frame-parameters fr)))  0)
                         (if (eq direction 'horizontal) fr-pixel-width fr-pixel-height))))))

(defun frcmds-extra-pixels-width (frame)
  "Pixel difference between FRAME total width and its text area width."
  (- (frame-pixel-width frame) (* (frame-char-width frame) (frame-width frame))))

(defun frcmds-extra-pixels-height (frame)
  "Pixel difference between FRAME total height and its text area height."
  (- (frame-pixel-height frame) (* (frame-char-height frame) (frame-height frame))))

(defun frcmds-smart-tool-bar-pixel-height (&optional frame)
  "Pixel height of macOS smart tool bar."
  (if (and (boundp 'mac-tool-bar-display-mode)  (> (frame-parameter frame 'tool-bar-lines) 0))
      (if (eq mac-tool-bar-display-mode 'icons) 40 56)
    0))

(defun frcmds-read-args-for-tiling ()
  "Read two frame names and return a list of their frames.
Return value can be used as second argument for `frcmds-tile-frames'."
  (list
   (list
    ;; Note: `read-frame' puts selected-frame name at front of `frame-name-history'.
    (get-a-frame (read-frame "Tile two frames - First frame: " nil t))
    ;; Get next visible frame.  For default (prompt) value:
    ;;   If there is another visible frame in `frame-name-history', use next such.
    ;;   Else if there is another visible frame in internal frame list, use next such.
    ;;   Else use selected frame. (`frame-name-history' is defined in `frame.el'.)
    (get-a-frame
     (read-frame
      "Second frame: "
      (let ((fr-names   (cdr frame-name-history))
            (visible-p  nil)
            (fr         nil))
        (while (and (not fr)  fr-names) ; While no visible frame found and still fr-names to check.
          (setq fr        (car fr-names) ; Name
                fr        (get-a-frame fr) ; Frame
                fr        (and fr  (eq t (frame-visible-p fr)) fr) ; Visible frame
                fr-names  (cdr fr-names)))

        ;; If no visible frames in history, besides selected-frame,
        ;; then get next visible frame (not its name) from internal frame list.
        (unless fr
          (setq fr  (selected-frame))
          (while (and (not visible-p)
                      (setq fr  (next-frame fr))
                      (not (equal fr (selected-frame)))) ; equal => no other found.
            (setq visible-p  (eq t (frame-visible-p fr)))))
        fr)
      t)))))

(defun frcmds-available-screen-pixel-bounds ()
  "Returns a value of the same form as option `available-screen-pixel-bounds'.
This represents the currently available screen area."
  (or available-screen-pixel-bounds     ; Use the option value, if available.
      (if (fboundp 'mac-display-available-pixel-bounds) ; macOS-specific.
          (mac-display-available-pixel-bounds)
        (if (fboundp 'display-monitor-attributes-list) ; Emacs 24.4+
            (let ((attss  (display-monitor-attributes-list))
                  (x0     most-positive-fixnum)
                  (y0     most-positive-fixnum)
                  (x1     0)
                  (y1     0)
                  geom)
              (dolist (atts  attss)
                (setq geom  (cdr (assq 'geometry atts))
                      x0    (min x0 (nth 0 geom))
                      y0    (min y0 (nth 1 geom))
                      x1    (max x1 (nth 2 geom))
                      ;; Use `max' for the height too, but it does not account for taskbar etc.
                      y1    (max y1 (nth 3 geom))))
              (list x0 y0 x1 y1))
          ;; Punt.  Assume only one monitor.
          (list 0 0 (x-display-pixel-width) (x-display-pixel-height))))))

; Emacs 20 doesn't have `butlast'.  Define it to avoid requiring `cl.el' at runtime.  From `subr.el'.
(unless (fboundp 'butlast)
  (defun nbutlast (list &optional n)
    "Modifies LIST to remove the last N elements."
    (let ((m  (length list)))
      (or n  (setq n  1))
      (and (< n m)  (progn (when (> n 0) (setcdr (nthcdr (- (1- m) n) list) ()))
                           list))))

  (defun butlast (list &optional n)
    "Return a copy of LIST with the last N elements removed."
    (if (and n  (<= n 0)) list (nbutlast (copy-sequence list) n))))

(defun frcmds-effective-screen-pixel-bounds ()
  "Upper left and lower right of available screen space for tiling frames.
This is `frcmds-available-screen-pixel-bounds', possibly adjusted to
allow for the standalone minibuffer frame provided by `oneonone.el'."
  (if (boundp '1on1-minibuffer-frame)
      (append (butlast (frcmds-available-screen-pixel-bounds))
              (list (frame-geom-value-numeric 'top (cdr (assq 'top (frame-parameters
                                                                    1on1-minibuffer-frame))))))
    (frcmds-available-screen-pixel-bounds)))

(defun frcmds-available-screen-pixel-width (&optional include-mini-p)
  "Width of the usable screen, in pixels.
Non-nil optional argument `include-mini-p' means include the space
occupied by a standalone minibuffer, if any."
  (let ((bounds  (if include-mini-p
                     (frcmds-available-screen-pixel-bounds)
                   (frcmds-effective-screen-pixel-bounds))))
    (- (caddr bounds) (car bounds)))) ; X1 - X0

(defun frcmds-available-screen-pixel-height (&optional include-mini-p)
  "Height of the usable screen, in pixels.
Non-nil optional argument `include-mini-p' means include the
space occupied by a standalone minibuffer, if any."
  (let ((bounds  (if include-mini-p
                     (frcmds-available-screen-pixel-bounds)
                   (frcmds-effective-screen-pixel-bounds))))
    (- (cadddr bounds) (cadr bounds)))) ; Y1 - Y0

;; Same as `zz-repeat-command' in `zones.el'.
;;
(defun frcmds-repeat-command (command)  ; Emacs 22+
  "Repeat COMMAND."
  (require 'repeat)         ; Define its vars before we let-bind them.
  (let ((repeat-previous-repeated-command  command)
        (repeat-message-function           #'ignore)
        (last-repeatable-command           'repeat))
    (repeat nil)))

;;;###autoload
(defun enlarge-window-horizontally-repeat () ; Emacs 22+
  "Enlarge selected window horizontally by one column.
You can repeat this by hitting the last key again..."
  (interactive)
  (require 'repeat)
  (frcmds-repeat-command 'enlarge-window-horizontally))

;;;###autoload
(defun shrink-window-horizontally-repeat () ; Emacs 22+
  "Srhink selected window horizontally by one column.
You can repeat this by hitting the last key again..."
  (interactive)
  (require 'repeat)
  (frcmds-repeat-command 'shrink-window-horizontally))

;;;###autoload
(defun enlarge-window-repeat ()         ; Emacs 22+
  "Enlarge selected window vertically by one line.
You can repeat this by hitting the last key again..."
  (interactive)
  (require 'repeat)
  (frcmds-repeat-command 'enlarge-window))

;;;###autoload
(defun shrink-window-repeat ()          ; Emacs 22+
  "Shrink selected window vertically by one line.
You can repeat this by hitting the last key again..."
  (interactive)
  (require 'repeat)
  (frcmds-repeat-command 'shrink-window))

;;;###autoload
(defun enlarge/shrink-window (arg)      ; Emacs 22+
  "Enlarge selected window vertically by one line.
With a prefix arg, shrink it."
  (interactive "P")
  (if arg (shrink-window 1) (enlarge-window 1)))

;;;###autoload
(defun enlarge/shrink-window-repeat ()  ; Emacs 22+
  "Enlarge selected window vertically by one line.
With a prefix arg, shrink it.
You can repeat this by hitting the last key again..."
  (interactive)
  (require 'repeat)
  (frcmds-repeat-command 'enlarge/shrink-window))

;; Inspired by `sk-grow-frame' from Sarir Khamsi [sarir.khamsi@raytheon.com]
;;;###autoload
(defun enlarge-frame (&optional increment frame) ; Suggested binding: `C-M-down'.
  "Increase the height of FRAME (default: selected-frame) by INCREMENT.
INCREMENT is in lines (characters).
Interactively, it is given by the prefix argument."
  (interactive "p")
  (set-frame-height frame (+ (frame-height frame) increment)))

;;;###autoload
(defun enlarge-frame-horizontally (&optional increment frame) ; Suggested binding: `C-M-right'.
  "Increase the width of FRAME (default: selected-frame) by INCREMENT.
INCREMENT is in columns (characters).
Interactively, it is given by the prefix argument."
  (interactive "p")
  (set-frame-width frame (+ (frame-width frame) increment)))

;;;###autoload
(defun shrink-frame (&optional increment frame) ; Suggested binding: `C-M-up'.
  "Decrease the height of FRAME (default: selected-frame) by INCREMENT.
INCREMENT is in lines (characters).
Interactively, it is given by the prefix argument."
  (interactive "p")
  (set-frame-height frame (- (frame-height frame) increment)))

;;;###autoload
(defun shrink-frame-horizontally (&optional increment frame) ; Suggested binding: `C-M-left'.
  "Decrease the width of FRAME (default: selected-frame) by INCREMENT.
INCREMENT is in columns (characters).
Interactively, it is given by the prefix argument."
  (interactive "p")
  (set-frame-width frame (- (frame-width frame) increment)))

;;;###autoload
(defun move-frame-down (&optional n frame) ; Suggested binding: `M-down'.
  "Move selected frame down.
Move it N times `frame-char-height', where N is the prefix arg.
In Lisp code, FRAME is the frame to move."
  (interactive "p")
  (unless n (setq n  1))
  (setq n  (* n (frame-char-height frame)))
  (modify-frame-parameters frame (list (list 'top '+ (frcmds-new-frame-position frame 'top n)))))

;;;###autoload
(defun move-frame-up (&optional n frame) ; Suggested binding: `M-up'.
  "Move selected frame up.
Same as `move-frame-down', except movement is up."
  (interactive "p")
  (unless n (setq n  1))
  (move-frame-down (- n)))

;;;###autoload
(defun move-frame-right (&optional n frame) ; Suggested binding: `M-right'.
  "Move frame to the right.
Move it N times `frame-char-width', where N is the prefix arg.
In Lisp code, FRAME is the frame to move."
  (interactive "p")
  (unless n (setq n  1))
  (setq n  (* n (frame-char-width frame)))
  (modify-frame-parameters frame (list (list 'left '+ (frcmds-new-frame-position frame 'left n)))))

;;;###autoload
(defun move-frame-left (&optional n frame) ; Suggested binding: `M-left'.
  "Move frame to the left.
Same as `move-frame-right', except movement is to the left."
  (interactive "p")
  (unless n (setq n  1))
  (move-frame-right (- n)))

;; Helper function.
(defun frcmds-new-frame-position (frame type incr)
  "Return the new TYPE position of FRAME, incremented by INCR.
TYPE is `left' or `top'.
INCR is the increment to use when changing the position."
  (let* ((f-dim      (if (eq 'left type) (frame-pixel-width frame) (frame-pixel-height frame)))
         (f-min      (cadr (frame-geom-value-cons type (cdr (assq type (frame-parameters frame))))))
         (f-max      (+ f-min f-dim))
         (new-f-min  (+ incr f-min))
         (new-f-max  (+ incr f-max))
         (d-bnds     (frcmds-available-screen-pixel-bounds))
         (d-min      (if (eq 'left type) (nth 0 d-bnds) (nth 1 d-bnds)))
         (d-max      (if (eq 'left type) (nth 2 d-bnds) (nth 3 d-bnds))))
    (if (not move-frame-wrap-within-display-flag)
        new-f-min
      (when (< new-f-max d-min) (setq new-f-min  d-max))
      (when (> new-f-min d-max) (setq new-f-min  (- d-min (- f-max f-min))))
      new-f-min)))

;;;###autoload
(defun move-frame-to-screen-top (arg &optional frame) ; Suggested binding: `M-S-v'.
  "Move FRAME (default: selected-frame) to the top of the screen.
With a prefix arg, offset it that many char heights from the top."
  (interactive (list (if current-prefix-arg
                         (* (frame-char-height) (prefix-numeric-value current-prefix-arg))
                       0)
                     (get-a-frame (read-frame "Frame: " nil 'EXISTING))))
  (modify-frame-parameters frame `((top . ,arg))))

;;;###autoload
(defun move-frame-to-screen-bottom (arg &optional frame) ; Suggested binding: `C-S-v'.
  "Move FRAME (default: selected-frame) to the bottom of the screen.
With a prefix arg, offset it that many char heights from the bottom."
  (interactive (list (if current-prefix-arg
                         (* (frame-char-height) (prefix-numeric-value current-prefix-arg))
                       0)
                     (get-a-frame (read-frame "Frame: " nil 'EXISTING))))
  (let* ((borders       (* 2 (cdr (assq 'border-width (frame-parameters frame)))))
         (avail-height  (- (/ (- (frcmds-available-screen-pixel-height) borders
                                 (frcmds-extra-pixels-height frame)
                                 window-mgr-title-bar-pixel-height
                                 (frcmds-smart-tool-bar-pixel-height))
                              (frame-char-height frame))
                           ;; Subtract menu bar unless on Carbon Emacs (menu bar not in the frame).
                           (if (eq window-system 'mac)
                               0
                             (cdr (assq 'menu-bar-lines (frame-parameters frame)))))))
    (modify-frame-parameters frame `((top . ,(- (+ avail-height arg)))))))

;;;###autoload
(defun move-frame-to-screen-left (arg &optional frame) ; Suggested binding: `C-S-prior'.
  "Move FRAME (default: selected-frame) to the left side of the screen.
With a prefix arg, offset it that many char widths from the left."
  (interactive (list (if current-prefix-arg
                         (* (frame-char-width) (prefix-numeric-value current-prefix-arg))
                       0)
                     (get-a-frame (read-frame "Frame: " nil 'EXISTING))))
  (modify-frame-parameters frame `((left . ,arg))))

;;;###autoload
(defun move-frame-to-screen-right (arg &optional frame) ; Suggested binding: `C-S-next'.
  "Move FRAME (default: selected-frame) to the right side of the screen.
With a prefix arg, offset it that many char widths from the right."
  (interactive (list (if current-prefix-arg
                         (* (frame-char-width) (prefix-numeric-value current-prefix-arg))
                       0)
                     (get-a-frame (read-frame "Frame: " nil 'EXISTING))))
  (modify-frame-parameters
   frame                                ; Hard-code 7 here - what does it depend on?
   `((left . ,(- (x-display-pixel-width) (+ (frame-pixel-width) 7 arg))))))

;;;###autoload
(defun move-frame-to-screen-top-left (arg &optional frame) ; Suggested binding: `C-S-home'.
  "Move FRAME (default: selected-frame) to the top and left of the screen.
With a prefix arg, offset it that many char widths from the edges.

Note: You can use this command to move an off-screen (thus not
visible) frame back onto the screen."
  (interactive (list (if current-prefix-arg
                         (* (frame-char-width) (prefix-numeric-value current-prefix-arg))
                       0)
                     (get-a-frame (read-frame "Frame: " nil 'EXISTING))))
  (modify-frame-parameters frame '((top . ,arg) (left . ,arg))))


(when (> emacs-major-version 22)        ; Emacs 23+

  (defun decrease-frame-transparency (&optional n frame) ; Suggested binding: `C-M-S-up'.
    "Decrease the transparency of the selected frame.
Decrease it by N percent, where N is the prefix arg.
In Lisp code, FRAME is the frame to move."
    (interactive "p")
    (unless n (setq n  1))
    (let* ((now  (or (frame-parameter frame 'alpha)  100))
           (new  (+ now n)))
      (when (> new 100) (setq new  frame-alpha-lower-limit))
      (when (< new frame-alpha-lower-limit) (setq new  100))
      (set-frame-parameter frame 'alpha new)))

  (defun increase-frame-transparency (&optional n frame) ; Suggested binding: `C-M-S-down'.
    "Increase the transparency of the selected frame.
Same as `decrease-frame-transparency', except increase."
    (interactive "p")
    (unless n (setq n  1))
    (decrease-frame-transparency (- n) frame)))



;; This does not work 100% well.  For instance, set frame font to
;; "-raster-Terminal-normal-r-normal-normal-12-90-96-96-c-50-ms-oemlatin", then decrease font size.
;; The next smaller existing font on my machine is
;; "-raster-Terminal-normal-r-normal-normal-11-*-96-96-c-*-ms-oemlatin".  Decrease size again.
;; Next smaller font is "-raster-Terminal-bold-r-normal-normal-5-37-96-96-c-60-ms-oemlatin".  Notice
;; the switch to bold from regular.  Cannot decrease any more.  Increase size.  Next larger font is
;; "-raster-Terminal-bold-r-normal-normal-8-*-96-96-c-*-ms-oemlatin".  Can no longer increase size.
;;
;;;###autoload
(defun enlarge-font (&optional increment frame)
  "Increase size of font in FRAME by INCREMENT.
Interactively, INCREMENT is given by the prefix argument.
Optional FRAME parameter defaults to current frame."
  (interactive "p")
  (setq frame  (or frame  (selected-frame)))
  (let ((fontname  (cdr (assq 'font (frame-parameters frame))))
        (count     enlarge-font-tries))
    (setq fontname  (frcmds-enlarged-font-name fontname frame increment))
    (while (and (not (x-list-fonts fontname))  (wholenump (setq count  (1- count))))
      (setq fontname  (frcmds-enlarged-font-name fontname frame increment)))
    (unless (x-list-fonts fontname) (error "Cannot change font size"))
    (modify-frame-parameters frame (list (cons 'font fontname)))
    ;; Update faces that want a bold or italic version of the default font.
    (when (< emacs-major-version 21) (frame-update-faces frame))))

;;; This was a workaround hack for an Emacs 23 bug (#119, aka #1562).
;;; This works OK, but it is not as refined as the version I use, and it does not work for
;;; older Emacs versions.
;;;
;;; (when (> emacs-major-version 22)
;;;   (defun enlarge-font (&optional increment frame)
;;;     "Increase size of font in FRAME by INCREMENT.
;;; Interactively, INCREMENT is given by the prefix argument.
;;; Optional FRAME parameter defaults to current frame."
;;;     (interactive "p")
;;;     (setq frame  (or frame  (selected-frame)))
;;;     (set-face-attribute
;;;      'default frame :height (+ (* 10 increment)
;;;                                (face-attribute 'default :height frame 'default)))))





;;; Define error symbols `font-too-small' and `font-size', and their error conditions and messages.
;;;
;;; You can use these to handle an error of trying to make the font too small.
;;; See library `thumb-frm.el', command `thumfr-thumbify-frame'.
;;;
(put 'font-too-small 'error-conditions '(error font-size font-too-small))
(put 'font-too-small 'error-message    "Font size is too small")

(put 'font-size      'error-conditions '(error font-size))
(put 'font-size      'error-message    "Bad font size")

(defun frcmds-enlarged-font-name (fontname frame increment)
  "FONTNAME, after enlarging font size of FRAME by INCREMENT.
FONTNAME is the font of FRAME."
  (when (query-fontset fontname)
    (let ((ascii  (assq 'ascii (aref (fontset-info fontname frame) 2))))
      (when ascii (setq fontname  (nth 2 ascii)))))
  (let ((xlfd-fields  (x-decompose-font-name fontname)))
    (unless xlfd-fields (error "Cannot decompose font name"))
    (let ((new-size  (+ (string-to-number (aref xlfd-fields xlfd-regexp-pixelsize-subnum))
                        increment)))
      (unless (> new-size 0) (signal 'font-too-small (list new-size)))
      (aset xlfd-fields xlfd-regexp-pixelsize-subnum (number-to-string new-size)))
    ;; Set point size & width to "*", so frame width will adjust to new font size
    (aset xlfd-fields xlfd-regexp-pointsize-subnum "*")
    (aset xlfd-fields xlfd-regexp-avgwidth-subnum "*")
    (x-compose-font-name xlfd-fields)))

;;;###autoload
(defun set-frame-alist-parameter-from-frame (alist parameter &optional frame)
  "Set PARAMETER of frame alist ALIST to its current value in FRAME.
FRAME defaults to the selected frame.  ALIST is a variable (symbol)
whose value is an alist of frame parameters."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (symbolp (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read
                    "Frame alist to change (variable): "
                    (frcmds-frame-alist-var-names) nil t nil nil 'default-frame-alist t))
           (intern (completing-read "Parameter to set:" ; Lax completion - not just known parameters.
                                    (frcmds-frame-parameter-names) nil nil nil nil 'left t))
           (get-a-frame (read-frame "Frame to copy parameter value from: " nil t)))))
  (unless (boundp alist)
    (error "Not a defined Emacs variable: `%s'" alist))
  (set alist (assq-delete-all parameter (copy-alist (eval alist))))
  (set alist (cons (assq parameter (frame-parameters frame)) (eval alist)))
  (tell-customize-var-has-changed alist))

;;; Standard Emacs 21+ function, defined here for Emacs 20.
(unless (fboundp 'assq-delete-all)
  (defun assq-delete-all (key alist)
    "Delete from ALIST all elements whose car is `eq' to KEY.
Return the modified alist.
Elements of ALIST that are not conses are ignored."
    (while (and (consp (car alist))  (eq (car (car alist)) key)) (setq alist  (cdr alist)))
    (let ((tail  alist)
          tail-cdr)
      (while (setq tail-cdr  (cdr tail))
        (if (and (consp (car tail-cdr))  (eq (car (car tail-cdr)) key))
            (setcdr tail (cdr tail-cdr))
          (setq tail  tail-cdr))))
    alist))

;; Define this to avoid requiring `cl.el' at runtime.  Same as `icicle-set-difference'.
(defun frcmds-set-difference (list1 list2 &optional key)
  "Combine LIST1 and LIST2 using a set-difference operation.
Optional arg KEY is a function used to extract the part of each list
item to compare.

The result list contains all items that appear in LIST1 but not LIST2.
This is non-destructive; it makes a copy of the data if necessary, to
avoid corrupting the original LIST1 and LIST2."
  (if (or (null list1)  (null list2))
      list1
    (let ((keyed-list2  (and key  (mapcar key list2)))
          (result       ()))
      (while list1
        (unless (if key
                    (member (funcall key (car list1)) keyed-list2)
                  (member (car list1) list2))
          (setq result  (cons (car list1) result)))
        (setq list1  (cdr list1)))
      result)))

;;;###autoload
(defun set-all-frame-alist-parameters-from-frame (alist &optional frame really-all-p)
  "Set frame parameters of ALIST to their current values in FRAME.
Unless optional argument REALLY-ALL-P (prefix arg) is non-nil, the
frame parameters in list `frame-parameters-to-exclude' are
excluded: they are not copied from FRAME to ALIST.
ALIST is a variable (symbol) whose value is an alist of frame parameters.
FRAME defaults to the selected frame."
  (interactive
   (let ((symb                          (or (and (fboundp 'symbol-nearest-point)
                                                 (symbol-nearest-point))
                                            (symbolp (variable-at-point))))
         (enable-recursive-minibuffers  t))
     (list (intern (completing-read
                    "Frame alist to change (variable): "
                    (frcmds-frame-alist-var-names) nil t nil nil 'default-frame-alist t))
           (get-a-frame (read-frame "Frame to copy parameter values from: " nil t))
           current-prefix-arg)))
  (unless (boundp alist)
    (error "Not a defined Emacs variable: `%s'" alist))
  (set alist (frcmds-set-difference (frame-parameters frame)
                                    (and (not really-all-p)  frame-parameters-to-exclude)
                                    #'car))
  (tell-customize-var-has-changed alist))

(defun frcmds-frame-alist-var-names ()
  "Return an alist of all variable names that end in \"frame-alist\".
The CAR of each list item is a string variable name.
The CDR is nil."
  (let ((vars  ()))
    (mapatoms (lambda (sym) (and (boundp sym)
                             (setq sym  (symbol-name sym))
                             (string-match "frame-alist$" sym)
                             (push (list sym) vars))))
    vars))

(defun frcmds-frame-parameter-names ()
  "Return an alist of all available frame-parameter names.
These are the documented, out-of-the-box (predefined) parameters.
The CAR of each list item is a string parameter name.
The CDR is nil."
  (let ((params  '(("auto-lower")
                   ("auto-raise")
                   ("background-color")
                   ("background-mode")
                   ("border-color")
                   ("border-width")
                   ("buffer-list")
                   ("buffer-predicate")
                   ("cursor-color")
                   ("cursor-type")
                   ("display")
                   ("display-type")
                   ("font")
                   ("foreground-color")
                   ("height")
                   ("horizontal-scroll-bars")
                   ("icon-left")
                   ("icon-name")
                   ("icon-top")
                   ("icon-type")
                   ("internal-border-width")
                   ("left")
                   ("menu-bar-lines")
                   ("minibuffer")
                   ("mouse-color")
                   ("name")
                   ("scroll-bar-width")
                   ("title")
                   ("top")
                   ("unsplittable")
                   ("user-position")
                   ("vertical-scroll-bars")
                   ("visibility")
                   ("width")
                   ("window-id"))))
    (when (> emacs-major-version 20)
      (setq params  (nconc params '(("fullscreen")
                                    ("left-fringe")
                                    ("line-spacing")
                                    ("outer-window-id")
                                    ("right-fringe")
                                    ("screen-gamma")
                                    ("scroll-bar-background")
                                    ("scroll-bar-foreground")
                                    ("tool-bar-lines")
                                    ("tty-color-mode")
                                    ("wait-for-wm")))))
    (when (> emacs-major-version 21)
      (setq params  (nconc params '(("user-size")))))
    (when (> emacs-major-version 22)
      (setq params  (nconc params '(("alpha")
                                    ("display-environment-variable")
                                    ("font-backend")
                                    ("sticky")
                                    ("term-environment-variable")))))
    (when (> emacs-major-version 23)
      (setq params  (nconc params '(("explicit-name")
                                    ("tool-bar-position")))))
    params))

;;;###autoload
(defun tell-customize-var-has-changed (variable)
  "Tell Customize to recognize that VARIABLE has been set (changed).
VARIABLE is a symbol that names a user option."
  (interactive "vVariable: ")
  (put variable 'customized-value (list (custom-quote (symbol-value variable)))))

;;;###autoload
(defun other-window-or-frame (arg)
  "`other-frame', if `one-window-p'; otherwise, `other-window'."
  (interactive "p")
  (if (one-window-p) (other-frame arg) (other-window arg)))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'frame-cmds)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; frame-cmds.el ends here
#+end_src


** autofit-frame.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220350678843900

#+name: 20210601220350678843900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; autofit-frame.el --- Automatically resize one-window frames to fit
;;
;; Filename: autofit-frame.el
;; Description: Automatically resize one-window frames to fit.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2000-2018, Drew Adams, all rights reserved.
;; Created: Thu Dec  7 10:06:18 2000
;; Version: 0
;; Package-Requires: ((fit-frame "0"))
;; Last-Updated: Mon Jan  1 09:29:01 2018 (-0800)
;;           By: dradams
;;     Update #: 712
;; URL: https://www.emacswiki.org/emacs/download/autofit-frame.el
;; Doc URL: http://www.emacswiki.org/emacs/Shrink-Wrapping_Frames
;; Keywords: internal, extensions, convenience, local
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x
;;
;; Features that might be required by this library:
;;
;;   `fit-frame', `misc-fns', `strings', `thingatpt', `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Automatically resize one-window frames to fit.
;;
;;  Functions are provided here to automatically resize each frame to
;;  fit its selected window, when there is no other window in the
;;  frame.  Some standard Emacs primitive functions are redefined to
;;  do this: `display-buffer' (prior to Emacs 23 only),
;;  `switch-to-buffer', and `pop-to-buffer' (prior to Emacs 23 only).
;;
;;  Prior to Emacs 23, automatic frame resizing is also provided here
;;  implicitly for functions `switch-to-buffer-other-window' and
;;  `switch-to-buffer-other-frame', since they ultimately use
;;  `display-buffer', and so the version of it defined here.  (Command
;;  `switch-to-buffer' does not use `display-buffer' - it is redefined
;;  separately here, for all Emacs versions.)
;;
;;  Put the following in your Emacs initialization file (`~/.emacs'),
;;  in order to provide for automatic frame resizing:
;;
;;    (require 'autofit-frame)
;;    (add-hook 'after-make-frame-functions 'fit-frame)
;;
;;  The second line here causes newly created frames to be fitted to
;;  their buffer (window).  Even if you load `auto-fit-frames.el', you
;;  will still need to do this, because `display-buffer' and so on are
;;  not called when a new frame is created.
;;
;;  To automatically fit frames that show a temporary buffer in their
;;  sole window, add this to your initialization file also:
;;
;;    (add-hook 'temp-buffer-show-hook                ; Emacs < 24.4
;;              'fit-frame-if-one-window 'append)
;;
;;    (add-hook 'temp-buffer-window-show-hook         ; Emacs 24.4+
;;              'fit-frame-if-one-window 'append)
;;
;;  User option (variable) `autofit-frames-flag' turns on and off the
;;  automatic resizing defined here.  Setting it to nil turns it off:
;;  (setq autofit-frames-flag nil).  You can also bind it to nil to
;;  temporarily inhibit frame resizing in Lisp code:
;;
;;         (let ((autofit-frames-flag nil))...)
;;
;;
;;  New user option (variable) defined here: `autofit-frames-flag'.
;;
;;  New function defined here (useful as a `temp-buffer-show-hook'):
;;
;;    `fit-frame-if-one-window'.
;;
;;
;;  ***** NOTE: The following function defined in `window.el' has been
;;              REDEFINED HERE:
;;
;;  `window--display-buffer-1' (Emacs 23+) -
;;     Resize frame to fit sole window if `autofit-frames-flag'.
;;
;;
;;  ***** NOTE: The following EMACS PRIMITIVES are REDEFINED HERE:
;;
;;  `display-buffer' (prior to Emacs 23 only) -
;;     1) Use `read-buffer' in interactive spec.
;;     2) Resize frame to fit sole window if `autofit-frames-flag'
;;        (and provided buffer was not yet displayed).
;;     3) Raise the frame.
;;     4) Restore point in buffer - fixes unknown Emacs 22 bug.
;;
;;  `pop-to-buffer' (prior to Emacs 23 only) -
;;     Use the `display-buffer' defined here.
;;
;;  `switch-to-buffer' (all Emacs versions) -
;;     1) Use `read-buffer' in interactive spec.
;;     2) If current window is dedicated, then use another window.
;;     3) Resize frame to fit sole window if `autofit-frames-flag'
;;        (unless BUFFER is already the `current-buffer').
;;
;;
;;  This file loads file `fit-frame.el', which provides the main
;;  functionality behind the automatic frame resizing.  See it for
;;  user options to do such things as customize default frame sizes.
;;
;;  The reason for separating the code here from that in
;;  `fit-frame.el' is to let you load that code but not load the code
;;  here, if you do not want to redefine Emacs primitives.
;;
;;  This file was formerly called `shrink-fit-all.el', then
;;  `auto-resize-frames.el'.
;;
;;
;;  See also these files for other frame commands:
;;
;;     `doremi-frm.el'    - Incrementally adjust frame properties
;;                          using arrow keys and/or mouse wheel.
;;
;;     `frame-cmds.el'    - Miscellaneous frame and window commands.
;;
;;     `thumb-frm.el'     - Shrink frames to a thumbnail size and
;;                          restore them again.
;;
;;     `zoom-frm.el'      - Zoom a frame, so that its font becomes
;;                          larger or smaller.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2011/11/30 dadams
;;     switch-to-buffer:
;;       Pass NORECORD arg to switch-to-buffer-other-window.
;;       Emacs 24+: Same as other versions: use other window if dedicated window.
;; 2011/11/08 dadams
;;     switch-to-buffer: Added Emacs 24+ version (they changed Emacs 24 again).
;; 2011/10-19 dadams
;;     Removed redefinition of pop-to-buffer-same-window (Emacs 24 pretest).
;; 2011/08/14 dadams
;;     Added redefinition of pop-to-buffer-same-window, for Emacs 24.
;; 2011/02/25 dadams
;;     switch-to-buffer:
;;       If BUFFER is nil, use other-buffer.  Thx to Martial Boniou.
;; 2011/01/03 dadams
;;     Removed autoload cookies: non def* sexps, non-interactive functions.
;; 2009/05/03 dadams
;;     Use (fboundp 'window--display-buffer-1), not Emacs version test.
;; 2009/03/08 dadams
;;     Do not redefine for Emacs 23+: pop-to-buffer, display-buffer.
;;     Added (Emacs 23+): window--display-buffer-1.
;;     display-buffer: Added save-excursion around save-selected-window.
;; 2007/09/03 dadams
;;     Added: redefinition of pop-to-buffer.
;;     display-buffer: Raise frame.  Needed for buffer in thumbnail frame.
;;                     Don't fit frame if buffer was already displayed.
;; 2007/02/14 dadams
;;     display-buffer: Hack: restore point, to work around some Emacs 22 bug.
;; 2006/03/07 dadams
;;     switch-to-buffer: Bug fix: return destination buffer.  Thx to AndreyZ.
;; 2006/01/07 dadams
;;     Added :link for sending bug report.
;; 2006/01/06 dadams
;;     Removed defgroup - we require fit-frame.el, which does it.
;; 2005/09/02 dadams
;;     switch-to-buffer: Don't require existing buffer.
;; 2005/05/28 dadams
;;     autofit-frames-flag: defvar -> defcustom.  Added defgroup fit-frame.
;;     switch-to-buffer: Use explicit default in read-buffer.
;;       Require misc-fns.el.
;; 2004/10/07 dadams
;;     Renamed resize-* to fit-*, per RMS.
;;     Renamed automatically-resize-frames-p to autofit-frames-flag.
;; 2004/09/21 dadams
;;     Commented-out redefinition of pop-to-buffer.  Removed it from intro.
;; 2004/06/01 dadams
;;     1. Replaced fit-frame-when-display-p, fit-frame-when-pop-to-p,
;;        and fit-frame-when-switch-to-p by
;;        automatically-resize-frames-p.
;;     2. Removed pop-to-buffer and
;;        resize-frame-if-one-window-and-cond.
;;     3. Renamed fit-frame-* to resize-frame-*.  Renamed file.
;;     4. switch-to-buffer: Don't resize if buffer is already current.
;; 2004/05/07 dadams
;;     Updated to work with Emacs 21:
;;       pop-to-buffer has additional arg and doc-string changes
;;       display-buffer has doc-string changes
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'fit-frame) ;; fit-frame
(require 'strings nil t) ;; (no error if not found) read-buffer
(require 'misc-fns nil t) ;; (no error if not found) another-buffer

(unless (> emacs-major-version 22)      ; Quiet the byte-compiler.
  (defvar display-buffer-reuse-frames))

;;;;;;;;;;;;;;;;;;;;;;;

;;; User options ---------------------------------------------------

;;;###autoload
(defcustom autofit-frames-flag t
  "*Non-nil means automatically resize one-window frames to fit buffer."
  :type 'boolean :group 'Fit-Frame      ; Group is defined in `fit-frame.el'.
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
autofit-frame.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions.")))




;;; Non-interactive functions ---------------------------------

;; This is not used here.  It is useful as a `temp-buffer-show-hook':
;;   (add-hook 'temp-buffer-show-hook 'fit-frame-if-one-window 'append)
;;
(defun fit-frame-if-one-window ()
  "Resize frame to fit selected window if it is alone in the frame.
Usable in `temp-buffer-show-hook'.
This does nothing if `autofit-frames-flag' is nil."
  (and (one-window-p t) autofit-frames-flag (fit-frame)))


(when (< emacs-major-version 23)

  (or (fboundp 'old-pop-to-buffer)
      (fset 'old-pop-to-buffer (symbol-function 'pop-to-buffer)))

  ;; REPLACES ORIGINAL (built-in):
  ;; Call my version of `display-buffer'.  Needed because built-in
  ;; `pop-to-buffer' calls C version, Fdisplay_buffer, not `display-buffer'.
  ;;
  (defun pop-to-buffer (buffer &optional other-window norecord)
    "Select buffer BUFFER in some window, preferably a different one.
BUFFER may be a buffer, a string (a buffer name), or nil.
 If BUFFER is a string which is not the name of an existing buffer,
    then create a buffer with that name.
 If BUFFER is nil, then choose some other buffer.
 If `pop-up-windows' is non-nil, windows can be split.

If optional second arg OTHER-WINDOW is non-nil, then insist on finding
another window, even if BUFFER is already visible in the selected
window, and ignore `same-window-regexps' and
`same-window-buffer-names'.

Optional third arg NORECORD non-nil means do not put this buffer at
the front of the list of recently selected ones.

Return the buffer switched to.
This uses function `display-buffer' as a subroutine; see the documentation
of `display-buffer' for additional customization information."
    (display-buffer (get-buffer-create buffer))
    (old-pop-to-buffer buffer other-window norecord)))

;;; Commands ---------------------------------------------------

(when (< emacs-major-version 23)

  (or (fboundp 'old-display-buffer)
      (fset 'old-display-buffer (symbol-function 'display-buffer)))

  ;; REPLACES ORIGINAL (built-in):
  ;; 1) Use `read-buffer' in interactive spec.
  ;; 2) Resize frame to fit sole window if `autofit-frames-flag'.
  ;; 3) Raise the frame.  In particular, this ensures that a thumbified frame
  ;;    is raised (see `thumb-frm.el').
  ;; 4) Hack to restore point in buffer - fixes unknown Emacs 22 bug.
  ;;
  ;; NOTE: It would be better to rewrite the C code, so that the frame
  ;;       is not resized if the frame is simply _raised_.
  (defun display-buffer (buffer &optional not-this-window frame)
    "Make BUFFER appear in some window but don't select it.
BUFFER can be a buffer or the name of an existing buffer.
If BUFFER is shown already in some window, just use that one,
unless the window is the selected window and the optional second
argument NOT-THIS-WINDOW is non-nil (interactively, with prefix arg).
If `pop-up-frames' is non-nil, make a new frame if no window shows BUFFER.
Return the window displaying BUFFER.

Emacs 21 or later only:
  If `display-buffer-reuse-frames' is non-nil, and another frame is
  currently displaying BUFFER, then simply raise that frame.

The variables `special-display-buffer-names', `special-display-regexps',
`same-window-buffer-names', and `same-window-regexps' customize how certain
buffer names are handled.

If optional argument FRAME is `visible', search all visible frames.
If FRAME is 0, search all visible and iconified frames.
If FRAME is t, search all frames.
If FRAME is a frame, search only that frame.
If FRAME is nil, search only the selected frame
 (actually the last nonminibuffer frame),
 unless `pop-up-frames' or `display-buffer-reuse-frames' is non-nil,
 which means search visible and iconified frames.

Emacs 21 or later only:
  If `even-window-heights' is non-nil, window heights will be evened
  out if displaying the buffer causes two vertically adjacent windows
  to be displayed.

Resizes frame to fit sole window if `autofit-frames-flag', but only if
BUFFER was not yet displayed.  If BUFFER was already displayed, its
frame is assumed to already be the size you want (perhaps you resized
it manually)."
    (interactive
     (list (read-buffer "Display buffer: " (current-buffer) 'existing)
           current-prefix-arg))
    (let* ((wins      ())
           (old-wins  (progn (walk-windows (lambda (w) (push w wins)) t 0) wins))
           (win       (old-display-buffer buffer not-this-window frame))
           (pt        (save-excursion (set-buffer buffer) (point))))
      (when (window-live-p win)
        (save-excursion
          (save-selected-window
            (select-window win)
            (raise-frame)
            (goto-char pt)              ; Hack to fix unknown Emacs 22 bug.
            (and (one-window-p t)
                 autofit-frames-flag
                 (not (member win old-wins)) ; Don't fit if already displayed.
                 (fit-frame)))))
      win)))                            ; Return the window



;; REPLACES ORIGINAL defined in `window.el' (Emacs 23+):
;; Resize frame to fit sole window if `autofit-frames-flag'.
;;
(when (fboundp 'window--display-buffer-1) ; Emacs 23+

  ;; We save the original anyway, but we don't use it.
  (or (fboundp 'old-window--display-buffer-1)
      (fset 'old-window--display-buffer-1
            (symbol-function 'window--display-buffer-1)))

  (defun window--display-buffer-1 (window)
    "Raise the frame containing WINDOW.
Do not raise the selected frame.
Resize frame to fit sole window if `autofit-frames-flag'.
Return WINDOW."
    (let* ((frame    (window-frame window))
           (visible  (frame-visible-p frame)))
      (unless (or (not visible)
                  ;; Assume the selected frame is already visible enough.
                  (eq frame (selected-frame))
                  ;; Assume frame from which we invoked minibuffer is visible.
                  (and (minibuffer-window-active-p (selected-window))
                       (eq frame (window-frame (minibuffer-selected-window)))))
        (raise-frame frame)
        (save-excursion
          (save-selected-window
            (select-window window)
            (and (one-window-p t) autofit-frames-flag (fit-frame)))))
      window)))



(or (fboundp 'old-switch-to-buffer)
    (fset 'old-switch-to-buffer (symbol-function 'switch-to-buffer)))

(if (< emacs-major-version 24)

    ;; REPLACES ORIGINAL (built-in):
    ;; 1) Use `read-buffer' interactively.  If null BUFFER, use `other-buffer'.
    ;; 2) If current window is dedicated, then use another window, instead of
    ;;    raising an error.
    ;; 3) Resize frame to fit sole window if `autofit-frames-flag'
    ;;    (unless BUFFER is already the `current-buffer').
    (defun switch-to-buffer (buffer &optional norecord)
      "Select buffer BUFFER in current window, unless the window is dedicated.
If the selected window is dedicated (`window-dedicated-p'), then use
another window.

BUFFER may be a buffer, a string (a buffer name), or nil.  If BUFFER
is a string that does not identify an existing buffer, then a new
buffer with that name is created.  If BUFFER is nil, then function
`other-buffer' is used to choose a buffer.

Optional second arg NORECORD non-nil means do not put BUFFER at the
front of the list of recently selected buffers.

The buffer switched to is returned.

,*WARNING*: This is NOT the way to work on another buffer temporarily
within a Lisp program!  Use `set-buffer' instead, to avoid messing
with correspondences between windows and buffers.

Resize frame to fit sole window if `autofit-frames-flag'
\(unless BUFFER is already the `current-buffer')."
      (interactive
       (list (read-buffer "Switch to buffer: "
                          (if (fboundp 'another-buffer) ; In `misc-fns.el'.
                              (another-buffer nil t)
                            (other-buffer (current-buffer))))))
      ;; If string arg, convert to a buffer.  If nil, use `other-buffer'.
      (setq buffer  (if buffer (get-buffer-create buffer) (other-buffer)))
      (let ((orig-buf  (current-buffer)))
        (prog1 (if (window-dedicated-p (selected-window))
                   (switch-to-buffer-other-window buffer norecord)
                 (old-switch-to-buffer buffer norecord))
          (and (one-window-p t)
               (not (eq buffer orig-buf)) ; Don't resize if same buffer.
               autofit-frames-flag
               (fit-frame)))))

  ;; REPLACES ORIGINAL (built-in):
  ;;
  ;; 1) If current window is dedicated, then use another window,
  ;;    instead of raising an error.  In this case, FORCE-SAME-WINDOW is ignored.
  ;; 2) Resize frame to fit sole window if `autofit-frames-flag'
  ;;    (unless BUFFER is already the `current-buffer').
  ;;
  (defun switch-to-buffer (buffer-or-name &optional norecord force-same-window)
    "Switch to buffer BUFFER-OR-NAME in the selected window.
Return the buffer switched to.

If the selected window is dedicated (`window-dedicated-p'), then use
another window, regardless of argument FORCE-SAME-WINDOW.

If called interactively, prompt for the buffer name with completion.
Variable `confirm-nonexistent-file-or-buffer' determines whether to
require confirmation before creating a new buffer.

BUFFER-OR-NAME may be a buffer, a buffer name (a string), or nil.  If
it is a string that does not identify an existing buffer, create a
buffer with that name.  If nil, switch to `other-buffer'.

Optional argument NORECORD non-nil means do not put the buffer
specified by BUFFER-OR-NAME at the front of the buffer list and
do not make the window displaying it the most recently selected
one.

If the selected window is not dedicated, then:
,* If FORCE-SAME-WINDOW is non-nil, signal an error if BUFFER-OR-NAME
  cannot be displayed in the selected window (e.g. if the selected
  window is minibuffer-only).
,* If FORCE-SAME-WINDOW is nil, display BUFFER-OR-NAME in another
  window if it cannot be displayed in the selected window."
    (interactive
     (list (read-buffer-to-switch "Switch to buffer: ") nil 'force-same-window))
    (let ((orig-buf    (current-buffer))
          (switch-buf  (if (not (window-dedicated-p (selected-window)))
                           (old-switch-to-buffer
                            buffer-or-name norecord force-same-window)
                         ;; If string, convert to buffer.
                         ;; If nil, use `other-buffer'.
                         (setq buffer-or-name  (if buffer-or-name
                                                   (get-buffer-create
                                                    buffer-or-name)
                                                 (other-buffer)))
                         (switch-to-buffer-other-window
                          buffer-or-name norecord))))
      (when (and (one-window-p t)
                 (not (eq switch-buf orig-buf)) ; Don't resize if same buffer.
                 autofit-frames-flag
                 (fit-frame)))
      switch-buf)))


;;; ;; REPLACES ORIGINAL in `window.el':
;;; ;; 1) Use `read-buffer' in interactive spec.
;;; ;; 2) Resize frame to fit sole window if `autofit-frames-flag'
;;; ;;    (unless BUFFER is already the `current-buffer').
;;; (when (fboundp 'pop-to-buffer-same-window) ; Emacs 24+.
;;;
;;; $$$$$$ Martin Rudalics's version, modified for frame fitting,
;;;        before Yidong Chong got into the act.
;;;   (defun pop-to-buffer-same-window (&optional buffer-or-name norecord label)
;;;     "Pop to buffer specified by BUFFER-OR-NAME in the selected window.
;;; Another window is used only if the buffer cannot be shown in the
;;; selected window, usually because it is dedicated to another buffer.
;;; Optional arguments BUFFER-OR-NAME, NORECORD, and LABEL are as for
;;; `pop-to-buffer'.
;;;
;;; Resize frame to fit sole window if `autofit-frames-flag' is non-nil.
;;; \(unless BUFFER is already the `current-buffer')."
;;;     (interactive
;;;      (list (read-buffer "Pop to buffer in selected window: "
;;;                         (if (fboundp 'another-buffer) ; In `misc-fns.el'.
;;;                             (another-buffer nil t)
;;;                           (other-buffer (current-buffer))))
;;;            current-prefix-arg))
;;;     ;; If string arg, convert to a buffer.  If nil, use `current-buffer'.
;;;     (setq buffer-or-name  (if buffer-or-name
;;;                               (get-buffer-create buffer-or-name)
;;;                             (current-buffer)))
;;;     (let ((orig-buf  (current-buffer)))
;;;       (prog1 (pop-to-buffer buffer-or-name 'same-window norecord label)
;;;         (and (one-window-p t)
;;;              (not (eq buffer-or-name orig-buf)) ; No resize if same buffer.
;;;              autofit-frames-flag
;;;              (fit-frame))))))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'autofit-frame)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; autofit-frame.el ends here
#+end_src

** buff-menu+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220402754928300

#+name: 20210601220402754928300
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; buff-menu+.el --- Extensions to `buff-menu.el'.    -*- coding:utf-8 -*-
;;
;; Filename: buff-menu+.el
;; Description: Extensions to `buff-menu.el'
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2017, Drew Adams, all rights reserved.
;; Created: Mon Sep 11 10:29:56 1995
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Tue Feb 21 07:59:07 2017 (-0800)
;;           By: dradams
;;     Update #: 2847
;; URL: https://www.emacswiki.org/emacs/download/buff-menu%2b.el
;; Doc URL: http://www.emacswiki.org/BufferMenuPlus
;; Keywords: mouse, local, convenience
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.1
;;
;; Features that might be required by this library:
;;
;;   `avoid', `fit-frame', `frame-fns', `misc-cmds', `misc-fns',
;;   `strings', `thingatpt', `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `buff-menu.el', including: new bindings, faces,
;;    and menus; selective column display; and directional column
;;    sorting.
;;
;;    NOTE: Emacs Dev rewrote `buff-menu.el' for Emacs 24.2, so that
;;          it uses `tabulated-list-mode'.  I have not yet updated
;;          `buff-menu+.el' to accommodate this vanilla rewrite, and I
;;          do not know when I might get around to doing that.
;;
;;          If you want to use `buff-menu+.el' with Emacs 24.2 or
;;          later, then you can download the Emacs 23 or Emacs 24.1
;;          version of `buff-menu.el' and put that in your `load-path'
;;          in such a way that it shadows the Emacs 24.2+ version.
;;          You can get the Emacs 23.4 version here, for instance
;;          (combine the URL into a single line):
;;
;;            http://bzr.savannah.gnu.org/lh/emacs/emacs-23/download/
;;             head:/buffmenu.el-20091113204419-o5vbwnq5f7feedwu-197/buff-menu.el
;;
;;          Sorry for the inconvenience.
;;
;;    Note: By default, the buffer menu is shown in a different
;;          window.  If you prefer to show it in the current window,
;;          then just do this:
;;
;;          (add-to-list 'same-window-buffer-names "*Buffer List*")
;;
;;  Faces defined here:
;;
;;    `buffer-menu-headings', `buffer-menu-current-buffer',
;;    `buffer-menu-directory-buffer', `buffer-menu-flagged-buffer',
;;    `buffer-menu-marked-buffer', `buffer-menu-star-buffer',
;;    `buffer-menu-view-mark', `buffer-menu-delete-mark',
;;    `buffer-menu-save-mark', `buffer-menu-modified-mark',
;;    `buffer-menu-read-only-mark', `buffer-menu-buffer-name',
;;    `buffer-menu-mode', `buffer-menu-size', `buffer-menu-time',
;;    `buffer-menu-file-name'.
;;
;;  User options defined here (Emacs 22+):
;;
;;    `Buffer-menu-file-flag', `Buffer-menu-mode-flag',
;;    `Buffer-menu-time-flag', `Buffer-menu-time-format'.
;;
;;  Commands defined here:
;;
;;    `Buffer-menu-decrease-max-buffer+size' (Emacs 22+),
;;    `Buffer-menu-delete-flagged',
;;    `Buffer-menu-increase-max-buffer+size' (Emacs 22+),
;;    `Buffer-menu-mouse-3-menu', `Buffer-menu-mouse-delete',
;;    `Buffer-menu-mouse-execute', `Buffer-menu-mouse-modified',
;;    `Buffer-menu-mouse-other-window', `Buffer-menu-mouse-save',
;;    `Buffer-menu-mouse-unmark', `Buffer-menu-toggle-file-column'
;;    (Emacs 22+), `Buffer-menu-toggle-mode-column' (Emacs 22+),
;;    `Buffer-menu-toggle-time-column' (Emacs 22+),
;;    `Buffer-menu-toggle-time-format' (Emacs 22+).
;;
;;  Internal variables defined here:
;;
;;    `buffer-menu-buffer-name',
;;    `Buffer-menu-buffer+size-computed-width',
;;    `buffer-menu-current-buffer', `buffer-menu-directory-buffer',
;;    `buffer-menu-flagged-buffer', `buffer-menu-marked-buffer',
;;    `buffer-menu-star-buffer', `buffer-menu-delete-mark',
;;    `buffer-menu-file-name', `buffer-menu-font-lock-keywords',
;;    `buffer-menu-headings', `buffer-menu-mode',
;;    `buffer-menu-modified-mark', `buffer-menu-read-only-mark',
;;    `buffer-menu-save-mark', `buffer-menu-size', `buffer-menu-time',
;;    `buffer-menu-view-mark'.
;;
;;  Other functions defined here:
;;
;;    `Buffer-menu-fontify-and-adjust-frame',
;;    `buffer-menu-nb-marked-in-mode-name',
;;    `buffer-menu-set-default-value'.
;;
;;
;;  ***** NOTE: The following user option (variable) defined in
;;              `buff-menu.el' has been REDEFINED HERE:
;;
;;  `Buffer-menu-sort-column' - A user option now. Numeric, default=1.
;;
;;
;;  ***** NOTE: The following hook defined in `buff-menu.el'
;;              has been REDEFINED HERE:
;;
;;  `Buffer-menu-mode-hook' (aka `buffer-menu-mode-hook') -
;;     Fontify buffer and fits its frame.
;;     Add number of marked and flagged lines to mode in mode line.
;;
;;
;;  ***** NOTE: The following functions defined in `buff-menu.el'
;;              have been REDEFINED HERE:
;;
;;  `buffer-menu' -
;;     1. Different help message.
;;     2. Prefix ARG =< 0 now means list (all) buffers alphabetically.
;;        (It used to mean the same as ARG > 0.)
;;        Prefix ARG >= 0 means list just file buffers.
;;     3. Use pop-to-buffer instead of switch-to-buffer.
;;  `Buffer-menu-beginning' - Protected with `boundp' for Emacs 20.
;;  `Buffer-menu-buffer+size' - Use computed width for Buffer + Size.
;;  `Buffer-menu-execute' - Deletes windows (frame) when kills buffer.
;;  `Buffer-menu-make-sort-button' -
;;     1. If same column as last sort, flip direction of sort.
;;     2. Column header face indicates sort direction.
;;     3. CRM is indicated by COLUMN = 1, not by nil COLUMN.
;;  `Buffer-menu-mode' -
;;     1. Doc string reflects new bindings.
;;     2. mouse-face on whole line, not just buffer name.
;;  `Buffer-menu-select' - When Buffer Menu is `window-dedicated-p',
;;                         uses `pop-to-buffer' to display.
;;  `Buffer-menu-sort' -
;;     1. Allow negative COLUMN. Allow COLUMN = 1 or -1.
;;     2. When COLUMN = `Buffer-menu-sort-column', then flip that.
;;     3. Added message at end indicating the kind of sort.
;;  `list-buffers-noselect' - Use longest buffer name+size to indent.
;;                          - Change sort direction if same column.
;;                          - Add sort buttons for CRM and Time also.
;;                          - Sort test is different: no sort for CRM.
;;                          - Go to bob if `desired-point' undefined.
;;
;;  In your init file (`~/.emacs') file, do this:
;;
;;    (require 'buff-menu+)
;;
;;  NOTE:
;;
;;  1. This file MUST be saved with encoding UTF-8 or equivalent,
;;     because it contains an em-dash character.
;;
;;  2. If you byte-compile this using a version of Emacs prior to 23,
;;     and you use the byte-compiled file with Emacs 23 or later, then
;;     some keys, such as `q', will not be defined in the buffer list.
;;     (So byte-compile it using Emacs 23 or later.)
;;
;;  3. Starting with Emacs 24.3, Emacs development changed
;;     `buff-menu.el' so that it is based on `tabulated-list' mode.
;;     Unfortunately, that breaks the `buff-menu+.el' enhancements.  I
;;     have not had the time to update `buff-menu+.el' for
;;     compatibility with Emacs 24.3 and later.  If you want to use
;;     `buff-menu+.el' with Emacs 24.3 or later, you can download the
;;     Emacs 23 version of `buff-menu.el' and put that in your
;;     `load-path'.  You will lose no features if you do that: Emacs
;;     24.3 and later add no enhancements to `buff-menu.el' - they
;;     just base it on `tabulated-list.el'.  You can download Emacs 23
;;     `buff-menu.el' here: http://ftp.gnu.org/gnu/emacs/ or here:
;;     http://www.gnu.org/prep/ftp.html.  That version will work fine
;;     with Emacs 24.3 and later and with `buff-menu+.el'.  I might
;;     eventually get around to updating `buff-menu+.el' to
;;     accommodate the `buff-menu.el' change, but it is not my first
;;     priority.  Sorry for this annoyance.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2013/04/20 dadams
;;     list-buffers-noselect and globally:
;;       Set Buffer-menu-buffer+size-width to 26 if nil or unbound.  Emacs 24.3+ defaults it to nil.
;; 2012/08/28 dadams
;;     Buffer-menu-select: Updated for Emacs 24.3+ (but I don't yet support > 24.2).
;;     Handle Emacs 23 capitalization of buffer-menu-mode-hook.
;; 2012/06/21 dadams
;;     Added: buffer-menu-nb-marked-in-mode-name.
;; 2012/01/15 dadams
;;     Rename commands to capitalized Buffer-menu from buffer-menu.
;;     Bind Buffer-menu-toggle-(file|mode|time)-column to M-f, M-m, M-t.
;;     Bind Buffer-menu-toggle-time-format to C-M-t.
;;     Bind Buffer-menu-delete-flagged to C-M-x for all Emacs versions.
;;     Buffer-menu-mode: Use \\[...] for those commands.
;; 2011/12/19 dadams
;;     Buffer-menu-mode, Buffer-menu-mouse-3-menu: Use line-end-position, not end-of-line + point.
;; 2011/10/27 dadams
;;     Handle Dired buffers like file buffers, e.g., wrt arg FILES-ONLY.
;; 2011/06/29 dadams
;;     Buffer-menu-buffer+size: Corrected SPC syntax (for Emacs 20) from ?\s  to ?\ .
;; 2011/05/02 dadams
;;     buffer-menu-font-lock-keywords, Buffer-menu(-mouse)-execute, list-buffers-noselect,
;;       Buffer-menu-mouse-unmark:
;;         Accommodate frame-bufs.el.
;; 2011/04/28 dadams
;;     Buffer-menu-fontify-and-adjust-frame:
;;       Fix bug introduced 2011-04-16: Do frame operations inside save-window-excursion.
;; 2011/04/22 dadams
;;     list-buffers-noselect: Removed (if buffer-list... around the dolist.
;; 2011/04/18 dadams
;;     Buffer-menu-sort, Buffer-menu-revert-function, buffer-menu:
;;       Use Buffer-menu-buffer-column, not hard-coded 4.  Thx to Alp Aker.
;; 2011/04/16 dadams
;;     Buffer-menu-fontify-and-adjust-frame:
;;       Use with-current-buffer, not save(-window)-excursion.  Thx to Alp Aker.
;; 2011/02/20 dadams
;;     list-buffers-noselect: Use only Emacs 22+ call to format-mode-line.
;;                            Use property font-lock-face, not face.
;;     Buffer-menu-sort: Typo: setq buffer-read-only was missing value.
;; 2011/02/03 dadams
;;     All deffaces: Provided default values for dark-background screens too.
;; 2011/01/03 dadams
;;     Removed autoload cookies from non def* sexps.
;; 2010/07/15 dadams
;;     Buffer-menu-fontify-and-adjust-frame:
;;       Added call to font-lock-refresh-defaults.  Thx to Bastian Beischer.
;; 2009/07/27 dadams
;;     Buffer-menu-revert-function: Updated wrt Emacs 23: use window-buffer.
;;     Buffer-menu-mode (Emacs 23): Use revert-buffer in doc string, not Buffer-menu-revert.
;;     Buffer-menu-(sort|delete-flagged): Buffer-menu-revert -> Buffer-menu-revert-function.
;;     Do defvars to silence byte-compiler for all Emacs versions.
;; 2009/05/26 dadams
;;     Buffer-menu-mode: Added separate definition for Emacs 23, because derived mode (keys etc.).
;; 2009/04/16 dadams
;;     buffer-menu-font-lock-keywords: Fix regexp for truncated star buffers (...[).
;; 2009/02/22 dadams
;;     Added comment to Commentary about how to show the buffer menu in the same window.
;; 2008/02/09 dadams
;;     Added: Buffer-menu-delete-flagged. Bound to C-M-x and added to Buffer-menu-mouse-3-menu.
;; 2008/02/05 dadams
;;     Added: buffer-menu-toggle-time-format, Buffer-menu-time-format.
;;     buffer-menu-font-lock-keywords, list-buffers-noselect: Treat short and long time formats.
;;     list-buffers-noselect: Extend column buttons from one column to the next (beyond text).
;;     Removed optional arg for column toggles.
;;     Renamed buffer-menu-set-flag to buffer-menu-set-default-value.
;;     Buffer-menu-buffer+size: Add name-props and size-props only if non-nil.
;; 2008/02/04 dadams
;;     buffer-menu-font-lock-keywords: Highlight Dired buffer name even if no Mode.
;;                                     Allow multiple digits in <N>.
;;     list-buffers-noselect:
;;       Compute longest buffer name + size combination, and use when indenting file name.
;;     Added: Buffer-menu-buffer+size, buffer-menu-(de|in)crease-max-buffer+size (and bound),
;;            Buffer-menu-buffer+size-computed-width.
;;     buffer-menu: Updated doc string.
;;     Thx to Tom Wurgler for suggestions.
;; 2008/02/03 dadams
;;     buffer-menu-font-lock-keywords: Highlight Dired buffer name, if file flag but no mode flag.
;; 2008/02/01 dadams
;;     Allow <0-9> after star buffer names.  Thx to Tom Wurgler.
;; 2008/01/31 dadams
;;     Added options to hide columns.  Thx to Tom Wurgler for the suggestion.
;;       Buffer-menu-*-flag, and changed buffer-menu-font-lock-keywords accordingly.
;;       list-buffers-noselect: Update for Buffer-menu-*-flag.
;;       Added: *-set-flag, *-toggle-*-column, buffer-menu-font-lock-keywords (function).
;;     Group Buffer-Menu-Plus: Remove prefix.  Different parent group for Emacs 22.
;; 2008/01/05 dadams
;;     list-buffers-noselect: Eval underline char at compile time - see comment.
;;     Buffer-menu-sort-column: Made it a user option.
;;     Removed: Buffer-menu-sort-button-map, Buffer-menu-sort-by-column.
;;     Don't define for Emacs before version 22: Buffer-menu-make-sort-button, Buffer-menu-sort*.
;; 2007/09/23 dadams
;;     Removed second arg to undefine-killer-commands.
;;     Brought up to date with Emacs 22.
;; 2007/02/28 dadams
;;     buffer-menu-font-lock-keywords: regexp tweaks.
;; 2007/02/26 dadams
;;     Added: buffer-menu-(star|directory|marked|flagged)-buffer.
;;     buffer-menu-font-lock-keywords: Treat new faces.  Thx to Tom Wurgler <twurgl@goodyear.com>.
;; 2007/02/16 dadams
;;     buffer-menu: Fixed use of negative arg when using header line.
;;     list-buffers-noselect:
;;       Don't sort if sort column is 1 or -1.  Instead, just don't reverse list if -1.
;;       Go to point-min if desired-point is not defined.
;;     Buffer-menu-make-sort-button: Different help echoes for CRM and Buffer.
;;     Buffer-menu-sort, Buffer-menu-make-sort-button:
;;       Add to help message for CRM sort: mention Buffer-menu-use-frame-buffer-list.
;;     Buffer-menu-mode: Mention sorting columns in doc string.
;;     Add defvar for Buffer-menu-use-frame-buffer-list to quiet byte compiler.
;;     Changed all Emacs 22 tests to test emacs-major-version.
;; 2007/02/05 dadams
;;     list-buffers-noselect: Use ?\u2014 for the EM dash.  Thx to Henry Atting.
;; 2007/02/02 dadams
;;     Added coding declaration to file header.  Thx to Henry Atting.
;;     Changed temporary emacs version tests to > emacs 21.
;; 2006/04/10 dadams
;;      list-buffers-noselect: Updated Emacs 22 version wrt latest CVS version.
;; 2006/01/07 dadams
;;      Added :link for sending bug report.
;; 2006/01/06 dadams
;;     Added defgroup 'Buffer-Menu-Plus.  Added :link.
;; 2005/11/04 dadams
;;     Added: Buffer-menu-sort-button-map, Buffer-menu-sort-by-column, if not available in Emacs.
;; 2005/11/01 dadams
;;     Buffer-menu-make-sort-button: Updated to reflect latest CVS version:
;;       Added text property: column.  Use Buffer-menu-sort-button-map.
;;       Mention mouse-1 in :help.
;; 2005/07/08 dadams
;;     Buffer-menu-fontify-and-adjust-frame: Wrapped in save-*excursion's.
;; 2005/07/04 dadams
;;     Buffer-menu-fontify-and-adjust-frame: Fixed typo: boundp -> fboundp.
;; 2005/06/22 dadams
;;     Use defface for faces now.
;;     Renamed faces: *-face to *.
;;     No longer require def-face-const.el.
;; 2005/06/21 dadams
;;     list-buffers-noselect: Emacs 22 renamed Buffer-menu-buffer-face to Buffer-menu-buffer.
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2004/12/05 dadams
;;     Buffer-menu-execute, Buffer-menu-mouse-execute: minor corrections.
;; 2004/11/30 dadams
;;     Added Time column (with sorting).
;;       Added buffer-menu-time-face.
;;       Buffer-menu-sort, Buffer-menu-make-sort-button, list-buffers-noselect,
;;     list-buffers-noselect: Major changes: Time column, updated to latest CVS (new 2nd arg) etc.
;;     buffer-menu-font-lock-keywords: Rewrote for time etc.
;;     Sort CRM column also now.
;;     Buffer-menu-fontify-and-fit-frame renamed to Buffer-menu-fontify-and-adjust-frame.
;;       Added raise-frame (but Emacs bug, so raise doesn't work on Windows).
;;       turn-on-font-lock, instead of font-lock-fontify-buffer.
;;     Removed defvar ;;;###autoload's.
;; 2004/11/23 dadams
;;     buffer-menu-mode-hook: call font-lock-fontify-buffer.
;;     buffer-menu: Do not call font-lock-fontify-buffer.
;;     Added Buffer-menu-fontify-and-fit-frame. Hook fits frame too.
;;     Require fit-frame.el.
;;     Removed Buffer-menu-revert.
;; 2004/11/20 dadams
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/11/19 dadams
;;     Protected tests of Buffer-menu-use-header-line with boundp for older versions.
;; 2004/11/13 dadams
;;     buffer-menu-font-lock-keywords: overwrite for *-mode-face, *-size-face, *-file-name-face.
;; 2004/10/17 dadams
;;     Updated to include Daniel Pfeiffer's fix to buff-menu.el of bug I reported on losing
;;       marks when you sort columns:
;;         1) Added Buffer-menu-revert-function, 2) Added (and modified) Buffer-menu-beginning,
;;         3) Use Buffer-menu-beginning in Buffer-menu-execute and Buffer-menu-select,
;;         4) Buffer-menu-sort: incorporated Daniel's mark-saving code.
;;     Note: when the new version comes out (from CVS),  I will 1) update list-buffers-noselect
;;       to new version that uses 4-arg version of format-mode-line and 2) remove new definition
;;       of Buffer-menu-revert-function added here now.
;; 2004/10/16 dadams
;;     Added directional column sorting, with highlighting:
;;       Added: Buffer-menu-make-sort-button, Buffer-menu-sort.
;;       list-buffers-noselect: Add sort button for CRM. Sort directionally.
;;     Only require cl.el when compile.
;;     Buffer-menu-revert: Fontify for Emacs 21 also (needed after revert).
;; 2004/10/15 dadams
;;     Buffer-menu-mode: Don't skip first two lines if Buffer-menu-use-header-line.
;; 2004/10/13 dadams
;;     Updated for Emacs 21:
;;       buffer-menu-font-lock-keywords, Buffer-menu-mode, Buffer-menu-execute, Buffer-menu-select
;;       Added list-buffers-noselect for Emacs 21 (bug fix).
;;       require cl.el only when compile on Emacs 20.
;;     Added Buffer-menu-revert: Fontifies.
;; 2004/07/21 dadams
;;     Buffer-menu-mode: Don't set Buffer-menu-buffer-column unless < Emacs 20.
;; 2001/01/02 dadams
;;     Protect undefine-killer-commands via fboundp.
;; 1999/08/26 dadams
;;     1. Added: buffer-menu-*-face's, buffer-menu-font-lock-keywords.
;;     2. Add buffer-menu-font-lock-keywords to buffer-menu-mode-hook.
;; 1997/03/21 dadams
;;     Buffer-menu-execute, Buffer-menu-mouse-execute:
;;       Only use kill-buffer-and-its-windows if fboundp.
;; 1996/07/01 dadams
;;     buffer-menu: Prefix arg =< 0 sorts alphabetically now.
;; 1996/07/01 dadams
;;     Added redefinition of Buffer-menu-select.
;; 1996/04/26 dadams
;;     Put escaped newlines on long-line strings.
;; 1996/01/25 dadams
;;     1. kill-buffer -> kill-buffer-and-its-windows.
;;     2. Buffer-menu-mode: Put mouse-face on whole buffer line.
;; 1996/01/12 dadams
;;     Redefined buffer-menu.
;; 1996/01/09 dadams
;;     kill-buffer -> kill-buffer-delete-frames
;; 1995/12/28 dadams
;;     Buffer-menu-mouse-3-menu: Corrected by adding temp local var.
;; 1995/12/14 dadams
;;     1. Highlight buffer line when mouse-3 menu displayed.
;;        Added Buffer-menu-overlay.
;;     2. mouse-3 menu is reduced to non-buffer-specifics when not on a buffer line.
;; 1995/12/13 dadams
;;     Added Buffer-menu-mouse-3-menu.  Use it instead of Buffer-menu-mouse-3-map.
;; 1995/12/13 dadams
;;     1) Put back Buffer-menu-select, in place of Buffer-menu-mouse-other-window.
;;     2) Added menu on mouse-3: Added: Buffer-menu-mouse-3-map,
;;        Buffer-menu-mouse-execute, Buffer-menu-mouse-modified,
;;        Buffer-menu-mouse-delete, Buffer-menu-mouse-save,
;;        Buffer-menu-mouse-unmark.
;; 1995/09/11 dadams
;;     Buffer-menu-mode: Added bindings list to doc string.
;; 1995/09/11 dadams
;;     Redefined Buffer-menu-execute: deletes frame w/ kill.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

 ;; Cannot do (require 'buff-menu), because `buff-menu.el' does no `provide'.
 ;; Don't want to do a (load-library "buff-menu") either, because it wouldn't
 ;; allow doing (eval-after-load "buff-menu" '(progn (require 'buff-menu+)))

(eval-when-compile (require 'cl-lib)) ;; case, (plus, for Emacs 20: push, pop, dolist,
                                  ;;        and, for Emacs <20: cadr, when, unless)

(require 'misc-fns nil t) ;; (no error if not found): undefine-killer-commands
(require 'misc-cmds nil t) ;; (no error if not found): kill-buffer-and-its-windows
(require 'fit-frame nil t) ;; (no error if not found): fit-frame


;; To quiet the byte compiler:
(defvar Buffer-menu-buffer+size-width)
(defvar Buffer-menu-file-flag)
(defvar Buffer-menu-files-only)
(defvar Buffer-menu-mode-flag)
(defvar Buffer-menu-mode-width)
(defvar Buffer-menu-sort-column)
(defvar Buffer-menu-sort-button-map)
(defvar Buffer-menu-time-flag)
(defvar Buffer-menu-time-format)
(defvar Buffer-menu-use-frame-buffer-list)
(defvar Buffer-menu-use-header-line)
(defvar frame-bufs-mode)                ; Defined in `frame-bufs.el'
(defvar frame-bufs-full-list)           ; Defined in `frame-bufs.el'
(defvar header-line-format)
(defvar Info-current-file)
(defvar Info-current-node)

;;;;;;;;;;;;;;;;;;;;;;;;;;;


(unless (> emacs-major-version 21)
  (defgroup Buffer-Menu-Plus nil
    "Enhancements to the buffer menu."
    :link `(url-link :tag "Send Bug Report"
            ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
buff-menu+.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
    :link '(url-link :tag "Other Libraries by Drew"
            "http://www.emacswiki.org/DrewsElispLibraries")
    :link '(url-link :tag "Download"
            "http://www.emacswiki.org/buff-menu+.el")
    :link '(url-link :tag "Description"
            "http://www.emacswiki.org/BufferMenu#BufferMenuPlus")
    :link '(emacs-commentary-link :tag "Commentary" "buff-menu+")
    :group 'tools :group 'convenience))

(when (> emacs-major-version 21)
  (defgroup Buffer-Menu-Plus nil
    "Enhancements to the buffer menu."
    :link `(url-link :tag "Send Bug Report"
            ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
buff-menu+.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
    :link '(url-link :tag "Other Libraries by Drew"
            "http://www.emacswiki.org/DrewsElispLibraries")
    :link '(url-link :tag "Download"
            "http://www.emacswiki.org/buff-menu+.el")
    :link '(url-link :tag "Description"
            "http://www.emacswiki.org/BufferMenu#BufferMenuPlus")
    :link '(emacs-commentary-link :tag "Commentary" "buff-menu+")
    :group 'Buffer-menu :group 'tools :group 'convenience)

  (defvar Buffer-menu-buffer+size-computed-width 0
    "Max width of all buffer names, plus 4 for initial `CRM '.")


  (define-key Buffer-menu-mode-map "-" 'Buffer-menu-decrease-max-buffer+size)

  (defun Buffer-menu-decrease-max-buffer+size () ; Bound to `-'.
    "Decrease option `Buffer-menu-buffer+size-width' by one."
    (interactive)
    (let ((orig  Buffer-menu-buffer+size-width))
      (condition-case nil
          (progn
            (setq Buffer-menu-buffer+size-width  (1- Buffer-menu-buffer+size-width))
            (buffer-menu)
            (message "New max width: %s" Buffer-menu-buffer+size-width))
        (error (progn (setq Buffer-menu-buffer+size-width  orig)
                      (buffer-menu)
                      (error "Cannot decrease further"))))))


  (define-key Buffer-menu-mode-map "+" 'Buffer-menu-increase-max-buffer+size)

  (defun Buffer-menu-increase-max-buffer+size () ; Bound to `+'.
    "Increase option `Buffer-menu-buffer+size-width' by one."
    (interactive)
    (when (> (1+ Buffer-menu-buffer+size-width) 150) (error "Cannot increase further"))
    (setq Buffer-menu-buffer+size-width  (1+ Buffer-menu-buffer+size-width))
    (buffer-menu)
    (message "New max width: %s" Buffer-menu-buffer+size-width))


  (define-key Buffer-menu-mode-map "\C-\M-t" 'Buffer-menu-toggle-time-format)

  (defun Buffer-menu-toggle-time-format () ; Bound to `C-M-t'.
    "Toggle `Buffer-menu-time-format' and redisplay Buffer Menu."
    (interactive)
    (buffer-menu-set-default-value 'Buffer-menu-time-format
                                   (if (eq 'short Buffer-menu-time-format) 'long 'short))
    (buffer-menu))


  (define-key Buffer-menu-mode-map "\M-t" 'Buffer-menu-toggle-time-column)

  (defun Buffer-menu-toggle-time-column () ; Bound to `M-t'.
    "Toggle `Buffer-menu-time-flag' and redisplay Buffer Menu."
    (interactive)
    (buffer-menu-set-default-value 'Buffer-menu-time-flag (not Buffer-menu-time-flag))
    (buffer-menu))


  (define-key Buffer-menu-mode-map "\M-m" 'Buffer-menu-toggle-mode-column)

  (defun Buffer-menu-toggle-mode-column () ; Bound to `M-m'.
    "Toggle `Buffer-menu-mode-flag' and redisplay Buffer Menu."
    (interactive)
    (buffer-menu-set-default-value 'Buffer-menu-mode-flag (not Buffer-menu-mode-flag))
    (buffer-menu))


  (define-key Buffer-menu-mode-map "\M-f" 'Buffer-menu-toggle-file-column)

  (defun Buffer-menu-toggle-file-column () ; Bound to `M-f'.
    "Toggle `Buffer-menu-file-flag' and redisplay Buffer Menu."
    (interactive)
    (buffer-menu-set-default-value 'Buffer-menu-file-flag (not Buffer-menu-file-flag))
    (buffer-menu))

  (defun buffer-menu-set-default-value (symb val)
    "Set default value of SYMB to VAL.
Update `buffer-menu-font-lock-keywords' accordingly."
    (set-default symb val)
    (setq buffer-menu-font-lock-keywords  (buffer-menu-font-lock-keywords)))

  (defun buffer-menu-font-lock-keywords ()
    "Returns the list of font lock keywords for the buffer menu."
    (let* ((frame-bufs-p       (and (boundp 'frame-bufs-mode) frame-bufs-mode))
           (bit-column-header  (if frame-bufs-p "CRM[ F].*" "CRM.*"))
           (bits               (if frame-bufs-p "....." "...."))
           (shortbits          (if frame-bufs-p "...." "...")))
      (list
       (list (concat "^\\(" bit-column-header "\\)") 1 'buffer-menu-headings) ; CRM or CRMF
       (list (concat "^" bits
                     "\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+\\(.* \\(AM\\|PM\\)\\)?\\([^/\n]+\\)")
             (list 1 'buffer-menu-buffer-name)) ; Default buffer name
       (cond (Buffer-menu-mode-flag     ; Directory buffer name
              (list (concat "^" bits "\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+[a-zA-Z :0-9]*[ \t]+Dired")
                    1 'buffer-menu-directory-buffer t t))
             (Buffer-menu-file-flag
              (list (concat "^" bits "\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+[^/\n]+[ \t\n]\
\\(\\([~]\\|\\([a-zA-Z]:\\)\\)?/.*/\\)$")
                    1 'buffer-menu-directory-buffer t t))
             ;; We can't show that it's a directory, because we have no way of knowing that
             (t (list "")))
       (list (concat "^" bits
                     "\\(\\*.*[^ \t\n][[*]\\(<[0-9]+>\\)?\\)[ \t]+") ; Star buffer (e.g. *scratch*)
             1 'buffer-menu-star-buffer t t)
       ;; Time & Mode
       (cond ((and Buffer-menu-time-flag Buffer-menu-mode-flag (eq 'short Buffer-menu-time-format))
              (list "^.*[ \t][0-9]+[ \t]+\\([0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\)?\\([^\n]+\\)"
                    (list 1 'buffer-menu-time t t) (list 2 'buffer-menu-mode t t)))
             ((and Buffer-menu-time-flag Buffer-menu-mode-flag)
              (list "^.*[ \t][0-9]+[ \t]+\\(.* \\(AM\\|PM\\)\\)?\\([^\n]+\\)"
                    (list 1 'buffer-menu-time t t) (list 3 'buffer-menu-mode t t)))
             (Buffer-menu-time-flag
              (if (eq 'short Buffer-menu-time-format)
                  (list "^.*[ \t][0-9]+[ \t]+\\([0-2][0-9]:[0-5][0-9]:[0-5][0-9]\\)?"
                        (list 1 'buffer-menu-time t t))
                (list "^.*[ \t][0-9]+[ \t]+\\(.* \\(AM\\|PM\\)\\)?" (list 1 'buffer-menu-time t t))))
             (Buffer-menu-mode-flag
              (list "^.*[ \t][0-9]+[ \t]+\\([^/\n]+\\)" 1 'buffer-menu-mode t t))
             (t ""))
       (list "^.*[ \t]\\([0-9]+\\)\\(  \\|[\n]\\)" 1 'buffer-menu-size t t) ; Size
       (if Buffer-menu-file-flag
           (list "^.*[ \t][0-9]+[ \t]+[^/\n]+[ \t\n]\
\\(\\(\\([~]\\|\\([a-zA-Z]:\\)\\)*/.*\\)\\|([^ \t]+).*\\)$" ; File name of Info file + node
                 1 'buffer-menu-file-name t t)
         "")
       (list "^\\([.]\\)" 1 'buffer-menu-current-buffer t t) ; Current buffer mark (.)
       (list "^\\(>\\)" 1 'buffer-menu-view-mark t t) ; To view mark (>)
       (list (concat "^>" shortbits
                     "\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+\\(.* \\(AM\\|PM\\)\\)?\\([^/\n]+\\)")
             (list 1 'buffer-menu-marked-buffer 'prepend t)) ; Buffer name when marked (>)
       (list (concat "^D" shortbits
                     "\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+\\(.* \\(AM\\|PM\\)\\)?\\([^/\n]+\\)")
             (list 1 'buffer-menu-flagged-buffer t t)) ; Buffer name when flagged (D)
       (list "^\\(D\\)" 1 'buffer-menu-delete-mark t t) ; Deletion flag (D)
       (list "^..\\(S\\)" 1 'buffer-menu-save-mark t t) ; Save flag (S)
       (list "^..\\([*]\\)" 1 'buffer-menu-modified-mark t t) ; Buffer-modified-p (*)
       (list "^.\\(%\\)" 1 'buffer-menu-read-only-mark t t)))) ; Read-only-p (%)


  (defcustom Buffer-menu-time-format 'short
    "*Format for Time column of buffer menu."
    :type '(choice
            (const :tag "Short: hh:mm:ss"          short)
            (const :tag "Long: day hh:mm:ss AM/PM" long))
    :group 'Buffer-Menu-Plus)

  (defcustom Buffer-menu-time-flag t
    "*Non-nil means Buffer Menu displays the last time the buffer was displayed."
    :type 'boolean :group 'Buffer-Menu-Plus
    :initialize 'custom-initialize-default
    :set 'buffer-menu-set-default-value)

  (defcustom Buffer-menu-mode-flag t
    "*Non-nil means Buffer Menu displays the buffer's mode."
    :type 'boolean :group 'Buffer-Menu-Plus
    :initialize 'custom-initialize-default
    :set 'buffer-menu-set-default-value)

  (defcustom Buffer-menu-file-flag t
    "*Non-nil means Buffer Menu displays the buffer's file."
    :type 'boolean :group 'Buffer-Menu-Plus
    :initialize 'custom-initialize-default
    :set 'buffer-menu-set-default-value)


  ;; REPLACE ORIGINAL in `buff-menu.el'.
  ;;
  ;; A user option now.  It must be numeric.  Initial value is 1, not nil.
  ;;
  (defcustom Buffer-menu-sort-column 1
    "*Sorted by (1) visit, (2) buffer, (3) size, (4) time, (5) mode, (6) file.
Click a column heading to sort by that field and update this option."
    :type '(choice
            (const :tag "Sort by time of last visit" 1)
            (const :tag "Sort by buffer name"        2)
            (const :tag "Sort by buffer size"        3)
            (const :tag "Sort by time of last use"   4)
            (const :tag "Sort by file name"          5))
    :group 'Buffer-Menu-Plus)


  ;; This is needed because `buff-menu.el' is preloaded and set to nil.
  (setq Buffer-menu-sort-column  (or Buffer-menu-sort-column 1))


  ;; REPLACE ORIGINAL in `buff-menu.el'.
  ;;
  ;; Use `Buffer-menu-buffer+size-computed-width', not `Buffer-menu-buffer+size-width'.
  ;;
  (defun Buffer-menu-buffer+size (name size &optional name-props size-props)
    (if (> (+ (length name) (length size) 1) Buffer-menu-buffer+size-computed-width)
        (setq name  (if (string-match "<[0-9]+>$" name)
                        (concat (substring name 0 (- Buffer-menu-buffer+size-computed-width
                                                     (max (length size) 3)
                                                     (match-end 0)
                                                     (- (match-beginning 0))
                                                     2))
                                "["     ; Cut-off character.
                                (match-string 0 name))
                      (concat (substring name 0 (- Buffer-menu-buffer+size-computed-width
                                                   (max (length size) 3)
                                                   2))
                              "[")))    ; Cut-off character.
      (setq name  (copy-sequence name))) ; Don't put properties on (buffer-name).
    (when name-props (add-text-properties 0 (length name) name-props name))
    (when size-props (add-text-properties 0 (length size) size-props size))
    (concat name (make-string (- Buffer-menu-buffer+size-computed-width
                                 (length name)
                                 (length size))
                              ?\ )     ; ?\  instead of ?\s, so can be byte-compiled in Emacs 20.
            size)))



;; Emacs 24.3+ sets the default value to nil.
(unless (and (boundp 'Buffer-menu-buffer+size-width)  Buffer-menu-buffer+size-width)
  (setq Buffer-menu-buffer+size-width  26))




;;; Faces used to fontify buffer.

(defface buffer-menu-headings
    '((((background dark))
       (:foreground "#00005A5AFFFF" :background "#FFFF9B9BFFFF")) ; ~ blue, pink
      (t (:foreground "Orange" :background "DarkGreen")))
  "*Face used for headings in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-headings 'buffer-menu-headings)

(defface buffer-menu-current-buffer
    '((((background dark)) (:foreground "Cyan" :background "#808000002B2B")) ; dark red brown
      (t (:foreground "Red" :background "Aquamarine")))
  "*Face used for current buffer mark in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-current-buffer 'buffer-menu-current-buffer)

(defface buffer-menu-view-mark
    '((((background dark)) (:foreground "Cyan" :background "#808000002B2B")) ; dark red brown
      (t (:foreground "Red" :background "Aquamarine")))
  "*Face used for buffers to view mark (>) in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-view-mark 'buffer-menu-view-mark)

(defface buffer-menu-star-buffer
    '((((background dark)) (:foreground "#FFFFFFFF7474")) ; ~ light yellow
      (t (:foreground "DarkBlue")))
  "*Face used for buffers named \"*...*\"in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)
(defvar buffer-menu-star-buffer 'buffer-menu-star-buffer)

(defface buffer-menu-directory-buffer
    '((((background dark)) (:foreground "Yellow" :background "#525227271919")) ; ~ dark brown
      (t (:foreground "Blue" :background "LightBlue")))
  "*Face used for directory buffers in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)
(defvar buffer-menu-directory-buffer 'buffer-menu-directory-buffer)

(defface buffer-menu-marked-buffer
    '((t (:underline t)))
  "*Face used for buffers marked with `>' in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)
(defvar buffer-menu-marked-buffer 'buffer-menu-marked-buffer)

(defface buffer-menu-flagged-buffer
    '((((background dark)) (:foreground "Cyan"))
      (t (:foreground "Red")))
  "*Face used for buffers marked with `D' in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)
(defvar buffer-menu-flagged-buffer 'buffer-menu-flagged-buffer)

(defface buffer-menu-delete-mark
    '((((background dark)) (:foreground "#808000002B2B" :background "Cyan"))
      (t (:foreground "Aquamarine" :background "Red")))
  "*Face used for buffers to delete mark (D) in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-delete-mark 'buffer-menu-delete-mark)

(defface buffer-menu-save-mark
    '((((background dark)) (:foreground "#00005A5AFFFF" :background "Yellow")) ; ~blue
      (t (:foreground "Orange" :background "Blue")))
  "*Face used for buffers to save mark (S) in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-save-mark 'buffer-menu-save-mark)

(defface buffer-menu-modified-mark
    '((((background dark)) (:foreground "#00007373FFFF")) ; ~ blue
      (t (:foreground "DarkOrange")))
  "*Face used for modified buffers mark (*) in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-modified-mark 'buffer-menu-modified-mark)

(defface buffer-menu-read-only-mark
    '((((background dark)) (:foreground "Blue"))
      (t (:foreground "Yellow")))
  "*Face used for read-only buffers mark (%) in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-read-only-mark 'buffer-menu-read-only-mark)

(defface buffer-menu-buffer-name
    '((((background dark)) (:foreground "Yellow"))
      (t (:foreground "Blue")))
  "*Face used for buffer names in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-buffer-name 'buffer-menu-buffer-name)
;; Redefine standard face `Buffer-menu-buffer' as `buffer-menu-buffer-name'.
(put 'Buffer-menu-buffer 'face-alias 'buffer-menu-buffer-name)

(defface buffer-menu-mode
    '((((background dark)) (:foreground "#FFFF9B9BFFFF")) ; ~ pink
      (t (:foreground "DarkGreen")))
  "*Face used for buffer modes in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-mode 'buffer-menu-mode)

(defface buffer-menu-size
    '((((background dark)) (:foreground "#7474FFFFFFFF")) ; ~ light cyan
      (t (:foreground "DarkRed")))
  "*Face used for buffer sizes in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-size 'buffer-menu-size)

(defface buffer-menu-time
    '((((background dark)) (:foreground "#74749A9AF7F7")) ; ~ light blue
      (t (:foreground "DarkGoldenrod4")))
  "*Face used for buffer time in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-time 'buffer-menu-time)

(defface buffer-menu-file-name
    '((((background dark)) (:foreground "#7474FFFF7474")) ; ~ light green
      (t (:foreground "DarkMagenta")))
  "*Face used for file names in *Buffer List* buffer."
  :group 'Buffer-Menu-Plus
  :group 'font-lock-highlighting-faces)
(defvar buffer-menu-file-name 'buffer-menu-file-name)

(if (> emacs-major-version 21)
    (defvar buffer-menu-font-lock-keywords (buffer-menu-font-lock-keywords) ; Emacs 22
      "*Expressions to highlight in Buffer Menu mode.")
  (defvar buffer-menu-font-lock-keywords ; Emacs 20, 21
    (list
     (list "^\\( M.*\\)" 1 'buffer-menu-headings)
     (list "^....\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+" ; Default buffer name
           1 'buffer-menu-buffer-name)
     (list "^....\\(.*[^ \t\n]\\)[ \t]+[0-9]+[ \t]+[a-zA-Z :0-9]*[ \t]+Dired"
           1 'buffer-menu-directory-buffer t t) ; Directory buffer name
     (list "^....\\(\\*.*[^ \t\n]\\*\\(<[0-9]+>\\)?\\)[ \t]+" ; Star buffer name
           1 'buffer-menu-star-buffer t t)
     (list "^.*[ \t][0-9]+[ \t]+\\([^/\n]+\\)" 1 'buffer-menu-mode t t) ; Mode
     (list "^.*[ \t]\\([0-9]+\\)[ \t]+[^/\n]+" 1 'buffer-menu-size t t) ; Size
     (list "^.*[ \t][0-9]+[ \t]+[^/\n]+[ \t\n]\\(\\([~]\\|\\([a-zA-Z]:\\)\\)*/.*\\)$"
           1 'buffer-menu-file-name t t) ; File name
     (list "^\\([.]\\)" 1 'buffer-menu-current-buffer t t) ; Current buffer mark (.)
     (list "^\\(>\\)" 1 'buffer-menu-view-mark t t) ; To view mark (>)
     (list "^>...\\(.*[^ \t\n]\\)[ \t\]+[0-9]" ; Buffer name when marked (>)
           1 'buffer-menu-marked-buffer 'prepend t)
     (list "^D...\\(.*[^ \t\n]\\)[ \t\]+[0-9]" ; Buffer name when flagged (D)
           1 'buffer-menu-flagged-buffer t t)
     (list "^\\(D\\)" 1 'buffer-menu-delete-mark t t) ; Deletion flag (D)
     (list "^.\\(S\\)" 1 'buffer-menu-save-mark t t) ; Save flag (S)
     (list "^.\\([*]\\)" 1 'buffer-menu-modified-mark t t) ; Buffer-modified-p (*)
     (list "^..\\(%\\)" 1 'buffer-menu-read-only-mark t t)) ; Read-only-p (%)
    "*Expressions to highlight in Buffer Menu mode."))


;; Undefine some bindings that would try to modify a buffer-menu buffer. Their key sequences
;; will then appear to the user as available for local (Buffer Menu) definition.
(when (fboundp 'undefine-killer-commands) (undefine-killer-commands Buffer-menu-mode-map))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; Protect `Buffer-menu-files-only' with boundp (for Emacs 20).
;;
(defun Buffer-menu-revert-function (ignore1 ignore2)
  (unless (eq buffer-undo-list t) (setq buffer-undo-list  ()))
  ;; We can not use save-excursion here.  The buffer gets erased.
  (let ((opoint            (point))
        (eobp              (eobp))
        (ocol              (current-column))
        (oline             (progn (move-to-column Buffer-menu-buffer-column)
                                  (get-text-property (point) 'buffer)))
        (prop              (point-min))
        ;; Do not make undo records for the reversion.
        (buffer-undo-list  t))
    ;; We can be called by Auto Revert Mode with the "*Buffer Menu*"
    ;; temporarily the current buffer.  Make sure that the
    ;; interactively current buffer is correctly identified with a `.'
    ;; by `list-buffers-noselect'.
    (with-current-buffer (window-buffer)
      (list-buffers-noselect (and (boundp 'Buffer-menu-files-only) Buffer-menu-files-only)))
    (if oline
        (while (setq prop  (next-single-property-change prop 'buffer))
          (when (eq (get-text-property prop 'buffer) oline)
            (goto-char prop)
            (move-to-column ocol)))
      (goto-char (if eobp (point-max) opoint)))))

(defun Buffer-menu-fontify-and-adjust-frame ()
  "Use for `Buffer-menu-mode-hook'.  Fontify, fit and raise frame."
  (with-current-buffer (get-buffer-create "*Buffer List*")
    (when (< emacs-major-version 21) (make-local-variable 'font-lock-defaults))
    (setq font-lock-defaults  '(buffer-menu-font-lock-keywords t))
    (turn-on-font-lock)
    (when (get-buffer-window (current-buffer) 'visible)
      (save-window-excursion
        (select-window (get-buffer-window (current-buffer) 'visible))
        (when (and (fboundp 'fit-frame) (one-window-p t)) (fit-frame))
        (raise-frame)))
    ;; Refresh `font-lock-keywords' from `font-lock-defaults'
    (when (fboundp 'font-lock-refresh-defaults) (font-lock-refresh-defaults))))

;; Fontify buffer, then fit and raise its frame.  (In Emacs 23 they capitalized the name.)
(if (> emacs-major-version 22)
    (add-hook 'Buffer-menu-mode-hook 'Buffer-menu-fontify-and-adjust-frame)
  (add-hook 'buffer-menu-mode-hook 'Buffer-menu-fontify-and-adjust-frame))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; Treat Emacs 20 too.
;;
(defun Buffer-menu-beginning ()
  (goto-char (point-min))
  (unless (and (boundp 'Buffer-menu-use-header-line) Buffer-menu-use-header-line)
    (forward-line)))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;;   1. Different help message.
;;   2. Prefix ARG =< 0 now means list all buffers alphabetically.
;;      (It used to mean the same as ARG > 0.)
;;      Prefix ARG >= 0 means list just file buffers.
;;   3. Use `pop-to-buffer' instead of `switch-to-buffer'.
;;      This means that the buffer menu is shown in a different window.
;;      If you prefer to show it in the current window, then just do this:
;;          (add-to-list 'same-window-buffer-names "*Buffer List*")
;;
;;;###autoload
(defun buffer-menu (&optional arg)
  "Show a menu to let you save, delete or select buffers.
By default (no or null prefix arg), the buffers are listed in order of
last access (visit).  With a non-nil prefix ARG:
  ARG >= 0  means only buffers visiting files are listed.
  ARG <= 0  means the buffers are listed alphabetically.
 (ARG = 0   means only buffers visiting files, listed alphabetically.)

Type `?' in buffer \"*Buffer List*\" for more information.
Type `q' there to quit the buffer menu."
  (interactive "P")
  (let ((num-arg  (prefix-numeric-value arg)))
    (if (and arg (< num-arg 0)) (list-buffers) (list-buffers arg))
    (let ((newpoint  (save-excursion (set-buffer "*Buffer List*") (point))))
      (pop-to-buffer "*Buffer List*")
      (when (and arg (not (> num-arg 0))) ; Sort lines after header.
        (let ((buffer-read-only  nil))
          (goto-char (point-min))
          (unless Buffer-menu-use-header-line (forward-line 2)) ; Header.
          (forward-char Buffer-menu-buffer-column)
          (sort-columns nil (point) (save-excursion (goto-char (point-max))
                                                    (when (bolp) (backward-char 1))
                                                    (point)))))
      (goto-char newpoint)))
  (message "Help: ?;   Menu: mouse-3;   Show: v;   Mark: u,m,s,d;   \
Save/Delete: x;   Misc: g,~,%%,t"))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; 1. Doc string reflects new bindings.
;; 2. mouse-face on whole line, not just buffer name.
;; 3. Compatible with Emacs prior to Emacs 22 also.
;;
(when (< emacs-major-version 23)
  (defun Buffer-menu-mode ()
    "Major mode for editing a list of buffers.
Each line describes one of the buffers in Emacs.
In Buffer menu mode, chars do not insert themselves, but are commands.
\\<Buffer-menu-mode-map>
\(\"Current line\" here is the line of the text cursor or the mouse.)


Display Options
---------------
Click `mouse-3' for a context-sensitive menu of buffer operations.

These features are available for Emacs 22 and later:

,* You can click a column heading to sort by that column.  Clicking
  again reverses the sort direction.  The current sort column is
  indicated by an underlined or overlined column heading.  Sorting by
  column `CRM' depends on the value of option
  `Buffer-menu-use-frame-buffer-list'.

,* You can resize the Buffer and Size columns using `+' and `-'.

,* You can toggle showing columns Time, Mode, and File using
  `\\[Buffer-menu-toggle-time-column]',
  `\\[Buffer-menu-toggle-mode-column]', and
  `\\[Buffer-menu-toggle-file-column]'.
  You can toggle the Time format using
  `\\[Buffer-menu-toggle-time-format]]'.
  (These re only for Emacs 21 and later.)

Column `CRM':
 `C' shows `>' if you have marked the buffer to be displayed,
           `D' if you have marked it for deletion, and
           `.' for the buffer from which you came (current).
 `R' shows `%' if the buffer is read-only.
 `M' shows `*' if the buffer is modified, and
           `S' if you have marked it for saving.

The other columns are the Buffer name, its Size in characters, the
last Time the buffer was displayed, its major Mode, and the visited
File name (if any).

Displaying Buffers
------------------
\\[Buffer-menu-mouse-select], \\[Buffer-menu-select], \\[Buffer-menu-this-window] -- \
Select current line's buffer.
\\[Buffer-menu-mark]\t-- Mark current line's buffer `>' to be displayed (via \
`\\[Buffer-menu-select]').
\\[Buffer-menu-select]\t-- Show buffers marked `>'.  Select current line's \
buffer.
\\[Buffer-menu-1-window]\t-- Select current line's buffer (only) in a \
full-frame window.
\\[Buffer-menu-2-window]\t-- Select current line's buffer in one window.
\t   Display previous buffer in a second window.
\\[Buffer-menu-switch-other-window]\t-- Display current line's buffer in \
another window.  No select.
\\[Buffer-menu-view]\t-- select current line's buffer, but in view-mode.
\\[Buffer-menu-view-other-window]\t-- select that buffer in
  another window, in view-mode.
\\[Buffer-menu-toggle-files-only]\t-- toggle whether to display only file buffers.

Marking/Unmarking Buffers to be Saved/Deleted
---------------------------------------------
\\[Buffer-menu-save]\t-- Mark current line's buffer `S' to be saved.    \
Cursor down.
\\[Buffer-menu-delete]\t-- Mark current line's buffer `D' to be deleted.  \
Cursor down.
\\[Buffer-menu-delete-backwards]\t-- Mark current line's buffer `D' to be \
deleted.  Cursor up.
\\[Buffer-menu-unmark]\t-- Unmark current line.  Cursor down. (Prefix arg: \
Cursor up.)
\\[Buffer-menu-backup-unmark]\t-- Cursor up, then unmark line.

Saving/Deleting Buffers
-----------------------
\\[Buffer-menu-execute]\t-- Save / Delete marked buffers (marks `S', `D').
\\[Buffer-menu-delete-flagged]\t-- Delete all buffers marked `D', even if modified.

Miscellaneous
-------------
\\[Buffer-menu-revert]\t-- Update the list of buffers.
\\[Buffer-menu-not-modified]\t-- Clear modified-flag on current line's buffer.
\\[Buffer-menu-toggle-read-only]\t-- Toggle read-only status of current \
line's buffer.
\\[Buffer-menu-visit-tags-table]\t-- `visit-tags-table' using current line's \
buffer.


Bindings in Buffer Menu mode:
----------------------------

\\{Buffer-menu-mode-map}"
    (kill-all-local-variables)
    (use-local-map Buffer-menu-mode-map)
    (setq major-mode  'Buffer-menu-mode
          mode-name   "Buffer Menu")
    (save-excursion
      (goto-char (point-min))
      (when (< emacs-major-version 20)  ; Hardcoded to 4, starting in Emacs 20
        (search-forward "Buffer")
        (backward-word 1)
        (setq Buffer-menu-buffer-column  (current-column)))
      (when (or (not (boundp 'Buffer-menu-use-header-line)) (not Buffer-menu-use-header-line))
        (forward-line 2))               ; First two lines are title, unless use header line.
      (while (not (eobp))
        (put-text-property (point) (line-end-position) 'mouse-face 'highlight)
        (forward-line 1)))
    (set (make-local-variable 'revert-buffer-function) 'Buffer-menu-revert-function)
    (when (> emacs-major-version 21)
      (set (make-local-variable 'buffer-stale-function) #'(lambda (&optional noconfirm) 'fast)))
    (setq truncate-lines    t
          buffer-read-only  t)
    (if (> emacs-major-version 21)
        (if (> emacs-major-version 22)  ; Capitalized in Emacs 23.
            (run-mode-hooks 'Buffer-menu-mode-hook)
          (run-mode-hooks 'buffer-menu-mode-hook))
      (run-hooks 'buffer-menu-mode-hook))))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; 1. Doc string reflects new bindings.
;; 2. mouse-face on whole line, not just buffer name.
;;
;; NOTE: If you byte-compile this file with Emacs 20 and then use the byte-compiled result,
;; `buff-menu+.elc', in Emacs 23, then keys such as `q' and `g' will not be defined.  It's best
;; to byte-compile `buff-menu+.el' with the same Emacs version where you use `buff-menu+.elc'.
;;
(when (> emacs-major-version 22)
  ;; Buffer Menu mode is suitable only for specially formatted data.
  (put 'Buffer-menu-mode 'mode-class 'special)

  (define-derived-mode Buffer-menu-mode special-mode "Buffer Menu"
    "Major mode for editing a list of buffers.
Each line describes one of the buffers in Emacs.
In Buffer menu mode, chars do not insert themselves, but are commands.
\\<Buffer-menu-mode-map>
\(\"Current line\" here is the line of the text cursor or the mouse.)


Display Options
---------------
Click `mouse-3' for a context-sensitive menu of buffer operations.

These features are available for Emacs 22 and later:

,* You can click a column heading to sort by that column.  Clicking
  again reverses the sort direction.  The current sort column is
  indicated by an underlined or overlined column heading.  Sorting by
  column `CRM' depends on the value of option
  `Buffer-menu-use-frame-buffer-list'.

,* You can resize the Buffer and Size columns using `+' and `-'.

,* You can toggle showing columns Time, Mode, and File using `\\[Buffer-menu-toggle-time-column]',
  `\\[Buffer-menu-toggle-mode-column]', and `\\[Buffer-menu-toggle-file-column]'.  You can toggle \
the Time format using `\\[Buffer-menu-toggle-time-format]'.

Column `CRM':
 `C' shows `>' if you have marked the buffer to be displayed,
           `D' if you have marked it for deletion, and
           `.' for the buffer from which you came (current).
 `R' shows `%' if the buffer is read-only.
 `M' shows `*' if the buffer is modified, and
           `S' if you have marked it for saving.

The other columns are the Buffer name, its Size in characters, the
last Time the buffer was displayed, its major Mode, and the visited
File name (if any).

Displaying Buffers
------------------
\\[Buffer-menu-mouse-select], \\[Buffer-menu-select], \\[Buffer-menu-this-window], \
\\[Buffer-menu-other-window] -- Select current line's buffer.
\\[Buffer-menu-mark]\t-- Mark current line's buffer `>' to be displayed (via \
`\\[Buffer-menu-select]').
\\[Buffer-menu-select]\t-- Show buffers marked `>'.  Select current line's \
buffer.
\\[Buffer-menu-1-window]\t-- Select current line's buffer (only) in a \
full-frame window.
\\[Buffer-menu-2-window]\t-- Select current line's buffer in one window.
\t   Display previous buffer in a second window.
\\[Buffer-menu-switch-other-window]\t-- Display current line's buffer in \
another window.  No select.
\\[Buffer-menu-view]\t-- select current line's buffer, but in view-mode.
\\[Buffer-menu-view-other-window]\t-- select that buffer in
  another window, in view-mode.
\\[Buffer-menu-toggle-files-only]\t-- toggle whether to display only file & Dired buffers.

Marking/Unmarking Buffers to be Saved/Deleted
---------------------------------------------
\\[Buffer-menu-save]\t-- Mark current line's buffer `S' to be saved.    \
Cursor down.
\\[Buffer-menu-delete]\t-- Mark current line's buffer `D' to be deleted.  \
Cursor down.
\\[Buffer-menu-delete-backwards]\t-- Mark current line's buffer `D' to be \
deleted.  Cursor up.
\\[Buffer-menu-unmark]\t-- Unmark current line.  Cursor down. (Prefix arg: \
Cursor up.)
\\[Buffer-menu-backup-unmark]\t-- Cursor up, then unmark line.

Saving/Deleting Buffers
-----------------------
\\[Buffer-menu-execute]\t-- Save / Delete marked buffers (marks `S', `D').
\\[Buffer-menu-delete-flagged]\t-- Delete all buffers marked `D', even if modified.

Miscellaneous
-------------
\\[revert-buffer]\t-- Update the list of buffers.
\\[Buffer-menu-not-modified]\t-- Clear modified-flag on current line's buffer.
\\[Buffer-menu-toggle-read-only]\t-- Toggle read-only status of current \
line's buffer.
\\[Buffer-menu-visit-tags-table]\t-- `visit-tags-table' using current line's \
buffer.
\\[Buffer-menu-isearch-buffers] -- Do incremental search in the marked buffers.
\\[Buffer-menu-isearch-buffers-regexp] -- Isearch for regexp in the marked buffers.
\\[Buffer-menu-bury] -- bury the buffer listed on this line.


Bindings in Buffer Menu mode:
----------------------------

\\{Buffer-menu-mode-map}"
    (save-excursion
      (let ((inhibit-read-only  t))
        (goto-char (point-min))
        (when (or (not (boundp 'Buffer-menu-use-header-line)) (not Buffer-menu-use-header-line))
          (forward-line 2))             ; First two lines are title, unless use header line.
        (while (not (eobp))
          (put-text-property (point) (line-end-position) 'mouse-face 'highlight)
          (forward-line 1))))
    (set (make-local-variable 'revert-buffer-function) 'Buffer-menu-revert-function)
    (set (make-local-variable 'buffer-stale-function) #'(lambda (&optional noconfirm) 'fast))
    (setq truncate-lines    t
          buffer-read-only  t)))


(define-key Buffer-menu-mode-map "\C-\M-x" 'Buffer-menu-delete-flagged)

;;;###autoload
(defun Buffer-menu-delete-flagged ()    ; Bound to `C-M-x'.
  "Delete all buffers marked `D', even if they have been modified.
If there are any file buffers that have been modified since the last
save, then you must confirm the deletion of all at once.

You can mark a buffer for deletion (`D') using command `\\<Buffer-menu-mode-map>\
\\[Buffer-menu-delete]'."
  (interactive)
  (save-excursion
    (Buffer-menu-beginning)
    (let ((buff-menu-buffer  (current-buffer))
          (buffer-read-only  nil)
          (bufs              ())
          (mod-bufs          ())
          (kill-fn           (if (fboundp 'kill-buffer-and-its-windows)
                                 #'kill-buffer-and-its-windows
                               #'kill-buffer))
          buf)
      (while (re-search-forward "^D" nil t)
        (forward-char -1)
        (setq buf  (Buffer-menu-buffer nil))
        (unless (or (eq buf nil) (eq buf buff-menu-buffer))
          (push buf bufs)
          (when (and (buffer-file-name buf) (buffer-modified-p buf)) (push buf mod-bufs)))
        (forward-line 1))
      (unless bufs (error "No buffers flagged for deletion"))
      (when (and mod-bufs (let ((visible-bell  t)) (ding) t)
                 (let ((last-nonmenu-event  nil)
                       (use-dialog-box      t))
                   (not (yes-or-no-p
                         (concat "Modified buffers.  Delete all anyway? (`"
                                 (mapconcat (lambda (b) (buffer-name b)) mod-bufs "', `")
                                 "')")))))
        (error "OK, no buffers deleted"))
      (dolist (buf bufs)
        (save-excursion
          (set-buffer buf)
          (set-buffer-modified-p nil)
          (funcall kill-fn buf)))
      (Buffer-menu-revert-function nil nil))))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; 1. Deletes frame when kills buffer.
;; 2. Compatible with Emacs prior to Emacs 22 also.
;; 3. Accommodate `frame-bufs.el'.
;;
;;;###autoload
(defun Buffer-menu-execute ()
  "Save or delete buffers marked `S' (\"save\") or `D' (\"delete\").
Buffers can be so marked using commands `\\<Buffer-menu-mode-map>\
\\[Buffer-menu-save]' and `\\[Buffer-menu-delete]', respectively."
  (interactive)
  (when (and (boundp 'frame-bufs-mode) frame-bufs-mode) (frame-bufs-buffer-menu-execute))
  (save-excursion
    (Buffer-menu-beginning)
    (while (if (> emacs-major-version 21)
               (re-search-forward "^..S" nil t)
             (re-search-forward "^.S" nil t))
      (let ((modp  nil))
        (save-excursion
          (set-buffer (Buffer-menu-buffer t))
          (save-buffer)
          (setq modp  (buffer-modified-p)))
        (let ((buffer-read-only  nil))
          (delete-char -1)
          (insert (if modp ?* ?))))))
  (save-excursion
    (Buffer-menu-beginning)
    (let ((buff-menu-buffer  (current-buffer))
          (buffer-read-only  nil))
      (while (re-search-forward "^D" nil t)
        (forward-char -1)
        (let ((buf  (Buffer-menu-buffer nil)))
          (or (eq buf nil) (eq buf buff-menu-buffer)
              (save-excursion (if (fboundp 'kill-buffer-and-its-windows)
                                  (kill-buffer-and-its-windows buf)
                                (kill-buffer buf))))
          (if (and buf (buffer-name buf))
              (progn (delete-char 1) (insert ?))
            (delete-region (point) (progn (forward-line 1) (point)))
            (unless (bobp) (forward-char -1))))))))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; When Buffer Menu is `window-dedicated-p', uses `pop-to-buffer' to display.
;;
(when (or (> emacs-major-version 24)    ; Emacs 24.3+.
          (and (= emacs-major-version 24)  (> emacs-minor-version 2)))
  (defun Buffer-menu-select ()
    "Select this line's buffer; also display buffers marked with `>'.
You can mark buffers with command `\\<Buffer-menu-mode-map>\\[Buffer-menu-mark]'.
Delete and replace any previously existing windows in the selected
frame.  But if the Buffer Menu window is dedicated, do not delete it."
    (interactive)
    (let* ((line-buffer  (Buffer-menu-buffer t))
           (menu-buffer  (current-buffer))
           (others       (delq line-buffer (Buffer-menu-marked-buffers t))))
      (cond ((window-dedicated-p (selected-window)) ; Keep Buffer Menu if dedicated window.
             (pop-to-buffer line-buffer)
             (unless (eq menu-buffer line-buffer) (bury-buffer menu-buffer))
             (dolist (buf others) (pop-to-buffer buf)))
            (t
             (delete-other-windows)
             (switch-to-buffer line-buffer)
             (unless (eq menu-buffer line-buffer) (bury-buffer menu-buffer))
             (let ((height       (/ (1- (frame-height)) (1+ (length others)))))
               (dolist (buf others)
                 (split-window nil height)
                 (other-window 1)
                 (switch-to-buffer buf)))
             (other-window 1))))))      ; Back to beginning.


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; When Buffer Menu is `window-dedicated-p', uses `pop-to-buffer' to display.
;;
(unless (or (> emacs-major-version 24)  ; Emacs 20-23.
            (and (= emacs-major-version 24)  (> emacs-minor-version 2)))
  (defun Buffer-menu-select ()
    "Select this line's buffer; also display buffers marked with `>'.
You can mark buffers with command `\\<Buffer-menu-mode-map>\\[Buffer-menu-mark]'.
Delete and replace any previously existing windows in the selected
frame.  But if the Buffer Menu window is dedicated, do not delete it."
    (interactive)
    (let ((buff    (Buffer-menu-buffer t))
          (menu    (current-buffer))
          (others  ())
          tem)
      (Buffer-menu-beginning)
      (while (re-search-forward "^>" nil t)
        (setq tem  (Buffer-menu-buffer t))
        (let ((buffer-read-only  nil)) (delete-char -1) (insert ?\ ))
        (or (eq tem buff) (memq tem others) (setq others  (cons tem others))))
      (setq others  (nreverse others))
      (cond ((window-dedicated-p (selected-window)) ; Can't split dedicated win.
             (pop-to-buffer buff)
             (unless (eq menu buff) (bury-buffer menu))
             (while others
               (pop-to-buffer (car others))
               (pop others)))
            (t
             (setq tem  (/ (1- (frame-height)) (1+ (length others))))
             (delete-other-windows)
             (switch-to-buffer buff)
             (unless (eq menu buff) (bury-buffer menu))
             (if (equal (length others) 0)
                 (progn
;;;              ;; Restore previous window configuration before displaying
;;;              ;; selected buffers.
;;;              (if Buffer-menu-window-config
;;;                  (progn (set-window-configuration
;;;                            Buffer-menu-window-config)
;;;                         (setq Buffer-menu-window-config  nil)))
                   (switch-to-buffer buff))
               (while others
                 (split-window nil tem)
                 (other-window 1)
                 (switch-to-buffer (car others))
                 (setq others  (cdr others)))
               (other-window 1)))))))   ; Back to the beginning.


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; Allow negative COLUMN.  Allow COLUMN = 1 or -1.
;; When COLUMN = `Buffer-menu-sort-column', then flip `Buffer-menu-sort-column'.
;; Message at end.
;;
(when (> emacs-major-version 21)
  (defun Buffer-menu-sort (column)
    "Sort the buffer menu by COLUMN.
Consecutive executions of the same COLUMN reverse the sort order."
    (interactive "P")
    (when column
      (setq column  (prefix-numeric-value column))
      (when (= column 0) (setq column  1))
      (when (> column 6) (setq column  6))
      (when (< column -6) (setq column  -6)))
    (if (equal Buffer-menu-sort-column column)
        (setq Buffer-menu-sort-column  (- column))
      (setq Buffer-menu-sort-column  column))
    (let (buffer-read-only lll buf m1 m2)
      (save-excursion
        (Buffer-menu-beginning)
        (while (not (eobp))
          (when (buffer-live-p
                 (setq buf  (get-text-property (+ (point) Buffer-menu-buffer-column) 'buffer)))
            (setq m1  (char-after)
                  m1  (and (memq m1 '(?> ?D)) m1)
                  m2  (char-after (+ (point) 2))
                  m2  (and (eq m2 ?S) m2))
            (when (or m1 m2) (push (list buf m1 m2) lll)))
          (forward-line)))
      (Buffer-menu-revert-function nil nil)
      (setq buffer-read-only  t)
      (save-excursion
        (Buffer-menu-beginning)
        (while (not (eobp))
          (when (setq buf  (assq (get-text-property (+ (point) Buffer-menu-buffer-column) 'buffer)
                                 lll))
            (setq m1  (cadr buf)
                  m2  (cadr (cdr buf)))
            (when m1 (delete-char 1) (insert m1) (backward-char 1))
            (when m2 (forward-char 2) (delete-char 1) (insert m2)))
          (forward-line))))
    (message "Buffers are now sorted %s%s."
             (case (abs column)
               (1 "by time of last visit - see `Buffer-menu-use-frame-buffer-list'")
               (2 "by buffer name")
               (3 "by size")
               (4 "by time of last display")
               (5 "by major-mode name")
               (otherwise "by associated file (including path)"))
             (if (natnump Buffer-menu-sort-column) ", ascending" ", descending"))))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; If same column as last sort, then flip direction of sort.
;; CRM is indicated by COLUMN = 1, not by nil COLUMN.
;; Apply different face to sort column heading, depending on direction.
;;
(when (> emacs-major-version 21)
  (defun Buffer-menu-make-sort-button (name button-column)
    (let ((the-sort-column-p  nil))
      (when (equal button-column (abs Buffer-menu-sort-column))
        (setq the-sort-column-p  t
              button-column      (- button-column)))
      (propertize name 'column button-column
                  'help-echo (case (abs button-column)
                               (1 (if Buffer-menu-use-header-line
                                      "mouse-1, mouse-2: sort by time of last visit - \
see `Buffer-menu-use-frame-buffer-list'"
                                    "mouse-2, RET: sort by time of last visit - \
see `Buffer-menu-use-frame-buffer-list'"))
                               (2 (if Buffer-menu-use-header-line
                                      "mouse-1, mouse-2: sort by buffer name"
                                    "mouse-2, RET: sort by buffer name"))
                               (4 "mouse-1, mouse-2: sort by time of last display/access")
                               (t (if Buffer-menu-use-header-line
                                      (concat "mouse-1, mouse-2: sort by " (downcase name))
                                    (concat "mouse-2, RET: sort by " (downcase name)))))
                  'mouse-face 'highlight
                  (when the-sort-column-p 'face) (when the-sort-column-p
                                                   (if (natnump Buffer-menu-sort-column)
                                                       '(:underline t)
                                                     '(:overline t)))
                  'keymap Buffer-menu-sort-button-map))))


;; REPLACE ORIGINAL in `buff-menu.el'.
;;
;; 1. Compute longest buffer name + size combination, and use when indenting file name.
;; 2. Add sort buttons for CRM and Time also.
;; 3. The test for column 1 (CRM) to determine whether to sort is =1, not null.
;; 4. Sort direction depends on sign of `Buffer-menu-sort-column'.
;; 5. Go to beginning of buffer if `desired-point' is not defined.
;; 6. Accommodate `frame-bufs.el'.
;; 7. Treat Dired buffers like file buffers, e.g., wrt FILES-ONLY.
;;
(when (> emacs-major-version 21)
  (defun list-buffers-noselect (&optional files-only buffer-list)
    "Create and return a buffer with a list of names of existing buffers.
The buffer is named `*Buffer List*'.
Note that buffers with names starting with spaces are omitted.
Non-null optional arg FILES-ONLY means mention only file buffers.

If BUFFER-LIST is non-nil, it should be a list of buffers;
it means list those buffers and no others.

For more information, see the function `buffer-menu'."
    ;; Compute longest buffer name + size combination.
    ;; $$$$$$ Could be costly if lots of buffers - maybe have an option to be able to not do it?
    (let ((len  0)
          buf+size)
      ;; Emacs 24.3+ sets the default value of `Buffer-menu-buffer+size-width' to nil.
      (unless Buffer-menu-buffer+size-width  (setq Buffer-menu-buffer+size-width  26))
      (setq Buffer-menu-buffer+size-computed-width  Buffer-menu-buffer+size-width)
      (dolist (buffer (buffer-list))
        (setq buf+size  (concat (buffer-name buffer) (number-to-string (buffer-size buffer))))
        (when (and (not (string= (substring buf+size 0 1) " ")) ; Don't count internal buffers.
                   (> (length buf+size) len))
          (setq len  (length buf+size))))
      (when (< (+ len 1) Buffer-menu-buffer+size-width)
        (setq Buffer-menu-buffer+size-computed-width  (+ len 1))))
    (let* ((old-buffer       (current-buffer))
           (standard-output  standard-output)
           (mode-end         (if Buffer-menu-mode-flag
                                 (make-string (- Buffer-menu-mode-width 4) ?\ )
                               ""))
           (frame-bufs-p     (and (boundp 'frame-bufs-mode) frame-bufs-mode))
           (header
            (concat (Buffer-menu-make-sort-button
                     (concat "CRM" (if frame-bufs-p (if frame-bufs-full-list "F" " ") "")) 1)
                    " "
                    (Buffer-menu-buffer+size (Buffer-menu-make-sort-button "Buffer" 2)
                                             (Buffer-menu-make-sort-button "Size" 3))
                    "  "
                    (and Buffer-menu-time-flag
                         (if (eq 'short Buffer-menu-time-format)
                             (Buffer-menu-make-sort-button "Time   " 4)
                           (Buffer-menu-make-sort-button "Time          " 4)))
                    (and Buffer-menu-time-flag "   ")
                    (and Buffer-menu-mode-flag
                         (Buffer-menu-make-sort-button (concat "Mode" mode-end) 5))
                    (if Buffer-menu-mode-flag
                        (if Buffer-menu-time-flag " " "  ")
                      (and (not Buffer-menu-time-flag) " "))
                    (and Buffer-menu-file-flag (Buffer-menu-make-sort-button
                                                "File           " 6))
                    "\n"))
           list desired-point name buffer-time mode file)
      (when (and (boundp 'Buffer-menu-use-header-line) Buffer-menu-use-header-line)
        (let ((pos  0))
          ;; Turn whitespace chars in the header into stretch specs so
          ;; they work regardless of the header-line face.
          (while (string-match "[ \t\n]+" header pos)
            (setq pos  (match-end 0))
            (put-text-property (match-beginning 0) pos 'display
                               ;; Assume fixed-size chars in the buffer.
                               (list 'space :align-to pos)
                               header)
            (put-text-property (match-beginning 0) (1- pos) 'mouse-face 'highlight header)))
        ;; REMOVED:
        ;; Try to better align the one-char headers.
        ;; (put-text-property 0 (if frame-bufs-p 4 3) 'face 'fixed-pitch header)
        ;; Add a "dummy" leading space to align the beginning of the header
        ;; line with the beginning of the text (rather than with the left
        ;; scrollbar or the left fringe). --Stef
        (setq header  (concat (propertize " " 'display '(space :align-to 0)) header)))
      (with-current-buffer (get-buffer-create "*Buffer List*")
        (setq buffer-read-only  nil)
        (erase-buffer)
        (setq standard-output  (current-buffer))
        (unless (and (boundp 'Buffer-menu-use-header-line) Buffer-menu-use-header-line)
          ;; Use U+2014 (EM DASH) to underline if possible, else use U+002D (HYPHEN-MINUS).
          ;; Must eval this at compile time.
          ;; Tried a runtime check of (char-displayable-p ?\u2014), but if this is compiled in
          ;; an Emacs version before 22 then get an error that `char-displayable-p' is called
          ;; with two args (since ?\u is interpreted as ?u).
          (let ((underline  (eval-when-compile (if (> emacs-major-version 21) ?\u2014 ?-))))
            (insert header (apply 'string
                                  (mapcar (lambda (ch) (if (memq ch '(?\n ?\  )) ch underline))
                                          header)))))
;;;;           (insert header (propertize "---" 'face 'fixed-pitch) " ")
;;;;           (insert (Buffer-menu-buffer+size "------" "----"))
;;;;           (insert "  ----" mode-end "----\n")
;;;;           (put-text-property 1 (point) 'intangible t))
        ;; Collect info for every buffer we're interested in.
        (dolist (buffer  (or buffer-list
                             (and frame-bufs-p  (frame-bufs-buffer-list (selected-frame)
                                                                        frame-bufs-full-list))
                             (buffer-list (and Buffer-menu-use-frame-buffer-list
                                               (selected-frame)))))
          (with-current-buffer buffer
            (let ((name  (buffer-name))
                  (file  (or buffer-file-name
                             (and (eq major-mode 'dired-mode) default-directory))))
              (unless (and (not buffer-list)
                           (or
                            ;; Don't mention internal buffers.
                            (and (string= (substring name 0 1) " ") (null file))
                            ;; Maybe don't mention buffers without files.
                            (and files-only (not file))
                            (string= name "*Buffer List*")))
                ;; Otherwise output info.
                (let (;; Need to record two values for time: numerical time value, for
                      ;; sorting, and string time value, for display.
                      (buffer-time (and Buffer-menu-time-flag
                                        (cons (or (float-time buffer-display-time) 0)
                                              (if buffer-display-time
                                                  (format-time-string
                                                   (if (eq 'short Buffer-menu-time-format)
                                                       "%02H:%02M:%02S"
                                                     "%_3a %_2l:%02M:%02S %_2p")
                                                   buffer-display-time)
                                                (if (eq 'short Buffer-menu-time-format)
                                                    "        "
                                                  "               ")))))
                      (mode (concat (format-mode-line mode-name nil nil buffer)
                                    (and mode-line-process
                                         (format-mode-line
                                          mode-line-process nil nil buffer))))
                      (bits (concat (if (eq buffer old-buffer) "." " ")
                                    ;; Make output buffer appear read-only, even though it is not
                                    ;; (yet).  Actually make it read-only later.
                                    (if (or (eq buffer standard-output) buffer-read-only)
                                        "%"
                                      " ")
                                    (if (buffer-modified-p) "*" " ") ; Modified mark.
                                    (if frame-bufs-p ; Frame-bufs info.
                                        (frame-bufs-bit-info buffer)
                                      "")
                                    " "))) ; Space separator.
                  (unless file
                    ;; No visited file.  Check local value of `list-buffers-directory' and,
                    ;; for Info buffers, `Info-current-file'.
                    (cond ((and (boundp 'list-buffers-directory) list-buffers-directory)
                           (setq file  list-buffers-directory))
                          ((eq major-mode 'Info-mode)
                           (setq file  Info-current-file)
                           (cond ((equal file "dir")
                                  (setq file  "*Info Directory*"))
                                 ((eq file 'apropos)
                                  (setq file  "*Info Apropos*"))
                                 ((eq file 'history)
                                  (setq file  "*Info History*"))
                                 ((eq file 'toc)
                                  (setq file  "*Info TOC*"))
                                 ((not (stringp file)) ; avoid errors
                                  (setq file  nil))
                                 (t
                                  (setq file  (concat "(" (file-name-nondirectory file) ")"
                                                      Info-current-node)))))))
                  (push (list buffer bits name (buffer-size) buffer-time mode file) list))))))
        ;; Preserve original list order (by reversing).
        ;; Flip it if Buffer-menu-sort-column = -1.
        (unless (eq -1 Buffer-menu-sort-column) (setq list  (nreverse list)))
        ;; Place the buffers's info in the output buffer, sorted if necessary.
        (dolist (buffer (if (eq 1 (abs Buffer-menu-sort-column))
                            list
                          (let* ((descending-p             (natnump Buffer-menu-sort-column))
                                 (Buffer-menu-sort-column  (abs Buffer-menu-sort-column)))
                            (sort list
                                  (cond ((eq Buffer-menu-sort-column 3) ; Size
                                         (if descending-p
                                             (lambda (a b) (< (nth 3 a) (nth 3 b)))
                                           (lambda (a b) (< (nth 3 b) (nth 3 a)))))
                                        ((eq Buffer-menu-sort-column 4) ; Time (value)
                                         (if descending-p
                                             (lambda (a b) (< (car (nth 4 a)) (car (nth 4 b))))
                                           (lambda (a b) (< (car (nth 4 b)) (car (nth 4 a))))))
                                        (t
                                         (if descending-p
                                             (lambda (a b)
                                               (string< (nth Buffer-menu-sort-column a)
                                                        (nth Buffer-menu-sort-column b)))
                                           (lambda (a b)
                                             (string< (nth Buffer-menu-sort-column b)
                                                      (nth Buffer-menu-sort-column a))))))))))
          (when (eq (car buffer) old-buffer) (setq desired-point  (point)))
          (insert (cadr buffer)
                  ;; Put the buffer name into a text property
                  ;; so we don't have to extract it from the text.
                  ;; This way we avoid problems with unusual buffer names.
                  (Buffer-menu-buffer+size (nth 2 buffer)
                                           (int-to-string (nth 3 buffer))
                                           `(buffer-name ,(nth 2 buffer) buffer ,(car buffer)
                                             font-lock-face
                                             ,(if (facep 'Buffer-menu-buffer-face)
                                                  'Buffer-menu-buffer-face ; < Emacs 22
                                                  'Buffer-menu-buffer) ; Emacs 22
                                             mouse-face highlight
                                             help-echo "mouse-2: select this buffer")))
          (when Buffer-menu-time-flag (insert "  " (cdr (nth 4 buffer)))) ; Time
          (when Buffer-menu-mode-flag
            (insert "  "
                    (if (> (length (nth 5 buffer)) Buffer-menu-mode-width) ; Mode
                        (substring (nth 5 buffer) 0 Buffer-menu-mode-width)
                      (nth 5 buffer))))
          (when (and Buffer-menu-file-flag (nth 6 buffer)) ; File
            (indent-to (+ Buffer-menu-buffer-column Buffer-menu-buffer+size-computed-width
                          (if Buffer-menu-mode-flag (1+ Buffer-menu-mode-width) 0)
                          (if Buffer-menu-time-flag
                              (if (eq 'short Buffer-menu-time-format) 9 16)
                            0)
                          3)
                       1)
            (princ (abbreviate-file-name (nth 6 buffer))))
          (princ "\n"))
        (Buffer-menu-mode)
        (when (and (boundp 'Buffer-menu-use-header-line) Buffer-menu-use-header-line)
          (setq header-line-format  header))
        ;; DESIRED-POINT doesn't have to be set; it is not set when the
        ;; current buffer is not displayed for some reason.
        (goto-char (or desired-point (point-min)))
        (setq Buffer-menu-files-only  files-only)
        (set-buffer-modified-p nil)
        (current-buffer)))))

(define-key Buffer-menu-mode-map [down-mouse-3] 'Buffer-menu-mouse-3-menu)
(define-key Buffer-menu-mode-map [mouse-3] 'ignore)

;; Another way, but it shows the menu even if not on a buffer line,
;; and it doesn't show it if on the line but not on the buffer name itself.
;;(defvar Buffer-menu-mouse-3-map (make-sparse-keymap "Buffers"))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-execute]
;;  '("Execute: Save/Delete Marked Buffers" . Buffer-menu-mouse-execute))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-modified]
;;  '("Mark as Modified/Unmodified (*)" . Buffer-menu-mouse-modified))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-delete]
;;  '("Mark to Delete Buffer (D)" . Buffer-menu-mouse-delete))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-save]
;;  '("Mark to Save Buffer (S)" . Buffer-menu-mouse-save))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-unmark]
;;  '("Unmark Buffer" . Buffer-menu-mouse-unmark))
;;(define-key Buffer-menu-mouse-3-map [Buffer-menu-mouse-select]
;;  '("Select Buffer" . Buffer-menu-mouse-select))

(defvar Buffer-menu-overlay nil
  "Overlay to highlight line of buffer during popup of `mouse-3' menu.")

;;;###autoload
(defun Buffer-menu-mouse-3-menu (event)
  "Pop up menu for Mouse-3 for buffer listed in buffer menu."
  (interactive "e")
  (let* ((mouse-pos    (event-start event))
         bol eol temp
         (buffer-name  (save-excursion
                         (set-buffer (window-buffer (posn-window mouse-pos)))
                         (save-excursion
                           (goto-char (posn-point mouse-pos))
                           (setq bol  (line-beginning-position)
                                 eol  (line-end-position))
                           (if Buffer-menu-overlay ; Don't recreate if exists.
                               (move-overlay Buffer-menu-overlay bol eol (current-buffer))
                             (setq Buffer-menu-overlay  (make-overlay bol eol))
                             (overlay-put Buffer-menu-overlay 'face 'region))
                           (setq temp  (and (not (eobp)) (Buffer-menu-buffer nil)))
                           ;; Nil if mouse is not on a buffer name.
                           (and temp (buffer-name temp)))))) ; temp no longer used.
    (sit-for 0)
    (let ((selection
           (x-popup-menu
            event
            (list
             "Menu"
             (if buffer-name
                 (list
                  buffer-name
                  '("Select Buffer" . Buffer-menu-mouse-select)
                  '("Unmark Buffer" . Buffer-menu-mouse-unmark)
                  '("Mark to Save Buffer (S)" . Buffer-menu-mouse-save)
                  '("Mark to Delete Buffer (D)" . Buffer-menu-mouse-delete)
                  '("Mark as Modified/Unmodified (*)" . Buffer-menu-mouse-modified)
                  '("--")               ; Separator: next not buffer-specific.
                  '("Execute: Save/Delete Marked Buffers" . Buffer-menu-mouse-execute)
                  '("Delete All `D', Even If Modified" . Buffer-menu-delete-flagged))
               (list ""
                     '("Execute: Save/Delete Marked Buffers" . Buffer-menu-mouse-execute)
                     '("Delete All `D', Even If Modified" . Buffer-menu-delete-flagged)))))))
      (when Buffer-menu-overlay (delete-overlay Buffer-menu-overlay))
      (and selection (call-interactively selection)))))

;; Don't need this if use dedicated frame for buffer menu.
;;;###autoload
(defun Buffer-menu-mouse-other-window (event)
  "Select, in another window, the buffer on whose line you click."
  (interactive "e")
  (let (buffer)
    (save-excursion
      (set-buffer (window-buffer (posn-window (event-end event))))
      (save-excursion
        (goto-char (posn-point (event-end event)))
        (setq buffer  (Buffer-menu-buffer t))))
    (select-window (posn-window (event-end event)))
    (switch-to-buffer-other-window buffer)))

;;;###autoload
(defun Buffer-menu-mouse-unmark (event)
  "Cancel all requested operations on buffer."
  (interactive "e")
  (let ((frame-bufs-p  (and (boundp 'frame-bufs) frame-bufs-mode))
        buffer)
    (save-excursion
      (set-buffer (window-buffer (posn-window (event-end event))))
      (save-excursion
        (goto-char (posn-point (event-end event)))
        (setq buffer  (Buffer-menu-buffer t))))
    (select-window (posn-window (event-end event)))
    (goto-char (posn-point (event-end event)))
    (beginning-of-line)
    (if (looking-at " [-M]")            ;header lines
        (ding)
      (let* ((mod               (buffer-modified-p buffer))
             (readonly          (save-excursion (set-buffer buffer) buffer-read-only))
             (buffer-read-only  nil)
             (local-info        (if frame-bufs-p
                                    (frame-bufs-bit-info buffer)
                                  "")))
        (delete-char (if frame-bufs-p 4 3))
        (insert (concat (if readonly (if mod " *%" "  %") (if mod " * " "   ")) local-info))))
    (beginning-of-line)))

;;;###autoload
(defun Buffer-menu-mouse-save (event)
  "Mark buffer to be saved.
Actual deletion is done via `\\<Buffer-menu-mode-map>\\[Buffer-menu-execute]' \
or `\\<Buffer-menu-mode-map>\\[Buffer-menu-mouse-execute]'."
  (interactive "e")
  (select-window (posn-window (event-end event)))
  (goto-char (posn-point (event-end event)))
  (beginning-of-line)
  (forward-char 1)
  (if (looking-at " [-M]")              ;header lines
      (ding)
    (let ((buffer-read-only  nil)) (delete-char 1) (insert ?S)))
  (beginning-of-line))

;;;###autoload
(defun Buffer-menu-mouse-delete (event)
  "Mark buffer to be deleted.
Actual deletion is done via `\\<Buffer-menu-mode-map>\\[Buffer-menu-execute]' \
or `\\<Buffer-menu-mode-map>\\[Buffer-menu-mouse-execute]'."
  (interactive "e")
  (select-window (posn-window (event-end event)))
  (goto-char (posn-point (event-end event)))
  (beginning-of-line)
  (if (looking-at " [-M]")              ;header lines
      (ding)
    (let ((buffer-read-only  nil))  (delete-char 1) (insert ?D)))
  (beginning-of-line))

;;;###autoload
(defun Buffer-menu-mouse-modified (event)
  "Mark buffer as unmodified (no changes to save) if modified, and vice versa."
  (interactive "e")
  (select-window (posn-window (event-end event)))
  (goto-char (posn-point (event-end event)))
  (beginning-of-line)
  (forward-char 1)
  (let ((buffer-read-only  nil)
        modified-p)
    (save-excursion
      (set-buffer (Buffer-menu-buffer t))
      (set-buffer-modified-p (not (buffer-modified-p))))
    (cond ((= ?\* (char-after (point)))
           (delete-char 1)
           (insert ?\ ))
          (t
           (delete-char 1)
           (insert ?\*))))
  (beginning-of-line))

;;;###autoload
(defun Buffer-menu-mouse-execute (event)
  "Save and/or delete buffers marked `S' or `D', respectively.
Buffers can be marked via commands `\\<Buffer-menu-mode-map>\
\\[Buffer-menu-save]' and `\\<Buffer-menu-mode-map>\\[Buffer-menu-delete]'
\(or `\\<Buffer-menu-mode-map>\\[Buffer-menu-mouse-save]' and \
`\\<Buffer-menu-mode-map>\\[Buffer-menu-mouse-delete]')."
  (interactive "e")
  (select-window (posn-window (event-end event)))
  (when (and (boundp 'frame-bufs-mode) frame-bufs-mode) (frame-bufs-buffer-menu-execute))
  (save-excursion
    (Buffer-menu-beginning)
    (while (if (> emacs-major-version 21)
               (re-search-forward "^..S" nil t)
             (re-search-forward "^.S" nil t))
      (let ((modp  nil))
        (save-excursion
          (set-buffer (Buffer-menu-buffer t))
          (save-buffer)
          (setq modp  (buffer-modified-p)))
        (let ((buffer-read-only  nil))  (delete-char -1) (insert (if modp ?* ?))))))
  (save-excursion
    (Buffer-menu-beginning)
    (let ((buff-menu-buffer  (current-buffer))
          (buffer-read-only  nil))
      (while (re-search-forward "^D" nil t)
        (forward-char -1)
        (let ((buf  (Buffer-menu-buffer nil)))
          (or (eq buf nil) (eq buf buff-menu-buffer)
              (save-excursion (if (fboundp 'kill-buffer-and-its-windows)
                                  (kill-buffer-and-its-windows buf)
                                (kill-buffer buf))))
          (if (and buf (buffer-name buf))
              (progn (delete-char 1) (insert ?))
            (delete-region (point) (progn (forward-line 1) (point)))
            (unless (bobp) (forward-char -1))))))))

(when (> emacs-major-version 21)
  (defun buffer-menu-nb-marked-in-mode-name ()
    "Add number of marked and flagged lines to mode name in the mode line.
\(Flagged means flagged for deletion.)
If the current line is marked/flagged and there are others
marked/flagged after it then show `N/M', where N is the number
marked/flagged through the current line and M is the total number
marked/flagged."
    (setq mode-name
          `(,mode-name
            (:eval (let* ((marked-regexp   "^>")
                          (nb-marked       (count-matches marked-regexp
                                                          (point-min) (point-max))))
                     (if (not (> nb-marked 0))
                         ""
                       (propertize
                        (format " %s%d>"
                                (save-excursion
                                  (forward-line 0)
                                  (if (looking-at (concat marked-regexp ".*"))
                                      (format "%d/" (1+ (count-matches marked-regexp
                                                                       (point-min) (point))))
                                    ""))
                                nb-marked)
                        'face 'buffer-menu-mode-line-marked))))
            (:eval (let* ((flagged-regexp  "^D")
                          (nb-flagged      (count-matches flagged-regexp
                                                          (point-min) (point-max))))
                     (if (not (> nb-flagged 0))
                         ""
                       (propertize
                        (format " %s%dD"
                                (save-excursion
                                  (forward-line 0)
                                  (if (looking-at (concat flagged-regexp ".*"))
                                      (format "%d/" (1+ (count-matches flagged-regexp
                                                                       (point-min) (point))))
                                    ""))
                                nb-flagged)
                        'face 'buffer-menu-mode-line-flagged)))))))

  (defface buffer-menu-mode-line-marked
      ;; '((t (:inherit buffer-menu-view-mark)))
      '((t (:foreground "Blue")))
    "*Face for marked number in mode line `mode-name' for Dired buffers."
    :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)

  (defface buffer-menu-mode-line-flagged
      ;;  '((t (:inherit buffer-menu-delete-mark)))
      '((t (:foreground "Red")))
    "*Face for flagged number in mode line `mode-name' for Dired buffers."
    :group 'Buffer-Menu-Plus :group 'font-lock-highlighting-faces)

  (if (> emacs-major-version 22)
      (add-hook 'Buffer-menu-mode-hook 'buffer-menu-nb-marked-in-mode-name)
    (add-hook 'buffer-menu-mode-hook 'buffer-menu-nb-marked-in-mode-name)))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'buff-menu+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; buff-menu+.el ends here
#+end_src

** compile-.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220406083051600

#+name: 20210601220406083051600
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; compile-.el --- Extensions to `compile.el'.
;;
;; Filename: compile-.el
;; Description: Extensions to `compile.el'
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2004-2018, Drew Adams, all rights reserved.
;; Created: Tue Nov 16 17:04:11 2004
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 10:22:54 2018 (-0800)
;;           By: dradams
;;     Update #: 126
;; URL: https://www.emacswiki.org/emacs/download/compile-.el
;; Doc URL: https://www.emacswiki.org/emacs/GrepPlus
;; Doc URL: https://www.emacswiki.org/emacs/CompilationMode
;; Keywords: tools, processes
;; Compatibility: GNU Emacs: 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `fit-frame', `frame-fns'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `compile.el'.
;;
;;  See also the companion file `compile+.el', if you are using Emacs
;;  22 or later.
;;
;;        `compile-.el' should be loaded before `compile.el'.
;;        `compile+.el' should be loaded after `compile.el'.
;;
;;  Put this in your initialization file (`~/.emacs'):
;;
;;    (require 'compile-)
;;
;;  Face suggestion (what I use):
;;
;;    `next-error': SkyBlue background, no inheritance
;;
;;
;;  New face defined here:
;;
;;  `compilation-mouseover' - Use instead of highlight for mouse-face.
;;
;;  Function `fit-1-window-frames-on' (defined in `fit-frame.el') is
;;  added here to `compilation-finish-functions'.
;;
;;
;;  ***** NOTE: The following variable defined in `compile.el'
;;              has been REDEFINED HERE:
;;
;;  `compilation-message-face' -
;;     We set the default value to nil, to get rid of underlining.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2011/08/30 dadams
;;     Do not change next-error face - just suggest changes.
;; 2011/01/03 dadams
;;     Added autoload cookie for the defcustom.  Corrected install instructions.
;; 2006/04/02 dadams
;;     Added defcustom of compilation-message-face (nil) to get rid of underlining.
;; 2005/12/26 dadams
;;     Updated parent groups.
;; 2005/12/16 dadams
;;     Added: compilation-mouseover.
;;     Removed: compile-regexp-face.  Use next-error face, not compile-regexp-face.
;; 2004/11/26 dadams
;;     Require frame-fns.el[c].
;; 2004/11/16 dadams
;;     New version for Emacs 21.  Old version renamed to compile-20.el.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'fit-frame nil t) ;; (no error if not found): fit-frame
(require 'frame-fns nil t) ;; 1-window-frames-on

;;;;;;;;;;;;;;;;;;;;;;;;;


;; Use nil, not `underline', to turn off underlining.
;;;###autoload
(defcustom compilation-message-face nil
  "*Face name to use for whole messages.
Faces `compilation-error-face', `compilation-warning-face',
`compilation-info-face', `compilation-line-face' and
`compilation-column-face' get prepended to this, when applicable."
  :type 'face :group 'compilation :version "22.1")

;; Instead of `highlight', which is hard-coded in `compile.el'.
;;;###autoload
(defface compilation-mouseover '((t (:underline t)))
  "*Face used to highlight text the mouse is over."
  :group 'compilation :group 'font-lock-highlighting-faces)

(unless (facep 'next-error)
  (defface next-error '((t (:background "SkyBlue")))
    "Face used to highlight next error locus."
    :group 'next-error))


;; Resize frame to fit buffer - hook `compilation-finish-functions'.
(when (and (fboundp 'fit-frame) (fboundp '1-window-frames-on))
  (defun fit-1-window-frames-on (buf &optional ignored)
    "Resize buffer BUF's one-window frame(s) to fit the buffer.
Usable, e.g., as a member of `compilation-finish-functions'."
    ;; Optional arg IGNORED is ignored.
    ;; It is for compatibility with `compilation-finish-functions'.
    (let ((frs (1-window-frames-on buf)))
      (while frs
        (fit-frame (car frs))           ; Defined in `fit-frame.el'.
        (setq frs (cdr frs)))))
  (add-hook 'compilation-finish-functions 'fit-1-window-frames-on))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'compile-)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile-.el ends here
#+end_src

** compile+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220408082274600

#+name: 20210601220408082274600
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; compile+.el --- Extensions to `compile.el'.
;;
;; Filename: compile+.el
;; Description: Extensions to `compile.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2004-2018, Drew Adams, all rights reserved.
;; Created: Tue Nov 16 16:38:23 2004
;; Version: 0
;; Package-Requires: ((compile- "0"))
;; Last-Updated: Fri Sep 21 13:24:54 2018 (-0700)
;;           By: dradams
;;     Update #: 949
;; URL: https://www.emacswiki.org/emacs/download/compile%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/GrepPlus
;; Doc URL: https://www.emacswiki.org/emacs/CompilationMode
;; Keywords: tools, processes
;; Compatibility: GNU Emacs: 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `compile', `compile-', `fit-frame', `frame-fns',
;;   `misc-fns'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `compile.el'.
;;
;;  See also the companion file `compile-.el'.
;;        `compile-.el' should be loaded before `compile.el'.
;;        `compile+.el' should be loaded after `compile.el'.
;;
;;  Put this in your initialization file (`~/.emacs'):
;;
;;    (require 'compile+)
;;
;;  Additional keys are bound here.  Some bindings that would normally
;;  try to modify a compilation mode buffer are unbound, so they are
;;  available for local (Compilation Mode) definition.
;;
;;
;;  ***** NOTE: The following variable defined in `compile.el'
;;              has been REDEFINED HERE:
;;
;;  `compilation-error-regexp-alist-alist' -
;;     Regexp matches whole line, so mouse-over it.
;;
;;
;;  ***** NOTE: The following macro defined in `compile.el'
;;              has been REDEFINED HERE:
;;
;;  `compilation-assq'.
;;
;;
;;  ***** NOTE: The following functions defined in `compile.el'
;;              have been REDEFINED HERE:
;;
;;  `compilation-compat-error-properties',
;;  `compilation-directory-properties', `compilation-goto-locus',
;;  `compilation-internal-error-properties'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2018/09/21 dadams
;;     Use pop-to-buffer-same-window, not switch-to-buffer.
;; 2016/02/11 dadams
;;     Removed r and R bindings for recompile (they are used in grep+.el to rename buffer).
;; 2015/04/01 dadams
;;     compilation-goto-locus: Fix for Emacs bug #20241.
;; 2011/10/03 dadams
;;     Added macros from compile.el: compilation--make-cdrloc, compilation--loc->marker,
;;                                   compilation--file-struct->loc-tree
;;     compilation-directory-properties: Updated Emacs 24 definition.
;; 2011/02/15 dadams
;;     compilation-directory-properties, compilation-internal-error-properties,
;;       compilation--compat-error-properties:
;;         Updated for Emacs 24.
;; 2011/01/03 dadams
;;     Corrected compatibility: Emacs 22+, not 21+.
;; 2009/02/22 dadams
;;     compilation-goto-locus:
;;       Respect until-move value of next-error-highlight (defined in simple+.el).
;; 2007/09/23 dadams
;;     Removed second arg to undefine-killer-commands.
;; 2007/03/15 dadams
;;     Added: compilation-goto-locus (redefinition).
;; 2005/12/16 dadams
;;     Updated to use compilation-mouseover (in compile-.el).
;;       Added: Redefinitions of compilation-error-regexp-alist-alist,
;;              compilation-assq, compilation-compat-error-properties,
;;              compilation-directory-properties
;;              compilation-internal-error-properties.
;;     Added compile-mode-summary and key bindings.
;;     Removed redefinitions of compilation-goto-locus and overlay.
;;       No longer require strings.el.
;; 2004/11/16 dadams
;;     New version for Emacs 21. Old version renamed to compile+20.el.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'compile-) ;; compilation-mouseover
(require 'compile) ;; compilation-error-regexp-alist-alist, compilation-minor-mode-map

(require 'misc-fns nil t) ;; (no error if not found): undefine-killer-commands


;; Quiet the byte-compiler.
(defvar compilation-debug)
(defvar compilation-enter-directory-face)
(defvar compilation-error-regexp-alist-alist)
(defvar compilation-highlight-overlay)
(defvar compilation-highlight-regexp)
(defvar compilation-leave-directory-face)
(defvar next-error-highlight)
(defvar next-error-highlight-timer)
(defvar next-error-overlay-arrow-position)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(define-key compilation-minor-mode-map "?" 'describe-mode) ; Defined in `help.el'.
(define-key compilation-minor-mode-map "a" 'first-error)
(define-key compilation-minor-mode-map "b" 'compile-mode-summary)
(define-key compilation-minor-mode-map "c" 'compile)
(define-key compilation-minor-mode-map "d" 'compile-mode-summary)
(define-key compilation-minor-mode-map "e" 'compile-mode-summary)
(define-key compilation-minor-mode-map "f" 'compile-goto-error)
(define-key compilation-minor-mode-map "g" 'recompile)
(define-key compilation-minor-mode-map "h" 'describe-mode) ; Defined in `help.el'.
(define-key compilation-minor-mode-map "i" 'compile-mode-summary)
(define-key compilation-minor-mode-map "j" 'compile-mode-summary)
(define-key compilation-minor-mode-map "k" 'kill-compilation)
(define-key compilation-minor-mode-map "l" 'compile-mode-summary)
(define-key compilation-minor-mode-map "m" 'compile)       ; Make.
(define-key compilation-minor-mode-map "n" 'compilation-next-error)
(define-key compilation-minor-mode-map "o" 'compile-mode-summary)
(define-key compilation-minor-mode-map "p" 'compilation-previous-error)
(define-key compilation-minor-mode-map "q" 'quit-window)
(define-key compilation-minor-mode-map "s" 'compile-mode-summary)
(define-key compilation-minor-mode-map "t" 'compile-mode-summary)
(define-key compilation-minor-mode-map "u" 'compile-mode-summary)
(define-key compilation-minor-mode-map "v" 'compile-mode-summary)
(define-key compilation-minor-mode-map "w" 'compile-mode-summary)
(define-key compilation-minor-mode-map "x" 'compile-mode-summary)
(define-key compilation-minor-mode-map "y" 'compile-mode-summary)
(define-key compilation-minor-mode-map "z" 'compile-mode-summary)
(define-key compilation-minor-mode-map "A" 'first-error)
(define-key compilation-minor-mode-map "B" 'compile-mode-summary)
(define-key compilation-minor-mode-map "C" 'compile)
(define-key compilation-minor-mode-map "D" 'compile-mode-summary)
(define-key compilation-minor-mode-map "E" 'compile-mode-summary)
(define-key compilation-minor-mode-map "F" 'compile-goto-error)
(define-key compilation-minor-mode-map "G" 'recompile)
(define-key compilation-minor-mode-map "H" 'describe-mode) ; Defined in `help.el'.
(define-key compilation-minor-mode-map "I" 'compile-mode-summary)
(define-key compilation-minor-mode-map "J" 'compile-mode-summary)
(define-key compilation-minor-mode-map "K" 'kill-compilation)
(define-key compilation-minor-mode-map "L" 'compile-mode-summary)
(define-key compilation-minor-mode-map "M" 'compile)       ; Make
(define-key compilation-minor-mode-map "N" 'compilation-next-error)
(define-key compilation-minor-mode-map "O" 'compile-mode-summary)
(define-key compilation-minor-mode-map "P" 'compilation-previous-error)
(define-key compilation-minor-mode-map "Q" 'quit-window)
(define-key compilation-minor-mode-map "S" 'compile-mode-summary)
(define-key compilation-minor-mode-map "T" 'compile-mode-summary)
(define-key compilation-minor-mode-map "U" 'compile-mode-summary)
(define-key compilation-minor-mode-map "V" 'compile-mode-summary)
(define-key compilation-minor-mode-map "W" 'compile-mode-summary)
(define-key compilation-minor-mode-map "X" 'compile-mode-summary)
(define-key compilation-minor-mode-map "Y" 'compile-mode-summary)
(define-key compilation-minor-mode-map "Z" 'compile-mode-summary)
(define-key compilation-minor-mode-map "{" 'compilation-previous-file)
(define-key compilation-minor-mode-map "}" 'compilation-next-file)



;;; REPLACE ORIGINAL defined in `compile.el'.
;;;
;; Use mouseover on whole line.  Same as original in `compile.el', except for this.
(unless (featurep 'compile+)
  (setq compilation-error-regexp-alist-alist
        (mapcar (lambda (elt) `(,(car elt) ,(concat (cadr elt) ".*") ,@(cddr elt)))
                compilation-error-regexp-alist-alist)))

;; Undefine some bindings that would try to modify a Compilation mode buffer.
;; Their key sequences will then appear to the user as available for local
;; (Compilation Mode) definition.
(when (fboundp 'undefine-killer-commands)
  (undefine-killer-commands compilation-mode-map))

;;;###autoload
(defun compile-mode-summary ()
  "Display brief help message for Compile Mode."
  (interactive)
  (message
   (concat
    (substitute-command-keys
     "\\[describe-mode]= help,  \\[compile-goto-error] & \
\\[compile-mouse-goto-error]= this error,  \\[next-error]= next error,  \
\\[kill-compilation]= kill,  \\[grep]= grep,  \\[compile]= compile,  \
\\[recompile]= recompile"))))



;;; ----------------------------------------------------------------
;;; The rest of this file is redefinitions of standard functions in
;;; `compile.el.  The only changes made have been to replace face
;;; `highlight' by face `compilation-mouseover'.  There is no change
;;; at all in macro `compilation-assq'.
;;; ----------------------------------------------------------------


;;; REPLACE ORIGINAL defined in `compile.el'.
;;; Use face `compilation-mouseover', not `highlight'.
;;;
(if (> emacs-major-version 23)
    ;; Internal function for calculating the text properties of a directory
    ;; change message.  The `compilation-directory' property is important, because it
    ;; is the stack of nested enter-messages.  Relative filenames on the following
    ;; lines are relative to the top of the stack.
    (defun compilation-directory-properties (idx leave)
      (if leave (setq leave (match-end leave)))
      ;; find previous stack, and push onto it, or if `leave' pop it
      (let ((dir (compilation--previous-directory (match-beginning 0))))
        (setq dir (if dir (or (get-text-property (1- dir) 'compilation-directory)
                              (get-text-property dir 'compilation-directory))))
        `(font-lock-face
          ,(if leave compilation-leave-directory-face compilation-enter-directory-face)
          compilation-directory ,(if leave
                                     (or (cdr dir)
                                         '(nil)) ; nil only isn't a property-change
                                     (cons (match-string-no-properties idx) dir))
          ;; Place a `compilation-message' everywhere we change text-properties
          ;; so compilation--remove-properties can know what to remove.
          compilation-message ,(compilation--make-message nil 0 nil)
          mouse-face compilation-mouseover
          keymap compilation-button-map
          help-echo "mouse-2: visit destination directory")))
  ;; Internal function for calculating the text properties of a directory
  ;; change message.  The `directory' property is important, because it is
  ;; the stack of nested enter-messages.  Relative filenames on the following
  ;; lines are relative to the top of the stack.
  (defun compilation-directory-properties (idx leave)
    (if leave (setq leave (match-end leave)))
    ;; find previous stack, and push onto it, or if `leave' pop it
    (let ((dir (previous-single-property-change (point) 'directory)))
      (setq dir (if dir (or (get-text-property (1- dir) 'directory)
                            (get-text-property dir 'directory))))
      `(face ,(if leave
                  compilation-leave-directory-face
                  compilation-enter-directory-face)
             directory ,(if leave
                            (or (cdr dir)
                                '(nil)) ; nil only isn't a property-change
                            (cons (match-string-no-properties idx) dir))
             mouse-face compilation-mouseover
             keymap compilation-button-map
             help-echo "mouse-2: visit current directory"))))


;;; SAME AS ORIGINAL defined in `compile.el'.
;;;
;; Data type `reverse-ordered-alist' retriever.  This function retrieves the
;; KEY element from the ALIST, creating it in the right position if not already
;; present. ALIST structure is
;; '(ANCHOR (KEY1 ...) (KEY2 ...)... (KEYn ALIST ...))
;; ANCHOR is ignored, but necessary so that elements can be inserted.  KEY1
;; may be nil.  The other KEYs are ordered backwards so that growing line
;; numbers can be inserted in front and searching can abort after half the
;; list on average.
(eval-when-compile            ;Don't keep it at runtime if not needed.
  (defmacro compilation-assq (key alist)
    `(let* ((l1 ,alist)
            (l2 (cdr l1)))
       (car (if (if (null ,key)
                    (if l2 (null (caar l2)))
                  (while (if l2 (if (caar l2) (< ,key (caar l2)) t))
                    (setq l1 l2
                          l2 (cdr l1)))
                  (if l2 (eq ,key (caar l2))))
                l2
              (setcdr l1 (cons (list ,key) l2)))))))


;;; REPLACE ORIGINAL defined in `compile.el'.
;;; 1. Respect new value of `until-move' for `next-error-highlight' (from `simple+.el').
;;; 2. Raise frame - especially useful when used with `thumb-frm.el'.
;;; 3. Use `pop-to-buffer-same-window', not `switch-to-buffer'.
;;;
(defun compilation-goto-locus (msg mk end-mk)
  "Jump to an error corresponding to MSG at MK.
All arguments are markers.  If END-MK is non-nil, mark is set there
and overlay is highlighted between MK and END-MK."
  ;; Show compilation buffer in other window, scrolled to this error.
  (let* ((from-compilation-buffer (eq (window-buffer (selected-window))
                                      (marker-buffer msg)))
         ;; Use an existing window if it is in a visible frame.
         (pre-existing (get-buffer-window (marker-buffer msg) 0))
         (w (if (and from-compilation-buffer pre-existing)
                ;; Calling display-buffer here may end up (partly) hiding
                ;; the error location if the two buffers are in two
                ;; different frames.  So don't do it if it's not necessary.
                pre-existing
              (let ((display-buffer-reuse-frames t)
                    (pop-up-windows t))
                ;; Pop up a window.
                (display-buffer (marker-buffer msg)))))
         (highlight-regexp (with-current-buffer (marker-buffer msg)
                             ;; also do this while we change buffer
                             (compilation-set-window w msg)
                             compilation-highlight-regexp)))
    ;; Ideally, the window-size should be passed to `display-buffer' (via
    ;; something like special-display-buffer) so it's only used when
    ;; creating a new window.
    (unless pre-existing (compilation-set-window-height w))

    (if from-compilation-buffer
        ;; If the compilation buffer window was selected,
        ;; keep the compilation buffer in this window;
        ;; display the source in another window.
        (let ((pop-up-windows t))
          (pop-to-buffer (marker-buffer mk) 'other-window))
      (if (window-dedicated-p (selected-window))
          (pop-to-buffer (marker-buffer mk))
        (if (fboundp 'pop-to-buffer-same-window)
            (pop-to-buffer-same-window (marker-buffer mk))
          (switch-to-buffer (marker-buffer mk)))))
    ;; If narrowing gets in the way of going to the right place, widen.
    (unless (eq (goto-char mk) (point))
      (widen)
      (goto-char mk))
    (if end-mk
        (push-mark end-mk t)
      (if mark-active (setq mark-active  nil))) ; See Emacs bug #20241.
    ;; If hideshow got in the way of
    ;; seeing the right place, open permanently.
    (dolist (ov (overlays-at (point)))
      (when (eq 'hs (overlay-get ov 'invisible))
        (delete-overlay ov)
        (goto-char mk)))

    (when highlight-regexp
      (if (timerp next-error-highlight-timer)
          (cancel-timer next-error-highlight-timer))
      (unless compilation-highlight-overlay
        (setq compilation-highlight-overlay
              (make-overlay (point-min) (point-min)))
        (overlay-put compilation-highlight-overlay 'face 'next-error))
      (with-current-buffer (marker-buffer mk)
        (save-excursion
          (if end-mk (goto-char end-mk) (end-of-line))
          (let ((end (point)))
            (if mk (goto-char mk) (beginning-of-line))
            (if (and (stringp highlight-regexp)
                     (re-search-forward highlight-regexp end t))
                (progn
                  (goto-char (match-beginning 0))
                  (move-overlay compilation-highlight-overlay
                                (match-beginning 0) (match-end 0)
                                (current-buffer)))
              (move-overlay compilation-highlight-overlay
                            (point) end (current-buffer)))
            (if (or (eq next-error-highlight t)
                    (numberp next-error-highlight))
                ;; We want highlighting: delete overlay on next input.
                (add-hook 'pre-command-hook
                          'compilation-goto-locus-delete-o)
              (unless (eq next-error-highlight 'until-move)
                ;; We don't want highlighting: delete overlay now.
                (delete-overlay compilation-highlight-overlay)))
            ;; We want highlighting for a limited time:
            ;; set up a timer to delete it.
            (when (numberp next-error-highlight)
              (setq next-error-highlight-timer
                    (run-at-time next-error-highlight nil
                                 'compilation-goto-locus-delete-o)))))
        (raise-frame)))
    (when (and (eq next-error-highlight 'fringe-arrow))
      ;; We want a fringe arrow (instead of highlighting).
      (setq next-error-overlay-arrow-position
            (copy-marker (line-beginning-position))))))


(defmacro compilation--make-cdrloc (line file-struct marker)
  `(list ,line ,file-struct ,marker nil))
(defmacro compilation--loc->marker (loc) `(nth 3 ,loc))
(defmacro compilation--file-struct->loc-tree (fs) `(cdr ,fs))


;;; REPLACE ORIGINAL defined in `compile.el'.
;;; Use face `compilation-mouseover', not `highlight'.
;;;
(if (> emacs-major-version 23)
    (defun compilation-internal-error-properties (file line end-line col end-col type fmts)
      "Get the meta-info that will be added as text-properties.
LINE, END-LINE, COL, END-COL are integers or nil.
TYPE can be 0, 1, or 2, meaning error, warning, or just info.
FILE should be (FILENAME) or (RELATIVE-FILENAME . DIRNAME) or nil.
FMTS is a list of format specs for transforming the file name.
 (See `compilation-error-regexp-alist'.)"
      (unless file (setq file '("*unknown*")))
      (let* ((file-struct (compilation-get-file-structure file fmts))
             ;; Get first already existing marker (if any has one, all have one).
             ;; Do this first, as the compilation-assq`s may create new nodes.
             (marker-line               ; a line structure
              (cadr (compilation--file-struct->loc-tree file-struct)))
             (marker
              (if marker-line (compilation--loc->marker (cadr marker-line))))
             (compilation-error-screen-columns compilation-error-screen-columns)
             end-marker loc end-loc)
        (if (not (and marker (marker-buffer marker)))
            (setq marker nil)      ; no valid marker for this file
          (setq loc (or line 1))   ; normalize no linenumber to line 1
          (catch 'marker       ; find nearest loc, at least one exists
            (dolist (x (cddr (compilation--file-struct->loc-tree
                              file-struct))) ; cl-loop over remaining lines.
              (if (> (car x) loc)            ; still bigger
                  (setq marker-line x)
                (if (> (- (or (car marker-line) 1) loc)
                       (- loc (car x)))     ; current line is nearer
                    (setq marker-line x))
                (throw 'marker t))))
          (setq marker (compilation--loc->marker (cadr marker-line))
                marker-line (or (car marker-line) 1))
          (with-current-buffer (marker-buffer marker)
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (marker-position marker))
                (when (or end-col end-line)
                  (beginning-of-line (- (or end-line line) marker-line -1))
                  (if (or (null end-col) (< end-col 0))
                      (end-of-line)
                    (compilation-move-to-column
                     end-col compilation-error-screen-columns))
                  (setq end-marker (point-marker)))
                (beginning-of-line (if end-line
                                       (- line end-line -1)
                                     (- loc marker-line -1)))
                (if col
                    (compilation-move-to-column
                     col compilation-error-screen-columns)
                  (forward-to-indentation 0))
                (setq marker (point-marker))))))

        (setq loc (compilation-assq line (compilation--file-struct->loc-tree
                                          file-struct)))
        (setq end-loc
              (if end-line
                  (compilation-assq
                   end-col (compilation-assq
                            end-line (compilation--file-struct->loc-tree
                                      file-struct)))
                (if end-col             ; use same line element
                    (compilation-assq end-col loc))))
        (setq loc (compilation-assq col loc))
        ;; If they are new, make the loc(s) reference the file they point to.
        ;; FIXME-omake: there's a problem with timestamps here: the markers
        ;; relative to which we computed the current `marker' have a timestamp
        ;; almost guaranteed to be different from compilation-buffer-modtime, so if
        ;; we use their timestamp, we'll never use `loc' since the timestamp won't
        ;; match compilation-buffer-modtime, and if we use
        ;; compilation-buffer-modtime then we have different timestamps for
        ;; locations that were computed together, which doesn't make sense either.
        ;; I think this points to a fundamental problem in our approach to the
        ;; "omake -P" problem.  --Stef
        (or (cdr loc)
            (setcdr loc (compilation--make-cdrloc line file-struct marker)))
        (if end-loc
            (or (cdr end-loc)
                (setcdr end-loc
                        (compilation--make-cdrloc (or end-line line) file-struct
                                                  end-marker))))

        ;; Must start with face
        `(font-lock-face ,compilation-message-face
                         compilation-message ,(compilation--make-message loc type end-loc)
                         help-echo ,(if col
                                        "mouse-2: visit this file, line and column"
                                        (if line
                                            "mouse-2: visit this file and line"
                                          "mouse-2: visit this file"))
                         keymap compilation-button-map
                         mouse-face compilation-mouseover)))
  (defun compilation-internal-error-properties
      (file line end-line col end-col type fmts)
    "Get the meta-info that will be added as text-properties.
LINE, END-LINE, COL, END-COL are integers or nil.
TYPE can be 0, 1, or 2, meaning error, warning, or just info.
FILE should be (FILENAME) or (RELATIVE-FILENAME . DIRNAME) or nil.
FMTS is a list of format specs for transforming the file name.
 (See `compilation-error-regexp-alist'.)"
    (unless file (setq file '("*unknown*")))
    (let* ((file-struct (compilation-get-file-structure file fmts))
           ;; Get first already existing marker (if any has one, all have one).
           ;; Do this first, as the compilation-assq`s may create new nodes.
           (marker-line (car (cddr file-struct))) ; a line structure
           (marker (nth 3 (cadr marker-line)))    ; its marker
           (compilation-error-screen-columns compilation-error-screen-columns)
           end-marker loc end-loc)
      (if (not (and marker (marker-buffer marker)))
          (setq marker nil)    ; no valid marker for this file
        (setq loc (or line 1)) ; normalize no linenumber to line 1
        (catch 'marker         ; find nearest loc, at least one exists
          (dolist (x (nthcdr 3 file-struct)) ; cl-loop over remaining lines
            (if (> (car x) loc)              ; still bigger
                (setq marker-line x)
              (if (> (- (or (car marker-line) 1) loc)
                     (- loc (car x)))   ; current line is nearer
                  (setq marker-line x))
              (throw 'marker t))))
        (setq marker (nth 3 (cadr marker-line))
              marker-line (or (car marker-line) 1))
        (with-current-buffer (marker-buffer marker)
          (save-excursion
            (save-restriction
              (widen)
              (goto-char (marker-position marker))
              (when (or end-col end-line)
                (beginning-of-line (- (or end-line line) marker-line -1))
                (if (or (null end-col) (< end-col 0))
                    (end-of-line)
                  (compilation-move-to-column
                   end-col compilation-error-screen-columns))
                (setq end-marker (list (point-marker))))
              (beginning-of-line (if end-line
                                     (- line end-line -1)
                                   (- loc marker-line -1)))
              (if col
                  (compilation-move-to-column
                   col compilation-error-screen-columns)
                (forward-to-indentation 0))
              (setq marker (list (point-marker)))))))

      (setq loc (compilation-assq line (cdr file-struct)))
      (if end-line
          (setq end-loc (compilation-assq end-line (cdr file-struct))
                end-loc (compilation-assq end-col end-loc))
        (if end-col                     ; use same line element
            (setq end-loc (compilation-assq end-col loc))))
      (setq loc (compilation-assq col loc))
      ;; If they are new, make the loc(s) reference the file they point to.
      (or (cdr loc) (setcdr loc `(,line ,file-struct ,@marker)))
      (if end-loc
          (or (cdr end-loc)
              (setcdr end-loc `(,(or end-line line) ,file-struct ,@end-marker))))

      ;; Must start with face
      `(face ,compilation-message-face
             message (,loc ,type ,end-loc)
             ,@(if compilation-debug
                   `(debug (,(assoc (with-no-warnings matcher) font-lock-keywords)
                             ,@(match-data))))
             help-echo ,(if col
                            "mouse-2: visit this file, line and column"
                            (if line
                                "mouse-2: visit this file and line"
                              "mouse-2: visit this file"))
             keymap compilation-button-map
             mouse-face compilation-mouseover))))


;;; REPLACE ORIGINAL defined in `compile.el'.
;;; Use face `compilation-mouseover', not `highlight'.
;;;
;;; Note that they also renamed this function, adding an extra `-'.
;;;
(if (> emacs-major-version 23)
    (defun compilation--compat-error-properties (err)
      "Map old-style error ERR to new-style message."
      ;; Old-style structure is (MARKER (FILE DIR) LINE COL) or
      ;; (MARKER . MARKER).
      (let ((dst (cdr err)))
        (if (markerp dst)
            `(compilation-message ,(compilation--make-message
                                    (cons nil (compilation--make-cdrloc
                                               nil nil dst))
                                    2 nil)
                                  help-echo "mouse-2: visit the source location"
                                  keymap compilation-button-map
                                  mouse-face compilation-mouseover)
          ;; Too difficult to do it by hand: dispatch to the normal code.
          (let* ((file (pop dst))
                 (line (pop dst))
                 (col (pop dst))
                 (filename (pop file))
                 (dirname (pop file))
                 (fmt (pop file)))
            (compilation-internal-error-properties
             (cons filename dirname) line nil col nil 2 fmt)))))
  (defun compilation-compat-error-properties (err)
    "Map old-style error ERR to new-style message."
    ;; Old-style structure is (MARKER (FILE DIR) LINE COL) or
    ;; (MARKER . MARKER).
    (let ((dst (cdr err)))
      (if (markerp dst)
          ;; Must start with a face, for font-lock.
          `(face nil
                 message ,(list (list nil nil nil dst) 2)
                 help-echo "mouse-2: visit the source location"
                 keymap compilation-button-map
                 mouse-face compilation-mouseover)
        ;; Too difficult to do it by hand: dispatch to the normal code.
        (let* ((file (pop dst))
               (line (pop dst))
               (col (pop dst))
               (filename (pop file))
               (dirname (pop file))
               (fmt (pop file)))
          (compilation-internal-error-properties
           (cons filename dirname) line nil col nil 2 fmt))))))

;;;;;;;;;;;;;;;;;;

(provide 'compile+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; compile+.el ends here
#+end_src