#+setupfile: ./README.org
#+include: ./README.org

This is used to hold larger files for =./oreo.aiern.org=.

* lib
** grep+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220410729118900

#+name: 20210601220410729118900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; grep+.el --- Extensions to standard library `grep.el'.
;;
;; Filename: grep+.el
;; Description: Extensions to standard library `grep.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2005-2021, Drew Adams, all rights reserved.
;; Created: Fri Dec 16 13:36:47 2005
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Sun Jan  3 15:53:42 2021 (-0800)
;;           By: dradams
;;     Update #: 766
;; URL: https://www.emacswiki.org/emacs/download/grep%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/GrepPlus
;; Keywords: tools, processes, compile
;; Compatibility: GNU Emacs: 22.x, 23.x, 24.x, 25.x, 26.x, 27.x
;;
;; Features that might be required by this library:
;;
;;   `ansi-color', `avoid', `comint', `compile', `compile+',
;;   `compile-', `fit-frame', `frame-fns', `grep', `misc-fns',
;;   `regexp-opt', `ring', `thingatpt', `thingatpt+', `tool-bar'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  Extensions to standard library `grep.el':
;;
;;    1. Additional keys are bound here.
;;    2. Mouse-over is active on the entire hit line, not just on the
;;       file-name part.
;;    3. `grep' command provides a default search string in all cases,
;;       and that default value is better.
;;    4. Commands are provided to remove commented lines from `grep'
;;       output and toggle their automatic removal.
;;
;;  If you want the current `grep' buffer to be renamed automatically
;;  to reflect the particular `grep' command used, do this:
;;
;;  (add-hook 'grep-mode-hook 'grepp-rename-buffer-to-last-no-confirm)
;;
;;  Otherwise, you can use `r' to rename it on demand (command
;;  `grepp-rename-buffer-to-last').
;;
;;
;;  Put this in your initialization file (`~/.emacs'):
;;
;;    (require 'grep+)
;;
;;  Face suggestions:
;;
;;    `compilation-info-face':   Blue3' foreground,        no inherit
;;    `compilation-line-number': DarkGoldenrod foreground, no inherit
;;    `match':                   SkyBlue background,       no inherit
;;
;;  User options defined here:
;;
;;    `grepp-default-comment-line-regexp', `grepp-default-regexp-fn'.
;;
;;  Commands defined here:
;;
;;    `choose-grep-buffer', `grepp-choose-grep-buffer',
;;    `grepp-new-grep-buffer', `grepp-remove-comments',
;;    `grepp-rename-buffer-to-last', `grepp-toggle-comments',
;;    `new-grep-buffer', `remove-grep-comments',
;;    `toggle-grep-comments'.
;;
;;  Non-interactive functions defined here:
;;
;;    `grepp-buffers', `grepp-default-regexp-fn',
;;    `grepp-rename-buffer-to-last-no-confirm'.
;;
;;  Internal variables defined here:
;;
;;    `grepp-last-args'.
;;
;;
;;
;;  ***** NOTE: The following variables defined in `grep.el'
;;              have been REDEFINED HERE:
;;
;;  `grep-mode-font-lock-keywords', `grep-regexp-alist'
;;    - Mouse-over the whole line.
;;
;;
;;
;;  ***** NOTE: The following minor mode defined in `grep.el'
;;              has been REDEFINED HERE:
;;
;;  `grep-mode' - No change.  Redefined here so it uses modified value
;;                of `grep-regexp-alist'.
;;
;;
;;  ***** NOTE: The following functions defined in `grep.el'
;;              have been REDEFINED HERE:
;;
;;  `grep', `grep-default-command' - Use `grepp-default-regexp-fn'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/01/03 dadams
;;     grep-default-command: Use grep-tag-default for Emacs 27.
;;     Don't bother to modify grep-tag-default for Emacs 26+.
;;     grep-mode-font-lock-keywords: Updated per vanilla Emacs 27.
;;     grep-mode: Use regexp-unmatchable for compilation-directory-matcher, for Emacs 27+.
;; 2020/12/06 dadams
;;     grep-regexp-alist: Put mouse-face on whole line for Emacs > 24 also.
;;     grep-mode-font-lock-keywords: Updated for Emacs 26.3.
;; 2018/09/21 dadams
;;     grepp-new-grep-buffer, grepp-choose-grep-buffer: Use pop-to-buffer-same-window, not switch-to-buffer.
;; 2016/09/23 dadams
;;     grep-regexp-alist: Also inappropriate for Emacs 24.
;; 2016/09/22 dadams
;;     grep-regexp-alist: Not needed for Emacs 25+.
;; 2016/02/12 dadams
;;     Added commands to Grep menu-bar menu.
;; 2016/02/11 dadams
;;     Added: grepp-rename-buffer-to-last, grepp-rename-buffer-to-last-no-confirm, grepp-last-args.
;;     Bind grepp-rename-buffer-to-last to r and R.
;;     grep: Save command args as grepp-last-args.
;; 2013/12/05 dadams
;;     grep-default-command: Made argument &optional, since can be called elsewhere.
;; 2013/07/03 dadams
;;     grepp-default-regexp-fn: Added arg TAG-DEFAULT (so it is computed only once).
;;     grep: Call grepp-default-regexp-fn only once, and pass value to grepp-default-regexp-fn.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;; 2011/10/03 dadams
;;     Updated to fit latest Emacs 24.
;;       grep-default-command: Wrapped replacement of file pattern in condition-case.
;;       grep: Added read-shell-command from Emacs 24 code, but commented it out, for now.
;;       grep-regexp-alist: Removed initial regexp to match file and line.
;;                          Removed escape codes in regexps.  Instead, lambdas pick up match face.
;;       grep-mode-font-lock-keywords: Removed escape codes in regexps.  Emacs 24 code.
;;       grep-mode: Use Emacs 24 definition.
;; 2011/09/03 dadams
;;     Removed unneeded require of font-lock.el.
;; 2011/08/30 dadams
;;     grepp-default-regexp-fn: symbol-name-nearest-point -> non-nil-symbol-name-nearest-point.
;;                              Use functionp, not fboundp.
;;     grep: Test value of function, not option, grepp-default-regexp-fn, before funcall.
;;     Do not change any faces - just suggest.
;; 2011/02/15 dadams
;;     For Emacs 24+, do not set grep-hit-face to font-lock-keyword-face.
;;     grep-regexp-alist, grep-mode-font-lock-keywords, grep-mode: Updated for Emacs 24.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive functions.  Added them for defalias commands.
;; 2007/12/04 dadams
;;     grep, grepp-default-regexp-fn: Changed single-quote to double-quote.
;; 2007/12/02 dadams
;;     grep and doc strings of grepp-default-regexp-fn (option and function):
;;       If active, nonempty region, use its (quoted) text as default regexp.
;;         Thx to Martin Nordholts for the suggestion.
;; 2006/12/11 dadams
;;     Added: grepp-toggle-comments.  Bound to M-;.
;; 2006/12/09 dadams
;;     Added: grep-mode-font-lock-keywords.  Needed for refontification (e.g. flush-lines).
;;     Added: grepp-remove-comments, grepp-default-comment-line-regexp.  Bound former to ;.
;; 2006/11/17 dadams
;;     grep-regexp-alist: Defined explicitly, not by modifying original.
;;                        Use nil for HIGHLIGHT part of structure.
;; 2006/11/14 dadams
;;     Added: grepp-buffers, grepp-choose-grep-buffer, grepp-new-grep-buffer.
;;            Bound: grepp-choose-grep-buffer, grepp-new-grep-buffer.
;;     Renamed: grep-default-regexp-fn to grepp-default-regexp-fn.
;; 2006/09/10 dadams
;;     Updated definition of grep-mode with latest from grep.el.
;; 2005/12/17 dadams
;;     Added: grep-default-regexp-fn, grep-default-command.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; ;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'compile+ nil t) ;; (no error if not found) - to pick up enhancements for grep too.
(require 'grep)

(when (and (require 'thingatpt+ nil t);; (no error if not found)
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))
 ;; non-nil-symbol-name-nearest-point

;;;;;;;;;;;;;;;;;;;;;;;


;;;###autoload
(defcustom grepp-default-comment-line-regexp ":[0-9]+: *;"
  "*Default regexp for a comment line, for use in `grepp-remove-comments'.
The default value matches lines that begin with a Lisp comment."
  :type 'string :group 'grep)

;;;###autoload
(defcustom grepp-default-regexp-fn (if (fboundp 'non-nil-symbol-name-nearest-point)
                                       'non-nil-symbol-name-nearest-point
                                     'word-at-point)
  "*Function of 0 args called to provide default search regexp to \\[grep].
Some reasonable choices are defined in `thingatpt+.el':
`word-nearest-point', `non-nil-symbol-name-nearest-point',
`region-or-non-nil-symbol-name-nearest-point', `sexp-nearest-point'.

This is ignored if Transient Mark mode is on and the region is active
and non-empty.  In that case, the quoted (\") region text is used as
the default regexp.

If `grepp-default-regexp-fn' is nil and no prefix arg is given to
`grep', then no defaulting is done.

Otherwise, if the value is not a function, then function
`grepp-default-regexp-fn' does the defaulting."
  :type '(choice
          (const :tag "No default search regexp (unless you use `C-u')" nil)
          (function :tag "Function of zero args to provide default search regexp"))
  :group 'grep)

(defun grepp-default-regexp-fn ()
  "*Function of 0 args called to provide default search regexp to \\[grep].
This is used only if both of the following are true:
- Transient Mark mode is off or the region is inactive or empty.
- The value of option `grepp-default-regexp-fn' is
  `grepp-default-regexp-fn'.

When this is used, the default regexp is provided by calling the
first of these that references a defined function:
  - variable `grepp-default-regexp-fn'
  - variable `find-tag-default-function'
  - the `find-tag-default-function' property of the `major-mode'
  - function `non-nil-symbol-name-nearest-point', if bound
  - function `grep-tag-default'"
  (cond ((functionp grepp-default-regexp-fn) grepp-default-regexp-fn)
        (find-tag-default-function)
        ((get major-mode 'find-tag-default-function))
        ((fboundp 'non-nil-symbol-name-nearest-point) 'non-nil-symbol-name-nearest-point)
        (t 'find-tag-default)))

(defvar grepp-last-args nil
  "String holding the arguments of the last `grep' command used.")


;;; REPLACE ORIGINAL in `grep.el'
;;;
;;; Added optional arg TAG-DEFAULT, passed from `grep'.  Needs to be optional, in case called elsewhere.
;;;
(defun grep-default-command (&optional tag-default)
  (let ((quoted-tag-def  (shell-quote-argument (or tag-default  (if (fboundp 'grep-tag-default) ; Emacs 27+
                                                                    (grep-tag-default)
                                                                  ""))))
    ;; Regexp to match single shell arguments.
        (sh-arg-re     "\\(\\(?:\"\\(?:[^\"]\\|\\\\\"\\)+\"\\|'[^']+'\\|[^\"' \t\n]\\)+\\)")
        (grep-default  (or (car grep-history) grep-command)))
    ;; In the default command, find the arg that specifies the pattern.
    (when (or (string-match
               (concat "[^ ]+\\s +\\(?:-[^ ]+\\s +\\)*" sh-arg-re "\\(\\s +\\(\\S +\\)\\)?")
               grep-default)
              (string-match "\\(\\)\\'" grep-default)) ; If the string is not yet complete.
      ;; Maybe we will replace the pattern with the default tag.
      ;; But first, maybe replace the file name pattern.
      (condition-case nil
          (unless (or (not (stringp buffer-file-name))
                      (and (match-beginning 2)
                           (save-match-data
                             (string-match (wildcard-to-regexp (file-name-nondirectory
                                                                (match-string 3 grep-default)))
                                           (file-name-nondirectory buffer-file-name)))))
            (setq grep-default  (concat (substring grep-default 0 (match-beginning 2)) " *."
                                        (file-name-extension buffer-file-name))))
    ;; In case wildcard-to-regexp gets an error from invalid data.
        (error nil))
             ;; Replace the pattern with the default tag.
      (replace-match quoted-tag-def t t grep-default 1))))


;;; REPLACE ORIGINAL in `grep.el'
;;;
;;; Use `grepp-default-regexp-fn' to define default search string (aka "tag default").
;;;
;;;###autoload
(defun grep (command-args &optional highlight-regexp)
  "Run `grep', with user-specified args, and collect output in a buffer.
The output goes to buffer `*grep*'.

COMMAND-ARGS are the user-specified arguments.
While `grep' runs asynchronously, you can use
\\[next-error] (M-x next-error), or \\<grep-mode-map>\\[compile-goto-error]
in output buffer `*grep*', to go to the lines where `grep' found matches.

This command uses a special history list for its COMMAND-ARGS, so you can
easily repeat a grep command.

The text (regexp) to find is defaulted as follows:

- If Transient Mark mode is on and the region is active and nonempty,
  then the double-quoted region text is used.  (If the region contains
  double-quotes (\"), then you will need to escape them by hand.)

- If option `grepp-default-regexp-fn' is a function, then it is called
  to return the default regexp.

- If `grepp-default-regexp-fn' is nil and no prefix arg is provided,
  then no default regexp is used.

If a prefix arg is provided, the default text is substituted into the
last grep command in the grep command history (or into `grep-command'
if that history list is empty).  That is, the same command options and
files to search are used as the last time.

If specified, optional second arg HIGHLIGHT-REGEXP is the regexp to
temporarily highlight in visited source lines."
  (interactive
   (progn
     (unless (and grep-command  (memq grep-use-null-device '(t nil))) (grep-compute-defaults))
     (let* ((tag-default  (funcall (grepp-default-regexp-fn)))
            (default-cmd  (grep-default-command tag-default)))
       (list
        (if nil ;;$$$$$$ UNCOMMENT if you prefer: (fboundp 'read-shell-command)
            (read-shell-command "grep <pattern> <files> :  "
                                (if current-prefix-arg
                                    default-cmd
                                  (concat
                                   grep-command
                                   (if (and transient-mark-mode mark-active
                                            (not (eq (region-beginning) (region-end))))
                                       ;; $$$$$ Would it be better to use `shell-quote-argument' on region?
                                       (concat "\"" (buffer-substring (region-beginning) (region-end)) "\"")
                                     tag-default)
                                   " "))
                                'grep-history
                                (if current-prefix-arg nil default-cmd))
          (read-from-minibuffer
           "grep <pattern> <files> :  "
           (if current-prefix-arg
               default-cmd
             (concat grep-command
                     (if (and transient-mark-mode mark-active
                              (not (eq (region-beginning) (region-end))))
                         ;; $$$$$ Would it be better to use `shell-quote-argument' on region?
                         (concat "\"" (buffer-substring (region-beginning) (region-end)) "\"")
                       tag-default)
                     " "))
           nil nil 'grep-history
           (if current-prefix-arg nil default-cmd)))))))
  (setq grepp-last-args  (substring command-args 4))
  ;; Setting process-setup-function makes exit-message-function work
  ;; even when async processes aren't supported.
  (compilation-start (if (and grep-use-null-device null-device)
                         (concat command-args " " null-device)
                       command-args)
                     'grep-mode nil highlight-regexp))


;;;###autoload
(defalias 'new-grep-buffer 'grepp-new-grep-buffer)
;;;###autoload
(defun grepp-new-grep-buffer ()
  "Rename current grep buffer and switch to new buffer *grep*.
Current buffer must be a grep buffer.  It is renamed to *grep*<N>."
  (interactive)
  (unless (string-match "\\*grep\\*" (buffer-name (current-buffer)))
    (error "Not in a grep buffer"))
  (rename-uniquely)
  (if (fboundp 'pop-to-buffer-same-window)
      (pop-to-buffer-same-window "*grep*")
    (switch-to-buffer "*grep*"))
  (grep-mode))


;;;###autoload
(defalias 'choose-grep-buffer 'grepp-choose-grep-buffer)
;;;###autoload
(defun grepp-choose-grep-buffer (buf)
  "Switch to a grep buffer."
  (interactive
   (let ((bufs  (grepp-buffers)))
     (unless bufs (error "No grep buffers"))
     (list (completing-read "Grep buffer: " bufs nil t nil nil
                            (and grep-last-buffer (buffer-name grep-last-buffer))))))
  (if (fboundp 'pop-to-buffer-same-window)
      (pop-to-buffer-same-window buf)
    (switch-to-buffer buf))
  (select-frame-set-input-focus (selected-frame))
  (grep-mode))

(defun grepp-buffers ()
  "List of names of grep buffers."
  (let ((bufs  ()))
    (dolist (buf (buffer-list))
      (when (string-match "\\*grep\\*" (buffer-name buf))
        (push (list (buffer-name buf)) bufs)))
    (nreverse bufs)))

;;;###autoload
(defun grepp-rename-buffer-to-last (&optional no-confirm)
  "Rename current `grep' buffer uniquely to reflect the command args."
  (interactive)
  (unless grepp-last-args (error "You must invoke Emacs command `grep' first"))
  (when (and (eq major-mode 'grep-mode)
             (or no-confirm  (y-or-n-p (format "Rename buffer to `*grep* %s'? " grepp-last-args))))
    (rename-buffer (concat "*grep* " grepp-last-args) 'UNIQUE)))

(defun grepp-rename-buffer-to-last-no-confirm ()
  "Rename current `grep' buffer uniquely to reflect the command args."
  (unless grepp-last-args (error "You must invoke Emacs command `grep' first"))
  (when (eq major-mode 'grep-mode) (rename-buffer (concat "*grep* " grepp-last-args) 'UNIQUE)))

;;;###autoload
(defalias 'remove-grep-comments 'grepp-remove-comments)
;;;###autoload
(defun grepp-remove-comments (&optional read-regexp-p)
  "Remove lines that are completely commented out.
With a prefix argument, you are prompted for the regexp used to match
 commented lines.  The default value is
 `grepp-default-comment-line-regexp'.
With no prefix argument, this default value is used as the regexp.

You can use command `grep-toggle-comments' to toggle automatic removal
of commented lines.

Note: This simply removes lines that begin with the regexp you
provide.  It does not, in general, remove multi-line comments.  Use it
to remove C++ comments that start with //, but not multi-line comments
between /* and */."
  (interactive "P")
  (when (eq major-mode 'grep-mode) ; Do nothing otherwise, so can use in `compilation-filter-hook'.
    (let ((inhibit-read-only  t)
          (regexp  (if read-regexp-p
                       (read-from-minibuffer "Comment regexp: " nil nil nil 'regexp-history
                                             grepp-default-comment-line-regexp)
                     grepp-default-comment-line-regexp)))
      (save-excursion (flush-lines regexp (point-min) (point-max))))))

;;;###autoload
(defalias 'toggle-grep-comments 'grepp-toggle-comments)
;;;###autoload
(defun grepp-toggle-comments ()
  "Toggle removal of commented lines in grep output."
  (interactive)
  (cond ((and (boundp 'compilation-filter-hook)
              (memq 'remove-grep-comments compilation-filter-hook))
         (remove-hook 'compilation-filter-hook 'remove-grep-comments)
         (when (consp grep-history) (grep (car grep-history)))
         (message "Automatic removal of commented lines is now OFF"))
        (t
         (add-hook 'compilation-filter-hook 'remove-grep-comments)
         (when (consp grep-history) (grep (car grep-history)))
         (message "Automatic removal of commented lines is now ON"))))


;; New bindings.
(define-key grep-mode-map "g" 'grep)
(define-key grep-mode-map "G" 'grep)
(define-key grep-mode-map "n" 'next-error-no-select)
(define-key grep-mode-map "N" 'next-error-no-select)
(define-key grep-mode-map "p" 'previous-error-no-select)
(define-key grep-mode-map "P" 'previous-error-no-select)
(define-key grep-mode-map "+" 'grepp-new-grep-buffer)
(define-key grep-mode-map "b" 'grepp-choose-grep-buffer)
(define-key grep-mode-map "B" 'grepp-choose-grep-buffer)
(define-key grep-mode-map "r" 'grepp-rename-buffer-to-last)
(define-key grep-mode-map "R" 'grepp-rename-buffer-to-last)
(define-key grep-mode-map ";" 'grepp-remove-comments)
(define-key grep-mode-map [(meta ?\;)] 'grepp-toggle-comments)

;; Menu-bar menu `Grep'.
(define-key-after grep-mode-map [menu-bar grep grepp-separator1] '("----") 'compilation-compile)
(define-key-after grep-mode-map [menu-bar grep grepp-new-grep-buffer]
  '(menu-item "Rename and Switch" grepp-new-grep-buffer
    :help "Rename current buffer to *grep*<N> and switch to new buffer *grep*.")
  'grepp-separator1)
(define-key-after grep-mode-map [menu-bar grep grepp-choose-grep-buffer]
  '(menu-item "Switch to Other Grep Buffer..." grepp-choose-grep-buffer)
  'grepp-new-grep-buffer)
(define-key-after grep-mode-map [menu-bar grep grepp-rename-buffer-to-last]
  '(menu-item "Rename Showing Args" grepp-rename-buffer-to-last
    :help "Rename current `grep' buffer uniquely to reflect the command args.")
  'grepp-choose-grep-buffer)
(define-key-after grep-mode-map [menu-bar grep grepp-separator2] '("----") 'grepp-rename-buffer-to-last)
(define-key-after grep-mode-map [menu-bar grep grepp-remove-comments]
  '(menu-item "Removed Commented Lines" grepp-remove-comments
    :help "Remove output lines that are completely commented out.")
  'grepp-separator2)
(define-key-after grep-mode-map [menu-bar grep grepp-toggle-comments]
  '(menu-item "Automatic Removal of Commented Lines" grepp-toggle-comments
    :help "Toggle removal of commented lines in grep output.")
  'grepp-remove-comments)


;;; REPLACE ORIGINAL `grep-regexp-alist' defined in `grep.el'.
;;;
;;; Use mouseover on whole line.  Same as original, except for this.
;;; Don't bother to even try for Emacs 26+, since it won't work with `xref' etc.
;;;
(unless (or (featurep 'grep+)  (> emacs-major-version 24))
  (if (= emacs-major-version 24)
      ;; Gross hack.  Append ".*" to regexps (but put it before a $ at end, if present).
      ;; If HIGHLIGHT is nil then the whole line will get `mouse-face'.
      (dolist (entry  grep-regexp-alist)
        (when (and (consp entry)  (stringp (car entry)))
          (let* ((regexp      (car entry))
                 (up-to-last  (substring regexp 0 -1))
                 (last        (substring regexp -1)))
            (setcar entry (if (string= "$" last) (concat up-to-last ".*$") (concat regexp ".*"))))))
    (setq grep-regexp-alist
          `(
            ;; Use as tight a regexp as possible to try to handle weird file names (with colons) as well as
            ;; possible.  E.g. use [1-9][0-9]* rather than [0-9]+ so as to accept ":034:" in file names.
            ;;
            ;; Appended `.*', to match whole line for `mouse-face'.
            ("^\\(.+?\\)\\(:[ \t]*\\)\\([1-9][0-9]*\\)\\2.*"
             1 3
             ;; Calculate column positions (col . end-col) of first grep match on a line
             ((lambda ()
                (when grep-highlight-matches
                  (let* ((beg   (match-end 0))
                         (end   (save-excursion (goto-char beg) (line-end-position)))
                         (mbeg  (text-property-any beg end 'font-lock-face ,(if (boundp 'grep-match-face)
                                                                                grep-match-face
                                                                              'match))))
                    (and mbeg (- mbeg beg)))))
              .
              (lambda ()
                (when grep-highlight-matches
                  (let* ((beg   (match-end 0))
                         (end   (save-excursion (goto-char beg) (line-end-position)))
                         (mbeg  (text-property-any beg end 'font-lock-face ,(if (boundp 'grep-match-face)
                                                                                grep-match-face
                                                                              'match)))
                         (mend  (and mbeg (next-single-property-change mbeg 'font-lock-face nil end))))
                    (and mend (- mend beg))))))
             nil
             nil)
            ("^Binary file \\(.+\\) matches$" 1 nil nil 0 1)))))


;;; REPLACE ORIGINAL `grep-mode-font-lock-keywords' defined in `grep.el'.
;;;
;;; Use mouseover on whole line.  Same as original, except for this.
;;;
(unless (featurep 'grep+)
  (setq grep-mode-font-lock-keywords
        (if (> emacs-major-version 23)
            '(;; Command output lines.
              ("^\\(.+?\\):\\([0-9]+\\):.*" (0 '(face nil mouse-face compilation-mouseover)))

              (": \\(.+\\): \\(?:Permission denied\\|No such \\(?:file or directory\\|device or \
address\\)\\)$"
               1 grep-error-face)
              ;; Remove match from `grep-regexp-alist' before fontifying.
              ("^Grep[/a-zA-Z]* started.*"
               (0 '(face nil compilation-message nil help-echo nil mouse-face nil) t))
              ("^Grep[/a-zA-Z]* finished with \\(?:\\(\\(?:[0-9]+ \\)?match\\(?:es\\)? \
found\\)\\|\\(no matches found\\)\\).*"
               (0 '(face nil compilation-message nil help-echo nil mouse-face nil) t)
               (1 compilation-info-face nil t)
               (2 compilation-warning-face nil t))
              ("^Grep[/a-zA-Z]* \\(exited abnormally\\|interrupt\\|killed\\|terminated\\)\\(?:.*with \
code \\([0-9]+\\)\\)?.*"
               (0 '(face nil compilation-message nil help-echo nil mouse-face nil) t)
               (1 grep-error-face)
               (2 grep-error-face nil t))
              ;; "filename-linenumber-" format is used for context lines in GNU grep,
              ;; "filename=linenumber=" for lines with function names in "git grep -p".
              ("^.+?\\([-=\0]\\)[0-9]+\\([-=]\\).*\n" (0 grep-context-face)
               (1 (and (eq (char-after (match-beginning 1)) ?\0)  `(face nil display ,(match-string 2)))))
              ("^find \\(\\. -type d .*\\\\)\\)" ; Hide excessive part of `rgrep' command
               (1 (if grep-find-abbreviate
                      grep-find-abbreviate-properties
                    '(face nil abbreviated-command t))))
              ("^grep \\( *--exclude.*--exclude[^ ]+\\)" ; Hide excessive part of `lgrep' command
               (1 (if grep-find-abbreviate
                      grep-find-abbreviate-properties
                    '(face nil abbreviated-command t)))))

          ;; Emacs 22, 23
          '(;; Command output lines.
            ("^\\(.+?\\):\\([0-9]+\\):.*" (0 '(face nil mouse-face compilation-mouseover)))
            (": \\(.+\\): \\(?:Permission denied\\|No such \\(?:file or directory\\|device or \
address\\)\\)$"
             1 grep-error-face)
            ;; Remove match from grep-regexp-alist before fontifying.
            ;; Set `compilation-message' and `message' to nil: Emacs before version 24 uses `message'.
            ("^Grep[/a-zA-Z]* started.*"
             (0 '(face nil compilation-message nil message nil help-echo nil mouse-face nil) t))
            ("^Grep[/a-zA-Z]* finished \\(?:(\\(matches found\\))\\|with \\(no matches found\\)\\).*"
             ;; Set `compilation-message' and `message' to nil: Emacs before version 24 uses `message'.
             (0 '(face nil compilation-message nil message nil help-echo nil mouse-face nil) t)
             (1 compilation-info-face nil t)
             (2 compilation-warning-face nil t))
            ("^Grep[/a-zA-Z]* \\(exited abnormally\\|interrupt\\|killed\\|terminated\\)\\(?:.*with \
code \\([0-9]+\\)\\)?.*"
             ;; Set `compilation-message' and `message' to nil: Emacs before version 24 uses `message'.
             (0 '(face nil compilation-message nil message nil help-echo nil mouse-face nil) t)
             (1 grep-error-face)
             (2 grep-error-face nil t))
            ("^.+?-[0-9]+-.*\n" (0 grep-context-face))
            ;; Highlight grep matches and delete markers
            ("\\(\033\\[01;31m\\)\\(.*?\\)\\(\033\\[[0-9]*m\\)"
             ;; Refontification does not work after the markers have been
             ;; deleted.  So we use the font-lock-face property here as Font
             ;; Lock does not clear that.
             (2 (list 'face nil 'font-lock-face grep-match-face))
             ((lambda (bound))
              (progn
                ;; Delete markers with `replace-match' because it updates
                ;; the match-data, whereas `delete-region' would render it obsolete.
                (when (> emacs-major-version 23) (syntax-ppss-flush-cache (match-beginning 0)))
                (replace-match "" t t nil 3)
                (replace-match "" t t nil 1))))
            ("\033\\[[0-9;]*[mK]"
             ;; Delete all remaining escape sequences
             ((lambda (bound))
              (when (> emacs-major-version 23) (syntax-ppss-flush-cache (match-beginning 0)))
              (replace-match "" t t)))))))


;;; REPLACE ORIGINAL `grep-mode' defined in `grep.el'.
;;; Re-create, so it uses the modified `grep-regexp-alist'.
;;; This definition SHOULD BE THE SAME AS THE ORIGINAL in `grep.el'.
;;;
(define-compilation-mode grep-mode "Grep"
  "Sets `grep-last-buffer' and `compilation-window-height'."
  (setq grep-last-buffer  (current-buffer))
  (when (boundp 'grep-mode-tool-bar-map)
    (set (make-local-variable 'tool-bar-map) grep-mode-tool-bar-map))
  (set (make-local-variable 'compilation-error-face) grep-hit-face)
  (set (make-local-variable 'compilation-error-regexp-alist) grep-regexp-alist)
  ;; compilation-directory-matcher can't be nil, so we set it to a regexp that
  ;; can never match.
  (set (make-local-variable 'compilation-directory-matcher) (if (boundp 'regexp-unmatchable)
                                                                (list regexp-unmatchable) ; Emacs 27+
                                                              '("\\`a\\`")))
  (set (make-local-variable 'compilation-process-setup-function) 'grep-process-setup)
  (set (make-local-variable 'compilation-disable-input) t)
  (set (make-local-variable 'compilation-error-screen-columns)
       grep-error-screen-columns)
  (when (fboundp 'grep-filter) (add-hook 'compilation-filter-hook 'grep-filter nil t)))

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'grep+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; grep+.el ends here
#+end_src

** dired+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220413315315300

#+name: 20210601220413315315300
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; dired+.el --- Extensions to Dired.
;;
;; Filename: dired+.el
;; Description: Extensions to Dired.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1999-2021, Drew Adams, all rights reserved.
;; Created: Fri Mar 19 15:58:58 1999
;; Version: 2020.12.01
;; Package-Requires: ()
;; Last-Updated: Mon May 10 09:08:06 2021 (-0700)
;;           By: dradams
;;     Update #: 12975
;; URL: https://www.emacswiki.org/emacs/download/dired%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/DiredPlus
;; Keywords: unix, mouse, directories, diredp, dired
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x, 27.x
;;
;; Features that might be required by this library:
;;
;;   `apropos', `apropos+', `autofit-frame', `avoid', `backquote',
;;   `bookmark', `bookmark+', `bookmark+-1', `bookmark+-bmu',
;;   `bookmark+-key', `bookmark+-lit', `button', `bytecomp', `cconv',
;;   `cl', `cl-lib', `cmds-menu', `col-highlight', `crosshairs',
;;   `custom', `dired', `dired+', `dired-aux', `dired-loaddefs',
;;   `dired-x', `doremi', `doremi-frm', `easymenu', `facemenu',
;;   `facemenu+', `faces', `faces+', `fit-frame', `font-lock',
;;   `font-lock+', `font-lock-menus', `format-spec', `frame-cmds',
;;   `frame-fns', `gv', `help+', `help-fns', `help-fns+',
;;   `help-macro', `help-macro+', `help-mode', `hexrgb', `highlight',
;;   `hl-line', `hl-line+', `image', `image-dired', `image-file',
;;   `image-mode', `info', `info+', `kmacro', `macroexp', `menu-bar',
;;   `menu-bar+', `misc-cmds', `misc-fns', `mwheel', `naked',
;;   `palette', `pp', `pp+', `radix-tree', `replace', `ring',
;;   `second-sel', `strings', `syntax', `text-mode', `thingatpt',
;;   `thingatpt+', `timer', `vline', `w32-browser',
;;   `w32browser-dlgopen', `wid-edit', `wid-edit+', `widget',
;;   `zones'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to Dired.
;;
;;  This file extends functionalities provided by standard GNU Emacs
;;  files `dired.el', `dired-aux.el', and `dired-x.el'.
;;
;;  Key bindings changed.  Menus redefined.  `diredp-mouse-3-menu'
;;  popup menu added.  New commands.  Some commands enhanced.
;;
;;  All of the new functions, variables, and faces defined here have
;;  the prefix `diredp-' (for Dired Plus) in their names.
;;
;;
;;  Wraparound Navigation
;;  ---------------------
;;
;;  In vanilla Dired, `dired-next-marked-file' (`M-}' or `* C-n') and
;;  `dired-previous-marked-file' (`M-{' or `* C-p') wrap around when
;;  you get to the end or the beginning of the Dired buffer.  Handy.
;;
;;  But the other navigation commands do not wrap around.  In `Dired+'
;;  they do, provided option `diredp-wrap-around-flag' is non-nil,
;;  which it is by default.  This means the following commands:
;;
;;    `diredp-next-line'     - `n', `C-n', `down', `SPC'
;;    `diredp-previous-line' - `p', `C-p', `up'
;;    `diredp-next-dirline'  - `>'
;;    `diredp-prev-dirline'  - `<'
;;    `diredp-next-subdir'   - `C-M-n'
;;    `diredp-prev-subdir'   - `C-M-p'
;;
;;
;;  Quick Viewing While Navigating
;;  ------------------------------
;;
;;  You can use key `C-down' or `C-up' to navigate to the next or
;;  previous file line, respectively, and at the same time show its
;;  file in another window.  The focus remains on the Dired buffer.
;;  A numeric prefix arg means move that many lines first.
;;
;;  Names of files and directories that match either of the options
;;  `diredp-visit-ignore-extensions' or `diredp-visit-ignore-regexps'
;;  are skipped.
;;
;;  You can use `e' to show the file of the current line.  If it is
;;  already shown in the same frame, and if Dired is the only other
;;  window there, then the file is hidden (its window is deleted).
;;
;;
;;  Font-Lock Highlighting
;;  ----------------------
;;
;;  If you want a maximum or minimum fontification for Dired mode,
;;  then customize option `font-lock-maximum-decoration'.  If you want
;;  a different fontification level for Dired than for other modes,
;;  you can do this too by customizing
;;  `font-lock-maximize-decoration'.
;;
;;  A few of the user options defined here have an effect on
;;  font-locking, and this effect is established only when Dired+ is
;;  loaded, which defines the font-lock keywords for Dired.  These
;;  options include `diredp-compressed-extensions',
;;  `diredp-ignore-compressed-flag', `dired-omit-extensions', and
;;  `diredp-omit-files-font-lock-regexp'.  This means that if you
;;  change the value of such an option then you will see the change
;;  only in a new Emacs session.
;;
;;  (You can see the effect in the same session if you use `C-M-x' on
;;  the `defvar' sexp for `diredp-font-lock-keywords-1', and then you
;;  toggle font-lock off and back on.)
;;
;;
;;  Act on All Files
;;  ----------------
;;
;;  Most of the commands (such as `C' and `C-M-g') that operate on the
;;  marked files have the added feature here that multiple `C-u' use
;;  not the files that are marked or the next or previous N files, but
;;  *all* of the files in the Dired buffer.  Just what "all" files
;;  means changes with the number of `C-u', as follows:
;;
;;    `C-u C-u'         - Use all files present, but no directories.
;;    `C-u C-u C-u'     - Use all files and dirs except `.' and `..'.
;;    `C-u C-u C-u C-u' - use all files and dirs, `.' and `..'.
;;
;;    (More than four `C-u' act the same as two.)
;;
;;  This feature can be particularly useful when you have a Dired
;;  buffer with files chosen from multiple directories.
;;
;;  Note that in most cases this behavior is described only in the doc
;;  string of function `dired-get-marked-files'.  It is generally
;;  *not* described in the doc strings of the various commands,
;;  because that would require redefining each command separately
;;  here.  Instead, we redefine macro `dired-map-over-marks' and
;;  function `dired-get-filename' in order to achieve this effect.
;;
;;  Commands such as `dired-do-load' for which it does not make sense
;;  to act on directories generally treat more than two `C-u' the same
;;  as two `C-u'.
;;
;;  Exceptions to the general behavior described here are called out
;;  in the doc strings.  In particular, the behavior of a prefix arg
;;  for `dired-do-query-replace-regexp' is different, so that you can
;;  use it also to specify word-delimited replacement.
;;
;;
;;  Act on Marked (or All) Files Here and Below
;;  -------------------------------------------
;;
;;  The prefix argument behavior just described does not apply to the
;;  `diredp-*-recursive' commands.  These commands act on the marked
;;  files in the current Dired buffer or on all files in the directory
;;  if none are marked.
;;
;;  But these commands also handle marked subdirectories recursively,
;;  in the same way.  That is, they act also on the marked files in
;;  any marked subdirectories, found recursively.  If such a
;;  descendant directory is listed in a Dired buffer then its marked
;;  files and subdirs are handled the same way.  If there is no Dired
;;  buffer that lists a given marked subdirectory then all of its
;;  files and subdirs are acted on.
;;
;;  For most such here-and-below commands, a prefix argument means
;;  ignore all marks.  The commands then act on all files in the
;;  current Dired buffer and all of its subdirectories, recursively.
;;
;;  But here-and-below commands that unmark or change marks act
;;  differently for different kinds of prefix argument:
;;
;;  * A non-positive prefix arg means ignore subdir markings and act
;;    instead on ALL subdirs.
;;
;;  * A non-negative prefix arg means do not change marks on subdirs
;;    themselves.
;;
;;  For example, `M-+ U' removes all marks, including from marked
;;  subdirs, recursively.  `C-- M-+ U' removes them from all files in
;;  all subdirs (marked or not), recursively.  `C-9 M-+ U' removes all
;;  marks, recursively, except the marks on subdirs themselves.  `C-0
;;  M-+ U' acts like those two combined: it descends everywhere,
;;  ignoring which subdirs are marked, but it does not remove marks
;;  from subdirs themselves.
;;
;;  All of the `diredp-*-recursive' commands are on prefix key `M-+',
;;  and most are available on submenu `Marked Here and Below' of the
;;  `Multiple' menu-bar menu.  The commands that unmark and change
;;  marks are also in submenu `Here and Below' of menu-bar menu
;;  `Marks'.
;;
;;  If you use library `Icicles' then you have the following
;;  additional commands/keys that act recursively on marked files.
;;  They are in the `Icicles' submenu of menu `Multiple' > `Marked
;;  Here and Below'.
;;
;;  * `M-+ M-s M-s' or `M-s M-s m' - Use Icicles search (and its
;;                  on-demand replace) on the marked files.
;;
;;  * Save the names of the marked files:
;;
;;    `M-+ C-M->' - Save as a completion set, for use during
;;                  completion (e.g. with `C-x C-f').
;;
;;    `M-+ C->'   - Add marked names to the names in the current saved
;;                  completion set.
;;
;;    `M-+ C-}'   - Save persistently to an Icicles cache file, for
;;                  use during completion in another session.
;;
;;    `icicle-dired-save-marked-to-fileset-recursive' - Like `M-+
;;                  C-}', but save persistently to an Emacs fileset.
;;
;;    `M-+ C-M-}' - Save to a Lisp variable.
;;
;;
;;  In the other direction, if you have a saved set of file names then
;;  you can use `C-M-<' (`icicle-dired-chosen-files-other-window') in
;;  Dired to open a Dired buffer for just those files.  So you can
;;  mark some files and subdirs in a hierarchy of Dired buffers, use
;;  `M-+ C-}' to save their names persistently, then later use `C-{'
;;  to retrieve them, and `C-M-<' (in Dired) to open Dired on them.
;;
;;
;;  Image Files
;;  -----------
;;
;;  `Dired+' provides several enhancements regarding image files.
;;  Most of these require standard library `image-dired.el'.  One of
;;  them, command `diredp-do-display-images', which displays all of
;;  the marked image files, requires standard library `image-file.el'.
;;
;;  `Dired+' loads these libraries automatically, if available, which
;;  means an Emacs version that supports image display (Emacs 22 or
;;  later).  (You must of course have installed whatever else your
;;  Emacs version needs to display images.)
;;
;;  Besides command `diredp-do-display-images', see the commands whose
;;  names have prefix `diredp-image-'.  And see options
;;  `diredp-image-preview-in-tooltip' and
;;  `diredp-auto-focus-frame-for-thumbnail-tooltip-flag'.
;;
;;
;;  Inserted Subdirs, Multiple Dired Buffers, Files from Anywhere,...
;;  -----------------------------------------------------------------
;;
;;  These three standard Dired features are worth pointing out.  The
;;  third in particular is little known because (a) it is limited in
;;  vanilla Dired and (b) you cannot use it interactively.
;;
;;   * You can pass a glob pattern with wildcards to `dired'
;;     interactively, as the file name.
;;
;;   * You can insert multiple subdirectory listings into a single
;;     Dired buffer using `i' on each subdir line.  Use `C-u i' to
;;     specify `ls' switches.  Specifying switch `R' inserts the
;;     inserted subdirectory's subdirs also, recursively.  You can
;;     also use `i' to bounce between a subdirectory line and its
;;     inserted-listing header line.  You can delete a subdir listing
;;     using `C-u k' on its header line.  You can hide/show an
;;     inserted subdir using `$'.  You can use `C-_' to undo any of
;;     these operations.
;;
;;   * You can open a Dired buffer for an arbitrary set of files from
;;     different directories.  You do this by invoking `dired'
;;     non-interactively, passing it a cons of a Dired buffer name and
;;     the file names.  Relative file names are interpreted relative
;;     to the value of `default-directory'.  Use absolute file names
;;     when appropriate.
;;
;;  `Dired+' makes these features more useful.
;;
;;  `$' is improved: It is a simple toggle - it does not move the
;;  cursor forward.  `M-$' advances the cursor, in addition to
;;  toggling like `$'.  `C-u $' does hide/show all (what `M-$' does in
;;  vanilla Dired).
;;
;;  `i' is improved in these ways:
;;
;;   * Once a subdir has been inserted, `i' bounces between the subdir
;;     listing and the subdir line in the parent listing.  If the
;;     parent dir is hidden, then `i' from a subdir opens the parent
;;     listing so it can move to the subdir line there (Emacs 24+).
;;
;;   * Vanilla Dired lets you create a Dired listing with files and
;;     directories from arbitrary locations, but you cannot insert
;;     (`i') such a directory if it is not in the same directory tree
;;     as the `default-directory' used to create the Dired buffer.
;;     `Dired+' removes this limitation; you can insert any non-root
;;     directories (that is, not `/', `c:/', etc.).
;;
;;  `Dired+' lets you create Dired buffers that contain arbitrary
;;  files and directories interactively, not just using Lisp.  Just
;;  use a non-positive prefix arg (e.g., `C--') when invoking `dired'.
;;
;;  You are then prompted for the Dired buffer name (anything you
;;  like, not necessarily a directory name) and the individual files
;;  and directories that you want listed.
;;
;;  A non-negative prefix arg still prompts you for the `ls' switches
;;  to use.  (So `C-0' does both: prompts for `ls' switches and for
;;  the Dired buffer name and the files to list.)
;;
;;  `Dired+' adds commands for combining and augmenting Dired
;;  listings:
;;
;;   * `diredp-add-to-dired-buffer', bound globally to `C-x D A', lets
;;     you add arbitrary file and directory names to an existing Dired
;;     buffer.
;;
;;   * `diredp-dired-union', bound globally to `C-x D U', lets you
;;     take the union of multiple Dired listings, or convert an
;;     ordinary Dired listing to an explicit list of absolute file
;;     names.  With a non-positive prefix arg, you can add extra file
;;     and directory names, just as for `diredp-add-to-dired-buffer'.
;;
;;  You can open an Emacs fileset in Dired mode, using `C-x D S' or
;;  `C-x 4 D S'.  See the Emacs manual, node Filesets, or
;;  https://www.emacswiki.org/emacs/FileSets, for info about filesets.
;;
;;  You can visit your recent files or directories in Dired mode,
;;  using `C-x D R' or `C-x D r'.  Like the other commands on prefix
;;  key `C-x D', these Dired listings are composed of arbitrary files;
;;  they're not the output of `ls'.
;;
;;  You can sort any Dired buffer of arbitrary files in various ways,
;;  using `C-M-L' (aka `C-M-S-l').  You're prompted for the sort
;;  order.  The default sort order for such buffers is determined by
;;  option `diredp-default-sort-arbitrary-function'.  You can also
;;  revert such buffers, using `g'.  This applies to all Dired buffers
;;  created with the commands on prefix keys `C-x D' and `C-x 4 D'.
;;
;;  You can optionally add a header line to a Dired buffer using
;;  toggle command `diredp-breadcrumbs-in-header-line-mode'.  (A
;;  header line remains at the top of the window - no need to scroll
;;  to see it.)  If you want to show the header line automatically in
;;  all Dired buffers, you can do this:
;;
;;    (add-hook 'dired-before-readin-hook
;;              'diredp-breadcrumbs-in-header-line-mode)
;;
;;  Some other libraries, such as `Bookmark+' and `Icicles', make it
;;  easy to create or re-create Dired buffers that list specific files
;;  and have a particular set of markings.  `Bookmark+' records Dired
;;  buffers persistently, remembering `ls' switches, markings, subdir
;;  insertions, and hidden subdirs.  If you use `Icicles' then `dired'
;;  is a multi-command: you can open multiple Dired buffers with one
;;  `dired' invocation.
;;
;;  Dired can help you manage projects.  You might have multiple Dired
;;  buffers with quite specific contents.  You might have some
;;  subdirectories inserted in the same Dired buffer, and you might
;;  have separate Dired buffers for some subdirectories.  Sometimes it
;;  is useful to have both for the same subdirectory.  And sometimes
;;  it is useful to move from one presentation to the other.
;;
;;  This is one motivation for the `Dired+' `diredp-*-recursive'
;;  commands, which act on the marked files in marked subdirectories,
;;  recursively.  In one sense, these commands are an alternative to
;;  using a single Dired buffer with inserted subdirectories.  They
;;  let you use the same operations on the files in a set of Dired
;;  directories, without inserting those directories into an ancestor
;;  Dired buffer.
;;
;;  You can use command `diredp-dired-inserted-subdirs' to open a
;;  separate Dired buffer for each of the subdirs that is inserted in
;;  the current Dired buffer.  Markings and Dired switches are
;;  preserved.
;;
;;  In the opposite direction, if you use `Icicles' then you can use
;;  multi-command `icicle-dired-insert-as-subdir', which lets you
;;  insert any number of directories you choose interactively into a
;;  Dired ancestor directory listing.  If a directory you choose to
;;  insert already has its own Dired buffer, then its markings and
;;  switches are preserved for the new, subdirectory listing in the
;;  ancestor Dired buffer.
;;
;;
;;  Hide/Show Details
;;  -----------------
;;
;;  Starting with Emacs 24.4, listing details are hidden by default.
;;  Note that this is different from the vanilla Emacs behavior, which
;;  is to show details by default.
;;
;;  Use `(' anytime to toggle this hiding.  You can use option
;;  `diredp-hide-details-initially-flag' to change the default/initial
;;  state.  See also option `diredp-hide-details-propagate-flag'.
;;
;;  NOTE: If you do not want to hide details initially then you must
;;        either (1) change `diredp-hide-details-initially-flag' using
;;        Customize (recommended) or (2) set it to `nil' (e.g., using
;;        `setq') *BEFORE* loading `dired+.el'.
;;
;;  If you have an Emacs version older than 24.4, you can use library
;;  `dired-details+.el' (plus `dired-details.el') to get similar
;;  behavior.
;;
;;
;;  Mode-Line
;;  ---------
;;
;;  The number of files and dirs that are marked with `*', and the
;;  number that are flagged for deletion (marked `D') are indicated in
;;  the mode-line.  When the cursor is on such a line the indication
;;  tells you how many more there are.  For example, if the cursor is
;;  on the line of the third file that is marked `*', and there are
;;  seven of them total, then the mode-line shows `3/7*'.
;;
;;  The mode-line also indicates, for the current listing (which could
;;  be a subdir listing), how many files and dirs are listed.  If the
;;  cursor is on the 27th file in a listing of 78 files then the
;;  mode-line shows 27/78.
;;
;;  For counting files and dirs in a listing, option
;;  `diredp-count-.-and-..-flag' controls whether to count the lines
;;  for `.' and `..'.  By default it is nil, meaning they are not
;;  counted.
;;
;;
;;  If You Use Dired+ in Terminal Mode
;;  ----------------------------------
;;
;;  By default, Dired+ binds some keys that can be problematic in some
;;  terminals when you use Emacs in terminal mode (i.e., `emacs -nw').
;;  This is controlled by option
;;  `diredp-bind-problematic-terminal-keys'.
;;
;;  In particular, keys that use modifiers Meta and Shift together can
;;  be problematic.  If you use Dired+ in text-only terminal, and you
;;  find that your terminal does not support such keys, then you might
;;  want to customize the option to set the value to `nil', and then
;;  bind the commands to some other keys, which your terminal
;;  supports.
;;
;;  The problematic keys used by Dired+ include these:
;;
;;    `M-M'   (aka `M-S-m')   - `diredp-chmod-this-file'
;;    `M-O'   (aka `M-S-o')   - `diredp-chown-this-file'
;;    `M-T'   (aka `M-S-t')   - `diredp-touch-this-file'
;;    `C-M-B' (aka `C-M-S-b') - `diredp-do-bookmark-in-bookmark-file'
;;    `C-M-G' (aka `C-M-S-g') - `diredp-chgrp-this-file'
;;    `C-M-R' (aka `C-M-S-r') - `diredp-toggle-find-file-reuse-dir'
;;    `C-M-T' (aka `C-M-S-t') - `dired-do-touch'
;;    `M-+ M-B'   (aka `M-+ M-S-b') -
;;        `diredp-do-bookmark-dirs-recursive'
;;    `M-+ C-M-B' (aka `M-+ C-M-S-b') -
;;        `diredp-do-bookmark-in-bookmark-file-recursive'
;;    `M-+ C-M-T' (aka `M-+ C-M-S-t') - `diredp-do-touch-recursive'
;;
;;  (See also `(info "(org) TTY keys")' for more information about
;;  keys that can be problematic in a text-only terminal.)
;;
;;
;;  Faces defined here:
;;
;;    `diredp-autofile-name', `diredp-compressed-file-suffix',
;;    `diredp-date-time', `diredp-deletion',
;;    `diredp-deletion-file-name', `diredp-dir-heading',
;;    `diredp-dir-priv', `diredp-exec-priv', `diredp-executable-tag',
;;    `diredp-file-name', `diredp-file-suffix', `diredp-flag-mark',
;;    `diredp-flag-mark-line', `diredp-get-file-or-dir-name',
;;    `diredp-ignored-file-name', `diredp-link-priv',
;;    `diredp-mode-line-flagged', `diredp-mode-line-marked'
;;    `diredp-omit-file-name', `diredp-no-priv', `diredp-number',
;;    `diredp-other-priv', `diredp-rare-priv', `diredp-read-priv',
;;    `diredp-symlink', `diredp-tagged-autofile-name',
;;    `diredp-write-priv'.
;;
;;  Commands defined here:
;;
;;    `diredp-add-file-to-recentf', `diredp-add-this-to-recentf',
;;    `diredp-add-to-dired-buffer', `diredp-add-to-this-dired-buffer',
;;    `diredp-async-shell-command-this-file',
;;    `diredp-bookmark-this-file',
;;    `diredp-breadcrumbs-in-header-line-mode' (Emacs 22+),
;;    `diredp-byte-compile-this-file', `diredp-capitalize',
;;    `diredp-capitalize-recursive', `diredp-capitalize-this-file',
;;    `diredp-change-ls-switches', `diredp-change-marks-recursive'
;;    (Emacs 22+), `diredp-chgrp-this-file', `diredp-chmod-this-file',
;;    `diredp-chown-this-file',
;;    `diredp-compilation-files-other-window' (Emacs 24+),
;;    `diredp-compress-this-file',
;;    `diredp-copy-abs-filenames-as-kill',
;;    `diredp-copy-abs-filenames-as-kill-recursive',
;;    `diredp-copy-filename-as-kill-recursive',
;;    `diredp-copy-tags-this-file', `diredp-copy-this-file',
;;    `diredp-decrypt-this-file', `diredp-delete-this-file',
;;    `diredp-describe-autofile', `diredp-describe-file',
;;    `diredp-describe-marked-autofiles', `diredp-describe-mode',
;;    `diredp-dired-for-files', `diredp-dired-for-files-other-window',
;;    `diredp-dired-inserted-subdirs', `diredp-dired-plus-help',
;;    `diredp-dired-recent-dirs',
;;    `diredp-dired-recent-dirs-other-window',
;;    `diredp-dired-recent-files',
;;    `diredp-dired-recent-files-other-window',
;;    `diredp-dired-this-subdir', `diredp-dired-union',
;;    `diredp-do-add-to-recentf',
;;    `diredp-do-aggregate-apply-to-marked',
;;    `diredp-do-aggregate-eval-in-marked',
;;    `diredp-do-apply/eval-marked',
;;    `diredp-do-apply/eval-marked-recursive',
;;    `diredp-do-apply-to-marked',
;;    `diredp-do-apply-to-marked-recursive',
;;    `diredp-do-async-shell-command-recursive', `diredp-do-bookmark',
;;    `diredp-do-bookmark-dirs-recursive',
;;    `diredp-do-bookmark-in-bookmark-file',
;;    `diredp-do-bookmark-in-bookmark-file-recursive',
;;    `diredp-do-bookmark-recursive', `diredp-do-chmod-recursive',
;;    `diredp-do-chgrp-recursive', `diredp-do-chown-recursive',
;;    `diredp-do-command-in-marked',
;;    `diredp-do-command-in-marked-recursive',
;;    `diredp-do-copy-recursive', `diredp-do-decrypt-recursive',
;;    `diredp-do-delete-recursive', `diredp-do-display-images' (Emacs
;;    22+), `diredp-do-encrypt-recursive', `diredp-do-eval-in-marked',
;;    `diredp-do-eval-in-marked-recursive',
;;    `diredp-do-find-marked-files-recursive', `diredp-do-grep',
;;    `diredp-do-grep-recursive', `diredp-do-hardlink-recursive',
;;    `diredp-do-isearch-recursive',
;;    `diredp-do-isearch-regexp-recursive',
;;    `diredp-do-move-recursive', `diredp-do-paste-add-tags',
;;    `diredp-do-paste-replace-tags', `diredp-do-print-recursive',
;;    `diredp-do-query-replace-regexp-recursive',
;;    `diredp-do-redisplay-recursive',
;;    `diredp-do-relsymlink-recursive', `diredp-do-remove-all-tags',
;;    `diredp-do-remove-from-recentf', `diredp-do-search-recursive',
;;    `diredp-do-set-tag-value', `diredp-do-shell-command-recursive',
;;    `diredp-do-sign-recursive', `diredp-do-symlink-recursive',
;;    `diredp-do-tag', `diredp-do-touch-recursive', `diredp-do-untag',
;;    `diredp-do-verify-recursive', `diredp-downcase-recursive',
;;    `diredp-downcase-this-file', `diredp-ediff',
;;    `diredp-encrypt-this-file', `diredp-fileset',
;;    `diredp-fileset-other-window', `diredp-find-a-file',
;;    `diredp-find-a-file-other-frame',
;;    `diredp-find-a-file-other-window',
;;    `diredp-find-file-other-frame',
;;    `diredp-find-file-reuse-dir-buffer',
;;    `diredp-find-line-file-other-window',
;;    `diredp-flag-auto-save-files-recursive',
;;    `diredp-flag-region-files-for-deletion',
;;    `diredp-grepped-files-other-window', `diredp-grep-this-file',
;;    `diredp-hardlink-this-file', `diredp-highlight-autofiles-mode',
;;    `diredp-image-dired-comment-file',
;;    `diredp-image-dired-comment-files-recursive',
;;    `diredp-image-dired-copy-with-exif-name',
;;    `diredp-image-dired-create-thumb',
;;    `diredp-image-dired-delete-tag',
;;    `diredp-image-dired-delete-tag-recursive',
;;    `diredp-image-dired-display-thumb',
;;    `diredp-image-dired-display-thumbs-recursive',
;;    `diredp-image-dired-edit-comment-and-tags',
;;    `diredp-image-dired-tag-file',
;;    `diredp-image-dired-tag-files-recursive',
;;    `diredp-image-show-this-file', `diredp-insert-as-subdir',
;;    `diredp-insert-subdirs', `diredp-insert-subdirs-recursive',
;;    `diredp-kill-this-tree', `diredp-list-marked-recursive',
;;    `diredp-load-this-file', `diredp-mark', `diredp-mark-autofiles',
;;    `diredp-marked', `diredp-marked-other-window',
;;    `diredp-marked-recursive',
;;    `diredp-marked-recursive-other-window',
;;    `diredp-mark-extension-recursive',
;;    `diredp-mark-files-containing-regexp-recursive',
;;    `diredp-mark-files-regexp-recursive',
;;    `diredp-mark-files-tagged-all', `diredp-mark-files-tagged-none',
;;    `diredp-mark-files-tagged-not-all',
;;    `diredp-mark-files-tagged-some',
;;    `diredp-mark-files-tagged-regexp', `diredp-mark-region-files',
;;    `diredp-mark-region-files-with-char',
;;    `diredp-mark-sexp-recursive' (Emacs 22+),
;;    `diredp-mark/unmark-autofiles', `diredp-mark/unmark-extension',
;;    `diredp-mark-with-char', `diredp-mouse-3-menu',
;;    `diredp-mouse-backup-diff', `diredp-mouse-copy-tags',
;;    `diredp-mouse-describe-autofile', `diredp-mouse-describe-file',
;;    `diredp-mouse-diff', `diredp-mouse-do-bookmark',
;;    `diredp-mouse-do-byte-compile', `diredp-mouse-do-chgrp',
;;    `diredp-mouse-do-chmod', `diredp-mouse-do-chown',
;;    `diredp-mouse-do-compress', `diredp-mouse-do-copy',
;;    `diredp-mouse-do-delete', `diredp-mouse-do-grep',
;;    `diredp-mouse-do-hardlink', `diredp-mouse-do-load',
;;    `diredp-mouse-do-print', `diredp-mouse-do-remove-all-tags',
;;    `diredp-mouse-do-rename', `diredp-mouse-do-set-tag-value',
;;    `diredp-mouse-do-shell-command', `diredp-mouse-do-symlink',
;;    `diredp-mouse-do-tag', `diredp-mouse-do-untag',
;;    `diredp-mouse-downcase', `diredp-mouse-ediff',
;;    `diredp-mouse-find-line-file-other-window',
;;    `diredp-mouse-find-file-other-frame',
;;    `diredp-mouse-find-file-reuse-dir-buffer',
;;    `diredp-mouse-flag-file-deletion', `diredp-mouse-mark',
;;    `diredp-mouse-mark-region-files', `diredp-mouse-mark/unmark',
;;    `diredp-mouse-unmark', `diredp-mouse-upcase',
;;    `diredp-mouse-view-file', `diredp-move-file' (Emacs 24+),
;;    `diredp-multiple-w32-browser-recursive',
;;    `diredp-nb-marked-in-mode-name', `diredp-next-dirline',
;;    `diredp-next-line', `diredp-next-subdir', `diredp-omit-marked',
;;    `diredp-omit-unmarked', `diredp-paste-add-tags-this-file',
;;    `diredp-paste-files', `diredp-paste-replace-tags-this-file',
;;    `diredp-prev-dirline', `diredp-previous-line',
;;    `diredp-prev-subdir', `diredp-print-this-file',
;;    `diredp-quit-window-kill' (Emacs 24+),
;;    `diredp-relsymlink-this-file',
;;    `diredp-remove-all-tags-this-file',
;;    `diredp-remove-file-from-recentf',
;;    `diredp-remove-this-from-recentf', `diredp-rename-this-file',
;;    `diredp-send-bug-report',
;;    `diredp-set-bookmark-file-bookmark-for-marked',
;;    `diredp-set-bookmark-file-bookmark-for-marked-recursive',
;;    `diredp-set-tag-value-this-file',
;;    `diredp-shell-command-this-file', `diredp-show-metadata',
;;    `diredp-show-metadata-for-marked', `diredp-sign-this-file',
;;    `diredp-sort-arbitrary-command', `diredp-symlink-this-file',
;;    `diredp-tag-this-file', `diredp-toggle-find-file-reuse-dir',
;;    `diredp-toggle-marks-in-region', `diredp-touch-this-file',
;;    `diredp-unmark-all-files-recursive' (Emacs 22+),
;;    `diredp-unmark-all-marks-recursive' (Emacs 22+),
;;    `diredp-unmark-autofiles', `diredp-unmark-files-tagged-all',
;;    `diredp-unmark-files-tagged-none',
;;    `diredp-unmark-files-tagged-not-all',
;;    `diredp-unmark-files-tagged-some', `diredp-unmark-region-files',
;;    `diredp-untag-this-file', `diredp-upcase-recursive',
;;    `diredp-up-directory', `diredp-up-directory-reuse-dir-buffer',
;;    `diredp-upcase-this-file', `diredp-verify-this-file',
;;    `diredp-visit-next-file', `diredp-visit-previous-file',
;;    `diredp-visit-this-file', `diredp-w32-drives',
;;    `diredp-w32-drives-mode', `diredp-yank-files',
;;    `global-dired-hide-details-mode' (Emacs 24.4+),
;;    `toggle-diredp-find-file-reuse-dir'.
;;
;;  User options defined here:
;;
;;    `diredp-auto-focus-frame-for-thumbnail-tooltip-flag',
;;    `diredp-bind-problematic-terminal-keys',
;;    `diredp-case-fold-search', `diredp-compressed-extensions',
;;    `diredp-count-.-and-..-flag' (Emacs 22+),
;;    `diredp-default-sort-arbitrary-function',
;;    `diredp-do-report-echo-limit', `diredp-dwim-any-frame-flag'
;;    (Emacs 22+), `diredp-image-preview-in-tooltip', `diff-switches',
;;    `diredp-hide-details-initially-flag' (Emacs 24.4+),
;;    `diredp-highlight-autofiles-mode',
;;    `diredp-hide-details-propagate-flag' (Emacs 24.4+),
;;    `diredp-ignore-compressed-flag',
;;    `diredp-image-show-this-file-use-frame-flag' (Emacs 22+),
;;    `diredp-list-file-attributes', `diredp-max-frames',
;;    `diredp-move-file-dirs' (Emacs 24+),
;;    `diredp-omit-files-font-lock-regexp',
;;    `diredp-omit-lines-regexp',
;;    `diredp-prompt-for-bookmark-prefix-flag',
;;    `diredp-recent-files-quit-kills-flag',
;;    `diredp-switches-in-mode-line',
;;    `diredp-visit-ignore-extensions', `diredp-visit-ignore-regexps',
;;    `diredp-w32-local-drives', `diredp-wrap-around-flag'.
;;
;;  Non-interactive functions defined here:
;;
;;    `derived-mode-p' (Emacs < 22),
;;    `diredp--add-dired-to-invisibility-hook', `diredp-all-files',
;;    `diredp-ancestor-dirs', `diredp-apply-to-this-file',
;;    `diredp-bookmark', `diredp-cannot-revert',
;;    `diredp-copy-as-kill-from-clipboard',
;;    `diredp-create-files-non-directory-recursive',
;;    `diredp-delete-dups', `diredp-delete-if',
;;    `diredp-delete-if-not', `diredp-directories-within',
;;    `diredp-dired-plus-description',
;;    `diredp-dired-plus-description+links',
;;    `diredp-dired-plus-help-link', `diredp--dired-recent-files-1',
;;    `diredp-dired-union-1', `diredp-dired-union-interactive-spec',
;;    `diredp-display-image' (Emacs 22+), `diredp-do-chxxx-recursive',
;;    `diredp-do-create-files-recursive', `diredp-do-grep-1',
;;    `diredp-ensure-bookmark+', `diredp-ensure-fn-nonzero-arity',
;;    `diredp-ensure-fn-zero-arity', `diredp-ensure-mode',
;;    `diredp-eval-in-this-file', `diredp-existing-dired-buffer-p',
;;    `diredp-fewer-than-2-files-p',
;;    `diredp-fewer-than-echo-limit-files-p',
;;    `diredp-fewer-than-N-files-p', `diredp-fileset-1',
;;    `diredp-find-a-file-read-args',
;;    `diredp-file-for-compilation-hit-at-point' (Emacs 24+),
;;    `diredp-files-within', `diredp-files-within-1',
;;    `diredp-fit-frame-unless-buffer-narrowed' (Emacs 24.4+),
;;    `diredp-full-file-name-less-p', `diredp-full-file-name-more-p',
;;    `diredp-get-confirmation-recursive', `diredp-get-files',
;;    `diredp-get-files-for-dir', `diredp-get-image-filename',
;;    `diredp-get-subdirs', `diredp-hide-details-if-dired' (Emacs
;;    24.4+), `diredp-hide/show-details' (Emacs 24.4+),
;;    `diredp-highlight-autofiles', `diredp-image-dired-required-msg',
;;    `diredp-internal-do-deletions', `diredp-invoke-command',
;;    `diredp-invoke/eval-in-this-file', `diredp-invoke-in-this-file',
;;    `diredp-list-file', `diredp-list-files', `diredp-looking-at-p',
;;    `diredp-make-find-file-keys-reuse-dirs',
;;    `diredp-make-find-file-keys-not-reuse-dirs',
;;    `diredp-make-obsolete', `diredp-make-obsolete-variable',
;;    `diredp-maplist', `diredp-map-over-marks-and-report',
;;    `diredp-marked-here', `diredp-mark-files-tagged-all/none',
;;    `diredp-mark-files-tagged-some/not-all',
;;    `diredp-nondir-file-name-less-p',
;;    `diredp-nondir-file-name-more-p', `diredp-nonempty-region-p',
;;    `diredp-parent-dir', `diredp-paste-add-tags',
;;    `diredp-paste-replace-tags', `diredp-prefix-arg-all-files',
;;    `diredp-read-bookmark-file-args', `diredp-read-command',
;;    `diredp-read-expression' (Emacs 22+),
;;    `diredp-read-include/exclude', `diredp-read-regexp',
;;    `diredp-recent-dirs', `diredp-recent-files-buffer',
;;    `diredp-refontify-buffer', `diredp-remove-if',
;;    `diredp-remove-if-not', `diredp-report-file-result',
;;    `diredp-report-summary',
;;    `diredp-revert-displayed-recentf-buffers',
;;    `diredp--reuse-dir-buffer-helper', `diredp-root-directory-p',
;;    `diredp-set-header-line-breadcrumbs' (Emacs 22+),
;;    `diredp-set-tag-value', `diredp-set-union',
;;    `diredp--set-up-font-locking', `diredp-sort-arbitrary',
;;    `diredp-string-less-p', `diredp-string-match-p', `diredp-tag',
;;    `diredp-this-file-marked-p', `diredp-this-file-unmarked-p',
;;    `diredp-this-subdir', `diredp-untag',
;;    `diredp-visit-ignore-regexp', `diredp-y-or-n-files-p'.
;;
;;  Variables defined here:
;;
;;    `diredp-bookmark-menu', `diredp-file-line-overlay',
;;    `diredp-filename-separator', `diredp-files-within-dirs-done',
;;    `diredp-font-lock-keywords-1', `diredp-hide-details-last-state'
;;    (Emacs 24.4+), `diredp-hide-details-toggled' (Emacs 24.4+),
;;    `diredp-hide/show-menu', `diredp-images-recursive-menu',
;;    `diredp-last-copied-filenames', `diredp-list-files-map',
;;    `diredp-loaded-p', `diredp-marks-recursive-menu',
;;    `diredp-menu-bar-dir-menu', `diredp-menu-bar-marks-menu',
;;    `diredp-menu-bar-multiple-menu', `diredp-menu-bar-regexp-menu',
;;    `diredp-menu-bar-single-menu', `diredp-multiple-bookmarks-menu',
;;    `diredp-multiple-delete-menu', `diredp-multiple-dired-menu',
;;    `diredp-multiple-images-menu',
;;    `diredp-multiple-encryption-menu',
;;    `diredp-multiple-move-copy-link-menu',
;;    `diredp-multiple-omit-menu', `diredp-multiple-recursive-menu',
;;    `diredp-multiple-rename-menu', `diredp-multiple-search-menu',
;;    `diredp-navigate-menu', `diredp-recent-files-map',
;;    `diredp-regexp-recursive-menu', `diredp-re-no-dot',
;;    `diredp-single-bookmarks-menu', `diredp-single-encryption-menu',
;;    `diredp-single-image-menu', `diredp-single-move-copy-link-menu',
;;    `diredp-single-open-menu', `diredp-single-rename-menu',
;;    `diredp-w32-drives-mode-map'.
;;
;;  Macros defined here:
;;
;;    `diredp-mark-if', `diredp-user-error',
;;    `diredp-with-help-window'.
;;
;;
;;  ***** NOTE: The following macro defined in `subr.el' has
;;              been REDEFINED HERE:
;;
;;  `with-silent-modifications' - Adapt for older Emacs also.
;;
;;  ***** NOTE: The following macros defined in `dired.el' have
;;              been REDEFINED HERE:
;;
;;  `dired-map-over-marks'    - Treat multiple `C-u' specially.
;;
;;
;;  ***** NOTE: The following functions defined in `dired.el' have
;;              been REDEFINED or ADVISED HERE:
;;
;;  `dired'                   - Handle non-positive prefix arg.
;;  `dired-do-delete'         - Display message to warn that marked,
;;                              not flagged, files will be deleted.
;;  `dired-do-flagged-delete' - Display message to warn that flagged,
;;                              not marked, files will be deleted.
;;  `dired-dwim-target-directory' - Uses `diredp-dwim-any-frame-flag'.
;;  `dired-find-file'         - Allow `.' and `..' (Emacs 20 only).
;;  `dired-get-filename'      - Test `./' and `../' (like `.', `..').
;;  `dired-get-marked-files'  - Can include `.' and `..'.
;;                              Allow FILTER + DISTINGUISH-ONE-MARKED.
;;  `dired-goto-file'         - Fix Emacs bug #7126.
;;                              Remove `/' from dir before compare.
;;                              (Emacs < 24 only.)
;;  `dired-hide-details-mode' - Respect new user options:
;;                              * `diredp-hide-details-initially-flag'
;;                              * `diredp-hide-details-propagate-flag'
;;                              (Emacs 24.4+)
;;  `dired-insert-directory'  - Compute WILDCARD arg for
;;                              `insert-directory' for individual file
;;                              (don't just use nil). (Emacs 23+, and
;;                              only for MS Windows)
;;  `dired-insert-set-properties' - `mouse-face' on whole line.
;;  `dired-flag-auto-save-files', `dired-mark-directories',
;;  `dired-mark-executables', `dired-mark-files-containing-regexp',
;;  `dired-mark-files-regexp', `dired-mark-symlinks'
;;                            - Use `diredp-mark-if', not `dired-mark-if'.
;;  `dired-mark-files-regexp' - Add regexp to `regexp-search-ring'.
;;                              More matching possibilities.
;;                              Added optional arg LOCALP.
;;  `dired-mark-pop-up'       - Delete the window or frame popped up,
;;                              afterward, and bury its buffer. Do not
;;                              show a menu bar for pop-up frame.
;;  `dired-move-to-filename'  - Made it a command.
;;  `dired-other-frame'       - Handle non-positive prefix arg.
;;  `dired-other-window'      - Handle non-positive prefix arg.
;;  `dired-pop-to-buffer'     - Put window point at bob (bug #12281).
;;                              (Emacs 22-24.1)
;;  `dired-read-dir-and-switches' - Non-positive prefix arg behavior.
;;
;;; NOT YET:
;;; ;;  `dired-readin-insert'     - Use t as WILDCARD arg to
;;; ;;                              `dired-insert-directory'.  (Emacs 23+,
;;; ;;                              and only for MS Windows)
;;
;;  `dired-revert'            - Reset `mode-line-process' to nil.
;;  `dired-sort-set-mode-line' - Respect `diredp-switches-in-mode-line'.
;;  `dired-switches-escape-p' - Made compatible with Emacs 20, 21.
;;
;;
;;  ***** NOTE: The following functions are included here with little
;;              or no change to their definitions.  They are here to
;;              take advantage of the new definition of macro
;;              `dired-map-over-marks':
;;
;;  `dired-do-redisplay', `dired-map-over-marks-check',
;;  `image-dired-dired-insert-marked-thumbs',
;;  `image-dired-dired-toggle-marked-thumbs'.
;;
;;
;;  ***** NOTE: The following functions are included here with little
;;              or no change to their definitions.  They are here for
;;              older Emacs versions, to take advantage of the Emacs
;;              27+ way of hiding subdir listings:
;;
;;  `dired--find-hidden-pos', `dired--hidden-p', `dired--hide',
;;  `dired--unhide', `dired-remember-marks', `dired-unhide-subdir',
;;  `dired-subdir-hidden-p', `dired-add-entry',
;;  `dired-remember-hidden', `dired-move-to-end-of-filename',
;;  `dired-check-switches', `dired-hide-subdir', `dired-hide-all'.
;;
;;
;;  ***** NOTE: The following functions defined in `dired-aux.el' have
;;              been REDEFINED HERE:
;;
;;  `dired-do-byte-compile', `dired-do-compress', `dired-do-load' -
;;     Redisplay only if at most one file is being treated.
;;  `dired-do-find-regexp', `dired-do-find-regexp-and-replace' -
;;     Prefix arg lets you act on files other than those marked.
;;  `dired-do-isearch', `dired-do-isearch-regexp',
;;     `dired-do-query-replace-regexp', `dired-do-search' -
;;        Use new `dired-get-marked-files'.
;;  `dired-insert-subdir-newpos' - If not a descendant, put at eob.
;;  `dired-insert-subdir-validate' - Do nothing: no restrictions.
;;  `dired-do-kill-lines' - Added optional arg INIT-COUNT.
;;  `dired-maybe-insert-subdir' - Go back to subdir line if in listing.
;;  `dired-handle-overwrite' - Added optional arg FROM, for listing.
;;  `dired-copy-file(-recursive)', `dired-hardlink', `dired-query',
;;     `dired-rename-file' - You can list (`l') the files involved.
;;
;;
;;  ***** NOTE: The following functions defined in `dired-x.el' have
;;              been REDEFINED HERE:
;;
;;  `dired-copy-filename-as-kill' -
;;     Use `diredp-filename-separator', not SPC, as the separator.
;;     Put file names also in var `diredp-last-copied-filenames'.
;;  `dired-do-find-marked-files' -
;;     Call `dired-get-marked-files' with original ARG.
;;     Added optional arg INTERACTIVEP - no error if nil and no files.
;;  `dired-do-run-mail' - Require confirmation.
;;  `dired-mark-sexp' - 1. Variable `s' -> `blks'.
;;                      2. Fixes to `uid' and `gid'.
;;  `dired-mark-unmarked-files' (Emacs < 24 only) - Emacs 24+ version.
;;  `dired-omit-expunge' - Added optional args LINEP and INIT-COUNT.
;;  `dired-omit-mode' -  Call `dired-omit-expunge' with arg LINEP.
;;  `dired-simultaneous-find-file' -
;;     Use separate frames instead of windows if `pop-up-frames' is
;;     non-nil, or if prefix arg < 0.
;;
;;
;;  ***** NOTE: (Emacs 20 only) The following variable defined in
;;        `dired.el' has been REDEFINED HERE:
;;
;;  `dired-move-to-filename-regexp' - Recognize file size in k etc.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/05/10 dadams
;;     diredp-copy-filename-as-kill-recursive: use diredp-filename-separator, not SPC.
;;     dired-copy-filename-as-kill, diredp-yank-files: Mention diredp-filename-separator in doc string.
;;     diredp-copy-abs-filenames-as-kill-recursive: Corrected doc string to mention diredp-last-copied-filenames.
;; 2021/04/20 dadams
;;     Added: dired-move-to-filename, and made it a command.
;; 2021/04/14 dadams
;;     diredp-menu-bar-dir-menu: Added dired-undo.
;; 2021/03/20 dadams
;;     Added: diredp--dired-recent-files-1.
;;     diredp-recent-files-buffer is for dirs also now.
;;     diredp-dired-recent-(files|dirs)(-other-window):
;;       Added FILES arg.  Use diredp--dired-recent-files-1.  Revert-buffer respects prefix arg, else relists same.
;;     diredp-read-include/exclude: Added optional arg keep-duplicates-p.  Delete dups by default.
;; 2021/03/19 dadams
;;     Added: diredp-case-fold-search, diredp-default-sort-arbitrary-function, diredp-sort-arbitrary-command,
;;            diredp-sort-arbitrary, diredp-string-less-p, diredp-(full|nondir)-file-name-(less|more)-p.
;;     diredp-dired-recent-(files|dirs)(-other-window): Apply diredp-sort-arbitrary.
;;     diredp-dired-recent-dirs(-other-window): Made revert-buffer-function a local var (forgot this).
;;     diredp-sort-arbitrary-command: Add to diredp-menu-bar-dir-menu and bind to C-M-L.
;; 2021/03/10 dadams
;;     Added: diredp-copy-as-kill-from-clipboard.
;;     diredp-yank-files: You can now also yank the file names from the clipboard.
;; 2021/03/03 dadams
;;     Renamed: diredp-omit-files-regexp to diredp-omit-files-font-lock-regexp,
;;              diredp-omit-line-regexp to diredp-omit-lines-regexp.
;;     diredp-omit-lines-regexp: Value can also be a variable whose value is a regexp.
;;     dired-omit-expunge: If REGEXP is a variable, use its value.
;; 2021/03/02 dadams
;;     Added: diredp-omit-line-regexp, redefinitions of dired-do-kill-lines, dired-omit-expunge, dired-omit-mode.
;; 2021/02/07 dadams
;;     Added: diredp-mark.  Give it dired-mark's keys.
;;     diredp-mark-region-files: Non-negative prefix arg now prompts for the CHAR to mark with.
;; 2021/02/04 dadams
;;     diredp-mark(-region-files)-with-char: Updated since bug #46243 is now fixed (for Emacs 28+).
;; 2021/02/01 dadams
;;     Added: diredp-mark-region-files-with-char, diredp-mark-with-char.
;;     diredp-marks-mark-menu, diredp-mouse-3-menu: Added items for diredp-mark(-region-files)-with-char.
;; 2021/01/02 dadams
;;     Updates for Emacs 27.1.
;;       dired-map-over-marks-check: Use ngettext for Emacs 27.
;;       dired-do-search, dired-do-query-replace-regexp: Use filecl-loop-initialize-(search|replace) for Emacs 27.
;;       dired-do-find-regexp: Require xref.el.  Map over rgrep-find-ignored-directories.
;;                             For Emacs 27+, xref--show-xrefs needs a fetcher function, not a file list.
;; 2020/12/27 dadams
;;     dired(p)-do-find-marked-files(-recursive): Don't pass plain C-u as arg to dired-simultaneous-find-file.
;; 2020/12/05 dadams
;;     diredp-re-no-dot:
;;       Changed value to be that of directory-files-no-dot-files-regexp.  See comment in code.
;;       This value is OK for use by directory-files, at least.
;;       See https://lists.gnu.org/archive/html/emacs-devel/2020-04/msg00764.html and followups.
;; 2020/12/01 dadams
;;     dired-mark-files-regexp: For Lisp, swapped nil and non-nil (other than no-dir) cases of
;;       last arg, to be compatible with vanilla Emacs.  (No change to interactive behavior.)
;;       So it's no longer true that the last arg is just passed to dired-get-filename as LOCALP.
;;     diredp-menu-bar-regexp-menu, diredp-marks-(un)mark-menu: Adjusted last arg to dired-mark-files-regexp.
;; 2020/10/12 dadams
;;     diredp--add-dired-to-invisibility-hook: Correction for Emacs 20.
;; 2020/10/06 dadams
;;     Changes to use the Emacs 27+ way of hiding subdir listings.
;;       Added: macro with-silent-modifications (with changes to work with older Emacs).
;;       Added: dired--find-hidden-pos, dired--hidden-p, dired--hide, dired--unhide, dired-remember-marks,
;;              dired-unhide-subdir, dired-subdir-hidden-p, dired-add-entry, dired-remember-hidden,
;;              dired-move-to-end-of-filename, dired-check-switches, dired-hide-subdir, dired-hide-all.
;; 2020/09/04 dadams
;;     dired-rename-file: Applied fix for bug #32899.
;; 2020/06/24 dadams
;;     dired-do-find-regexp-and-replace: Bug fix: let -> let*.
;; 2020/03/16 dadams
;;     diredp-(un)mark-region-files, diredp-flag-region-files-for-deletion, diredp-toggle-marks-in-region:
;;       Added (when (and (bolp) (> end beg)) (backward-char)) for end pos (Emacs bug #39902).
;; 2020/01/12 dadams
;;     Added:diredp-make-obsolete, diredp-make-obsolete-variable.  Use everywhere.
;; 2020/01/05 dadams
;;     diredp-font-lock-keywords-1: Fixed typo: Second diredp-rare-priv occurrence -> diredp-link-priv.
;; 2020/01/04 dadams
;;     diredp-font-lock-keywords-1: Removed .* after dired-move-to-filename-regexp.  Thx to Axel Svensson.
;; 2019/12/28 dadams
;;     diredp-y-or-n-files-p: Restore echo area when done.
;; 2019/12/26 dadams
;;     Added: diredp-maybe-save-visited.
;;     Renamed: diredp-do-apply/eval(-recursive) to diredp-do-apply/eval-marked(-recursive).
;;     diredp-do-(apply-to|eval-in|invoke-in|command-in|apply/eval)-marked(-recursive): Use diredp-maybe-save-visited
;; 2019/12/23 dadams
;;     Added: diredp-do-aggregate-apply-to-marked-recursive, diredp-ensure-fn-nonzero-arity,
;;            diredp-ensure-fn-zero-arity.
;;     diredp-get-file-or-dir-name: Added optional LOCALP arg.  No longer local (by default).
;;     diredp-do-(apply-to|eval-in|invoke-in|apply/eval)-marked-recursive: Return list of results.
;;     diredp-(apply-to|invoke-in|eval-in|invoke/eval-in)-this-file, diredp-invoke-command:
;;         Get absolute, not relative, file name with dired-get-filename.
;; 2019/12/22 dadams
;;     Added: diredp-do-aggregate-apply-to-marked, diredp-do-aggregate-invoke-in-marked,
;;            diredp-do-aggregate-eval-in-marked, diredp-do-command/macro-in-marked-recursive, diredp-report-summary.
;;     Renamed: diredp-do-emacs-command to diredp-do-command/macro-in-marked,
;;              diredp-invoke-emacs-command to diredp-invoke-command.
;;     diredp-report-file-result: Return RESULT (input arg).
;;     Bound to keys and added to new submenus: diredp-do-(apply-to|invoke-in|eval-in|command)-marked(-recursive).
;;     Removed bindings for diredp-do-apply/eval(-recursive).
;;     Updated diredp-dired-plus-description.
;; 2019/12/19 dadams
;;     Added: diredp-do-eval-in-marked-recursive.
;;     Renamed diredp-eval-lisp-sexp to diredp-eval-in-this-file,
;;             diredp-do-lisp-sexp   to diredp-do-eval-in-marked.
;;     diredp-do-apply/eval-recursive: Pass ARG to diredp-get-files, unless single C-u.
;;     diredp-do-(apply-to|invoke-in|apply/eval)-marked(-recursive),
;;       diredp-(apply-to|invoke-in|invoke/eval)-this-file: Raise error if wrong-arity function.
;;     diredp-(apply-to|invoke-in|invoke/eval|eval)-this-file:
;;       Added ARG, passed to diredp-get-file-or-dir-name if multiple C-u .
;; 2019/12/18 dadams
;;     Added: diredp-filename-separator.  Use in dired-copy-filename-as-kill, diredp-yank-files, to allow spaces
;;            etc. in file names.  (Suggested by Alex Bernhofer.)
;;     Renamed: diredp-apply-function-to-file-name to diredp-apply-to-this-file.
;; 2019/12/14 dadams
;;     Added: diredp-prefix-arg-all-files, diredp-do-apply-to-marked, diredp-do-apply-to-marked-recursive,
;;            diredp-do-invoke-in-marked, diredp-do-invoke-in-marked-recursive.
;;     dired-map-over-marks: Fixed for ARG = 256: use diredp-prefix-arg-all-files.
;;     diredp-apply-function-to-file-name, diredp-invoke-in-this-file:
;;       Added second arg (raw prefix arg) - pass it to diredp-get-file-or-dir-name.
;; 2019/12/08 dadams
;;     Renamed: diredp-invoke-function-no-args to diredp-invoke-in-this-file.
;; 2019/12/05 dadams
;;     Added: diredp-invoke/eval-in-this-file.
;;     Renamed: diredp-do-apply-function(-recursive) to diredp-do-apply/eval(-recursive).
;;     diredp-do-apply/eval(-recursive): With C-u, can handle a sexp, not just a function name.
;;     diredp-do-apply/eval-recursive: Pass nil as first arg to diredp-get-files, for non-C-u case.
;;     diredp-(do|eval)-lisp-sexp: No longer only for Emacs 22+.
;;     diredp-read-expression: Usable with any Emacs version.  No longer aliased to read--expression.
;;     diredp-dired-plus-description: Updated for command renamings.  Remove mention of diredp-do-lisp-sexp.
;; 2019/10/22 dadams
;;     Added: diredp-recent-files-map, diredp-recent-files-quit-kills-flag, diredp-quit-window-kill.
;;     diredp-dired-recent-files(-other-window):
;;       (use-local-map diredp-recent-files-map)
;;       (set (make-local-variable 'revert-buffer-function)...), not setq.
;; 2019/10/21 dadams
;;     Added: diredp-revert-displayed-recentf-buffers, diredp-recent-files-buffer.
;;     diredp-list-file-attributes: Corrected - either a list of integers or a non-list.
;;     diredp-list-marked: Pass nil to dired-get-marked-files for DISTINGUISH-ONE-MARKED arg.
;;     diredp-dired-recent-files(-other-window): (set (make-local-variable 'diredp-recent-files-buffer) bufname)
;;     diredp-do-(add-to|remove-from)-recentf: Call diredp-revert-displayed-recentf-buffers afterward.
;;     diredp-add-file-to-recentf, diredp-remove-file-from-recentf:
;;       Make interactive (commandp).  Use code from recentf.el to add/remove.
;;       Call diredp-revert-displayed-recentf-buffers afterward.
;;     diredp-print-this-file, diredp-compress-this-file, diredp-(add|remove)-this-(to|from)-recentf:
;;       Bind use-file-dialog to nil so get correct file name.
;; 2019/10/18 dadams
;;     Added: diredp-add-this-to-recentf, diredp-remove-this-from-recentf.
;;     diredp-dired-recent-dirs(-other-window): Use diredp-dired-recent-dirs as revert function.
;;     diredp-dired-union-1, diredp-fileset-1, diredp-compilation-files-other-window:
;;       Set dired-sort-inhibit to t.
;;     diredp-mouse-3-menu: Added items for diredp-(add|remove)-this-(to|from)-recentf.
;; 2019/10/16 dadams
;;     Added: diredp-do-add-to-recentf,  diredp-do-remove-from-recentf, diredp-add-file-to-recentf,
;;            diredp-remove-file-from-recentf.
;;     diredp-dired-plus-description: Add diredp-do-(add-to|remove-from)-recentf to doc.
;;     diredp-menu-bar-multiple-menu: Add diredp-do-(add-to|remove-from)-recentf.
;;     diredp-dired-recent-files(-other-window): Provide revert function that keeps listing in recentf-list order.
;; 2019/10/15 dadams
;;     Set dired-sort-inhibit to t wherever set revert-buffer-function to diredp-cannot-revert.
;; 2019/10/13 dadams
;;     Added: diredp-cannot-revert, diredp-recent-files, diredp-dired-recent-files,
;;            diredp-dired-recent-files-other-window.
;;     diredp-dired-for-dirs(-other-window): Bind revert-buffer-function to diredp-cannot-revert.
;;     Bind diredp-dired-for-dirs to C-x D r, diredp-dired-recent-files to C-x D R.
;;     diredp-menu-bar-regexp-menu, diredp-marks-(un)mark-menu:
;;       Added items for the different dired-mark-files-regexp behaviors.
;; 2019/10/12 dadams
;;     dired-mark-files-regexp: Fixed prefix arg for LOCALP, to correspond to doc string:
;;       none, C-u (no dir),  M-9, C-u C-u (rel to default dir), M--, M-0 (absolute)
;; 2019/07/03 dadams
;;     dired-mark-unmarked-files: Apply fix for Emacs bug #27465.
;;     diredp-mark-if, diredp-mark-sexp(-recursive), dired-mark-unmarked-files:
;;       Use char-after, not diredp-looking-at-p.
;; 2019/07/19 dadams
;;     diredp-change-marks-recursive, diredp-unmark-all-files-recursive,
;;       diredp-mark-files(-containing)-regexp-recursive, diredp-mark-sexp-recursive, diredp-mark-recursive-1:
;;         Added missing PREDICATE arg in calls to diredp-get-subdirs.
;; 2019/06/25 dadams
;;     diredp-mark-if, diredp-this-file-(un)marked-p: Use regexp-quote for marker char.
;; 2019/06/03 dadams
;;     Removed autoload cookie for diredp-omit-files-regexp - it evaluates dired-omit-files, from dired-x.el.
;;     Hard-require dired-x.el.  (No reason not to.)  Removed fboundp guards for it.
;; 2019/04/22 dadams
;;     Added diredp-move-files-named-in-kill-ring.  Bound to C-w.
;; 2019/04/21 dadams
;;     Added redefinitions of dired-do-find-regexp, dired-do-find-regexp-and-replace.
;;     diredp-multiple-search-menu: Added "Using TAGS Table" for dired-do-(query-replace|search).
;; 2019/04/20 dadams
;;     Added:
;;       diredp-map-over-marks-and-report, diredp-do-emacs-command, diredp-invoke-emacs-command,
;;       diredp-read-command, diredp-do-lisp-sexp, diredp-eval-lisp-sexp, diredp-report-file-result,
;;       diredp-do-report-echo-limit, diredp-fewer-than-N-files-p, diredp-fewer-than-echo-limit-files-p,
;;       diredp-apply-function-to-file-name, diredp-invoke-function-no-args, diredp-list-file-attributes.
;;     diredp-do-apply-function: Redefine to use diredp-map-over-marks-and-report.
;;     diredp-dired-plus-description, diredp-menu-bar-multiple-menu:
;;       Added diredp-do-emacs-command, diredp-do-lisp-sexp.
;;     diredp-menu-bar-multiple-menu: Reordered items.
;;     diredp-list-marked, diredp-*-recursive, diredp-describe-marked-autofiles:
;;       Use diredp-list-file-attributes for DETAILS arg interactively.
;;     diredp-yank-files, dired-query: Use diredp-list-file-attributes, not hardcoded list (5 8).
;;     diredp-set-bookmark-file-bookmark-for-marked-recursive: Corrected interactive spec.
;; 2019/04/16 dadams
;;     Added: diredp-delete-if.
;;     dired-map-over-marks-check: Added &rest argument FUN-ARGS, so FUN can accept arguments.
;; 2019/04/12 dadams
;;     dired-get-marked-files: Do not add t to RESULT.  Thx to Jeff Spencer for bug report.
;;                             If all marked is (t) for some reason reset it to nil, per vanilla Emacs 24+.
;;     diredp-compressed-extensions: Added .rar, .rev.
;; 2019/04/10 dadams
;;     Added diredp-read-expression (forgot it when added diredp-mark-sexp-recursive).
;;     diredp-mark-sexp-recursive is thus only for Emacs 22+.
;; 2019/03/20 dadams
;;     Added option diredp-omit-files-regexp.
;;     Face diredp-omit-file-name: Added strike-through.
;;     diredp-font-lock-keywords-1, for face diredp-omit-file-name:
;;       Move to file name.  Use diredp-omit-files-regexp.  Append * for executable flag.  Highlight whole line.
;; 2019/03/17 dadams
;;     diredp-font-lock-keywords-1:
;;       Use just dired-omit-files as regexp - its components already have ^...$.
;;       Removed superfluous execute *'s in regexps and superfluous concat for compressed extensions.
;;     Face diredp-omit-file-name: Removed :strike-through for default value.
;; 2019/03/16 dadms
;;     Added face diredp-omit-file-name.
;;     diredp-font-lock-keywords-1: Use face diredp-omit-file-name for dired-omit-files matches.
;; 2019/03/15 dadams
;;     diredp-font-lock-keywords-1: Treat dired-omit-files like dired-omit-extensions.
;; 2019/01/27 dadams
;;     Added: diredp-mark-files-containing-regexp-recursive.
;;              Bound to M-+ % g.  Added to diredp-marks-recursive-menu, diredp-regexp-recursive-menu.
;; 2019/01/17 dadams
;;     Added: diredp-mark-sexp-recursive.  Bound to M-+ M-(, M-+ * (.  Added to diredp-marks-recursive-menu.
;;     dired-query: Use dired-query-alist only when available.
;;     diredp-move-file: Fix format string in error call.
;;     diredp-mark-symlinks-recursive: Added missing DETAILS arg for diredp-mark-recursive-1.
;; 2019/01/01 dadams
;;     Added: diredp-list-file.
;;     Added redefinitions of dired-query, dired-handle-overwrite, dired-copy-file(-recursive), dired-rename-file,
;;           dired-hardlink.
;;     Added optional arg DETAILS to these functions: diredp-get-(subdirs|files), diredp-y-or-n-files-p,
;;       diredp-list-(marked|files), diredp-yank-files, diredp-describe-marked-autofiles, plus all functions with
;;       "recursive" in their name except diredp-get-confirmation-recursive.
;;       Added optional arg DETAILS.
;;     diredp-get-(subdirs|files), diredp-y-or-n-files-p, diredp-list-(marked|files), diredp-yank-files,
;;       diredp-describe-marked-autofiles:
;;         Added optional arg DETAILS.
;;     diredp-list-files: Use dired-list-file, to optionally show details.
;;     diredp-yank-files: Non-positive prefix arg shows details now.
;; 2018/12/02 dadams
;;     dired-mark-pop-up: Work around Emacs 22 bug in dired-pop-to-buffer which can exit in Dired buffer.
;; 2018/10/17 dadams
;;     dired-read-dir-and-switches: Removed mention of icicle-file-sort-first-time-p (no longer used in Icicles).
;; 2018/09/21 dadams
;;     diredp-image-dired-edit-comment-and-tags, diredp-w32-drives:
;;       Use pop-to-buffer-same-window, not switch-to-buffer.
;; 2018/09/14 dadams
;;     Added: diredp-move-file-dirs, diredp-move-file.
;; 2018/06/30 dadams
;;     Added: diredp-delete-if-not.
;; 2018/06/16 dadams
;;     Added: diredp-visit-ignore-extensions, diredp-visit-ignore-regexps, diredp-visit-next-file,
;;            diredp-visit-previous-file, diredp-visit-this-file, diredp-visit-ignore-regexp.
;;     Bind the commands to C-down, C-up, e.
;; 2018/03/25 dadams
;;     Added: diredp-user-error.
;;     Updated for Emacs 27-pretest-2 change in dired-get-marked-files signature.
;;       dired-get-marked-files: Added optional arg ERROR-IF-NONE-P.
;;       diredp-list-marked, diredp-insert-subdirs, dired-do-(i)search(-regexp), dired-do-query-replace-regexp,
;;         dired-do-find-marked-files, diredp-describe-marked-autofiles:
;;           Added optional arg INTERACTIVEP.
;;           Pass non-nil ERROR-IF-NONE-P to dired-get-marked-files when INTERACTIVEP.  (See Emacs bug #30938.)
;; 2018/03/23 dadams
;;     Added diredp-mark-if.  Removed: redefinition of dired-mark-if.
;;       Differences: msg and return value include both number of matches and number of changes.
;;     Added redefinitions (use diredp-mark-if) of dired-flag-auto-save-files,
;;           dired-mark-(files-containing-regexp|symlinks|directories|executables).
;;     Everywhere: Use diredp-mark-if, not dired-mark-if.
;; 2018/03/03 dadams
;;     diredp-delete-dups: defalias the symbol, not its symbol-function (dunno why I did the latter).
;; 2018/02/28 dadams
;;     Added: diredp-last-copied-filenames, diredp-copy-abs-filenames-as-kill-recursive,
;;            and redefinition of vanilla diredp-last-copied-filenames.
;;     diredp-copy-abs-filenames-as-kill: Use diredp-ensure-mode in interactive spec.
;;     diredp-copy-filename-as-kill-recursive: Update diredp-last-copied-filenames with filenames string.
;;     diredp-yank-files: Require confirmation for pasting, using diredp-y-or-n-files-p.
;;                        Get file names from variable diredp-last-copied-filenames, not kill-ring.
;;                        Added NO-CONFIRM-P arg.
;;     diredp-ensure-mode: Added doc string.
;;     diredp-do-grep, diredp-do-grep-recursive: Changed bindings to C-M-G and M-+ C-M-G, due to M-g conflict.
;; 2018/02/27 dadams
;;     Added: diredp-copy-abs-filenames-as-kill, diredp-yank-files (aka diredp-paste-files) (bound to C-y).
;;     diredp-menu-bar-multiple-menu: Added diredp-copy-abs-filenames-as-kill.
;;     diredp-menu-bar-dir-menu: Added diredp-yank-files.
;; 2018/01/11 dadams
;;     diredp-get-files:
;;       Set IGNORE-MARKS-P to non-nil if nothing marked here.  (It was not getting all if nothing marked.)
;;     diredp-marked-recursive(-other-window):
;;       Corrected interactive spec, which was missing nil DIRNAME arg.  Corrected body: use DIRNAME.
;;     diredp-get-files-for-dir, diredp-do-bookmark-dirs-recursive, diredp-change-marks-recursive,
;;       diredp-unmark-all-files-recursive, diredp-mark-files-regexp-recursive, diredp-mark-recursive-1,
;;       diredp-do-delete-recursive:
;;         Factor out (dired-buffers-for-dir (expand-file-name directory)).
;; 2018/01/03 dadams
;;     dired-mark-files-regexp: Corrected doc string wrt prefix args.  Thx to John Mastro.
;;     diredp-do-grep-recursive: Removed unused optional arg IGNORE-MARKS-P.
;;     diredp-marked-recursive(-other-window): Moved handling of optional arg from interactive spec to body.
;; 2018/01/02 dadams
;;     Added: diredp-flag-auto-save-files-recursive.  Bound to M-+ #.
;;     diredp-get-file-or-dir-name, diredp-marked-here: Doubled backslashes to escape dots.
;;     diredp-marked-here: Fixed regexp to match only double-dot, not single-dot.
;;     diredp-flag-auto-save-files-recursive: Updated to include more M-+ keys.
;;     diredp-marks-recursive-menu: Added diredp-flag-auto-save-files-recursive.
;; 2017/12/31 dadams
;;     diredp-get-files-for-dir: Pass non-nil NO-DOT-DOT-P arg to diredp-marked-here.
;;     dired-get-marked-files: Allow use of FILTER and DISTINGUISH-ONE-MARKED together.
;;     diredp-marked-here: Added optional arg NO-DOT-DOT-P.
;;     diredp-change-marks-recursive, diredp-unmark-all-files-recursive: Removed unused vars include-dirs, files.
;; 2017/12/30 dadams
;;     Added: diredp-change-marks-recursive, diredp-unmark-all-files-recursive, diredp-unmark-all-marks-recursive.
;;            Bound to M-+ * c, M-+ M-DEL, M-+ U, respectively.
;;     diredp-menu-bar-marks-menu: Rename item Change Marks to Change Mark.
;;     diredp-marks-recursive-menu, diredp-multiple-recursive-menu:
;;       Added diredp-change-marks-recursive, diredp-unmark-all-(files|marks)-recursive.
;; 2017/12/21 dadams
;;     Added: diredp-mark-recursive-1.  Forgot to add it last June.
;; 2017/12/17 dadams
;;     Removed: diredp-display-graphic-p.
;;     Do not use diredp-display-graphic-p to allow binding diredp-bind-problematic-terminal-keys by default.
;; 2017/11/25 dadams
;;     diredp-nb-marked-in-mode-name: Wrap last :eval sexp in save-excursion.
;;                                    Protect Call dired-current-directory only when dired-subdir-alist.
;; 2017/10/23 dadams
;;     Added: diredp-count-.-and-..-flag, diredp--reuse-dir-buffer-helper.
;;     Removed: diredp-mouse-find-file.
;;     diredp-find-file-reuse-dir-buffer, diredp-mouse-find-file-reuse-dir-buffer,
;;       diredp-up-directory-reuse-dir-buffer:
;;         Use diredp--reuse-dir-buffer-helper.
;;     diredp-find-file-reuse-dir-buffer: Changed logic: do find-alternate-file only if target is a dir not in
;;                                        Dired and current Dired buffer is in only this window.
;;     diredp-mouse-find-file-reuse-dir-buffer: Added optional args FIND-FILE-FUNC and  FIND-DIR-FUNC.
;;     diredp-up-directory, diredp-up-directory-reuse-dir-buffer: Pass OTHER-WINDOW arg to diredp-w32-drives.
;;     diredp-nb-marked-in-mode-name: Show also number of lines in current listing, and listing-relative lineno,
;;                                    respecting diredp-count-.-and-..-flag.
;;     diredp-find-a-file*: Added autoload cookies.
;; 2017/08/18 dadams
;;     Fixed emacswiki URLs everywhere.  They changed the locations and changed http to https.
;; 2017/06/30 dadams
;;     Added: diredp-bind-problematic-terminal-keys, diredp-display-graphic-p.
;;     Guard bindings of problematic keys with diredp-display-graphic-p & diredp-bind-problematic-terminal-keys.
;;     Documented problematic keys for terminal mode in commentary.
;; 2017/06/23 dadams
;;     Added: diredp-read-regexp (removed alias to read-regexp), diredp-marks-recursive-menu,
;;       diredp-mark-executables-recursive (bound to M-+ * *),
;;       diredp-mark-directories-recursive (bound to M-+ * /),
;;       diredp-mark-extension-recursive (bound to M-+ * .),
;;       diredp-mark-autofiles-recursive (bound to M-+ * B),
;;       diredp-mark-executables-recursive (bound to M-+ * *),
;;       diredp-mark-directories-recursive (bound to M-+ * /),
;;       diredp-mark-symlinks-recursive (bound to M-+ * @),
;;     Bind diredp-mark-autofiles to * B.
;;     diredp-marked-here: Bind dired-marker-char to ?*.
;;     diredp-mark-files-regexp-recursive: Better msgs - show total count.
;;     Everywhere: Use diredp-looking-at, not looking-at.  Use diredp-read-regexp, not dired-read-regexp.
;; 2017/05/30 dadams
;;     Fixed typo: direp--set-up-font-locking -> diredp--set-up-font-locking.
;; 2017/05/22 dadams
;;     Added: direp--set-up-font-locking.
;;     Use direp--set-up-font-locking instead of lambda in dired-mode-hook.
;; 2017/04/09 dadams
;;     Version 2017.04.09.
;;     Added: diredp-multiple-move-copy-link-menu, diredp-multiple-rename-menu, diredp-multiple-dired-menu,
;;            diredp-multiple-omit-menu, diredp-multiple-delete-menu, diredp-single-bookmarks-menu,
;;            diredp-single-encryption-menu, diredp-single-image-menu, diredp-single-open-menu,
;;            diredp-single-move-copy-link-menu, diredp-single-rename-menu.
;;            Moved single menu items there.
;;     Renamed: diredp-menu-bar-encryption-menu        to diredp-multiple-encryption-menu,
;;              diredp-menu-bar-mark-menu              to diredp-menu-bar-marks-menu,
;;              diredp-menu-bar-operate-menu           to diredp-menu-bar-multiple-menu,
;;              diredp-menu-bar-operate-bookmarks-menu to diredp-multiple-bookmarks-menu,
;;              diredp-menu-bar-operate-recursive-menu to diredp-multiple-recursive-menu,
;;              diredp-menu-bar-operate-search-menu    to diredp-multiple-search-menu,
;;              diredp-menu-bar-images-menu            to diredp-multiple-images-menu,
;;              diredp-menu-bar-images-recursive-menu  to diredp-images-recursive-menu,
;;              diredp-menu-bar-immediate-menu         to diredp-menu-bar-single-menu,
;;              diredp-menu-bar-regexp-recursive-menu  to diredp-regexp-recursive-menu,
;;              diredp-menu-bar-subdir-menu            to diredp-menu-bar-dir-menu.
;;     Added dired-do-rename to diredp-multiple-rename-menu.
;;     diredp-nonempty-region-p: Ensure (mark) also.
;; 2017/03/30 dadams
;;     Moved key bindings to end of file.  Moved defgroup before defcustoms.
;;     Bind dired-multiple-w32-browser to C-M-RET, diredp-multiple-w32-browser-recursive to M-+ C-M-RET.
;; 2017/03/29 dadams
;;     Added: diredp-dired-union-other-window, diredp-add-to-dired-buffer-other-window.
;;     diredp-dired-union-1: Added optional arg OTHERWIN.
;;     diredp-dired-plus-description: Updated doc string.
;;     diredp-menu-bar-subdir-menu: Added diredp-dired-for-files.
;;     Bind diredp-w32-drives to :/, diredp-dired-inserted-subdirs to C-M-i.
;;     Bind diredp-add-to-dired-buffer to C-x D A (not C-x E), diredp-dired-union to C-x D U (not C-x D),
;;          diredp-fileset to C-x D S (not C-M-f), diredp-dired-recent-dirs to C-x D R (not C-x R),
;;          diredp-dired-for-files to C-x D F, plus other-window versions.
;; 2017/03/24 dadams
;;     Added defalias for dired-read-regexp.
;;     diredp-mouse-3-menu: Removed second arg to mouse-save-then-kill.
;; 2017/02/20 dadams
;;     diredp-(next|previous)-line, diredp-(next|prev)-dirline, diredp-(next|prev)-subdir:
;;       Update interactive spec to use (in effect) ^p for prefix arg (for shift-select-mode).
;; 2017/01/12 dadams
;;     dired-mark-files-regexp: Swapped prefix-arg behavior for relative and absolute name matching.
;; 2017/01/01 dadams
;;     dired-mark-files-regexp: Fix to prompt for no prefix arg.
;; 2016/12/28 dadams
;;     dired-mark-files-regexp: Corrected prompt string for Mark/UNmark.  Thx to Tino Calancha.
;; 2016/11/20 dadams
;;     diredp-menu-bar-operate-search-menu: Added dired-do-find-regexp and dired-do-find-regexp-and-replace.
;;     Bind dired-do-search to M-a and dired-do-query(-replace)-regexp to M-q.
;;     diredp-dired-plus-description: Added dired-do-find-regexp and dired-do-find-regexp-and-replace.
;; 2016/10/12 dadams
;;     diredp-compressed-extensions: Added extensions .xz and .lzma.  Thx to xuhdev (https://www.topbug.net/).
;; 2016/09/20 dadams
;;     Emacs 25.1: Bind M-z to dired-do-compress-to (replaces c).  (Emacs bug #24484.)
;;                 diredp-menu-bar-operate-menu: Added item: Compress to (dired-do-compress-to).
;; 2016/09/15 dadams
;;     Added: diredp-max-frames.
;;     dired-do-find-marked-files: Pass non-nil ARG to dired-get-marked-files only if it is a cons.
;;                                 Clarified doc string wrt prefix arg.
;;     dired-simultaneous-find-file: Require confirmation if more files than diredp-max-frames.
;;     diredp-do-find-marked-files-recursive: Clarified doc string wrt prefix arg.
;;     Thx to Tino Calancha.
;; 2016/09/14 dadams
;;     diredp-dired-plus-description: Added entry for dired-hide-details-mode - ( key.
;; 2016/08/26 dadams
;;     diredp-y-or-n-files-p: pop-to-buffer only when the buffer was created.
;;                            Update wrt vanilla (scroll actions).
;;     diredp-do-query-replace-regexp-recursive:
;;       Call diredp-get-confirmation-recursive.
;;       Use only diredp-get-files, not dired-get-marked-files.
;;       Non-positive prefix arg means DELIMITED.
;; 2016/08/08 dadams
;;     diredp-menu-bar-mark-menu:
;;       Added: dired-mark-files-containing-regexp, dired-mark-sexp, image-dired-mark-tagged-files,
;; 2016/05/28 dadams
;;     diredp-mark-files-regexp-recursive: Use nil for dired-get-filename LOCALP arg.
;;     dired-mark-files-regexp: Corrected doc string: absolute filename matching by default.
;; 2016/05/24 dadams
;;     dired-mark-files-regexp: Added optional arg LOCALP, so can mark/unmark matching different file-name forms.
;; 2016/05/15 dadams
;;     Added: diredp-bookmark-menu, diredp-hide/show-menu, diredp-navigate-menu.
;;     Move insert after revert and rename it to Insert/Move-To This Subdir.  Move create-directory before revert.
;; 2016/04/29 dadams
;;     diredp-next-line: Respect goal-column.
;; 2016/01/24 dadams
;;     Added: diredp-ensure-bookmark+, diredp-mark-autofiles, diredp-unmark-autofiles,
;;            diredp-mark/unmark-autofiles, diredp-describe-autofile, diredp-show-metadata,
;;            diredp-mouse-describe-autofile, diredp-describe-marked-autofiles, diredp-show-metadata-for-marked
;;     Soft-require help-fns+.el (Emacs 22+) or help+20.el (Emacs 20-21).
;;     Add to menu-bar menus:
;;       diredp-(un)mark-autofiles, diredp-describe-autofile, diredp-describe-marked-autofiles.
;;     diredp-menu-bar-immediate-menu: Add diredp-describe-file only if defined.
;;     Bind diredp-describe-file to keys only if defined.
;;     Use diredp-ensure-bookmark+ everywhere, instead of its definition.
;;     diredp(-mouse)-describe-file: Define only if describe-file is defined.  Removed raising error if not.
;;     diredp-mouse-3-menu: Use  diredp-describe-autofile if diredp-describe-file is not defined.
;;     diredp-dired-plus-description: Add diredp-mouse-describe-autofile, when bound.
;;     dired-mark-if: Do not count non-changes.
;; 2015/12/15 dadams
;;     diredp-font-lock-keywords-1: Follow # with optional [/ ], for face diredp-number.  Thx to Tino Calancha.
;; 2015/11/10 dadams
;;     diredp-fileset(-other-window): Separate error msgs for unloaded filesets.el and empty filesets-data.
;; 2015/10/02 dadams
;;     dired-mark-sexp: Like vanilla, skip extended attributes marker before setting NLINK.  Thx to Tino Calancha.
;; 2015/09/29 dadams
;;     diredp-delete-this-file: Redefined to use delete-file instead of dired-do-delete.
;; 2015/09/07 dadams
;;     diredp-font-lock-keywords-1: Do not test diredp-ignore-compressed-flag when highlighting file names.
;;                                  Use separate entries for compressed and non-compressed file names.
;;                                  Added missing \\| before ignored compressed extensions.
;; 2015/09/06 dadams
;;     diredp-compressed-extensions: Added .tgz.  Removed duplicate .gz.
;;     diredp-font-lock-keywords-1: Use regexp-opt where possible, instead of mapcar regexp-quote.
;; 2015/09/05 dadams
;;     Added: diredp-compressed-extensions, diredp-ignore-compressed-flag, diredp-compressed-file-name,
;;            diredp-dir-name.
;;     diredp-font-lock-keywords-1:
;;       Allow spaces in symlink names.  Highlight compressed-file names, if diredp-ignore-compressed-flag.
;;       Use diredp-compressed-extensions instead of hardcoding extensions.
;;     Highlight d with diredp-dir-priv (fix).
;;     Treat l in third column the same as - and d there.
;;     Highlight whole line for D-flagged files, with face diredp-deletion-file-name.
;;     Thx to Nick Helm.
;; 2015/08/30 dadams
;;     dired-mark-sexp: Updated per Emacs 25 code.
;; 2015/07/30 dadams
;;     diredp-fileset(-other-window): Changed key binding from C-x F to C-x C-M-f (conflicted with find-function).
;; 2015/06/24 dadams
;;     Added: diredp-parent-dir, diredp-breadcrumbs-in-header-line-mode, diredp-set-header-line-breadcrumbs.
;; 2015/06/06 dadams
;;     Added dired-other-(frame|window).
;;     diredp-font-lock-keywords-1:
;;       Use dired-re-maybe-mark and dired-re-inode-size for permission matchings and directory names.
;;     dired(-other-(frame|window)) advice:
;;       Add interactive spec, to handle arg <= 0 (broken by change to dired-read-dir-and-switches 2015/02/02).
;;     diredp-dired-for-files: Typo: pass empy string.
;; 2015/06/05 dadams
;;     Added: diredp-grepped-files-other-window as alias for diredp-compilation-files-other-window.
;;     diredp-compilation-files-other-window: Added SWITCHES optional arg (prefix arg).
;; 2015/06/04 dadams
;;     diredp-dired-for-files(-other-window):
;;       Updated to fit change to dired-read-dir-and-switches made 2015/02/02: addition of READ-EXTRA-FILES-P.
;;       Use prefix arg to prompt for switches.
;; 2015/05/31 dadams
;;     Added: diredp-image-show-this-file,diredp-image-show-this-file-use-frame-flag, diredp-get-image-filename.
;;     image-dired-dired-toggle-marked-thumbs, diredp-menu-bar-immediate-menu [image]:
;;       Use diredp-get-image-filename.
;;     Bound diredp-image-show-this-file to C-t I.
;;     diredp-menu-bar-immediate-image-menu: Added diredp-image-show-this-file and dired-find-file.
;;     Added autoload cookies for image commands.
;; 2015/04/16 dadams
;;     Added: diredp-do-apply-function, diredp-do-apply-function-recursive.  Added to menus.  Bind to @, M-+ @.
;;     dired-do-query-replace-regexp: Handle nil ARG properly.
;; 2015/03/26 dadams
;;     Added: redefinitions of dired-do-isearch, dired-do-isearch-regexp, dired-do-query-replace-regexp,
;;            dired-do-search, to handle multi-C-u.
;;     Added: dired-nondirectory-p (Emacs 20), diredp-refontify-buffer.
;;     dired-do-byte-compile, dired-do-load, : Corrected interactive spec, to treat more than two C-u as two.
;;     dired-after-readin-hook: Add diredp-refontify-buffer.  In particular, this ensures that reverting Dired
;;       for a listing of explicit file names gets refontified.  (Just turn-on-font-lock does not refontify.)
;; 2015/03/24 dadams
;;     Added: diredp-compilation-files-other-window, diredp-file-for-compilation-hit-at-point.
;; 2015/03/06 dadams
;;     Renamed: diredp-menu-bar-recursive-marked-menu to diredp-menu-bar-operate-recursive-menu.
;;     Added: diredp-do-delete-recursive: M-+ D.  Added to diredp-menu-bar-operate-recursive-menu.
;;     Added: diredp-mark-files-regexp-recursive: M-+ % m.  Added to diredp-menu-bar-regexp-recursive-menu.
;; 2015/03/04 dadams
;;     Added: diredp-dwim-any-frame-flag, (redefinition of) dired-dwim-target-directory.
;; 2015/02/22 dadams
;;     diredp-bookmark: Corrected for use without Bookmark+ - bookmark-store signature.
;;                      Pass correct value to bmkp-autofile-set for its MSG-P arg.
;;     diredp-mouse-do-bookmark: Do not pass non-nil NO-MSG-P arg to diredp-bookmark.
;; 2015/02/03 dadams
;;     Added: diredp-add-to-this-dired-buffer.
;;     Removed: diredp-add-to-dired-buffer-other-window, diredp-dired-union-other-window.
;;     diredp-dired-union-1: Removed optional arg OTHER-WINDOW-P.
;;     diredp-menu-bar-subdir-menu: Added diredp-add-to-this-dired-buffer.
;;     dired-read-dir-and-switches, diredp-dired-union-interactive-spec:
;;       Added optional arg DIRED-BUFFER.  If nil, use current buffer name as default when reading buffer name.
;; 2015/02/02 dadams
;;     Added: diredp-add-to-dired-buffer, diredp-add-to-dired-buffer-other-window, diredp-set-union,
;;            diredp-existing-dired-buffer-p.
;;     Bind diredp-add-to-dired-buffer(-other-window) globally to C-x E, C-x 4 E.
;;     diredp-dired-union(-other-window):
;;       Added args DIRNAME and EXTRA.  Pass them to diredp-dired-union-1.  Moved "UNION" to *-interactive-spec.
;;       Pass values for new args NO-DIRED-BUFS and READ-EXTRA-FILES-P to diredp-dired-union-interactive-spec.
;;     diredp-dired-union-interactive-spec:
;;       Added args NO-DIRED-BUFS and READ-EXTRA-FILES-P.  Use (updated) dired-read-dir-and-switches.
;;       Delete dead buffers from dired-buffers.  Remove DIRNAME buffer as candidate.
;;       Apply expand-file-name to default-directory.  Return list of DIRNAME BUFS SWITCHES EXTRA-FILES.
;;     diredp-dired-union-1:
;;       Added args DIRED-NAME and EXTRA.
;;       For existing Dired buffer whose dired-directory is a cons:
;;         Include its current listing.  Replace buffer with new one of same name, after deleting its window.
;;     dired-read-dir-and-switches:
;;       Added arg READ-EXTRA-FILES-P.
;;       If chosen Dired buffer exists and is an ordinary listing then start out with its directory-files.
;;     diredp-dired-union, diredp-fileset, diredp-dired-recent-dirs: Bind globally, not just in Dired mode.
;; 2015/01/30 dadams
;;     dired-read-dir-and-switches: Remove any killed buffers from dired-buffers, before using for completion.
;; 2014/10/25 dadams
;;     diredp-dired-union-interactive-spec: Typo: quote buffer-name-history.  Pass other-window STRING.
;;     diredp-dired-union-other-window: Pass other-window STRING.
;;     dired-read-dir-and-switches: Include STRING for reading buffer name also.
;;     dired (defadvice): Corrected doc string for prefix arg >= and <= 0.
;; 2014/10/15 dadams
;;     diredp-hide-details-initially-flag:
;;       Added :set, to ensure that diredp-hide-details-last-state is kept up-to-date.
;; 2014/09/28 dadams
;;     Added: diredp-recent-dirs, diredp-read-include/exclude, diredp-root-directory-p, diredp-remove-if.
;;     diredp-dired-recent-dirs(-other-window): Added optional ARG.  Use diredp-recent-dirs.  Pass SWITCHES.
;;     dired-read-dir-and-switches: Use diredp-root-directory-p.
;;     Bound diredp-dired-recent-dirs(-other-window) to C-x R and C-x 4 R.
;;     Added diredp-dired-recent-dirs to Dir menu.
;; 2014/09/27 dadams
;;     Added: diredp-dired-recent-dirs, diredp-dired-recent-dirs-other-window, diredp-delete-dups.
;; 2014/09/26 dadams
;;     diredp-mouseover-help: dired-get-filename etc. has to be inside the save-excursion.
;;     diredp-image-dired-create-thumb: Added FILE arg.  Use numeric prefix arg as the new thumbnail size.
;; 2014/09/22 dadams
;;     diredp-mouse-3-menu: Do not place overlay unless on a file/dir name (i.e., dired-get-filename).
;; 2014/09/15 dadams
;;     dired-read-dir-and-switches: Made it (thus dired too) an Icicles multi-command.
;;     dired (defadvice): Added doc about using it with Icicles.
;; 2014/09/14 dadams
;;     Added: diredp-kill-this-tree.
;;     Removed: diredp-dired-files(-other-window), diredp-dired-files-interactive-spec.
;;     dired-read-dir-and-switches:
;;       Based on diredp-dired-files-interactive-spec implementation now, but:
;;        Moved unwind-protect outside call to list.  completing-read, not read-string, for DIRBUF.
;;        Do not allow inclusion of root directories.  Protected icicle-sort-comparer with boundp.
;;     dired-insert-subdir-validate: Make it a no-op.
;;     dired advice (doc string): Mention wildcards, Icicles.
;;     diredp-dired-for-files(-other-window):
;;       Use dired-read-dir-and-switches and dired, not diredp-dired-files-interactive-spec and
;;       diredp-dired-files.
;;     diredp-menu-bar-immediate-menu, diredp-mouse-3-menu:
;;       Added item for diredp-kill-this-tree.
;;       Corrected visible condition: expand-file-name, so ~/ compares with its expansion.
;;     diredp-font-lock-keywords-1: Include period (.) for diredp(-compressed)-file-suffix.
;; 2014/09/09 dadams
;;     Added: dired-read-dir-and-switches.
;;     Advise dired, for doc string.
;;     dired-get-filename: Hack for Emacs 20-22, to expand ~/...
;; 2014/09/07 dadams
;;     Added: redefinitions of dired-insert-subdir-newpos, dired-insert-subdir-validate.
;; 2014/07/26 dadams
;;     diredp-do-find-marked-files-recursive:
;;       Only ARG >= 0 ignores marks now.  And ARG <= 0 means find but do not display.
;; 2014/07/13 dadams
;;     diredp-mouseover-help: Wrap (goto-char pos) in save-excursion (Emacs bug #18011).
;; 2014/07/12 dadams
;;     Faces diredp(-tagged)-autofile-name: Made paler/darker (less saturated).
;;     Moved diredp-highlight-autofiles before diredp-highlight-autofiles-mode, so will be
;;      defined for first revert.
;;     diredp-mouse-3-menu: Renamed items Tag, Untag to Add Tags, Remove Tags.
;;     diredp-dired-plus-description: Updated.
;; 2014/07/11 dadams
;;     Added: diredp-highlight-autofiles-mode, diredp-highlight-autofiles,
;;            diredp-autofile-name, diredp-tagged-autofile-name.
;;     Soft-require bookmark+.el.  Soft-require highlight.el if bookmark+.el is provided.
;;     diredp-menu-bar-subdir-menu: Added item Toggle Autofile Highlighting.
;;     Removed unused face: diredp-display-msg.
;; 2014/06/29 dadams
;;     dired-get-marked-files, diredp-internal-do-deletions:
;;       Remove nils from dired-map-over-marks result.
;; 2014/05/28 dadams
;;     diredp-mode-line-marked: Use DarkViolet for both light and dark background modes.
;; 2014/05/23 dadams
;;     Added: diredp-with-help-window.
;;     diredp-list-files, diredp-dired-plus-help:
;;       Use diredp-with-help-window, not with-output-to-temp-buffer.  See Emacs bug #17109.
;; 2014/05/06 dadams
;;     Added: diredp-image-dired-required-msg, diredp-list-files-map,
;;            diredp-find-line-file-other-window, diredp-mouse-find-line-file-other-window,
;;            image-dired-dired-toggle-marked-thumbs, diredp-list-marked.
;;     Soft-require image-dired.el and image-file.el.
;;     diredp-image-dired-create-thumb: Define unconditionally.
;;     image-dired-dired-insert-marked-thumbs, diredp-image-dired-comment-file,
;;       diredp-image-dired-tag-file, diredp-image-dired-delete-tag,
;;       diredp-image-dired-display-thumb, diredp-image-dired-copy-with-exif-name,
;;       diredp-image-dired-edit-comment-and-tags, diredp-do-display-images:
;;         Define unconditionally and raise error if no image-(dired|file).el.
;;     diredp-menu-bar-immediate-image-menu, diredp-menu-bar-images-menu,
;;       diredp-menu-bar-images-recursive-menu, image-dired-mark-tagged-files:
;;         Define unconditionally and use :enable.
;;     diredp-menu-bar-images-menu, diredp-menu-bar-images-recursive-menu:
;;       Add defalias so can use menu-item with :enable.
;;     diredp-list-files: Add properties mouse-face, keymap, and help-echo.
;;     diredp-mouseover-help: Make it work also for diredp-list-files listings.
;;     image-dired-dired-insert-marked-thumbs: Add autoload cookie.
;;     dired-get-marked-files: Pass non-nil 2nd arg to dired-get-filename, to include . and .. .
;;     Bind diredp-list-marked to C-M-l and diredp-list-marked-recursive to M+ C-M-l.
;;     diredp-insert-subdirs: Exclude . and .., as dired-get-marked-files can now include them.
;;     diredp-menu-bar-operate-menu: Add diredp-menu-bar-operate-menu to menu.
;;     diredp-dired-plus-description: Mention diredp-list-marked*.
;; 2014/05/03 dadams
;;     dired-switches-escape-p: Use dired-switches-check if available, based on bug #17218 fix.
;; 2014/04/25 dadams
;;     diredp-image-dired-create-thumb:
;;       Do not call diredp-image-dired-create-thumb twice: reuse THUMB-NAME.
;; 2014/04/24 dadams
;;     Added: diredp-mouseover-help, diredp-auto-focus-frame-for-thumbnail-tooltip-flag,
;;            diredp-image-preview-in-tooltip.
;;     dired-insert-set-properties: Show image-file preview in tooltip.
;;     diredp-image-dired-create-thumb: Return thumbnail file name or nil.
;; 2014/04/23 dadams
;;     Added: diredp-looking-at-p.
;;     dired-insert-set-properties: Applied fix for bug #17228.
;; 2014/04/05 dadams
;;     Added: diredp-do-bookmark-dirs-recursive.
;;            Renamed from bmkp-create-dired-bookmarks-recursive in bookmark+-1.el (removed).
;;       Bound to M-B (aka M-S-b).
;;       Added to menus *-subdir-menu, *-operate-bookmarks-menu, *-bookmarks-menu.
;;     diredp-get-confirmation-recursive: Added optional TYPE arg.
;;     diredp-insert-subdirs-recursive: Call diredp-get-confirmation-recursive with TYPE arg.
;; 2014/02/16 dadams
;;     dired-pop-to-buffer: Do not redefine for Emacs > 24.1.
;;     dired-mark-pop-up: Updated doc string.
;; 2014/02/13 dadams
;;     Added: diredp-fileset-other-window, diredp-fileset-1.
;;     diredp-fileset: Use diredp-fileset-1.
;;     Bind diredp-dired-union(-other-window) to C-x D, C-x 4 D,
;;          diredp-fileset(-other-window)     to C-x F, C-x 4 F.
;;     Use diredp-fileset-other-window, not diredp-fileset, in menu.
;; 2014/02/03 dadams
;;     Added: diredp-hide-subdir-nomove.
;;     Added: dired-goto-file for Emacs 24+ - open hidden parent dir, so can goto destination.
;;     Replace bindings for dired-hide-subdir with diredp-hide-subdir-nomove.
;;     Bind dired-hide-subdir to M-$ (not $).
;; 2014/02/02 dadams
;;     dired-goto-file: Redefine only for Emacs < 24.
;; 2014/01/15 dadams
;;     Bind diredp-toggle-find-file-reuse-dir to C-M-R (aka C-M-S-r).
;; 2014/01/05 dadams
;;     Bind dired-omit-mode (aka dired-omit-toggle) to C-x M-o.
;; 2013/12/05 dadams
;;     diredp-do-grep-1: Call grep-default-command with arg, if grep+.el is loaded.
;; 2013/11/05 dadams
;;     Added: diredp-get-subdirs.
;;     diredp-get-files, diredp-get-files-for-dir, diredp-marked-here: Added optional arg NIL-IF-NONE-P.
;;     diredp-get-files: Pass INCLUDE-DIRS-P to diredp-files-within.
;; 2013/11/04 dadams
;;     Renamed Bookmarks submenus to Bookmark.
;;     Added Bookmark Dired Buffer to Dir menu.
;;     Alias dired-toggle-marks to dired-do-toggle for Emacs 20, instead of backwards for others.
;;     Use dired-toggle-marks everywhere instead of dired-do-toggle.
;; 2013/11/03 dadams
;;     Created submenus of Multiple menu: Bookmarks, Search.
;;     Created submenus of Multiple > Marked Here and Below menu:
;;       Images, Encryption, Search, Bookmarks.
;;     Reordered menus.
;; 2013/09/26 dadams
;;     diredp-next-line: Use let*, so line-move sees let bindings.
;; 2013/08/11 dadams
;;     diredp-dired-files-interactive-spec:
;;       Protect icicle-file-sort with boundp.  Thx to Vladimir Lomov.
;; 2013/08/06 dadams
;;     diredp-display-image,diredp-menu-bar-immediate-image-menu (:enable's):
;;       Protect diredp-string-match-p from nil argument.
;; 2013/07/24 dadams
;;     Added: diredp-nonempty-region-p.  Use everywhere, in place of its definition.
;; 2013/07/21 dadams
;;     Added: diredp-image-dired-(comment-file|copy-with-exif-name|(create|display)-thumb|
;;                                delete-tag|edit-comment-and-tags|tag-file),
;;            diredp-string-match-p, diredp-menu-bar-immediate-image-menu.
;;     Put this-file image commands on new menu diredp-menu-bar-immediate-image-menu.
;;     diredp-menu-bar-images-menu: Added diredp-do-display-images.
;;     Use diredp-string-match-p instead of string-match where appropriate.
;;     diredp-find-a-file-read-args: Removed #' from lambda.
;; 2013/07/19 dadams
;;     Added redefinition of dired-hide-details-mode.
;;     Added: diredp-hide-details-propagate-flag, diredp-hide-details-initially-flag,
;;            diredp-hide-details-last-state, diredp-hide-details-toggled,
;;            diredp-hide-details-if-dired, global-dired-hide-details-mode,
;;            diredp-fit-frame-unless-buffer-narrowed, diredp-hide/show-details,
;;            diredp-do-display-images, diredp-display-image.
;;     On dired-after-readin-hook: diredp-hide/show-details.
;;     On dired-hide-details-mode-hook: diredp-fit-frame-unless-buffer-narrowed.
;;     diredp-maplist: Use diredp-maplist, not maplist, in recursive call.
;;     diredp-next-line: Added bobp test for negative ARG.
;;                       Emacs 20 line-move returns nil, so use (progn ... t).
;;     Soft-require autofit-frame.el.
;; 2013/07/18 dadams
;;     diredp-next-line: Protect visible-p with fboundp for Emacs 20.
;; 2013/07/17 dadams
;;     Added: diredp-menu-bar-encryption-menu, diredp-menu-bar-images-menu,
;;            diredp-menu-bar-immediate-encryption-menu,
;;            diredp-(decrypt|verify|sign|encrypt)-this-file.
;;     Added diredp-(decrypt|verify|sign|encrypt)-this-file to *-immediate-encryption-menu.
;;     Moved encryption and image-dired items to the new Multiple submenus from Multiple menu.
;; 2013/07/15 dadams
;;     Added: diredp-async-shell-command-this-file, diredp-do-async-shell-command-recursive.
;;            Added them to menus.  Bind diredp-do-async-shell-command-recursive to M-+ &.
;;     diredp-menu-bar-mark-menu, diredp-dired-plus-description: Added dired-mark-omitted.
;;     diredp-menu-bar-subdir-menu: Added dired-omit-mode, dired-hide-details-mode.
;;     diredp-menu-bar-regexp-menu: Added image-dired-mark-tagged-files.
;;     diredp-menu-bar-subdir-menu: Added dired-hide-details-mode.
;;     diredp-shell-command-this-file: Corrected: provide file list to dired-do-shell-command.
;; 2013/07/13 dadams
;;     diredp-font-lock-keywords-1:
;;       Ensure diredp-dir-priv is not used for directory header of d:/... (Windows drive name).
;;     dired-insert-directory:
;;       Update wrt Emacs 24.4: Do dired-insert-set-properties last; use saved CONTENT-POINT.
;;     dired-insert-set-properties: Updated for Emacs 24.4, for dired-hide-details-mode.
;;     Add frame-fitting to dired-hide-details-mode-hook.
;;     dired-mouse-find-file(-other-window): Error msg if click off a file name.
;; 2013/07/12 dadams
;;     Added: diredp-wrap-around-flag, diredp-(next|previous)-(subdir|(dir)line).
;;     Renamed dired-up-directory to diredp-up-directory.
;;     Replaced vanilla commands by these new commands everywhere.
;; 2013/07/11 dadams
;;     Added: diredp-up-directory-reuse-dir-buffer.
;;     diredp-make-find-file-keys(-not)-reuse-dirs: Added diredp-up-directory-reuse-dir-buffer.
;; 2013/02/06 dadams
;;     dired-mark-pop-up: goto point-min, so show start of file list.  Thx to Michael Heerdegen.
;; 2013/01/28 dadams
;;     Added redefinition of dired-do-run-mail.  Fixes Emacs bug #13561.
;; 2012/12/18 dadams
;;     diredp-ediff: Better default for FILE2.  Thx to Michael Heerdegen.
;;     Require subr-21.el for Emacs 20.
;; 2012/11/17 dadams
;;     Added: derived-mode-p (for Emacs < 22), diredp-ensure-mode.
;;     Use diredp-ensure-mode everywhere for mode, so compatible with Sunrise Commander etc.
;; 2012/11/01 dadams
;;     Do not require ediff.el.  It is required in diredp-ediff itself.
;; 2012/10/06 dadams
;;     Added: minibuffer-with-setup-hook for code byte-compiled using Emacs < 22.
;; 2012/09/28 dadams
;;     Moved dired-*w32* bindings after normal mouse bindings, so they override them.
;; 2012/09/05 dadams
;;     diredp-(rename|copy|(rel)symlink|hardlink)-this-file: Bind use-file-dialog to nil.
;; 2012/08/26 dadams
;;     Set font-lock-defaults to a 3-element list, so it works with font-menus(-da).el.
;; 2012/08/25 dadams
;;     Added: redefinition of dired-pop-to-buffer (fix for bug #12281).
;;     dired-mark-pop-up: If buffer is shown in a separate frame, do not show menu bar.
;; 2012/07/10 dadams
;;     Removed unneeded substitute-key-definition for (next|previous)-line.
;; 2012/07/09 dadams
;;     Added redefinition of dired-mark-files-regexp: Push REGEXP onto regexp-search-ring.
;; 2012/06/21 dadams
;;     diredp-nb-marked-in-mode-name:
;;       Add marker numbers regardless of name match.
;;       Use text property dired+-mode-name to tell whether mode-name was already changed.
;; 2012/06/20 dadams
;;     Added: diredp-nb-marked-in-mode-name, diredp-mode-line-(flagged|marked).  Added to hooks.
;;     Thx to Michael Heerdegen.
;; 2012/06/14 dadams
;;     dired-mark-pop-up: Wrap save-excursion around window/frame deletion.
;;     dired-do-redisplay: Updated wrt Emacs 23: bind, (then run) dired-after-readin-hook.
;;     diredp-y-or-n-files-p: Corrected construction of prompt wrt final SPC.
;; 2012/06/13 dadams
;;     dired-buffers-for-dir: Updated wrt Emacs 23:
;;       If dired-directory is a list then expand FILE in DIR & check whether in cdr of list.
;;     diredp-get-files-for-dir, diredp-files-within-1, diredp-insert-as-subdir:
;;       Expand dir name before passing it to dired-buffers-for-dir.
;; 2012/06/05 dadams
;;     MS Windows: Just do not define commands that are inappropriate for Windows (instead of
;;       defining them to raise an error or making them invisible in menus).
;; 2012/06/02 dadams
;;     Added: diredp-do-(print|encrypt|decrypt|sign|verify)-recursive.  Menus.  Keys.
;;     diredp-do-move-recursive: Corrected to use dired-rename-file, not dired-copy-file.
;; 2012/05/30 dadams
;;     diredp-insert-as-subdir: Added optional arg IN-DIRED-NOW-P.  Pick up markings & switches
;;                              from sole Dired buffer for CHILD if not in Dired now.
;; 2012/05/29 dadams
;;     Added: diredp-do-(chxxx|chgrp|chown|touch)-recursive, diredp-touch-this-file,
;;       diredp-menu-bar-(immediate|operate)-bookmarks-menu.  Added to menus.  Bound to keys.
;;     Factored bookmark stuff into Bookmark(s) submenus.
;;     diredp-menu-bar-immediate-menu: Added dired-kill-subdir, [goto-subdir].
;;     diredp-dired-this-subdir, dired-maybe-insert-subdir: Corrected :visible/enable.
;;     diredp-dired-inserted-subdirs: Do dired-(remember-marks|mark-remembered) in this-buff.
;;     diredp-mouse-3-menu:
;;       Do not use save-excursion, because some commands move point on purpose.  Just return to
;;         original point unless command intends to MOVEP.
;;       Added to menu dired-maybe-insert-subdir (two entries), dired-kill-subdir.
;;       Use *-this-file*, not *-do-*: copy|symlink|shell-command|grep|load (don't use :keys).
;; 2012/05/26 dadams
;;     diredp-dired-inserted-subdirs, diredp-insert-as-subdir:
;;       Preserve markings and switches in target buffer.
;;     dired-mark-pop-up: Use unwind-protect.  Bury buffer too.
;;     diredp-do-chmod-recursive: Use only 5 args if < Emacs 23.
;; 2012/05/25 dadams
;;     Added: diredp-insert-as-subdir, diredp-ancestor-dirs, diredp-maplist,
;;            diredp-do-redisplay-recursive, diredp-do-chmod-recursive.
;;            Bound diredp-do-chmod-recursive. to M-+ M and added to menu.
;;     diredp-get-files: Added optional arg DONT-ASKP.
;;     diredp-y-or-n-files-p: Kill list buffer if it was never shown.
;;     dired-mark-pop-up: ignore error when delete frame/window.
;; 2012/05/22 dadams
;;     diredp-get-files(-for-dir): Added optional arg INCLUDE-DIRS-P.
;;     Added: diredp-insert-subdirs(-recursive), diredp(-this)-dired-inserted-subdir(s).
;;            Added to menus.  Bound diredp-insert-subdirs* to (M-+) M-i.
;;     Bound diredp-capitalize(-recursive) to (M-+) %c.
;;     Added diredp-dired-union-other-window to Dirs menu.
;;     Updated diredp-dired-plus-description.
;; 2012/05/19 dadams
;;     Added: diredp-image-dired-*-recursive, diredp-*link-recursive,
;;            diredp-do-isearch(-regexp)-recursive, diredp-do-query-replace-regexp-recursive,
;;            diredp-do-search-recursive, diredp-(capitalize|(up|down)case)-recursive,
;;            diredp-create-files-non-directory-recursive.
;;              Bound on M-+ prefix key.  Added to menus.
;;     diredp-get-files, diredp-y-or-n-files-p, diredp-list-files, diredp-list-marked-recursive:
;;       Added optional arg PREDICATE.
;;     diredp-do-create-files-recursive: Removed MARKER-CHAR arg.  Hard-code to keep markings.
;;     diredp-do-(copy|move)-recursive: Use arg IGNORE-MARKS-P (forgot to use it).
;;                                      Removed MARKER-CHAR arg in call to d-d-c-f-r.
;;     Added missing autoload cookies.
;; 2012/05/06 dadsms
;;     diredp-y-or-n-files-p: Do not kill buffer *Files* - just bury it.
;; 2012/05/05 dadams
;;     Added: diredp-do-bookmark-recursive, diredp-do-bookmark-in-bookmark-file-recursive,
;;            diredp-set-bookmark-file-bookmark-for-marked-recursive.
;;              Bound to M-+ M-b, M-+ C-M-B (aka C-M-S-b), M-+ C-M-b, respectively.  Added to menus.
;;     diredp-bookmark: Added optional arg FILE.
;;     diredp-do-bookmark-in-bookmark-file: Added optional arg FILES.
;;     diredp-dired-plus-description: Updated.
;;     diredp-get-confirmation-recursive: Raise error if not in Dired.
;;     diredp-do-bookmark-recursive, diredp-marked-recursive(-other-window),
;;       diredp-multiple-w32-browser-recursive:
;;         Use diredp-get-confirmation-recursive.
;; 2012/05/04 dadams
;;     Added: dired-mark-unmarked-files for Emacs < 24.
;;     diredp-do-create-files-recursive: Corrected for Emacs < 24.
;;     diredp-do-create-files-recursive, diredp-(un)mark-files-tagged-regexp,
;;       diredp(-mouse)-do-(un)tag, diredp(-mouse)-do-remove-all-tags,
;;       diredp(-mouse)-do-paste-(add|replace)-tags, diredp(-mouse)-do-set-tag-value,
;;       diredp(-mouse)-do-bookmark(-in-bookmark-file), diredp-find-a-file-read-args,
;;       diredp-mouse-do-shell-command:
;;         Use lexical-let(*), to get closures for free vars in lambdas.
;; 2012/04/28 dadams
;;     Added:
;;       diredp-copy-filename-as-kill-recursive, diredp-do-copy-recursive,
;;       diredp-do-find-marked-files-recursive, diredp-do-grep-recursive,
;;       diredp-do-move-recursive, diredp-do-shell-command-recursive,
;;       diredp-list-marked-recursive, diredp-marked-recursive(-other-window),
;;       diredp-multiple-w32-browser-recursive, diredp-do-create-files-recursive,
;;       diredp-get-confirmation-recursive, diredp-list-files, diredp-y-or-n-files-p,
;;       diredp-menu-bar-recursive-marked-menu.
;;     diredp-get-files: Use diredp-y-or-n-files-p, not y-or-n-p.
;;     Commented out dired-readin-insert - see comment.
;;     Moved bookmark menu items to submenu Bookmarks.
;;     Added keys (with M-+ prefix) and menu items for new (*-recursive) commands.
;;     Reordered w32-browser stuff in menus.
;;     diredp-do-grep: Combined defs for diff Emacs versions - do version test at runtime.
;; 2012/04/25 dadams
;;     dired-insert-directory: Updated per Emacs 24.
;; 2012/04/23 dadams
;;     Added (moved here from Icicles, and renamed prefix):
;;       diredp-re-no-dot, diredp-get-files, diredp-get-files-for-dir, diredp-files-within,
;;       diredp-files-within-dirs-done.
;; 2012/04/05 dadams
;;     Added redefinition of dired-mark-pop-up, to fix Emacs bug #7533.  If they ever fix it
;;     then remove this hack.
;; 2012/03/13 dadams
;;     diredp-dired(-for)-files(-other-window):
;;       Bind: icicle-sort-comparer, icicle-all-candidates-list-alt-action-fn.
;;       Use icicle-(un)bind-file-candidate-keys.
;;     diredp-dired-files-interactive-spec: Updated doc strings accordingly.
;; 2012/03/07 dadams
;;     Added: dired-switches-escape-p.
;;     dired-get-filename: Updated wrt Emacs 24:
;;       whitespace quoting for bug #10469, filename quoting per Emacs 23.3+,
;;         MS Windows conversion of \ to / per Emacs 23.3+.
;;     dired-goto-file: Escape whitespace, per Emacs 24 (for bug #10469).
;; 2012/03/02 dadams
;;     Require cl.el at compile time even for Emacs 22+, for case macro.
;; 2012/02/28 dadams
;;     Do not bother to soft-require mkhtml.el anymore.
;; 2012/02/18 dadams
;;     Swapped keys for dired-w32(-browser|explore), so the former is M-RET, as in Bookmark+.
;; 2012/01/10 dadams
;;     diredp-font-lock-keywords-1: Corrected for date/time when locale is used, not iso.
;; 2011/12/19 dadams
;;     dired-insert-set-properties, dired-mark-sexp, diredp-(un)mark-region-files,
;;       diredp-flag-region-files-for-deletion, diredp-mouse-3-menu:
;;         Use line-(beginning|end)-position.
;; 2011/12/16 dadams
;;     diredp-menu-bar-mark-menu: Removed Revert item.
;;     diredp-menu-bar-subdir-menu: Add image-dired-dired-toggle-marked-thumbs.
;;     diredp-mouse-3-menu:
;;       Use commands bound to keys, so the keys show up in the menu.  Prefer *-this-file.
;;       Correct the mark/unmark/flag menu-item visibility.  Added Capitalize.
;; 2011/12/09 dadams
;;     diredp-w32-drives: Use dolist, not mapcar.
;;     diredp-mouse-3-menu: Use easymenu to build the menu.  Conditionalize some items.
;;     Bind down-mouse-3, not mouse-3, to diredp-mouse-3-menu.  (bind mouse-3 to ignore).
;;     Added eval-when-compile for easymenu.el.
;; 2011/12//02 dadams
;;     Added diredp-internal-do-deletions.
;;     dired(-mouse)-do(-flagged)-delete, : Use diredp-internal-do-deletions, for trash.
;; 2011/11/29 dadams
;;     diredp-read-bookmark-file-args: Corrected use of list of default file names: > Emacs 23.1.
;; 2011/10/31 dadams
;;     dired-mode-hook: Call font-lock-refresh-defaults - see Emacs 24 bugs #6662 and #9919.
;; 2011/10/24 dadams
;;     Protect dired-show-file-type with fboundp.
;; 2011/09/03 dadams
;;     diredp-do-grep-1: Map shell-quote-argument over file names.  Thx to Joe Bloggs.
;; 2011/08/07 dadams
;;     diredp-bookmark (need to keep in sync with bmkp-make-record-for-target-file):
;;       Instead of image-bookmark-make-record, use explicit function that includes file, type.
;; 2011/07/25 dadams
;;     Changed featurep to eval-after-load, for bookmark+-1.el and w32-browser.el.
;; 2011/07/01 dadams
;;     Fixed typo: dired-toggle-find-file-reuse-dir -> ...diredp....  Thx to pasja on Emacs Wiki.
;; 2011/06/18 dadams
;;     Added: diredp-describe-mode, diredp-dired-plus-help(-link), diredp-help-button,
;;            diredp-dired-plus-description(+links), diredp-send-bug-report.
;;     Bound diredp-describe-mode to whatever describe-mode is bound to.
;;     All menus, :enable with mark-active: Added transient-mark-mode and mark != point.
;;     toggle-diredp-find-file-reuse-dir: Swapped which one is the alias.
;;     diredp-w32-list-mapped-drives: Display *Shell Command Output* at end.
;;     diredp-mouse-(describe-file|3-menu|mark/unmark|(find|view)-file(-other-window)):
;;       save-excursion set-buffer -> with-current-buffer.
;; 2011/06/08 dadams
;;     Added: diredp-dired-for-files(-other-window).
;; 2011/06/07 dadams
;;     Bound dired-show-file-type to _, since y is diredp-relsymlink-this-file.
;; 2011/04/25 dadams
;;     Added (from files+.el): dired(-mouse)-describe-file. Bound to C-h (C-)RET, added to menus.
;; 2011/04/23 dadams
;;     Added, bound (T c, T M-w, T 0, T v, T p, T C-y, T q), and added to menus:
;;       diredp-copy-tags-this-file, diredp-mouse-copy-tags,
;;       diredp(-mouse)(-do)-remove-all-tags(-this-file),
;;       diredp(-mouse)(-do)-set-tag-value(-this-file),
;;       diredp(-mouse)(-do)-paste-(add|replace)-tags(-this-file).
;;     diredp-mark-files-tagged-(all/none|some/not-all): Bound free var presentp.
;;     dired-map-over-marks: Corrected: Bind NEWARG and use that, not ARG.
;;     dired-get-marked-files: let* -> let.
;;     dired-do-redisplay, diredp-mouse-diff: when/if -> and.
;;     dired-readin-insert, dired-get-filename: if -> unless/when.
;;     diredp-mouse-find-file-reuse-dir-buffer: with-current-buffer, not save...
;;     diredp-mouse-mark/unmark: Removed unused bol/eol vars.
;; 2011/04/19 dadams
;;     Added: diredp-(un)mark-files-tagged-((not-)all|none|some|regexp|all/none|some/not-all),
;;            dired-mark-if.  Added Tagged submenu for Mark menu.
;;     Put tags commands on prefix key T, as in Bookmark+.  Removed C-(M-)+/- tags-cmd bindings.
;;     diredp-untag-this-file: Added prefix-arg behavior.
;; 2011/04/18 dadams
;;     Added: diredp-prompt-for-bookmark-prefix-flag.
;;            Use it in diredp(-mouse)-do-(un)tag, diredp-read-bookmark-file-args,
;;                      diredp(-mouse)-do-bookmark, diredp-(bookmark|(un)tag)-this-file.
;;     diredp-(bookmark|(un)tag)-this-file, diredp(-do)-bookmark, diredp-(un)tag,
;;       diredp-do-bookmark-in-bookmark-file, diredp-set-bookmark-file-bookmark-for-marked:
;;         Made PREFIX arg optional.
;; 2011/04/17 dadams
;;     Added: diredp-(bookmark|(un)tag)-this-file, diredp(-mouse)(-do)-(un)tag.
;;     diredp-mouse-3-menu: Added: diredp-mouse-do-(un)tag.
;;     diredp-menu-bar-immediate-menu: Added diredp-(un)tag-this-file, diredp-bookmark-this-file.
;;     diredp-menu-bar-operate-menu: Added diredp-do-(un)tag.
;;     Bound diredp-do-tag to C-+, diredp-tag-this-file to C-M-+, diredp-do-untag to C--,
;;           diredp-untag-this-file to C-M--, diredp-bookmark-this-file to C-B.
;;     diredp-bookmark: Use bmkp-autofile-set, not bmkp-file-target-set, so get autofile.
;;     diredp-read-bookmark-file-args, diredp(-mouse)-do-bookmark:
;;       Default for prefix is now an empty string, not the directory.
;;     diredp-mouse-do-bookmark: Removed optional second arg.
;;     Corrected typo: direp-read-bookmark-file-args -> diredp-read-bookmark-file-args.
;; 2011/03/25 dadams
;;     diredp-bookmark: Fixed typo: bmkp-file-indirect-set -> bmkp-file-target-set.
;; 2011/02/11 dadams
;;     diredp-deletion, diredp-deletion-file-name, diredp-executable-tag:
;;       Made default the same for dark background as for light.
;;     diredp-ignored-file-name: Made default a bit darker for dark background.
;; 2011/02/03 dadams
;;     All deffaces: Provided default values for dark-background screens too.
;; 2011/01/12 dadams
;;     dired-do-flagged-delete: Removed sit-for added on 1/02.
;; 2011/01/04 dadams
;;     defsubst -> defun everywhere.
;;     Removed autoload cookies from non def* sexps, defvar, and non-interactive functions.
;;     Added some missing autoload cookies for defcustom and commands.
;; 2011/01/02 dadams
;;     Added: diredp-this-file-(un)marked-p, diredp-toggle-marks-in-region.
;;     diredp-(un)mark-region-files, diredp-flag-region-files-for-deletion:
;;       Act only on marked/unmarked files (opposite).  Fix 2nd arg to dired-mark-if.
;;     diredp-mouse-3-menu:
;;       If region is active and mouse3.el was loaded, then use its popup.
;;       Fix Toggle Marked/Unmarked:
;;         Use diredp-toggle-marks-in-region, so widen, show details and use bol/eol.
;;     dired-do-flagged-delete: Added sit-for.
;; 2010/11/28 dadams
;;     diredp-mouse-3-menu: Added Toggle Marked/Unmarked for region menu.
;; 2010/10/20 dadams
;;     Moved Emacs 20 tweak to recognize k in file sizes to var dired-move-to-filename-regexp.
;;     Added diredp-loaded-p.
;; 2010/10/19 dadams
;;     diredp-font-lock-keywords-1:
;;       Handle decimal pt in file size.  Thx to Michael Heerdegen.
;;       Enable Emacs 20/21 to handle -h option (decimal point size).
;;     Renamed: face diredp-inode+size to diredp-number.
;; 2010/10/01 dadams
;;     dired-goto-file: Avoid infcl-loop from looking for dir line.  Thx to not-use.dilines.net.
;; 2010/09/29 dadams
;;     Added: diredp-dired-union(-1|-other-window|-interactive-spec).
;;     dired-goto-file: fix for Emacs bug #7126.
;; 2010/09/27 dadams
;;     Renamed diredp-dired-interactive-spec to diredp-dired-files-interactive-spec.
;;     diredp-dired-files-interactive-spec: Respect file-list arg: kill existing Dired buffer.
;;                                          Fix use of prefix arg for switches.
;; 2010/09/26 dadams
;;     Added: dired-insert-directory: Compute WILDCARD arg for individual files.
;;     Added: dired-readin-insert: Use t as WILDCARD arg to dired-insert-directory.
;;     Added: diredp-dired-files(-other-window), diredp-dired-interactive-spec.
;; 2010/08/27 dadams
;;     Use diredp-font-lock-keywords-1 properly as a second level of fontification.
;;     Added: diredp-w32-drives(-mode(-map)), dired-up-directory.
;; 2010/08/07 dadams
;;     dired-map-over-marks: Removed cl-loop that used dired-between-files.
;;     diredp-get-file-or-dir-name: test against subdir/..? also.
;;     dired-do-find-marked-files: Pass original ARG to dired-get-marked-files.
;; 2010/08/05 dadams
;;     diredp-bookmark:
;;       Handle image files (and sound files, if Bookmark+ is used).
;;       Use bmkp-file-indirect-set if available.
;;       Use error-message-string to get failure msg.
;; 2010/07/11 dadams
;;     Added: diredp-set-bookmark-file-bookmark-for-marked (C-M-b), diredp-mouse-do-bookmark,
;;            diredp-do-bookmark-in-bookmark-file (C-M-B, aka C-M-S-b), diredp-read-bookmark-file-args.
;;     Added them to the operate menu.  Added diredp-do-bookmark to mouse-3 menu.
;; 2010/07/07 dadams
;;     dired-do-*: Updated doc strings for prefix arg treatment from dired-map-over-marks-check.
;;     Added missing autoload cookies.
;; 2010/05/29 dadams
;;     diredp-bookmark: Use relative file name in bookmark name.
;;     Removed defvar of directory-listing-before-filename-regexp.
;; 2010/05/28 dadams
;;     Changed menu item for dired-create-directory to New Directory.  Moved it before Up Dir.
;; 2010/03/19 dadams
;;     diredp-font-lock-keywords-1: Handle date+time wrt regexp changes for Emacs 23.2.
;; 2010/01/31 dadams
;;     diredp-bookmark:
;;       Don't use bookmark-set or find-file-noselect - inline the needed bookmark-store code.
;;       Call bookmark-maybe-load-default-file.  Use rudimentary bookmark-make-record-function.
;; 2010/01/21 dadams
;;     Renamed:
;;       diredp-subst-find-alternate-for-find to diredp-make-find-file-keys-reuse-dirs
;;       diredp-subst-find-for-find-alternate to diredp-make-find-file-keys-not-reuse-dirs.
;;     diredp-make-find-file-keys(-not)-reuse-dirs: Handle also dired(-mouse)-w32-browser.
;; 2010/01/10 dadams
;;     Added: face diredp-inode+size.  Use in diredp-font-lock-keywords-1.
;;     diredp-font-lock-keywords-1: Allow decimal point in file size.  Thx to Regis.
;; 2010/01/05 dadams
;;     dired-insert-set-properties:
;;       Add text property dired-filename to the file name (for Emacs 23).
;; 2009/10/23 dadams
;;     diredp-font-lock-keywords-1: Override `l' and `t' matches in headings with default face.
;; 2009/10/13 dadams
;;     Added: diredp(-do)-bookmark.  Added to Multiple menu, and bound to M-b.
;; 2009/10/11 dadams
;;     diredp-menu-bar-immediate-menu:
;;       Added items: image display items, dired-maybe-insert-subdir.
;;       Test dired-do-relsymlink, not diredp-relsymlink-this-file.
;;     diredp-menu-bar-operate-menu:
;;       Added items: epa encryption items, image items, isearch items.
;;     diredp-menu-bar-subdir-menu:
;;       Added items: revert, isearch file names, dired-compare-directories.
;;     Removed macro menu-item-any-version - use menu-item everywhere (works for Emacs 20+).
;;     Added wdired-change-to-wdired-mode to subdir menu even for Emacs 20, if defined.
;; 2009/07/09 dadams
;;     dired-goto-file: Make sure we have a string before calling directory-file-name.
;; 2009/05/08 dadams
;;     dired-find-file (Emacs 20): Raise error if dired-get-filename returns nil.
;; 2009/04/26 dadams
;;     dired-insert-set-properties, diredp-(un)mark-region-files,
;;       diredp-flag-region-files-for-deletion, diredp-mouse-3-menu, diredp-mouse-mark/unmark:
;;         Bind inhibit-field-text-motion to t, to ensure real eol.
;; 2008/12/17 dadams
;;     diredp-font-lock-keywords-1: Don't do diredp-deletion, diredp-flag-mark for empty lines.
;; 2008/09/22 dadams
;;     Added: diredp-fileset, diredp-get-file-or-dir-name, and redefinitions of
;;            dired-map-over-marks, dired-find-file, and dired-mouse-find-file-other-window.
;;     Added vanilla code to pick up macro dired-map-over-marks:
;;       dired-get-marked-files, dired-do-delete, dired-map-over-marks-check,
;;       dired-do-redisplay, image-dired-dired-insert-marked-thumbs.
;;     diredp-find-file-other-frame, diredp-mouse-(find|view)-file:
;;       Added nil t args to dired-get-filename calls.
;;     diredp-do-grep(-1): Use new dired-get-marked-files instead of ad-hoc treatment of C-u.
;; 2008/09/21 dadams
;;     diredp-marked(-other-window): Don't treat zero prefix arg as numerical (no empty Dired).
;;     Added dired-find-file redefinition for Emacs 20.
;; 2008/09/11 dadams
;;     diredp-do-grep: Plain C-u means grep all files in Dired buffer.
;;     diredp-do-grep-1: Treat 'all value of FILES arg.
;;     Added: diredp-all-files.
;; 2008/09/09 dadams
;;     Added: diredp-marked(-other-window).  Added to menus.  Bound *-other-window to C-M-*.
;; 2008/09/07 dadams
;;     Added: diredp(-mouse)-do-grep(-1), diredp-grep-this-file.
;;     Bound diredp-do-grep to M-g.  Added grep commands to menus.
;; 2008/07/18 dadams
;;     Soft-require w32-browser.el.  Bind its commands in Dired map and menus.
;; 2008/03/08 dadams
;;     dired-maybe-insert-subdir: Fit one-window frame after inserting subdir.
;; 2008/03/07 dadams
;;     Added: redefinitions of dired-maybe-insert-subdir, dired-goto-file, dired-get-filename.
;;     Added: diredp-this-subdir.
;; 2007/11/27 dadams
;;     diredp-mouse(-backup)-diff: If available, use icicle-read-string-completing.
;; 2007/09/23 dadams
;;     Removed second arg to undefine-killer-commands.
;; 2007/07/27 dadams
;;     diredp-font-lock-keywords-1: Allow also for bz2 compressed files - Thx to Andreas Eder.
;; 2006/09/03 dadams
;;     diredp-font-lock-keywords-1: Corrected file size and inode number.  Thx to Peter Barabas.
;; 2006/08/20 dadams
;;     Added: diredp-find-a-file*.
;; 2006/06/18 dadams
;;     diredp-font-lock-keywords-1: Highlight file name (also) of flagged files.
;;                                  Use dired-del-marker instead of literal D.
;;     Added: diredp-deletion-file-name.
;; 2006/03/31 dadams
;;     No longer use display-in-minibuffer.
;; 2006/01/07 dadams
;;     Added: link for sending bug report.
;; 2006/01/06 dadams
;;     Added defgroup Dired-Plus and used it. Added :link.
;; 2006/01/04 dadams
;;     Added defvar of directory-listing-before-filename-regexp, for Emacs 22 compatibility.
;; 2005/12/29 dadams
;;     Added: diredp-mouse-mark/unmark-mark-region-files.
;; 2005/12/26 dadams
;;     Updated groups.
;; 2005/12/05 dadams
;;     diredp-ignored-file-name: Made it slightly darker.
;; 2005/11/05 dadams
;;     Renamed all stuff defined here to have diredp- prefix.
;;     diredp-relsymlink-this-file: Protected with fboundp.
;;     Changed to soft require: dired-x.el.
;;     Removed comment to require this inside eval-after-load.
;; 2005/11/03 dadams
;;     Added: dired-display-msg.  Replace blue-foreground-face with it.
;;     Alias dired-do-toggle to dired-toggle-marks, if defined.
;; 2005/11/02 dadams
;;     Added: dired-get-file-for-visit, dired(-mouse)-find-alternate-file*,
;;            togglep-dired-find-file-reuse-dir, dired+-subst-find-*.
;;     Use defface for all faces.  Renamed without "-face".  No longer require def-face-const.
;;     dired-simultaneous-find-file: Minor bug fix (typo).
;; 2005/07/10 dadams
;;     dired-unmark-all-files-no-query -> dired-unmark-all-marks
;;       (thanks to Sivaram Neelakantan for bug report).
;; 2005/05/25 dadams
;;     string-to-int -> string-to-number everywhere.
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2005/02/16 dadams
;;     Added dired-mark/unmark-extension. Replaced dired-mark-extension with it everywhere.
;; 2005/01/08 dadams
;;     Bind [S-mouse-1], instead of [S-down-mouse-1], to dired-mouse-mark-region-files.
;; 2004/11/20 dadams
;;     dired-mark-sexp: Search for literal month names only for versions before Emacs 20.
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/11/14 dadams
;;     Bound dired-no-confirm to non-nil for dired-mouse-*.
;;     Updated for Emacs 21 and improved highlighting:
;;       Spaces OK in file and directory names. Highlight date/time and size.
;; 2004/10/17 dadams
;;     Require cl only for Emacs 20, and only when compile.
;; 2004/10/01 dadams
;;     Updated to work with Emacs 21 also.
;; 2004/04/02 dadams
;;     dired-font-lock-keywords-1: Prefer using dired-omit-extensions
;;     to completion-ignored-extensions, if available.
;; 2004/03/22 dadams
;;     Added dired-mouse-mark-region-files and dired-mouse-mark/unmark.
;; 2000/09/27 dadams
;;     1. dired-font-lock-keywords-1: fixed for spaces in dir names.
;;     2. Added: dired-buffers-for-dir.
;; 1999/09/06 dadams
;;     Added S-*-mouse-2 bindings (same as C-*-mouse-2).
;; 1999/08/26 dadams
;;     1. Added *-face vars and dired-font-lock-keywords-1.
;;     2. Added possibility to use dired-font-lock-keywords-1 via hook.
;; 1999/08/26 dadams
;;     Changed key binding of dired-mouse-find-file from down-mouse-2 to mouse-2.
;; 1999/08/25 dadams
;;     Changed (C-)(M-)mouse-2 bindings.
;; 1999/08/25 dadams
;;     1. Added cmds & menu bar and key bindings: (dired-)find-file-other-frame.
;;     2. Changed binding for dired-display-file.
;; 1999/03/26 dadams
;;     1. Get rid of Edit menu-bar menu.
;;     2. dired-mouse-3-menu: Changed popup titles and item names.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (require 'cl-lib)) ;; case (plus, for Emacs 20: dolist, pop, push)
(eval-when-compile (require 'easymenu)) ;; easy-menu-create-menu

(require 'dired) ;; dired-revert
(require 'dired-aux) ;; dired-bunch-files, dired-do-chxxx, dired-do-create-files,
                     ;; dired-mark-read-string, dired-read-shell-command,
                     ;; dired-run-shell-command, dired-shell-stuff-it
(require 'dired-x) ;; dired-do-relsymlink
(require 'autofit-frame nil t) ;; (no error if not found) fit-frame-if-one-window
(require 'bookmark+ nil t) ;; (no error if not found)
 ;; bmkp-autofile-add-tags, bmkp-autofile-remove-tags, bmkp-autofile-set, bmkp-copied-tags,
 ;; bmkp-current-bookmark-file, bmkp-describe-bookmark, bmkp-empty-file, bmkp-get-autofile-bookmark,
 ;; bmkp-get-bookmark-in-alist, bmkp-get-tags, bmkp-read-tag-completing,
 ;; bmkp-read-tags-completing, bmkp-refresh/rebuild-menu-list, bmkp-remove-all-tags,
 ;; bmkp-same-file-p, bmkp-set-bookmark-file-bookmark, bmkp-set-sequence-bookmark,
 ;; bmkp-set-tag-value, bmkp-some, bmkp-switch-bookmark-file, bmkp-tag-name

;; For now at least, `highlight.el' is needed only if you use `bookmark+.el'.
(when (featurep 'bookmark+) (require 'highlight nil t)) ;; (no error if not found):
 ;; hlt-highlight-region

(if (> emacs-major-version 21) (require 'help-fns+ nil t) (require 'help+20 nil t))  ;; (no error if not found):
 ;; describe-file

(require 'misc-fns nil t) ;; (no error if not found): undefine-killer-commands
(require 'image-file nil t) ;; (no error if not found): image-file-name-regexp
(require 'image-dired nil t) ;; (no error if not found):
 ;; image-dired-create-thumb, image-dired-create-thumbnail-buffer,
 ;; image-dired-dired-after-readin-hook, image-dired-delete-tag, image-dired-dired-comment-files,
 ;; image-dired-dired-display-external, image-dired-dired-display-image,
 ;; image-dired-display-thumbs, image-dired-get-comment, image-dired-get-exif-file-name,
 ;; image-dired-get-thumbnail-image, image-dired-insert-thumbnail, image-dired-line-up,
 ;; image-dired-line-up-dynamic, image-dired-line-up-interactive, image-dired-line-up-method,
 ;; image-dired-list-tags, image-dired-main-image-directory, image-dired-mark-tagged-files,
 ;; image-dired-read-comment, image-dired-remove-tag, image-dired-save-information-from-widgets,
 ;; image-dired-tag-files, image-dired-thumb-height, image-dired-thumbnail-buffer,
 ;; image-dired-thumb-name, image-dired-thumb-size, image-dired-thumb-width,
 ;; image-dired-widget-list, image-dired-write-comments, image-dired-write-tags
(when (memq system-type '(windows-nt ms-dos))
  ;; (no error if not found):
  (require 'w32-browser nil t));; dired-w32explore, dired-w32-browser, dired-mouse-w32-browser,
                               ;; dired-multiple-w32-browser
(when (< emacs-major-version 21) (require 'subr-21)) ;; replace-regexp-in-string

;; Provide macro for code byte-compiled using Emacs < 22.
(eval-when-compile
  (when (< emacs-major-version 22)
    ;; Same as vanilla definition.  Needed for byte-compiling.
    (defmacro minibuffer-with-setup-hook (fun &rest body)
      "Temporarily add FUN to `minibuffer-setup-hook' while executing BODY.
BODY should use the minibuffer at most once.
Recursive uses of the minibuffer are unaffected (FUN is not
called additional times).

This macro actually adds an auxiliary function that calls FUN,
rather than FUN itself, to `minibuffer-setup-hook'."
      ;; (declare (indent 1) (debug t))
      (let ((hook  (make-symbol "setup-hook")))
        `(let (,hook)
           (setq ,hook  (lambda ()
                          ;; Clear out this hook so it does not interfere
                          ;; with any recursive minibuffer usage.
                          (remove-hook 'minibuffer-setup-hook ,hook)
                          (funcall ,fun)))
           (unwind-protect
               (progn (add-hook 'minibuffer-setup-hook ,hook) ,@body)
             (remove-hook 'minibuffer-setup-hook ,hook))))))
  )

;; Provide macro for code byte-compiled using Emacs < 23.
(eval-and-compile
  (when (< emacs-major-version 23)


    ;; REPLACE ORIGINAL in `subr.el'.  Needed for byte-compiling.
    ;; Almost the same as vanilla definition.
    ;; The only difference is to use `set-buffer-modified-p' if `restore-buffer-modified-p' is  not defined.
    (defmacro with-silent-modifications (&rest body)
      "Execute BODY, pretending it does not modify the buffer.
This macro is typically used around modifications of
text properties that do not really affect the buffer's content.
If BODY performs real modifications to the buffer's text, other
than cosmetic ones, undo data may become corrupted.

This macro will run BODY normally, but doesn't count its buffer
modifications as being buffer modifications.  This affects things
like `buffer-modified-p', checking whether the file is locked by
someone else, running buffer modification hooks, and other things
of that nature."
      ;; (declare (debug t) (indent 0))
      (let ((modified  (make-symbol "modified")))
        `(let* ((,modified                   (buffer-modified-p))
                (buffer-undo-list            t)
                (inhibit-read-only           t)
                (inhibit-modification-hooks  t))
           (unwind-protect
               (progn ,@body)
             (unless ,modified
               (if (fboundp 'restore-buffer-modified-p)
                   (restore-buffer-modified-p nil)
                 (set-buffer-modified-p nil)))))))))

(defmacro diredp-user-error (&rest args)
  `(if (fboundp 'user-error) (user-error ,@args) (error ,@args)))

;; Define these for Emacs 20 and 21.
(unless (fboundp 'dired-get-file-for-visit) ; Emacs 22+
  (defun dired-get-file-for-visit ()    ; Not bound
    "Get the current line's file name, with an error if file does not exist."
    (interactive)
    (let ((raw  (dired-get-filename nil 'NO-ERROR)) ; No error for `.' and `..'.
          file-name)
      (unless raw (error "No file on this line"))
      (setq file-name  (file-name-sans-versions raw t))
      (if (file-exists-p file-name)
          file-name
        (if (file-symlink-p file-name)
            (error "File is a symlink to a nonexistent target")
          (error "File no longer exists; type `g' to update Dired buffer")))))

  (defun dired-find-alternate-file ()   ; Not bound
    "In Dired, visit this file or directory instead of the Dired buffer."
    (interactive)
    (set-buffer-modified-p nil)
    (find-alternate-file (dired-get-file-for-visit))))

(defun diredp-make-obsolete (obsolete-name current-name &optional when)
  "Same as `make-obsolete', but usable also prior to Emacs 23."
  (if (< emacs-major-version 23)
      (make-obsolete obsolete-name current-name)
    (make-obsolete obsolete-name current-name when)))

(defun diredp-make-obsolete-variable (obsolete-name current-name &optional when access-type)
  "Same as `make-obsolete-variable', but usable also prior to Emacs 23."
  (if (< emacs-major-version 23)
      (make-obsolete-variable obsolete-name current-name)
    (make-obsolete-variable obsolete-name current-name when)))


;;;;;;;;;;;;;;;;;;;;;;;


(provide 'dired+)
(require 'dired+)                       ; Ensure loaded before compile this.

;; Quiet the byte-compiler.
(defvar bmkp-copied-tags)                         ; In `bookmark+-1.el'
(defvar bmkp-current-bookmark-file)               ; In `bookmark+-1.el'
(defvar bookmark-default-file)                    ; In `bookmark.el'
(defvar compilation-current-error)                ; In `compile.el'
(defvar delete-by-moving-to-trash)                ; Built-in, Emacs 23+
(defvar dired-always-read-filesystem)             ; In `dired.el', Emacs 26+
(defvar dired-auto-revert-buffer)                 ; In `dired.el', Emacs 23+
(defvar dired-create-files-failures)              ; In `dired-aux.el', Emacs 22+
(defvar dired-details-state)                      ; In `dired-details+.el'
(defvar dired-keep-marker-hardlink)               ; In `dired-x.el'
(defvar dired-omit-mode)                          ; In `dired.el', Emacs 22+
(defvar dired-overwrite-confirmed)                ; In `dired-aux.el'
(defvar dired-query-alist)                        ; In `dired-aux.el', Emacs < 24
(defvar dired-recursive-copies)                   ; In `dired-aux.el', Emacs 22+
(defvar dired-recursive-deletes)                  ; In `dired.el', Emacs 22+
(defvar dired-shrink-to-fit)                      ; In `dired.el'
(defvar dired-switches-alist)                     ; In `dired.el'
(defvar dired-subdir-switches)                    ; In `dired.el'
(defvar dired-touch-program)                      ; Emacs 22+
(defvar dired-use-ls-dired)                       ; Emacs 22+
(defvar diredp-count-.-and-..-flag)               ; Here, Emacs 22+
(defvar diredp-hide-details-initially-flag)       ; Here, Emacs 24.4+
(defvar diredp-hide-details-last-state)           ; Here, Emacs 24.4+
(defvar diredp-hide-details-propagate-flag)       ; Here, Emacs 24.4+
(defvar diredp-hide-details-toggled)              ; Here, Emacs 24.4+
(defvar diredp-highlight-autofiles-mode)          ; Here, Emacs 22+
(defvar diredp-menu-bar-encryption-menu)          ; Here, Emacs 23+
(defvar diredp-menu-bar-images-recursive-menu)    ; Here (old name)
(defvar diredp-menu-bar-regexp-recursive-menu)    ; Here (old name)
(defvar diredp-menu-bar-subdir-menu)              ; Here (old name)
(defvar diredp-move-file-dirs)                    ; Here, Emacs 24+
(defvar diredp-single-bookmarks-menu)             ; Here, if Bookmark+ is available
(defvar filesets-data)                            ; In `filesets.el'
(defvar grep-use-null-device)                     ; In `grep.el'
(defvar header-line-format)                       ; Emacs 22+
(defvar icicle-file-sort)                         ; In `icicles-opt.el'
;; $$$$ (defvar icicle-file-sort-first-time-p)            ; In `icicles-var.el'
(defvar icicle-files-ido-like-flag)               ; In `icicles-opt.el'
(defvar icicle-ignored-directories)               ; In `icicles-opt.el'
(defvar icicle-sort-comparer)                     ; In `icicles-opt.el'
(defvar image-dired-display-image-buffer)         ; In `image-dired.el'
(defvar image-dired-line-up-method)               ; In `image-dired.el'
(defvar image-dired-main-image-directory)         ; In `image-dired.el'
(defvar image-dired-thumbnail-buffer)             ; In `image-dired.el'
(defvar image-dired-thumb-height)                 ; In `image-dired.el'
(defvar image-dired-thumb-width)                  ; In `image-dired.el'
(defvar image-dired-widget-list)                  ; In `image-dired.el'
(defvar ls-lisp-use-insert-directory-program)     ; In `ls-lisp.el'
(defvar minibuffer-default-add-function)          ; In `simple.el', Emacs 23+
(defvar mouse3-dired-function)                    ; In `mouse3.el'
(defvar read-file-name-completion-ignore-case)    ; In `minibuffer.el', Emacs 23+.  In C code, Emacs 22.
(defvar recentf-list)                             ; In `recentf.el'
;; Really a function, not a var - this quiets Emacs 20 byte-compiler, which doesn't recognize `declare-function'.
;; (defvar rgrep-find-ignored-directories)
(defvar save-some-buffers-action-alist)           ; In `files.el'
(defvar switch-to-buffer-preserve-window-point)   ; In `window.el', Emacs 24+
(defvar tooltip-mode)                             ; In `tooltip.el'
(defvar vc-directory-exclusion-list)              ; In `vc'
(defvar w32-browser-wait-time)                    ; In `w32-browser.el'

;;;;;;;;;;;;;;;;;;;;;;;

(defgroup Dired-Plus nil
  "Various enhancements to Dired."
  :prefix "diredp-" :group 'dired
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
dired+.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download"
          "https://www.emacswiki.org/emacs/download/dired%2b.el")
  :link '(url-link :tag "Description"
          "https://www.emacswiki.org/emacs/DiredPlus")
  :link '(emacs-commentary-link :tag "Commentary" "dired+"))

;;; Variables

;; `dired-do-toggle' was renamed to `dired-toggle-marks' after Emacs 20.
(unless (fboundp 'dired-toggle-marks) (defalias 'dired-toggle-marks 'dired-do-toggle))

;;; This is duplicated in `diff.el' and `vc.el'.
;;;###autoload
(defcustom diff-switches "-c"
  "*A string or list of strings specifying switches to be passed to diff."
  :type '(choice string (repeat string))
  :group 'dired :group 'diff)

;;;###autoload
(defcustom diredp-auto-focus-frame-for-thumbnail-tooltip-flag nil
  "*Non-nil means automatically focus the frame for a thumbnail tooltip.
If nil then you will not see a thumbnail image tooltip when you
mouseover an image-file name in Dired, unless you first give the frame
the input focus (e.g., by clicking its title bar).

This option has no effect if `diredp-image-preview-in-tooltip' is nil.
It also has no effect for Emacs versions prior to Emacs 22."
  :type 'boolean :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-bind-problematic-terminal-keys t
  "*Non-nil means bind some keys that might not work in a text-only terminal.
This applies to keys that use modifiers Meta and Shift together.
If you use Emacs in text-only terminal and your terminal does not
support the use of such keys then customize this option to nil."
  :type 'boolean :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-case-fold-search (if (boundp 'recentf-case-fold-search)
                                       recentf-case-fold-search
                                     (memq system-type '(windows-nt cygwin)))
  "Non-nil means some Dired+ functions ignore case.
The doc of such functions calls out the use of this option."
  :type '(choice
          (restricted-sexp :tag "Ignore case" :match-alternatives (identity)
                           :value (memq system-type '(windows-nt cygwin)))
          (const :tag "Respect case" nil))
  :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-compressed-extensions '(".tar" ".taz" ".tgz" ".arj" ".lzh"
                                          ".lzma" ".xz" ".zip" ".z" ".Z" ".gz" ".bz2" ".rar" ".rev")
  "*List of compressed-file extensions, for highlighting.

Note: If you change the value of this option then you need to restart
Emacs to see the effect of the new value on font-locking."
  :type '(repeat string) :group 'Dired-Plus)

(when (> emacs-major-version 21)        ; Emacs 22+
  (defcustom diredp-count-.-and-..-flag nil
    "Non-nil means count `.' and `..' when counting files for mode-line."
    :type 'boolean :group 'Dired-Plus))

;;;###autoload
(defcustom diredp-default-sort-arbitrary-function nil
  "Sorting used by default for sorting recent-files or dirs
You can re-sort the buffer using \\<dired-mode-map>`\\[diredp-sort-arbitrary-command]'."
  :type '(choice
          (const :tag "Access order, most recent first"   nil)
          (const :tag "Access order, least recent first"  t)
          (function :tag "File name, A-Z"          :value diredp-nondir-file-name-less-p)
          (function :tag "File name, Z-A"          :value diredp-nondir-file-name-more-p)
          (function :tag "Full file name, A-Z"     :value diredp-full-file-name-less-p)
          (function :tag "Full file name, Z-A"     :value diredp-full-file-name-more-p))
  :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-do-report-echo-limit 5
  "Echo result for each file, for fewer than this many files.
If more than this many files are acted on then there is no echoing.

Used by some commands, such as `diredp-do-apply-to-marked'.  Results
that are not echoed are anyway reported by `dired-log', so you can
show them with `?' in the Dired buffer."
  :type '(restricted-sexp :match-alternatives (wholenump)) :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-dwim-any-frame-flag pop-up-frames
  "*Non-nil means the target directory can be in a window in another frame.
Only visible frames are considered.
This is used by ``dired-dwim-target-directory'.
This option has no effect for Emacs versions before Emacs 22."
  :type 'boolean :group 'Dired-Plus)

(when (fboundp 'dired-hide-details-mode) ; Emacs 24.4+
  (defcustom diredp-hide-details-initially-flag t
    "*Non-nil means hide details in Dired from the outset."
    :type 'boolean :group 'Dired-Plus
    :set (lambda (sym defs)
           (custom-set-default sym defs)
           (setq diredp-hide-details-last-state  diredp-hide-details-initially-flag)))

  (defcustom diredp-hide-details-propagate-flag t
    "*Non-nil means display the next Dired buffer the same way as the last.
The last `dired-hide-details-mode' value set is used by the next Dired
buffer created."
    :type 'boolean :group 'Dired-Plus))

;; Emacs 20 only.
;;;###autoload
(unless (fboundp 'define-minor-mode)
  (defcustom diredp-highlight-autofiles-mode t
    "*Non-nil means highlight names of files that are autofile bookmarks.
Autofiles that have tags are highlighted using face
`diredp-tagged-autofile-name'.  Those with no tags are highlighted
using face `diredp-autofile-name'.

Setting this option directly does not take effect; use either
\\[customize] or command `diredp-highlight-autofiles-mode'.

NOTE: When `dired+.el' is loaded (for the first time per Emacs
session), the highlighting is turned ON, regardless of the option
value.  To prevent this and have the highlighting OFF by default, you
must do one of the following:

 ,* Put (diredp-highlight-autofiles-mode -1) in your init file, AFTER
   it loads `dired+.el'.

 ,* Customize the option to `nil', AND ensure that your `custom-file'
   (or the `custom-saved-variables' part of your init file) is
   evaluated before `dired+.el' is loaded.

This option has no effect unless you use libraries `Bookmark and
`highlight.el'."
    :set        (lambda (symbol value) (diredp-highlight-autofiles-mode (if value 1 -1)))
    :initialize 'custom-initialize-default
    :type 'boolean :group 'Dired-Plus :require 'dired+))

;;;###autoload
(defcustom diredp-ignore-compressed-flag t
  "*Non-nil means to font-lock names of compressed files as ignored files.
This applies to filenames whose extensions are in
`diredp-compressed-extensions'.  If nil they are highlighted using
face `diredp-compressed-file-name'.

Note: If you change the value of this option then you need to restart
Emacs to see the effect of the new value on font-locking."
  :type 'boolean :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-image-preview-in-tooltip (or (and (boundp 'image-dired-thumb-size)  image-dired-thumb-size)
                                               100)
  "*Whether and what kind of image preview to show in a tooltip.
The possible values are:

 `nil'       : do not show a tooltip preview
 integer N>0 : show a thumbnail preview of that size
 `full'      : show a full-size preview of the image

To enable tooltip image preview you must turn on `tooltip-mode' and
load library `image-dired.el'.  See also option
`diredp-auto-focus-frame-for-thumbnail-tooltip-flag'.

This option has no effect for Emacs versions prior to Emacs 22."
  :type '(choice
          (restricted-sexp :tag "Show a thumnail image of size"
           :match-alternatives ((lambda (x) (and (wholenump x)  (not (zerop x))))))
          (const :tag "Show a full-size image preview"      full)
          (const :tag "OFF: Do not show an image preview"   nil))
  :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-image-show-this-file-use-frame-flag t
  "Non-nil means `diredp-image-show-this-file' uses another frame.
If nil then it uses another window.  Using another frame means you
have more control over the image size when you use a prefix arg.

If it uses another window then the prefix arg controls only the
minimum window height, not necessarily the image scale (height).

\(If the buffer displaying the image is already considered a
special-display buffer by your Emacs setup, then a nil value of this
option has no effect.)"
  :type 'boolean :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-list-file-attributes (list 5 8)
  "Which file attributes `diredp-list-file' uses, and when.
A list of file attribute numbers means use only the values of those
attributes.
A non-list means use all attribute values."
  :group 'Dired-Plus :type '(choice
                             (repeat (integer :tag "Use attribute with number"))
                             (const :tag "Use all attributes" 'all)))

;;;###autoload
(defcustom diredp-max-frames 200
  "*Max number of frames, for commands that find files in separate frames.
These commands are `dired-do-find-marked-files' and
`diredp-do-find-marked-files-recursive'.  See their descriptions for
the circumstances in which they show the files in separate frames."
  :type '(restricted-sexp :match-alternatives ((lambda (x) (and (wholenump x)  (not (zerop x))))))
  :group 'Dired-Plus)

(when (fboundp 'file-equal-p)           ; Emacs 24+
  (defcustom diredp-move-file-dirs ()
    "Alist of names of files and preferred directories to move them to.
File names should be relative (no directory component).
Target directory names should be absolute."
    :group 'files :type '(alist :key-type file :value-type directory)))

;; (Not used - just use the body directly in the option default value.
;; (defun diredp-omit-files-font-lock-regexp ()
;;   "Return regexp to use for font-locking, using `dired-omit-files' as base."
;;   (let* ((strg  dired-omit-files)
;;          (strg  (if (eq ?^ (aref strg 0)) (substring strg 1) strg)) ; Remove initial ^
;;          (strg  (replace-regexp-in-string "\\(\\\\[|]\\)\\^" "\\1" strg 'FIXEDCASE nil)) ; Remove other ^'s
;;          (strg  (replace-regexp-in-string "\\([$]\\)" "" strg 'FIXEDCASE nil))) ; Remove $'s
;;     strg))

(diredp-make-obsolete-variable 'diredp-omit-files-regexp 'diredp-omit-files-font-lock-regexp "2021-03-03")
(defcustom diredp-omit-files-font-lock-regexp "\\.?#.*#\\|\\.\\|\\.\\."
  ;;
  ;; This was no good for `#...#'.  There's no rule good enough to work generally.
  ;; Can't just transform `dired-omit-files'.
  ;;
  ;; (let* ((strg  dired-omit-files)
  ;;        (strg  (if (eq ?^ (aref strg 0)) ; Remove initial ^
  ;;                   (substring strg 1)
  ;;                 strg))
  ;;        (strg  (replace-regexp-in-string "\\(\\\\[|]\\)\\^" ; Remove other ^'s
  ;;                                         "\\1"
  ;;                                         strg
  ;;                                         'FIXEDCASE
  ;;                                         nil))
  ;;        (strg  (replace-regexp-in-string "\\([$]\\)" ; Remove $'s
  ;;                                         ""
  ;;                                         strg
  ;;                                         'FIXEDCASE
  ;;                                         nil)))
  ;;   strg)
  "Regexp for font-locking file names to be omitted by `dired-omit-mode'.
The regexp is matched only against the file name, but the entire line
is highlighted (with face `diredp-omit-file-name').

The default value corresponds to the default value of option
`dired-omit-files': auto-save files, `.', and `..'.

The option value is wrapped with `^.*' and `[*]?$', to match the full
line, including a possible executable tag, `*', at the end.  The
option value should not, therefore, itself contain ^, $, \\`, or \\'.

This option is for font-locking, whereas `dired-omit-files' is used
only for recognizing a file name, to act on the file.  The latter does
not need to match the whole (nondirectory) file name, so its default
value includes, for example, just \\.?#, not \\.?#.*#.  Also, the
latter wraps ^ and $ around the regexp.

Note: If you change the value of this option then you need to restart
Emacs to see the effect of the new value on font-locking."
  :group 'Dired-Plus :type 'regexp)

;;;###autoload
(defcustom diredp-omit-lines-regexp nil
  "Regexp matching lines to be omitted by `dired-omit-mode'.
The value can also be a variable whose value is such a regexp.
The value can also be nil, which means do no line matching.

See command `dired-omit-mode' (\\[dired-omit-mode]).

Some predefined regexp variables for Dired, which you can use as the
option value:

,* `dired-re-inode-size'
,* `dired-re-mark'
,* `dired-re-maybe-mark'
,* `dired-re-dir'
,* `dired-re-sym'
,* `dired-re-exe'
,* `dired-re-perms'
,* `dired-re-dot'
,* `dired-re-no-dot'
,* `diredp-re-no-dot'"
  :type `(choice (const  :tag "Do not match lines to omit" nil)
                 (regexp :tag "Regexp to match lines to omit (default omits executables)" :value ,dired-re-exe)
                 (restricted-sexp :tag "Variable with regexp value (default: `dired-re-exe')"
                                  :match-alternatives ((lambda (obj) (and (symbolp obj) (boundp obj))))
                                  :value dired-re-exe))
  :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-prompt-for-bookmark-prefix-flag nil
  "*Non-nil means prompt for a prefix string for bookmark names."
  :type 'boolean :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-visit-ignore-regexps ()
  "Regexps matching file names for `diredp-visit-(next|previous)' to skip.
A file or directory name matching one of these regexps is skipped,
along with those with an extension in `diredp-visit-ignore-extensions'."
  :type '(repeat regexp) :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-switches-in-mode-line nil
  "How to indicate `dired-actual-switches' in mode-line.
Possible values:
 ,* `nil':    Indicate name-or-date sort order, if possible.
             Else show full switches.
 ,* `as-is':  Show full switches.
 ,* Integer:  Show only the first N chars of full switches.
 ,* Function: Pass `dired-actual-switches' as arg and show result."
  :group 'Dired-Plus
  :type '(choice
          (const    :tag "Indicate by name or date, else full"   nil)
          (const    :tag "Show full switches"                    as-is)
          (integer  :tag "Show first N chars of switches" :value 10)
          (function :tag "Format with function"           :value identity)))

;;;###autoload
(defcustom diredp-visit-ignore-extensions '("elc")
  "Extensions of file names for `diredp-visit-(next|previous)' to skip.
A file name with one of these extensions is skipped, along with those
matching a regexp in `diredp-visit-ignore-regexps'."
  :type '(repeat string) :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-w32-local-drives '(("C:" "Local disk"))
  "*Local MS Windows drives that you want to use for `diredp-w32-drives'.
Each entry is a list (DRIVE DESCRIPTION), where DRIVE is the drive
name and DESCRIPTION describes DRIVE."
  :type '(alist
          :key-type   (string        :tag "Drive name")
          :value-type (group (string :tag "Drive description")))
  :group 'Dired-Plus)

;;;###autoload
(defcustom diredp-wrap-around-flag t
  "*Non-nil means Dired \"next\" commands wrap around to buffer beginning."
  :type 'boolean :group 'Dired-Plus)

(when (fboundp 'dired-hide-details-mode) ; Emacs 24.4+
  (defvar diredp-hide-details-last-state diredp-hide-details-initially-flag
    "Last `dired-hide-details-mode' value.
Initialized to the value of option `diredp-hide-details-initially-flag'.")

  (defvar diredp-hide-details-toggled nil
    "Non-nil means you have already toggled hiding details in this buffer.")
  (make-variable-buffer-local 'diredp-hide-details-toggled))

;; 2020-12-05.
;;
;; This was previously "^\\([^.]\\|\\.\\([^.]\\|\\..\\)\\).*".  Changed to be the same as
;; `directory-files-no-dot-files-regexp' in `files.el', available for Emacs 23+, but changed in
;; Emacs 27+ to this value.  This value is a bit quicker than the previous value, and it can
;; match file names containing ^J.
;;
;; This value is OK, as long as no use is made of the match data.  In particular, as long as
;; the match data is not used to capture the file name.  That's the case (it's OK) for use by
;; `directory-files', which is currently the only use here.
;;
;; See https://lists.gnu.org/archive/html/emacs-devel/2020-04/msg00764.html, msg01247, msg01305
;;
;; Same as the default value of `icicle-re-no-dot', in `icicles-var.el'.
;;
(defvar diredp-re-no-dot "[^.]\\|\\.\\.\\."
  "Regexp that matches any nonempty file name except `.' and `..'.
Default value is same as `directory-files-no-dot-files-regexp'.")

(defvar diredp-recent-files-buffer nil
  "Non-nil means this buffer is a Dired listing of recent files or dirs.")
(make-variable-buffer-local 'diredp-recent-files-buffer)

(defvar diredp-w32-drives-mode-map (let ((map  (make-sparse-keymap)))
                                     (define-key map "q"       'bury-buffer)
                                     (define-key map "\r"      'widget-button-press)
                                     (define-key map [mouse-2] 'widget-button-click)
                                     map)
  "Keymap for `diredp-w32-drives-mode'.")

;;; $$$$$$ Starting with Emacs 22, *-move-to* is defvaraliased to *-listing-before*.
;;; But `files+.el' defines *-listing-before*, so we define it here too.
;;; (unless (> emacs-major-version 21)
;;;   (defvar directory-listing-before-filename-regexp dired-move-to-filename-regexp
;;;     "Regular expression to match up to the file name in a directory listing.
;;; The default value is designed to recognize dates and times
;;; regardless of the language."))

;;; Macros


;; Unlike `dired-mark-if':
;;
;; 1. Value returned and message indicate both the number matched and the number changed.
;; 2. Added optional arg PLURAL, for irregular plurals (e.g. "directories").
;;
(defmacro diredp-mark-if (predicate singular &optional plural)
  "Mark files for PREDICATE, according to `dired-marker-char'.
PREDICATE is evaluated on each line, with point at beginning of line.
SINGULAR is a singular noun phrase for the type of files being marked.
Optional arg PLURAL is a plural noun phrase for the type of files
 being marked.
If PLURAL is nil then SINGULAR should end with a noun that can be
pluralized by adding `s'.

Return nil if no files matched PREDICATE.
Otherwise return a cons (CHANGED . MATCHED), where:
 CHANGED is the number of markings that were changed by the operation.
 MATCHED is the number of files that matched PREDICATE."
  `(let ((inhibit-read-only  t)
         changed matched)
    (save-excursion
      (setq matched  0
            changed  0)
      (when ,singular (message "%s %s%s..."
                               (cond ((eq dired-marker-char ?\040)            "Unmarking")
                                     ((eq dired-del-marker dired-marker-char) "Flagging")
                                     (t                                       "Marking"))
                               (or ,plural  (concat ,singular "s"))
                               (if (eq dired-del-marker dired-marker-char) " for deletion" "")))
      (goto-char (point-min))
      (while (not (eobp))
        (when ,predicate
          (setq matched  (1+ matched))
          (unless (eq dired-marker-char (char-after))
            (delete-char 1) (insert dired-marker-char) (setq changed  (1+ changed))))
        (forward-line 1))
      (when ,singular (message "%s %s%s%s newly %s%s"
                               matched
                               (if (= matched 1) ,singular (or ,plural  (concat ,singular "s")))
                               (if (not (= matched changed)) " matched, " "")
                               (if (not (= matched changed)) changed "")
                               (if (eq dired-marker-char ?\040) "un" "")
                               (if (eq dired-marker-char dired-del-marker) "flagged" "marked"))))
    (and (> matched 0)  (cons changed matched))))


;; Just a helper function for `dired-map-over-marks'.
(defun diredp-get-file-or-dir-name (arg &optional localp)
  "Return name of next file or directory or nil if none.
Argument ARG:
 `all-files-no-dirs' or nil means skip directories.
 `all-files-no-dots' means skip `.' and `..'.
Optional arg LOCALP as in `dired-get-filename'."
  (let ((fname  nil))
    (while (and (not fname)  (not (eobp)))
      (setq fname  (dired-get-filename localp 'NO-ERROR))
      (when (and fname  (or (not arg)  (eq arg 'all-files-no-dirs))  (file-directory-p fname))
        (setq fname  nil))
      (when (and fname  (eq arg 'all-files-no-dots)  (or (member fname '("." ".."))
                                                         (diredp-string-match-p "/\\.\\.?$" fname)))
        (setq fname  nil))
      (forward-line 1))
    (forward-line -1)
    fname))

(defun diredp-prefix-arg-all-files (arg)
  "Return symbol for kind of \"all-files\" behavior, or nil for none.
ARG is a raw prefix arg.
Return value depends on the number of plain `C-u' used:
 ,* nil                 if 0 or 1 `C-u'
 ,* `all-files-no-dirs' if 2 or more than 4
 ,* `all-files-no-dots' if 3
 ,* `all-files'         if 4"
  (and (consp arg)
       (> (prefix-numeric-value arg) 4)
       (case (prefix-numeric-value arg)
         (16   'all-files-no-dirs)      ; `C-u C-u'
         (64   'all-files-no-dots)      ; `C-u C-u C-u'
         (256  'all-files)              ; `C-u C-u C-u C-u'
         (t    'all-files-no-dirs))))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; Treat multiple `C-u' specially.
;;
(defmacro dired-map-over-marks (body arg &optional show-progress
                                     distinguish-one-marked)
  "Eval BODY with point on each marked line.  Return a list of BODY's results.
If no marked file could be found, execute BODY on the current line.
ARG, if non-nil, specifies the files to use instead of the marked files.
 If ARG is an integer, use the next ARG files (previous -ARG, if < 0).
   Point is advanced accordingly.  This is so that commands for the
   next ARG (instead of the marked) files can be easily chained.
 If ARG is a cons with element 16, 64, or 256, corresponding to
   `C-u C-u', `C-u C-u C-u', or `C-u C-u C-u C-u', then use all files
   in the Dired buffer, where:
     16 includes NO directories (including `.' and `..')
     64 includes directories EXCEPT `.' and `..'
    256 includes ALL directories (including `.' and `..')
 If ARG is otherwise non-nil, use the current file.
If optional third arg SHOW-PROGRESS evaluates to non-nil,
 redisplay the Dired buffer after each file is processed.

No guarantee is made about the position on the marked line.  BODY must
ensure this itself, if it depends on this.

Search starts at the beginning of the buffer, thus the car of the list
corresponds to the line nearest the end of the buffer.  This is also
true for (positive and negative) integer values of ARG.

BODY should not be too long, because it is expanded four times.

If DISTINGUISH-ONE-MARKED is non-nil, then return (t FILENAME) instead
 of (FILENAME), if only one file is marked."
  ;; WARNING: BODY must not add new lines before point - this may cause an
  ;; endless cl-loop.  This warning should not apply any longer, sk  2-Sep-1991 14:10.
  `(prog1
       (let ((inhibit-read-only  t)
             (multi-C-u          (diredp-prefix-arg-all-files ,arg))
             case-fold-search
             found
             results)
         (if (and ,arg  (not multi-C-u))
             (if (integerp ,arg)
                 (progn     ; No `save-excursion', want to move point.
                   (dired-repeat-over-lines ,arg #'(lambda ()
                                                    (when ,show-progress (sit-for 0))
                                                    (setq results  (cons ,body results))))
                   (if (< ,arg 0) (nreverse results) results))
               ;; Non-nil, non-integer ARG means use current file:
               (list ,body))
           (let ((regexp  (dired-marker-regexp))
                 next-position)
             (save-excursion
               (goto-char (point-min))
               ;; Remember position of next marked file before BODY can insert lines before the
               ;; just found file, confusing us by finding the same marked file again and again...
               (setq next-position  (and (if multi-C-u
                                             (diredp-get-file-or-dir-name multi-C-u)
                                           (re-search-forward regexp nil t))
                                         (point-marker))
                     found          (not (null next-position)))
               (while next-position
                 (goto-char next-position)
                 (when ,show-progress (sit-for 0))
                 (setq results  (cons ,body results))
                 ;; move after last match
                 (goto-char next-position)
                 (forward-line 1)
                 (set-marker next-position nil)
                 (setq next-position  (and (if multi-C-u
                                               (diredp-get-file-or-dir-name multi-C-u)
                                             (re-search-forward regexp nil t))
                                           (point-marker)))))
             (when (and ,distinguish-one-marked  (= (length results) 1))
               (setq results  (cons t results)))
             (if found results (list ,body)))))
     ;; `save-excursion' loses, again
     (dired-move-to-filename)))

;; Same as `icicle-with-help-window' in `icicles-mac.el'
;; and `bmkp-with-help-window' in `bookmark+-mac.el'.
(defmacro diredp-with-help-window (buffer &rest body)
  "`with-help-window', if available; else `with-output-to-temp-buffer'."
  (if (fboundp 'with-help-window)
      `(with-help-window ,buffer ,@body)
    `(with-output-to-temp-buffer ,buffer ,@body)))

(put 'diredp-with-help-window 'common-lisp-indent-function '(4 &body))

;;; Utility functions

;; Same as `imenup-delete-if-not'.
;;
(defun diredp-delete-if-not (predicate xs)
  "Remove all elements of list XS that do not satisfy PREDICATE.
This operation is destructive, reusing conses of XS whenever possible."
  (while (and xs  (not (funcall predicate (car xs))))
    (setq xs  (cdr xs)))
  (let ((cl-p  xs))
    (while (cdr cl-p)
      (if (not (funcall predicate (cadr cl-p))) (setcdr cl-p (cddr cl-p)) (setq cl-p  (cdr cl-p)))))
  xs)

;; Same as `imenup-delete-if'.
;;
(defun diredp-delete-if (predicate xs)
  "Remove all elements of list XS that satisfy PREDICATE.
This operation is destructive, reusing conses of XS whenever possible."
  (while (and xs  (funcall predicate (car xs)))
    (setq xs  (cdr xs)))
  (let ((cl-p  xs))
    (while (cdr cl-p)
      (if (funcall predicate (cadr cl-p))
          (setcdr cl-p (cddr cl-p))
        (setq cl-p  (cdr cl-p)))))
  xs)

;; Define this to avoid requiring `cl.el' at runtime.  Same as `frcmds-set-difference' in `frame-cmds.el'.
(defun diredp-set-difference (list1 list2 &optional key)
  "Combine LIST1 and LIST2 using a set-difference operation.
Optional arg KEY is a function used to extract the part of each list
item to compare.

The result list contains all items that appear in LIST1 but not LIST2.
This is non-destructive; it makes a copy of the data if necessary, to
avoid corrupting the original LIST1 and LIST2."
  (if (or (null list1)  (null list2))
      list1
    (let ((keyed-list2  (and key  (mapcar key list2)))
          (result       ()))
      (while list1
        (unless (if key
                    (member (funcall key (car list1)) keyed-list2)
                  (member (car list1) list2))
          (setq result  (cons (car list1) result)))
        (setq list1  (cdr list1)))
      result)))

;; Same as `tap-string-match-p' in `thingatpt+.el'.
(if (fboundp 'string-match-p)
    (defalias 'diredp-string-match-p 'string-match-p) ; Emacs 23+
  (defun diredp-string-match-p (regexp string &optional start)
    "Like `string-match', but this saves and restores the match data."
    (save-match-data (string-match regexp string start))))

(if (fboundp 'looking-at-p)
    (defalias 'diredp-looking-at-p 'looking-at-p) ; Emacs 23+
  (defun diredp-looking-at-p (regexp)
    "Like `looking-at', but this saves and restores the match data."
    (save-match-data (looking-at regexp))))

;; `dired-read-regexp' does not accept DEFAULT and HISTORY for older Emacsen, so use this.
(defun diredp-read-regexp (prompt &optional default history)
  "Read a regexp.
HISTORY defaults to `dired-regexp-history'."
  (setq history  (or history 'dired-regexp-history))
  (if (fboundp 'read-regexp)
      (read-regexp prompt default history)
    (read-from-minibuffer prompt nil nil nil history default)))

(if (fboundp 'delete-dups)
    (defalias 'diredp-delete-dups 'delete-dups)
  (defun diredp-delete-dups (list)
    "Destructively remove `equal' duplicates from LIST.
Store the result in LIST and return it.  LIST must be a proper list.
Of several `equal' occurrences of an element in LIST, the first
one is kept."
    (let ((tail list))
      (while tail
        (setcdr tail (delete (car tail) (cdr tail)))
        (setq tail (cdr tail))))
    list))

(defun diredp-nonempty-region-p ()
  "Return non-nil if region is active and non-empty."
  (and transient-mark-mode  mark-active  (mark)  (> (region-end) (region-beginning))))

(defun diredp-get-image-filename (&optional localp no-error-if-not-filep)
  "Return the image-file name on this line, or nil if no image file.
If not in Dired (or a mode derived from Dired), then test the entire
text of the current line as the file name.

The optional args are the same as for `dired-get-filename'.  They are
ignored if not in a Dired mode.

\(Prior to Emacs 22, this function just returns nil.)"
  (let ((file  (if (derived-mode-p 'dired-mode)
                   (dired-get-filename localp no-error-if-not-filep)
                 ;; Make it work also for `diredp-list-files' listings.
                 (buffer-substring-no-properties (line-beginning-position) (line-end-position)))))
    (and file
         (fboundp 'image-file-name-regexp) ; Emacs 22+, `image-file.el'.
         (diredp-string-match-p (image-file-name-regexp) file)
         file)))

(defun diredp-root-directory-p (file)
  "Return non-nil if FILE is a root directory."
  (if (fboundp 'ange-ftp-root-dir-p)
      (ange-ftp-root-dir-p (file-name-as-directory file))
    ;; This is essentially `ange-ftp-root-dir-p' applied to `file-name-as-directory'.
    ;; If `ange-ftp-root-dir-p' changes, update this code.
    (or (and (eq system-type 'windows-nt)  (diredp-string-match-p "\\`[a-zA-Z]:[/\\]\\'"
                                                                  (file-name-as-directory file)))
        (string= "/" file))))

(defun diredp-parent-dir (file &optional relativep)
  "Return the parent directory of FILE, or nil if none.
Optional arg RELATIVEP non-nil means return a relative name, that is,
just the parent component."
  (let ((parent  (file-name-directory (directory-file-name (expand-file-name file))))
        relparent)
    (when relativep (setq relparent  (file-name-nondirectory (directory-file-name parent))))
    (and (not (equal parent file))  (or relparent  parent))))

(unless (fboundp 'derived-mode-p)       ; Emacs 20, 21.
  (defun derived-mode-p (&rest modes)
    "Non-nil if the current major mode is derived from one of MODES.
Uses the `derived-mode-parent' property of the symbol to trace backwards."
    (let ((parent  major-mode))
      (while (and (not (memq parent modes))  (setq parent  (get parent 'derived-mode-parent))))
      parent)))

(defun diredp-ensure-mode ()
  "Raise an error if not in Dired or a mode derived from it."
  (unless (derived-mode-p 'dired-mode)
    (error "You must be in Dired or a mode derived from it to use this command")))

(defun diredp-ensure-fn-nonzero-arity (obj)
  "Raise an error if FN is not a function that can accept 1 argument."
  (unless (functionp obj) (error "Not a function: `%s'" obj))
  (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
              (let ((max  (cdr (func-arity obj))))
                (or (eq max 'many)  (> max 0))))
    (error "Function `%s' cannot accept any args" obj)))

(defun diredp-ensure-fn-zero-arity (obj)
  "Raise an error if FN is not a function that can accept 0 arguments."
  (unless (functionp obj) (error "Not a function: `%s'" obj))
  (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
              (= 0 (car (func-arity obj))))
    (error "Function `%s' cannot accept zero args" obj)))

(defun diredp-ensure-bookmark+ ()
  (unless (require 'bookmark+ nil t) (error "This command requires library `bookmark+.el'")))

;; Same as `recentf-string-less-p'.
;;
(defun diredp-string-less-p (string1 string2)
  "Return non-nil if STRING1 is less than STRING2 in lexicographic order.
Ignore case if `diredp-case-fold-search' is non-nil."
  (if diredp-case-fold-search
      (string-lessp (downcase string1) (downcase string2))
    (string-lessp string1 string2)))

(defalias 'diredp-full-file-name-less-p 'diredp-string-less-p)

(defun diredp-full-file-name-more-p (file1 file2)
  "Return non-nil if full name of FILE1 comes after that of FILE2.
Comparison is lexicographic.
Ignore case if `diredp-case-fold-search' is non-nil."
  (diredp-string-less-p file2 file1))

(defun diredp-nondir-file-name-less-p (file1 file2)
  "Return non-nil if nondir name of FILE1 comes before that of FILE2.
Comparison is lexicographic.
Ignore case if `diredp-case-fold-search' is non-nil."
  (diredp-string-less-p (file-name-nondirectory file1) (file-name-nondirectory file2)))

(defun diredp-nondir-file-name-more-p (file1 file2)
  "Return non-nil if nondir name of FILE1 comes after that of FILE2.
Comparison is lexicographic.
Ignore case if `diredp-case-fold-search' is non-nil."
  (diredp-string-less-p (file-name-nondirectory file2) (file-name-nondirectory file1)))

(defun diredp-sort-arbitrary (function &optional arg)
  "Sort recent files or dirs with `diredp-default-sort-arbitrary-function'.
FUNCTION shoud be `diredp-recent-files' or `diredp-recent-dirs'.
ARG is as in `diredp-dired-recent-files'."
  (if diredp-default-sort-arbitrary-function
      (if (functionp diredp-default-sort-arbitrary-function)
          (sort (copy-sequence (funcall function arg)) diredp-default-sort-arbitrary-function)
        (nreverse (funcall function arg)))
    (funcall function arg)))


(unless (fboundp 'dired-nondirectory-p) ; Emacs 20, 21.
  (defun dired-nondirectory-p (file)
    "Return non-nil if FILE is not a directory."
    (not (file-directory-p file))))


;;; Some of the redefinitions that follow are essentially unaltered vanilla Emacs code to be
;;; reloaded, to use the new definition of `dired-map-over-marks' here.



;; REPLACE ORIGINAL in `dired.el'.
;;
;; Respect option `diredp-switches-in-mode-line'.
;;
(defun dired-sort-set-mode-line ()
  "Set mode-line according to option `diredp-switches-in-mode-line'."
  (when (eq major-mode 'dired-mode)
    (setq mode-name
          (let ((case-fold-search  nil))
            (if diredp-switches-in-mode-line
                (concat "Dired"
                        (cond ((integerp diredp-switches-in-mode-line)
                               (let* ((l1  (length dired-actual-switches))
                                      (xs  (substring dired-actual-switches 0 (min l1 diredp-switches-in-mode-line)))
                                      (l2  (length xs)))
                                 (if (zerop l2)
                                     xs
                                   (concat " " xs (and (< l2  l1) "...")))))
                              ((functionp diredp-switches-in-mode-line)
                               (format " %s" (funcall diredp-switches-in-mode-line
                                                     dired-actual-switches)))
                              (t (concat " " dired-actual-switches))))
              (cond ((string-match-p dired-sort-by-name-regexp dired-actual-switches)
                     "Dired by name")
                    ((string-match-p dired-sort-by-date-regexp dired-actual-switches)
                     "Dired by date")
                    (t (concat "Dired " dired-actual-switches))))))
    (force-mode-line-update)))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Pass non-nil second arg to `dired-get-filename' so we can include `.' and `..'.
;; 2. Doc string is updated to reflect the new ARG behavior.
;; 3. Allow, unlike vanilla Emacs, use of FILTER and DISTINGUISH-ONE-MARKED together.
;;
(defun dired-get-marked-files (&optional localp arg filter distinguish-one-marked error-if-none-p)
  "Return names of the marked files and directories as a list of strings.
The list is in the same order as the buffer, that is, the car is the
  first marked file.
Values returned are normally absolute file names.
Optional arg LOCALP as in `dired-get-filename'.
Optional second argument ARG specifies files to use instead of marked.
 Usually ARG comes from the command's prefix arg.
 If ARG is an integer, use the next ARG files (previous -ARG, if < 0).
 If ARG is a cons with element 16, 64, or 256, corresponding to
  `C-u C-u', `C-u C-u C-u', or `C-u C-u C-u C-u', then use all files
  in the Dired buffer, where:
    16 includes NO directories (including `.' and `..')
    64 includes directories EXCEPT `.' and `..'
   256 includes ALL directories (including `.' and `..')
 If ARG is otherwise non-nil, use the current file.
Optional third argument FILTER, if non-nil, is a function to select
 some of the files: those for which (funcall FILTER FILENAME) is
 non-nil.
If DISTINGUISH-ONE-MARKED is non-nil, then return (t FILENAME) instead
 of (FILENAME) if only one file is marked (after any filtering by
 FILTER).
If ERROR-IF-NONE-P is non-nil, signal an error if the list of files is
 empty.  If ERROR-IF-NONE-P is a string then it is the error message.

Note that the Dired+ version of this function differs from the vanilla
version in these respects:

,* There are more possibilities for argument ARG (prefix argument).
,* Directories `.' and `..' can be included as marked.
,* You can use arguments FILTER and DISTINGUISH-ONE-MARKED together."
  (let ((all  (delq nil (save-excursion (dired-map-over-marks (dired-get-filename localp 'NO-ERROR)
                                                              arg
                                                              nil
                                                              distinguish-one-marked))))
        result)
    (when (equal all '(t)) (setq all  nil)) ; Added by vanilla Emacs 24+.
    (if (and distinguish-one-marked  (eq (car all) t))
        (if (not filter)
            all
          (and (funcall filter (cadr all))  (list t (cadr all))))
      (dolist (file  all)
        (when (or (not filter)  (funcall filter file)) (push file result)))
      (when (and (null result)  error-if-none-p)
        (diredp-user-error (if (stringp error-if-none-p) error-if-none-p "No files specified")))
      result)))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Added optional arg INIT-COUNT.
;; 2. Changed doc to speak of removing, not killing.
;;
(defun dired-do-kill-lines (&optional arg fmt init-count)
  "Remove all marked lines, or the next ARG lines.
The files or directories on those lines are _not_ deleted.  Only the
Dired listing is affected.  To restore the removals, use `\\[revert-buffer]'.

With a numeric prefix arg, remove that many lines going forward,
starting with the current line.  (A negative prefix arg removes lines
going backward.)

If you use a prefix arg to remove the line for a subdir whose listing
you have inserted into the Dired buffer, then that subdir listing is
also removed.

To remove a subdir listing _without_ removing the subdir's line in its
parent listing, go to the header line of the subdir listing and use
this command with any prefix arg.

When called from Lisp, non-nil INIT-COUNT is added to the number of
lines removed by this invocation, for the reporting message."
  ;; Returns count of killed lines.  FMT="" suppresses message.
  (interactive "P")
  (if arg
      (if (dired-get-subdir) (dired-kill-subdir) (dired-kill-line arg))
    (save-excursion
      (goto-char (point-min))
      (let ((count   (or init-count  0))
            (regexp  (dired-marker-regexp))
            buffer-read-only)
        (while (and (not (eobp))  (re-search-forward regexp nil t))
          (setq count  (1+ count))
          (delete-region (line-beginning-position) (progn (forward-line 1) (point))))
        (unless (equal "" fmt) (message (or fmt "Killed %d line%s.") count (dired-plural-s count)))
        count))))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Define here to make use of my `dired-map-over-marks'.
;; 2. Added &rest arg FUN-ARGS.
;; 3. Added doc string.
;;
(defun dired-map-over-marks-check (fun mark-arg op-symbol &optional show-progress &rest fun-args)
  "Map FUN over marked lines and report failures.
FUN should return nil for success and non-nil (the offending object,
e.g. the short form of the filename) for a failure.  FUN can log a
detailed error explanation using `dired-log'.

MARK-ARG is as the second argument of `dired-map-over-marks'.

OP-SYMBOL is a symbol describing the operation performed (e.g.
`compress').  It is used with `dired-mark-pop-up' to prompt the user
\(e.g. with `Compress * [2 files]? ') and to display errors (e.g.
`Failed to compress 1 of 2 files - type ? for details (\"foo\")')

SHOW-PROGRESS if non-nil means redisplay Dired after each file.

FUN-ARGS is the list of any remaining args to
`dired-map-over-marks-check'.  Function FUN is applied to these
arguments.

To map a function whose return values you are interested in, that is,
a function that does not just return nil for success, use function
`diredp-map-over-marks-and-report'."
  (and (dired-mark-confirm op-symbol mark-arg)
       (let* ((results     (dired-map-over-marks (apply fun fun-args) mark-arg show-progress)) ; FUN return vals.
              (nb-results  (length results))
              (failures    (delq nil results))
              (nb-fail     (length failures))
              (op-strg     (if (eq op-symbol 'compress) "Compress or uncompress" (capitalize
                                                                                  (symbol-name op-symbol)))))
         (if (null failures)
             (if (fboundp 'ngettext)    ; Emacs 27+
                 (message (ngettext "%s: %d file." "%s: %d files." nb-results) op-strg nb-results)
               (message "%s: %d file%s." op-strg nb-results (dired-plural-s nb-results)))
           (dired-log-summary
            (if (fboundp 'ngettext)    ; Emacs 27+
                (format (ngettext "Failed to %s %d of %d file" "Failed to %s %d of %d files" nb-results)
                        (downcase op-strg) nb-fail nb-results)
              (format "Failed to %s %d of %d file%s"
                      (downcase op-strg) nb-fail nb-results (dired-plural-s nb-results)))
            failures)))))

(defun diredp-map-over-marks-and-report (fun mark-arg op-symbol &optional show-progress &rest fun-args)
  "Map FUN over marked lines and report the results.
Return the results as a list.

This is like `dired-map-over-marks-check', but use this if you are
interested in the values returned by FUN:
 ,* FUN can return anything.  There is no notion of failure, and
   returning nil does not indicate success.
 ,* FUN can log any information it wants using `dired-log'.
 ,* `diredp-report-summary' is called to display the log, instead of
   `dired-log-summary'.  (It is not used to report failure.)

MARK-ARG is as the second argument of `dired-map-over-marks'.

OP-SYMBOL is a symbol describing the operation performed (e.g.
`compress').  It is used with `dired-mark-pop-up' to prompt the user
\(e.g. with `Compress * [2 files]? ') and to display errors (e.g.
`Failed to compress 1 of 2 files - type ? to see why (\"foo\")')

SHOW-PROGRESS if non-nil means redisplay Dired after each file.

FUN-ARGS is the list of any remaining args to
`diredp-map-over-marks-and-report'.  Function FUN is applied to these
arguments."
  (and (dired-mark-confirm op-symbol mark-arg)
       (let* ((results     (dired-map-over-marks (apply fun fun-args) mark-arg show-progress)) ; FUN return vals.
              (nb-results  (length results))
              (op-strg     (capitalize (symbol-name op-symbol))))
         (diredp-report-summary (format "%s for %d file%s" op-strg nb-results (dired-plural-s nb-results)))
         results)))                     ; Return list of results.

(defun diredp-report-summary (string)
  "Report a summary for a command that maps over Dired lines.
Report in the echo area and display a log buffer."
  (message "%s--type ? for details" string)
  (dired-log (concat "\n" string "\n"))
  (dired-log t))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
(when (boundp 'dired-subdir-switches)   ; Emacs 22+
  (defun dired-do-redisplay (&optional arg test-for-subdir) ; Bound to `l'
    "Redisplay all marked (or next ARG) files.
If on a subdir line, redisplay that subdirectory.  In that case,
a prefix arg lets you edit the `ls' switches used for the new listing.

Dired remembers switches specified with a prefix arg, so reverting the
buffer does not reset them.  However, you might sometimes need to
reset some subdirectory switches after using \\<dired-mode-map>`\\[dired-undo]'.  You can reset all
subdirectory switches to the default value using
`\\[dired-reset-subdir-switches]'.
See Info node `(emacs) Subdir switches' for more details."
    ;; Moves point if the next ARG files are redisplayed.
    (interactive "P\np")
    (if (and test-for-subdir  (dired-get-subdir))
        (let* ((dir       (dired-get-subdir))
               (switches  (cdr (assoc-string dir dired-switches-alist))))
          (dired-insert-subdir dir (and arg  (read-string "Switches for listing: "
                                                          (or switches
                                                              dired-subdir-switches
                                                              dired-actual-switches)))))
      (message "Redisplaying...")
      ;; `message' is much faster than making `dired-map-over-marks' show progress
      (dired-uncache (if (consp dired-directory) (car dired-directory) dired-directory))
      (dired-map-over-marks (let ((fname                    (dired-get-filename))
                                  ;; Postpone readin hook map over all marked files (Bug#6810).
                                  (dired-after-readin-hook  nil))
                              (message "Redisplaying... `%s'" fname)
                              (dired-update-file-line fname))
                            arg)
      (run-hooks 'dired-after-readin-hook)
      (dired-move-to-filename)
      (message "Redisplaying...done"))))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
(unless (boundp 'dired-subdir-switches) ; Emacs 20, 21
  (defun dired-do-redisplay (&optional arg test-for-subdir) ; Bound to `l'
    "Redisplay all marked (or next ARG) files.
If on a subdir line, redisplay that subdirectory.  In that case,
a prefix arg lets you edit the `ls' switches used for the new listing."
    ;; Moves point if the next ARG files are redisplayed.
    (interactive "P\np")
    (if (and test-for-subdir  (dired-get-subdir))
        (dired-insert-subdir (dired-get-subdir)
                             (and arg  (read-string "Switches for listing: " dired-actual-switches)))
      (message "Redisplaying...")
      ;; `message' is much faster than making dired-map-over-marks show progress
      (dired-uncache (if (consp dired-directory) (car dired-directory) dired-directory))
      (dired-map-over-marks (let ((fname  (dired-get-filename)))
                              (message "Redisplaying... `%s'" fname)
                              (dired-update-file-line fname))
                            arg)
      (dired-move-to-filename)
      (message "Redisplaying...done"))))


;; REPLACE ORIGINAL in `dired.el'.
;;
(when (fboundp 'get-window-with-predicate) ; Emacs 22+
  (defun dired-dwim-target-directory ()
    "Guess a target directory to use for Dired.
If there is a Dired buffer displayed in another window, use its
current subdir, else use current subdir of this Dired buffer."
    (let ((this-dir  (and (eq major-mode 'dired-mode)  (dired-current-directory))))
      ;; Non-dired buffer may want to profit from this function, e.g. `vm-uudecode'.
      (if dired-dwim-target
          (let* ((other-win  (get-window-with-predicate (lambda (window)
                                                          (with-current-buffer (window-buffer window)
                                                            (eq major-mode 'dired-mode)))
                                                        nil
                                                        (and diredp-dwim-any-frame-flag  'visible)))
                 (other-dir  (and other-win  (with-current-buffer (window-buffer other-win)
                                               (and (eq major-mode 'dired-mode)  (dired-current-directory))))))
            (or other-dir  this-dir))
        this-dir))))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Added behavior for non-positive prefix arg:
;;    * Construct a cons DIRNAME arg.
;;    * Read a Dired buffer name (not a directory) for its car.
;;    * If READ-EXTRA-FILES-P is non-nil then read any number of file and dir names, to be included as its cdr.
;;    * If chosen Dired buffer exists and is an ordinary listing then start out with its `directory-files'.
;;
;; 2. If you use Icicles then this is a multi-command - see doc for `dired' defadvice.
;;
(defun dired-read-dir-and-switches (string &optional read-extra-files-p dired-buffer)
  "Read arguments for `dired' commands.
STRING is added to the prompt after \"Dired \".  If not \"\", it should
end with a space.

With a non-negative prefix arg, read the `ls' switches.
With a non-negative prefix arg or none, read the directory to Dired.

With a non-positive prefix arg:
,* If DIRED-BUFFER is non-nil, it is the name of the Dired buffer to
  use.  Otherwise, read it (it is not necessarily a directory name).
  If in Dired now, the current buffer name is the default.
,* If READ-EXTRA-FILES-P is non-nil then read any number of directory
  or file names, to make up the Dired arbitrary-files listing.  You
  can use file-name wildcards (i.e., `*' for globbing), to include the
  matching files and directories.  Use `C-g' when done entering the
  files and directories to list.

Return a list of arguments for `dired': (DIRNAME SWITCHES).  DIRNAME
here has the same form as `dired-directory'.  When a non-positive
prefix arg is used, DIRNAME is a cons of the buffer name and the list
of file names.

If you use Icicles then reading uses Icicles completion, with
additional multi-command keys.  See `dired' (defadvice doc)."
  (let* ((switchs                                     (and current-prefix-arg
                                                           (natnump (prefix-numeric-value current-prefix-arg))
                                                           (read-string "Dired listing switches: "
                                                                        dired-listing-switches)))
         (icicle-candidate-action-fn
          (lambda (cand)
            (dired-other-window cand (and current-prefix-arg  (read-string "Dired listing switches: "
                                                                           dired-listing-switches)))
            (select-window (minibuffer-window))
            (select-frame-set-input-focus (selected-frame))))
;;; $$$$$$ Alternative: Could choose no-op for non-dir candidate.
;;;          (icicle-candidate-action-fn
;;;           (lambda (cand)
;;;             (cond ((file-directory-p cand)
;;;                    (dired-other-window cand (and current-prefix-arg  (read-string "Dired listing switches: "
;;;                                                                                   dired-listing-switches)))
;;;                    (select-window (minibuffer-window))
;;;                    (select-frame-set-input-focus (selected-frame)))
;;;                   (t
;;;                    (message "Not a directory: `%s'" cand) (sit-for 2)))))
         (icicle-all-candidates-list-alt-action-fn ; M-|'
          (lambda (files)
            (let ((enable-recursive-minibuffers  t))
              (dired-other-window (cons (read-string (format "Dired %s(buffer name): " string)) files)))))
         (icicle-sort-comparer                        (or (and (boundp 'icicle-file-sort) ; If not reading files
                                                               icicle-file-sort) ; then dirs first.
                                                          (and (> (prefix-numeric-value current-prefix-arg) 0)
                                                               'icicle-dirs-first-p)
                                                          (and (boundp 'icicle-sort-comparer)
                                                               icicle-sort-comparer)))

         ;; The rest of the bindings are from `icicle-file-bindings', in `icicles-mac.el'.
         (completion-ignore-case
          (or (and (boundp 'read-file-name-completion-ignore-case)  read-file-name-completion-ignore-case)
              completion-ignore-case))
         (icicle-show-Completions-initially-flag      (and (boundp 'icicle-show-Completions-initially-flag)
                                                           (or icicle-show-Completions-initially-flag
                                                               icicle-files-ido-like-flag)))
         (icicle-top-level-when-sole-completion-flag  (and (boundp 'icicle-top-level-when-sole-completion-flag)
                                                           (or icicle-top-level-when-sole-completion-flag
                                                               icicle-files-ido-like-flag)))
         (icicle-default-value                        (and (boundp 'icicle-default-value)
                                                           (if (and icicle-files-ido-like-flag
                                                                    icicle-default-value)
                                                               icicle-files-ido-like-flag
                                                             ;;  Get default via `M-n', but do not insert it.
                                                             (and (memq icicle-default-value '(t nil))
                                                                  icicle-default-value))))
         (icicle-must-match-regexp                    (and (boundp 'icicle-file-match-regexp)
                                                           icicle-file-match-regexp))
         (icicle-must-not-match-regexp                (and (boundp 'icicle-file-no-match-regexp)
                                                           icicle-file-no-match-regexp))
         (icicle-must-pass-after-match-predicate      (and (boundp 'icicle-file-predicate)
                                                           icicle-file-predicate))
         (icicle-require-match-flag                   (and (boundp 'icicle-file-require-match-flag)
                                                           icicle-file-require-match-flag))
         (icicle-file-completing-p                    t)
         (icicle-extra-candidates                     (and (boundp 'icicle-file-extras)  icicle-file-extras))
         (icicle-transform-function                   'icicle-remove-dups-if-extras)
         ;; Put `icicle-file-sort' first.  If already in the list, move it, else add it, to beginning.
         (icicle--temp-orders                         (and (boundp 'icicle-sort-orders-alist)
                                                           (copy-sequence icicle-sort-orders-alist)))
         (icicle-candidate-help-fn                    (lambda (cand)
                                                        (icicle-describe-file cand current-prefix-arg t)))
         (icicle-candidate-alt-action-fn              (and (boundp 'icicle-candidate-alt-action-fn)
                                                           (or icicle-candidate-alt-action-fn
                                                               (icicle-alt-act-fn-for-type "file"))))
         (icicle-delete-candidate-object              'icicle-delete-file-or-directory)
         (icicle-sort-orders-alist
          (and (boundp 'icicle-sort-orders-alist)
               (progn (when t ; $$$$ (and icicle-file-sort-first-time-p  icicle-file-sort)
                        (setq icicle-sort-comparer  icicle-file-sort))
                        ; $$$$ (setq icicle-file-sort-first-time-p  nil))
                      (if icicle-file-sort
                          (let ((already-there  (rassq icicle-file-sort icicle--temp-orders)))
                            (if already-there
                                (cons already-there (setq icicle--temp-orders  (delete already-there
                                                                                       icicle--temp-orders)))
                              (cons `("by `icicle-file-sort'" ,@icicle-file-sort) icicle--temp-orders)))
                        icicle--temp-orders)))))
    (when (fboundp 'icicle-bind-file-candidate-keys) (icicle-bind-file-candidate-keys))
    (unwind-protect
         (list
          (if (> (prefix-numeric-value current-prefix-arg) 0)
              ;; If a dialog box is about to be used, call `read-directory-name' so the dialog
              ;; code knows we want directories.  Some dialog boxes can only select directories
              ;; or files when popped up, not both. If no dialog box is used, call `read-file-name'
              ;; because the user may want completion of file names for use in a wildcard pattern.
              (funcall (if (and (fboundp 'read-directory-name)  (next-read-file-uses-dialog-p))
                           #'read-directory-name
                         #'read-file-name)
                       (format "Dired %s(directory): " string) nil default-directory nil)
            (dolist (db  dired-buffers) ; Remove any killed buffers from `dired-buffers' (even if DIRED-BUFFER).
              (unless (buffer-name (cdr db)) (setq dired-buffers  (delq db dired-buffers))))
            (let* ((dbufs   (and (not dired-buffer)
                                 (mapcar (lambda (db) (list (buffer-name (cdr db)))) dired-buffers)))
                   (dirbuf  (or dired-buffer
                                (completing-read (format "Dired %s(buffer name): " string) dbufs nil nil nil nil
                                                 (and (derived-mode-p 'dired-mode)  (buffer-name)))))
                   (files   (and (diredp-existing-dired-buffer-p dirbuf)
                                 (with-current-buffer (get-buffer dirbuf)
                                   (and (not (consp dired-directory))
                                        (directory-files dired-directory 'FULL diredp-re-no-dot)))))
                   file)
              (when read-extra-files-p
                (while (condition-case nil ; Use lax completion, to allow wildcards.
                           (setq file  (read-file-name "File or dir (C-g when done): "))
                         (quit nil))
                  ;; Do not allow root dir (`/' or a Windows drive letter, e.g. `d:/').
                  (if (diredp-root-directory-p file)
                      (progn (message "Cannot choose root directory") (sit-for 1))
                    (push file files))))
              (cons dirbuf files)))
          switchs)
      (when (fboundp 'icicle-unbind-file-candidate-keys) (icicle-unbind-file-candidate-keys)))))


;;; $$$$$$$$ An alternative implementation - different behavior.
;;;
;;; ;; REPLACE ORIGINAL in `dired.el'.
;;; ;;
;;; ;; Non-positive prefix arg means construct cons DIRNAME arg: Read Dired name and files/dirs.
;;; ;;
;;; (defun dired-read-dir-and-switches (string)
;;;   "Read arguments for `dired'.
;;; With a non-negative prefix arg, prompt first for `ls' switches.
;;; With a non-positive prefix arg, read the Dired buffer name and then
;;;  read any number of dir or file names, to make up the Dired listing.

;;; STRING is appended to the prompt, unless prefix arg is non-positive.
;;; If non-empty, STRING should begin with a SPC."
;;;   (let ((switches    (and current-prefix-arg
;;;                           (>= (prefix-numeric-value current-prefix-arg) 0)
;;;                           (read-string "Dired listing switches: " dired-listing-switches)))
;;;         (formt       (format "Dired %s(directory): " string))
;;;         (entries     ())
;;;         (curr-entry  ""))
;;;     (when (and current-prefix-arg  (<= (prefix-numeric-value current-prefix-arg) 0))
;;;       (push (completing-read "Dired buffer name: " dired-buffers) entries)
;;;       (setq curr-entry  (read-file-name (format "Dir or file: ") nil "" 'MUST-MATCH))
;;;       (while (not (equal "" curr-entry))
;;;         (push curr-entry entries)
;;;         (setq curr-entry  (read-file-name (format "Dir or file: ") nil "" 'MUST-MATCH)))
;;;       (unless (cadr entries) (push default-directory entries)))
;;;     (list (or (nreverse entries)  (if (and (fboundp 'next-read-file-uses-dialog-p)
;;;                                            (next-read-file-uses-dialog-p))
;;;                                       (read-directory-name formt nil default-directory nil)
;;;                                     (read-file-name formt nil default-directory nil)))
;;;           switches)))


;; ADVISE ORIGINAL in `dired.el'.
;;
;; Add to doc string, to document non-positive prefix arg.
;;
(defadvice dired (before diredp-doc-cons-arg activate)
  "Interactively, a prefix argument changes the behavior as follows:

,* If >= 0, you are first prompted for the `ls' switches to use.

,* If <= 0, you are prompted first for the name of the Dired  buffer.
  Then you are prompted repeatedly for the names of the directories
  or files to list in the buffer.  You can use file-name wildcards
  (i.e., `*' for globbing), to include the matching files and
  directories.  Use `C-g' to end.

  In other words, instead of listing a single directory, the Dired
  buffer can list any number of directories and file names, which can
  even belong to different directory trees.

The rest of this description applies only if you use Icicles.

In Icicle mode this is a multi-command: You can cycle among file-name
completion candidates and act individually on those that name
directories.  The action is to open Dired for the directory.  While
cycling, these keys are active:

\\<minibuffer-local-completion-map>\
`C-mouse-2', `C-return' - Act on current completion candidate only
`C-down', `C-wheel-down' - Move to next completion candidate and act
`C-up', `C-wheel-up' - Move to previous completion candidate and act
`C-next'  - Move to next apropos-completion candidate and act
`C-prior' - Move to previous apropos-completion candidate and act
`C-end'   - Move to next prefix-completion candidate and act
`C-home'  - Move to previous prefix-completion candidate and act
`\\[icicle-all-candidates-action]'     - Act on *all* candidates, successively (careful!)
`\\[icicle-all-candidates-list-alt-action]'     - Open Dired on all candidates

When candidate action and cycling are combined (e.g. `C-next'), user
option `icicle-act-before-cycle-flag' determines which occurs first.

With prefix `C-M-' instead of `C-', the same keys (`C-M-mouse-2',
`C-M-RET', `C-M-down', and so on) provide help about candidates.

Use `mouse-2', `RET', or `S-RET' to finally choose a candidate, or
`C-g' to quit.

These keys are also bound in the minibuffer during completion (`*'
means the key requires library `Bookmark+'):

   S-delete    - Delete candidate file or (empty) dir
   C-c +       - Create a new directory
   C-backspace - Go up one directory level
 ,* C-x C-t *   - Narrow to files with all of the tags you specify
 ,* C-x C-t +   - Narrow to files with some of the tags you specify
 ,* C-x C-t % * - Narrow to files with all tags matching a regexp
 ,* C-x C-t % + - Narrow to files with some tags  matching a regexp
 ,* C-x a +     - Add tags to the current-candidate file
 ,* C-x a -     - Remove tags from the current-candidate file
 ,* C-x m       - Access file bookmarks (not just autofiles)"
  (interactive (dired-read-dir-and-switches "" 'READ-EXTRA-FILES-P)))


;; ADVISE ORIGINAL in `dired.el'.
;;
;; Add to doc string, to document non-positive prefix arg.
;;
(defadvice dired-other-window (before diredp-doc-cons-arg activate)
  "Interactively, a prefix argument changes the behavior.
A non-positive prefix arg lets you choose an explicit set of files and
directories to list.  See the advice for `dired' for more information."
  (interactive (dired-read-dir-and-switches "" 'READ-EXTRA-FILES-P)))


;; ADVISE ORIGINAL in `dired.el'.
;;
;; Add to doc string, to document non-positive prefix arg.
;;
(defadvice dired-other-frame (before diredp-doc-cons-arg activate)
  "Interactively, a prefix argument changes the behavior.
A non-positive prefix arg lets you choose an explicit set of files and
directories to list.  See the advice for `dired' for more information."
  (interactive (dired-read-dir-and-switches "" 'READ-EXTRA-FILES-P)))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; Made compatible with Emacs 20, 21, which do not have [:alnum].
;; Also, this is defined here because it is used elsewhere in the file.
;;
(defun dired-switches-escape-p (switches)
  "Return non-nil if the string SWITCHES contains `-b' or `--escape'."
  (if (fboundp 'dired-switches-check)   ; Emacs 24.4+ - see Emacs bug #17218.
      (dired-switches-check switches "escape" "b")
    ;; Do not match things like "--block-size" that happen to contain "b".
    (if (> emacs-major-version 21)      ; SWITCHES must be a string here, not nil.
        (diredp-string-match-p "\\(\\`\\| \\)-[[:alnum:]]*b\\|--escape\\>" switches)
      (diredp-string-match-p "\\(\\`\\| \\)-\\(\w\\|[0-9]\\)*b\\|--escape\\>" switches))))


;; From `dired.el'

(when (and (> emacs-major-version 22)  (featurep 'ls-lisp+))

;;; 2012/04/26: Commented this out.
;;;             Might need it again when update `ls-lisp+.el' to fix other things.
;;;
;;;   ;; Use t as WILDCARD arg to `dired-insert-directory'.
;;;   ;;
;;;   (defun dired-readin-insert ()
;;;     ;; Insert listing for the specified dir (and maybe file  list)
;;;     ;; already in dired-directory, assuming a clean buffer.
;;;     (let (dir  file-list)
;;;       (if (consp dired-directory)
;;;           (setq dir        (car dired-directory)
;;;                 file-list  (cdr dired-directory))
;;;         (setq dir        dired-directory
;;;               file-list  ()))
;;;       (setq dir  (expand-file-name dir))
;;;       (if (and (equal "" (file-name-nondirectory dir))  (not file-list))
;;;           ;; If we are reading a whole single directory...
;;;           (dired-insert-directory dir dired-actual-switches nil nil t)
;;;         (unless (file-readable-p (directory-file-name (file-name-directory dir)))
;;;           (error "Directory `%s' inaccessible or nonexistent" dir))
;;;         ;; Else treat it as a wildcard spec.
;;;         (dired-insert-directory dir dired-actual-switches file-list t t))))


  ;; REPLACE ORIGINAL in `dired.el'.
  ;;
  ;; Compute WILDCARD arg for `insert-directory' for individual file (don't just use nil).
  ;;
  (defun dired-insert-directory (dir switches &optional file-list wildcard hdr)
    "Insert a directory listing of DIR, Dired style.
Use SWITCHES to make the listings.
If FILE-LIST is non-nil, list only those files.
Otherwise, if WILDCARD is non-nil, expand wildcards;
 in that case, DIR should be a file name that uses wildcards.
In other cases, DIR should be a directory name or a directory filename.
If HDR is non-nil, insert a header line with the directory name."
    (let ((opoint               (point))
          (process-environment  (copy-sequence process-environment))
          end)
      (when (and
             ;; Do not try to invoke `ls' if on DOS/Windows, where `ls-lisp' is used, unless
             ;; the user really wants to use `ls', as indicated by
             ;; `ls-lisp-use-insert-directory-program'.
             (or (not (featurep 'ls-lisp))  ls-lisp-use-insert-directory-program)
             (or (if (eq dired-use-ls-dired 'unspecified)
                     ;; Check if "ls --dired" gives exit code 0.  Put it in `dired-use-ls-dired'.
                     (or (setq dired-use-ls-dired  (eq 0 (call-process insert-directory-program
                                                                       nil nil nil "--dired")))
                         (progn (message "Command `ls' does not support switch `--dired' - see \
`dired-use-ls-dired'.")
                                nil))
                   dired-use-ls-dired)
                 (file-remote-p dir)))
        (setq switches  (concat "--dired " switches)))
      ;; We used to specify the C locale here, to force English month names.  This should not be
      ;; necessary any more with the new value of `directory-listing-before-filename-regexp'.
      (if file-list
          (dolist (f  file-list)
            (let ((beg  (point)))
              ;; Compute wildcard arg for this file.
              (insert-directory f switches (diredp-string-match-p "[[?*]" f) nil)
              ;; Re-align fields, if necessary.
              (dired-align-file beg (point))))
        (insert-directory dir switches wildcard (not wildcard)))
      ;; Quote certain characters, unless `ls' quoted them for us.
      (unless (dired-switches-escape-p dired-actual-switches)
        (save-excursion
          (setq end  (point-marker))
          (goto-char opoint)
          (while (search-forward "\\" end t)
            (replace-match (apply #'propertize "\\\\" (text-properties-at (match-beginning 0)))
                           nil t))
          (goto-char opoint)
          (while (search-forward "\^m" end t)
            (replace-match (apply #'propertize "\\015" (text-properties-at (match-beginning 0)))
                           nil t))
          (set-marker end nil))
        ;; Comment in original, from some Emacs Dev developer:
        ;;
        ;; Replace any newlines in DIR with literal "\n" for the sake of the header line.  To
        ;; disambiguate a literal "\n" in the actual dirname, we also replace "\" with "\\".
        ;; I think this should always be done, irrespective of the value of
        ;; dired-actual-switches, because:
        ;;   i) Dired does not work with an unescaped newline in the directory name used in the
        ;;      header (bug=10469#28), and
        ;;  ii) "\" is always replaced with "\\" in the listing, so doing it in the header as
        ;;      well makes things consistent.
        ;; But at present it is done only if "-b" is in ls-switches, because newlines in dirnames
        ;; are uncommon, and people may have gotten used to seeing unescaped "\" in the headers.
        ;; Note: adjust `dired-build-subdir-alist' if you change this.
        (setq dir  (replace-regexp-in-string "\\\\" "\\\\" dir nil t)
              dir  (replace-regexp-in-string "\n" "\\n" dir nil t)))
      ;; If we used `--dired' and it worked, the lines are already indented.  Else indent them.
      (unless (save-excursion (goto-char opoint) (diredp-looking-at-p "  "))
        (let ((indent-tabs-mode  nil)) (indent-rigidly opoint (point) 2)))
      ;; Insert text at the beginning to standardize things.
      (let ((content-point opoint))
        (save-excursion
          (goto-char opoint)
          (when (and (or hdr  wildcard)  (not (and (looking-at "^  \\(.*\\):$")
                                                   (file-name-absolute-p (match-string 1)))))
            ;; `dired-build-subdir-alist' will replace the name by its expansion, so it does not
            ;; matter whether what we insert here is fully expanded, but it should be absolute.
            (insert "  " (directory-file-name (file-name-directory dir)) ":\n")
            (setq content-point (point)))
          (when wildcard
            ;; Insert "wildcard" line where "total" line would be for a full dir.
            (insert "  wildcard " (file-name-nondirectory dir) "\n")))
        (dired-insert-set-properties content-point (point))))))


;;; Image stuff.

(defun diredp-image-dired-required-msg ()
  "Raise an error if `image-dired.el' is not loaded."
  (unless (require 'image-dired nil t) (error "This command requires library `image-dired.el'")))

;; See `image-dired-create-thumb'.
;; Define this even if `image-dired.el' is not loaded.
;; Do NOT raise an error if not loaded, because this is used in `diredp-mouseover-help'.
;;;###autoload
(defun diredp-image-dired-create-thumb (file &optional arg)
  "Create thumbnail image file for FILE (default: file on current line).
With a prefix arg, replace any existing thumbnail for FILE.
With a numeric prefix arg (not a cons), use it as the thumbnail size.
Return the name of the thumbnail image file, or nil if none."
  (interactive (list (if (derived-mode-p 'dired-mode)
                         (dired-get-filename nil 'NO-ERROR)
                       ;; Make it work also for `diredp-list-files' listings.
                       (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
                     current-prefix-arg))
  (and (fboundp 'image-dired-thumb-name) ; No-op (return nil) if `image-dired.el' not loaded.
       (let ((thumb-name  (image-dired-thumb-name file)))
         (when arg (clear-image-cache))
         (when (or arg  (not (file-exists-p thumb-name)))
           (let ((image-dired-thumb-width   (or (and arg  (atom arg)  arg)  image-dired-thumb-width))
                 (image-dired-thumb-height  (or (and arg  (atom arg)  arg)  image-dired-thumb-height)))
             (unless (zerop (image-dired-create-thumb file thumb-name))
               (error "Thumbnail image file could not be created"))))
         (and (file-exists-p thumb-name)  thumb-name))))


;; REPLACE ORIGINAL in `image-dired.el' (Emacs 22-23).
;;
;; 1. Raise an error if `image-dired.el' is not available.
;; 2. Repro it here so it picks up `Dired+' version of `dired-map-over-marks'.
;;
;;;###autoload
(defun image-dired-dired-insert-marked-thumbs () ; Bound to `C-t C-t' (Emacs 22-23)
  "Insert thumbnails before file names of marked files in the Dired buffer."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (dired-map-over-marks
   (let* ((image-pos   (dired-move-to-filename))
          (image-file  (dired-get-filename))
          (thumb-file  (image-dired-get-thumbnail-image image-file))
          overlay)
     ;; If image is not already added, then add it.
     (unless (delq nil (mapcar (lambda (o) (overlay-get o 'put-image))
                               ;; Can't use (overlays-at (point)), BUG?
                               (overlays-in (point) (1+ (point)))))
       (put-image thumb-file image-pos)
       (setq overlay  (car (delq nil (mapcar (lambda (ov) (and (overlay-get ov 'put-image)  ov))
                                             (overlays-in (point) (1+ (point)))))))
       (overlay-put overlay 'image-file image-file)
       (overlay-put overlay 'thumb-file thumb-file)))
   nil)
  (add-hook 'dired-after-readin-hook 'image-dired-dired-after-readin-hook nil t))


;; REPLACE ORIGINAL in `image-dired.el' (Emacs 24+).
;;
;; 1. Raise an error if `image-dired.el' is not available.
;; 2. Repro it here so it picks up `Dired+' version of `dired-map-over-marks'.
;;
;;;###autoload
(defun image-dired-dired-toggle-marked-thumbs (&optional arg) ; Bound to `C-t C-t' (Emacs 24+)
  "Toggle thumbnails in front of file names in Dired.
If no files are marked, insert or hide thumbnails on the current line.
With a numeric prefix arg N, ignore marked files and act on the next N
files (previous -N files, if N < 0)."
  (interactive (progn (diredp-image-dired-required-msg) (list current-prefix-arg)))
  (dired-map-over-marks
   (let* ((image-pos   (dired-move-to-filename))
          (image-file  (diredp-get-image-filename nil 'NO-ERROR))
          thumb-file  overlay)
     (when image-file
       (setq thumb-file  (image-dired-get-thumbnail-image image-file))
       ;; If image is not already added, then add it.
       (let* ((cur-ovs   (overlays-in (point) (1+ (point))))
              (thumb-ov  (car (diredp-remove-if-not (lambda (ov) (overlay-get ov 'thumb-file))
                                                    cur-ovs))))
         (if thumb-ov
             (delete-overlay thumb-ov)
           (put-image thumb-file image-pos)
           (setq overlay (car (delq nil (mapcar (lambda (ov) (and (overlay-get ov 'put-image)  ov))
                                                (overlays-in (point) (1+ (point)))))))
           (overlay-put overlay 'image-file image-file)
           (overlay-put overlay 'thumb-file thumb-file)))))
   arg
   'SHOW-PROGRESS)
  (add-hook 'dired-after-readin-hook 'image-dired-dired-after-readin-hook nil t))

;; Corresponds to `image-dired-dired-comment-files'.
;;;###autoload
(defun diredp-image-dired-comment-file ()
  "Add comment to this image file."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (image-dired-write-comments (cons (dired-get-filename) (image-dired-read-comment))))

;; Corresponds to `image-dired-tag-files'.
;;;###autoload
(defun diredp-image-dired-tag-file ()
  "Tag this image file with an `image-dired' tag."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (image-dired-write-tags (cons (dired-get-filename)
                                (read-string "Tags to add (use `;' to separate): "))))

;; Corresponds to `image-dired-delete-tag'.
;;;###autoload
(defun diredp-image-dired-delete-tag ()
  "Remove an `image-dired' tag from  this image file."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (image-dired-remove-tag (list (dired-get-filename)) (read-string "Tag to remove: ")))

;; Corresponds to `image-dired-display-thumbs'.
;;;###autoload
(defun diredp-image-dired-display-thumb (&optional append)
  "Pop to thumbnail of this image file, in `image-dired-thumbnail-buffer'.
If a thumbnail image does not yet exist for this file, create it.
With a prefix arg, append the thumbnail to the thumbnails buffer,
instead of clearing the buffer first."
  (interactive (progn (diredp-image-dired-required-msg) (list current-prefix-arg)))
  (let* ((dired-buf   (current-buffer))
         (curr-file   (dired-get-filename))
         (thumb-name  (image-dired-thumb-name curr-file)))
    (with-current-buffer (image-dired-create-thumbnail-buffer)
      (let ((inhibit-read-only  t))
        (if (not append) (erase-buffer) (goto-char (point-max)))
        (if (and (not (file-exists-p thumb-name))
                 (not (zerop (image-dired-create-thumb curr-file thumb-name))))
            (message "Cannot create thumbnail image for file `%s'" curr-file)
          (image-dired-insert-thumbnail thumb-name curr-file dired-buf)))
      (cond ((eq 'dynamic image-dired-line-up-method)     (image-dired-line-up-dynamic))
            ((eq 'fixed image-dired-line-up-method)       (image-dired-line-up))
            ((eq 'interactive image-dired-line-up-method) (image-dired-line-up-interactive))
            ((eq 'none image-dired-line-up-method)        nil)
            (t                                            (image-dired-line-up-dynamic))))
    (pop-to-buffer image-dired-thumbnail-buffer)))

;; Corresponds to `image-dired-copy-with-exif-file-name'.
;;;###autoload
(defun diredp-image-dired-copy-with-exif-name ()
  "Copy this image file to your main image directory.
Uses `image-dired-get-exif-file-name' to name the new file."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (let* ((curr-file  (dired-get-filename))
         (new-name   (format "%s/%s" (file-name-as-directory
                                      (expand-file-name image-dired-main-image-directory))
                             (image-dired-get-exif-file-name curr-file))))
    (message "Copying `%s' to `%s'..." curr-file new-name)
    (copy-file curr-file new-name)
    (message "Copying `%s' to `%s'...done" curr-file new-name)))

;; Corresponds to `image-dired-dired-edit-comment-and-tags'.
;;;###autoload
(defun diredp-image-dired-edit-comment-and-tags ()
  "Edit comment and tags for this image file."
  (interactive (progn (diredp-image-dired-required-msg) ()))
  (setq image-dired-widget-list  ())
  (let ((file  (dired-get-filename)))
    (if (fboundp 'pop-to-buffer-same-window)
        (pop-to-buffer-same-window "*Image-Dired Edit Meta Data*")
      (switch-to-buffer "*Image-Dired Edit Meta Data*"))
    (kill-all-local-variables)
    (make-local-variable 'widget-example-repeat)
    (let ((inhibit-read-only  t))
      (erase-buffer)
      (remove-overlays)
      (widget-insert
       "\nEdit comment and tags for the image.  Separate multiple tags
with a comma (`,').  Move forward among fields using `TAB' or `RET'.
Move backward using `S-TAB'.  Click `Save' to save your edits or
`Cancel' to abandon them.\n\n")
      (let* ((thumb-file  (image-dired-thumb-name file))
             (img         (create-image thumb-file))
             comment-widget  tag-widget)
        (insert-image img)
        (widget-insert "\n\nComment: ")
        (setq comment-widget  (widget-create 'editable-field :size 60 :format "%v "
                                             :value (or (image-dired-get-comment file)  "")))
        (widget-insert "\nTags:    ")
        (setq tag-widget  (widget-create 'editable-field :size 60 :format "%v "
                                         :value (or (mapconcat #'identity (image-dired-list-tags file) ",")  "")))
        ;; Save info in widgets to use when the user saves the form.
        (setq image-dired-widget-list  (append image-dired-widget-list
                                               (list (list file comment-widget tag-widget))))
        (widget-insert "\n\n")))
    (widget-insert "\n")
    (widget-create 'push-button :notify (lambda (&rest _ignore)
                                          (image-dired-save-information-from-widgets)
                                          (bury-buffer)
                                          (message "Done"))
                   "Save")
    (widget-insert " ")
    (widget-create 'push-button :notify (lambda (&rest _ignore)
                                          (bury-buffer)
                                          (message "Operation canceled"))
                   "Cancel")
    (widget-insert "\n")
    (use-local-map widget-keymap)
    (widget-setup)
    (widget-forward 1)))                ; Jump to the first widget.

;;;###autoload
(defun diredp-do-display-images (&optional arg)
  "Display the marked image files.
A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any files are marked).
 More than one `C-u' means use all files in the Dired buffer, as if
 they were all marked."
  (interactive (progn (unless (require 'image-file nil t)
                        (error "This command requires library `image-file.el'"))
                      (diredp-ensure-mode)
                      (list current-prefix-arg)))
  (dired-map-over-marks-check #'diredp-display-image arg 'display\ image (diredp-fewer-than-2-files-p arg)))

(defun diredp-display-image ()
  "Display image file at point.  Log an error using `dired-log'."
  (let ((file     (dired-get-filename t 'NO-ERROR))
        (failure  nil))
    (save-excursion
      (if (let ((inhibit-changing-match-data  t))
            (and file  (diredp-string-match-p (image-file-name-regexp) file)))
          (condition-case err
              (let ((find-file-run-dired  nil)) (find-file-other-window file))
            (error (setq failure  (error-message-string err))))
        (dired-log (format "Not an image file: `%s'" file))
        (setq failure  t)))
    (and failure                    ; Return nil for success.
         (prog1 file                ; Return file name for failure.
           (unless (eq t failure) (dired-log "Cannot display image file `%s':\n%s\n" file failure)  t)))))

;;;###autoload
(defun diredp-image-show-this-file (&optional arg)
  "Show the image file named on this line in another frame or window.
Option `diredp-image-show-this-file-use-frame-flag' which is used.

With a prefix arg, shrink the image to fit a frame that many lines
high or a window at least that many lines high.
Otherwise, show the image full size.
Note:
 ,* To show the image full size, you can also use `\\<dired-mode-map>\\[dired-find-file]'.
 ,* To show the image in another window, at whatever scale fits there,
   you can use `\\[image-dired-dired-display-image]'."
  (interactive (progn (diredp-image-dired-required-msg) (list current-prefix-arg)))
  (image-dired-create-display-image-buffer)
  (let ((fit-frame-inhibit-fitting-flag  t) ; In `fit-frame.el'.
        (img-file                        (diredp-get-image-filename)))
    (if img-file
        (with-current-buffer image-dired-display-image-buffer
          (let* ((window-min-height  (if arg
                                         (prefix-numeric-value arg)
                                       (ceiling (cdr (image-size (create-image img-file))))))
                 (special-display-frame-alist   (if diredp-image-show-this-file-use-frame-flag
                                                    (cons `(height . ,window-min-height)
                                                          special-display-frame-alist)
                                                  special-display-frame-alist))
                 (special-display-buffer-names  (if diredp-image-show-this-file-use-frame-flag
                                                    (cons image-dired-display-image-buffer
                                                          special-display-buffer-names)
                                                  special-display-buffer-names)))
            (display-buffer image-dired-display-image-buffer)
            (image-dired-display-image img-file (not arg))))
      (message "No image file here")))) ; An error is handled by `diredp-get-image-filename'.

(defun diredp-report-file-result (file result failure echop)
  "Report failure (error) or success using `message' and logging.
Return RESULT."
  (let ((msg  (if failure
                  (format "Error for %s:\n%s\n" file failure)
                (format "Result for %s:\n%s\n" file result))))
    (when echop (message msg) (sit-for 1))
    (dired-log msg))
  result)

(defun diredp-read-command (&optional prompt default)
  "Read the name of a command and return a symbol with that name.
\(A command is anything that satisfies predicate `commandp'.)
Prompt with PROMPT, which defaults to \"Command: \".
By default, return the command named DEFAULT (or, with Emacs 23+, its
first element if DEFAULT is a list).  (If DEFAULT does not name a
command then it is ignored.)"
  (setq prompt  (or prompt  "Emacs command: "))
  (let ((name  (completing-read prompt obarray #'commandp t nil
                                'extended-command-history default)))
    (while (string= "" name)
      (setq name  (completing-read prompt obarray #'commandp t nil
                                   'extended-command-history default)))
    (intern name)))

;;; Face Definitions

(defface diredp-autofile-name
    '((((background dark)) (:background "#111313F03181")) ; Very dark blue
      (t                   (:background "#EEECEC0FCE7E"))) ; Very pale goldenrod
  "*Face used in Dired for names of files that are autofile bookmarks."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-autofile-name 'diredp-autofile-name)

(defface diredp-compressed-file-name
    '((((background dark)) (:foreground "Blue"))
      (t                   (:foreground "Brown")))
  "*Face used for compressed file names."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-compressed-file-name 'diredp-compressed-file-name)

(defface diredp-compressed-file-suffix
    '((((background dark)) (:foreground "Blue"))
      (t                   (:foreground "Yellow")))
  "*Face used for compressed file suffixes in Dired buffers.
This means the `.' plus the file extension.  Example: `.zip'."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-compressed-file-suffix 'diredp-compressed-file-suffix)

(defface diredp-date-time
    '((((background dark)) (:foreground "#74749A9AF7F7")) ; ~ med blue
      (t                   (:foreground "DarkGoldenrod4")))
  "*Face used for date and time in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-date-time 'diredp-date-time)

(defface diredp-deletion
    '((t (:foreground "Yellow" :background "Red")))
  "*Face used for deletion flags (D) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-deletion 'diredp-deletion)

(defface diredp-deletion-file-name
    '((t (:foreground "Red")))
  "*Face used for names of deleted files in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-deletion-file-name 'diredp-deletion-file-name)

(defface diredp-dir-heading
    '((((background dark)) (:foreground "Yellow" :background "#00003F3F3434")) ; ~ dark green
      (t                   (:foreground "Blue" :background "Pink")))
  "*Face used for directory headings in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-dir-heading 'diredp-dir-heading)

(defface diredp-dir-name
    '((((background dark))
       (:foreground "#7474FFFFFFFF" :background "#2C2C2C2C2C2C")) ; ~ cyan, dark gray
      (t (:foreground "DarkRed" :background "LightGray")))
  "*Face used for directory names."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-dir-name 'diredp-dir-name)

(defface diredp-dir-priv
    '((((background dark))
       (:foreground "#7474FFFFFFFF" :background "#2C2C2C2C2C2C")) ; ~ cyan, dark gray
      (t (:foreground "DarkRed" :background "LightGray")))
  "*Face used for directory privilege indicator (d) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-dir-priv 'diredp-dir-priv)

(defface diredp-exec-priv
    '((((background dark)) (:background "#4F4F3B3B2121")) ; ~ dark brown
      (t                   (:background "LightSteelBlue")))
  "*Face used for execute privilege indicator (x) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-exec-priv 'diredp-exec-priv)

;; For this to show up, you need `F' among the options in `dired-listing-switches'.
;; For example, I use "-alF" for `dired-listing-switches'.
(defface diredp-executable-tag
    '((t (:foreground "Red")))
  "*Face used for executable tag (*) on file names in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-executable-tag 'diredp-executable-tag)

(defface diredp-file-name
    '((((background dark)) (:foreground "Yellow"))
      (t                   (:foreground "Blue")))
  "*Face used for file names (without suffixes) in Dired buffers.
This means the base name.  It does not include the `.'."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-file-name 'diredp-file-name)

(defface diredp-file-suffix
    '((((background dark)) (:foreground "#7474FFFF7474")) ; ~ light green
      (t                   (:foreground "DarkMagenta")))
  "*Face used for file suffixes in Dired buffers.
This means the `.' plus the file extension.  Example: `.elc'."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-file-suffix 'diredp-file-suffix)

(defface diredp-flag-mark
    '((((background dark)) (:foreground "Blue" :background "#7575D4D41D1D")) ; ~ olive green
      (t                   (:foreground "Yellow" :background "Blueviolet")))
  "*Face used for flags and marks (except D) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-flag-mark 'diredp-flag-mark)

(defface diredp-flag-mark-line
    '((((background dark)) (:background "#787831311414")) ; ~ dark red brown
      (t                   (:background "Skyblue")))
  "*Face used for flagged and marked lines in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-flag-mark-line 'diredp-flag-mark-line)

(defface diredp-ignored-file-name
  '((((background dark)) (:foreground "#C29D6F156F15"))    ; ~ salmon
    (t                   (:foreground "#00006DE06DE0"))) ; ~ dark cyan
  "*Face used for files whose names are omitted based on the extension.
See also face `diredp-omit-file-name'."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-ignored-file-name 'diredp-ignored-file-name)

(defface diredp-link-priv
    '((((background dark)) (:foreground "#00007373FFFF")) ; ~ blue
      (t                   (:foreground "DarkOrange")))
  "*Face used for link privilege indicator (l) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-link-priv 'diredp-link-priv)

(when (> emacs-major-version 21)
  (defface diredp-mode-line-marked
      '((t (:foreground "DarkViolet")))
    "*Face for marked number in mode-line `mode-name' for Dired buffers."
    :group 'Dired-Plus :group 'font-lock-highlighting-faces)

  (defface diredp-mode-line-flagged
      '((t (:foreground "Red")))
    "*Face for flagged number in mode-line `mode-name' for Dired buffers."
    :group 'Dired-Plus :group 'font-lock-highlighting-faces))

(defface diredp-no-priv
    '((((background dark)) (:background "#2C2C2C2C2C2C")) ; ~ dark gray
      (t                   (:background "LightGray")))
  "*Face used for no privilege indicator (-) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-no-priv 'diredp-no-priv)

(defface diredp-number
    '((((background dark)) (:foreground "#FFFFFFFF7474")) ; ~ light yellow
      (t                   (:foreground "DarkBlue")))
  "*Face used for numerical fields in Dired buffers.
In particular, inode number, number of hard links, and file size."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-number 'diredp-number)

(defface diredp-omit-file-name
  (if (assq :inherit custom-face-attributes) ; Emacs 22+
      '((((background dark)) (:inherit diredp-ignored-file-name :strike-through "#555555555555")) ; ~ dark gray
        (t                   (:inherit diredp-ignored-file-name :strike-through "#AAAAAAAAAAAA"))) ; ~ light gray
    '((((background dark)) (:foreground "#C29D6F156F15")) ; ~ salmon
      (t                   (:foreground "#00006DE06DE0")))) ; ~ dark cyan
  "*Face used for files whose names will be omitted in `dired-omit-mode'.
This means file names that match regexp `diredp-omit-files-font-lock-regexp'.
\(File names matching `dired-omit-extensions' are highlighted with face
`diredp-ignored-file-name' instead.)"
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-omit-file-name 'diredp-omit-file-name)

(defface diredp-other-priv
    '((((background dark)) (:background "#111117175555")) ; ~ dark blue
      (t                   (:background "PaleGoldenrod")))
  "*Face used for l,s,S,t,T privilege indicators in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-other-priv 'diredp-other-priv)

(defface diredp-rare-priv
    '((((background dark)) (:foreground "Green" :background "#FFFF00008080")) ; ~ hot pink
      (t                   (:foreground "Magenta" :background "SpringGreen")))
  "*Face used for rare privilege indicators (b,c,s,m,p,S) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-rare-priv 'diredp-rare-priv)

(defface diredp-read-priv
    '((((background dark)) (:background "#999932325555")) ; ~ burgundy / dark magenta
      (t                   (:background "MediumAquamarine")))
  "*Face used for read privilege indicator (w) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-read-priv 'diredp-read-priv)

(defface diredp-symlink
    '((((background dark)) (:foreground "#00007373FFFF")) ; ~ blue
      (t                   (:foreground "DarkOrange")))
  "*Face used for symbolic links in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-symlink 'diredp-symlink)

(defface diredp-tagged-autofile-name
    '((((background dark)) (:background "#328C0411328C")) ; Very dark magenta
      (t                   (:background "#CD73FBEECD73"))) ; Very pale green
  "*Face used in Dired for names of files that are autofile bookmarks."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-tagged-autofile-name 'diredp-tagged-autofile-name)

(defface diredp-write-priv
    '((((background dark)) (:background "#25258F8F2929")) ; ~ dark green
      (t                   (:background "Orchid")))
  "*Face used for write privilege indicator (w) in Dired buffers."
  :group 'Dired-Plus :group 'font-lock-highlighting-faces)
(defvar diredp-write-priv 'diredp-write-priv)

;; Fix Emacs 20 recognition of fields up through file name when size is expressed using `k' etc.
(when (and (< emacs-major-version 21)  (not (boundp 'diredp-loaded-p))
           dired-move-to-filename-regexp ; These last two checks are just in case.
           (eq (aref dired-move-to-filename-regexp 7) ?\  ))
  (setq dired-move-to-filename-regexp  (concat "[0-9][BkKMGTPEZY]?"
                                               (substring dired-move-to-filename-regexp 7))))

;;; Define second level of fontifying.
(defvar diredp-font-lock-keywords-1
  (list
   '("^  \\(.+:\\)$" 1 diredp-dir-heading) ; Directory headers
   '("^  wildcard.*$" 0 'default)   ; Override others, e.g. `l' for `diredp-other-priv'.
   '("^  (No match).*$" 0 'default) ; Override others, e.g. `t' for `diredp-other-priv'.
   '("[^ .]\\(\\.[^. /]+\\)$" 1 diredp-file-suffix) ; Suffix, including `.'.
   '("\\([^ ]+\\) -> .+$" 1 diredp-symlink)         ; Symbolic links

   ;; 1) Date/time and 2) filename w/o suffix.
   ;;    This is a bear, and it is fragile - Emacs can change `dired-move-to-filename-regexp'.
   (if (or (not (fboundp 'version<))  (version< emacs-version "23.2"))
       (list dired-move-to-filename-regexp
             (list 1 'diredp-date-time t t) ; Date/time
             (list (concat "\\(.+\\)\\(" (concat (funcall #'regexp-opt diredp-compressed-extensions)
                                                 "\\)[*]?$")) ; Compressed-file name
                   nil nil (list 0 diredp-compressed-file-name 'keep t)))
     `(,dired-move-to-filename-regexp
       (7 diredp-date-time t t) ; Date/time, locale (western or eastern)
       (2 diredp-date-time t t) ; Date/time, ISO
       (,(concat "\\(.+\\)\\(" (concat (funcall #'regexp-opt diredp-compressed-extensions)
                                       "\\)[*]?$"))
        nil nil (0 diredp-compressed-file-name keep t)))) ; Compressed-file suffix
   (if (or (not (fboundp 'version<))  (version< emacs-version "23.2"))
       (list dired-move-to-filename-regexp
             (list 1 'diredp-date-time t t) ; Date/time
             (list "\\(.+\\)$" nil nil (list 0 diredp-file-name 'keep t))) ; Filename
     `(,dired-move-to-filename-regexp
       (7 diredp-date-time t t) ; Date/time, locale (western or eastern)
       (2 diredp-date-time t t) ; Date/time, ISO
       ("\\(.+\\)$" nil nil (0 diredp-file-name keep t)))) ; Filename (not a compressed file)

   ;; Files to ignore.
   ;;   Use face `diredp-ignored-file-name' for omission by file-name extension.
   ;;   Use face `diredp-omit-file-name' for omission by entire file name.
   (let* ((omit-exts   (or (and (boundp 'dired-omit-extensions)  dired-omit-extensions)
                           completion-ignored-extensions))
          (omit-exts   (and omit-exts  (mapconcat #'regexp-quote omit-exts "\\|")))
          (compr-exts  (and diredp-ignore-compressed-flag
                            (concat "\\|" (mapconcat #'regexp-quote diredp-compressed-extensions "\\|")))))
     (list (concat "^  \\(.*\\(" omit-exts compr-exts "\\)[*]?\\)$") ; [*]? allows for executable flag (*).
           1 diredp-ignored-file-name t))
   `(,(concat "^.*" dired-move-to-filename-regexp
              "\\(" diredp-omit-files-font-lock-regexp "\\)[*]?$") ; [*]? allows for executable flag (*).
     (0 diredp-omit-file-name t))

   ;; Compressed-file (suffix)
   (list (concat "\\(" (funcall #'regexp-opt diredp-compressed-extensions) "\\)[*]?$")
         1 diredp-compressed-file-suffix t)
   '("\\([*]\\)$" 1 diredp-executable-tag t) ; Executable (*)

   ;; Inode, hard-links, & file size (. and , are for the decimal point, depending on locale)
   ;; See comment for `directory-listing-before-filename-regexp' in `files.el' or `files+.el'.
   '("\\(\\([0-9]+\\([.,][0-9]+\\)?\\)[BkKMGTPEZY]?[ /]?\\)" 1 diredp-number)

   ;; Directory names - exclude d:/..., Windows drive letter in a dir heading.
   (list (concat dired-re-maybe-mark dired-re-inode-size "\\(d\\)[^:]")
         '(1 diredp-dir-priv t) '(".+" (dired-move-to-filename) nil (0 diredp-dir-name t)))

   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\(x\\)") ; o x
         '(1 diredp-exec-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\([lsStT]\\)") ; o misc
         '(1 diredp-other-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].......\\(w\\).") ; o w
         '(1 diredp-write-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]......\\(r\\)..") ; o r
         '(1 diredp-read-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\(x\\)...") ; g x
         '(1 diredp-exec-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\([lsStT]\\)...") ; g misc
         '(1 diredp-other-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]....\\(w\\)....") ; g w
         '(1 diredp-write-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]...\\(r\\).....") ; g r
         '(1 diredp-read-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\(x\\)...") ; u x
         '(1 diredp-exec-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\([lsStT]\\)...") ; u misc
         '(1 diredp-other-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].\\(w\\)....") ; u w
         '(1 diredp-write-priv))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]\\(r\\).....") ; u r
         '(1 diredp-read-priv))

   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]........\\([-rwxlsStT]\\)") ; o -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].......\\([-rwxlsStT]\\).") ; g -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]......\\([-rwxlsStT]\\)..") ; u -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].....\\([-rwxlsStT]\\)...") ; o -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]....\\([-rwxlsStT]\\)....") ; g -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]...\\([-rwxlsStT]\\).....") ; u -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]..\\([-rwxlsStT]\\)......") ; o -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl].\\([-rwxlsStT]\\).......") ; g -
         '(1 diredp-no-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "[-dl]\\([-rwxlsStT]\\)........") ; u -
         '(1 diredp-no-priv keep))

   (list (concat dired-re-maybe-mark dired-re-inode-size "\\([bcsmpS]\\)") ; (rare)
         '(1 diredp-rare-priv keep))
   (list (concat dired-re-maybe-mark dired-re-inode-size "\\(l\\)[-rwxlsStT]") ; l
         '(1 diredp-link-priv keep))

   (list (concat "^\\([^\n " (char-to-string dired-del-marker) "].*$\\)")
         1 diredp-flag-mark-line t)     ; Flag/mark lines
   (list (concat "^\\([^\n " (char-to-string dired-del-marker) "]\\)") ; Flags, marks (except D)
         1 diredp-flag-mark t)

   (list (concat "^\\([" (char-to-string dired-del-marker) "].*$\\)") ; Deletion-flagged lines
         1 diredp-deletion-file-name t)
   (list (concat "^\\([" (char-to-string dired-del-marker) "]\\)") ; Deletion flags (D)
         1 diredp-deletion t)

   ) "2nd level of Dired highlighting.  See `font-lock-maximum-decoration'.")


(defun diredp--set-up-font-locking ()
  "Add this to `dired-mode-hook' to provide for second-level fontifying."
  (set (make-local-variable 'font-lock-defaults)
       ;; Two levels.  Use 3-element list, since it is standard to have one more
       ;; than the number of levels.  This is necessary for it to work with
       ;; `font(-lock)-menus.el'.
       '((dired-font-lock-keywords
          dired-font-lock-keywords
          diredp-font-lock-keywords-1)
         t nil nil beginning-of-line))
  ;; Refresh `font-lock-keywords' from `font-lock-defaults'
  (when (fboundp 'font-lock-refresh-defaults) (font-lock-refresh-defaults)))

;;; Provide for the second level of fontifying.
(add-hook 'dired-mode-hook 'diredp--set-up-font-locking)

;; Ensure that Dired buffers are refontified when you use `g' or otherwise read in the file list.
(defun diredp-refontify-buffer ()
  "Turn `font-lock-mode' off, then on."
  (setq font-lock-mode  nil)
  (font-lock-mode))
(add-hook 'dired-after-readin-hook 'diredp-refontify-buffer)

;;; Function Definitions

;;; $$$$$$$$
;;; (defun diredp-dired-files (arg &optional switches) ; Not bound
;;;   "Like `dired', but non-positive prefix arg prompts for files to list.
;;; This is like `dired' unless you use a non-positive prefix arg.
;;; In that case, you are prompted for names of files and directories to
;;; list, and then you are prompted for the name of the Dired buffer that
;;; lists them.  Use `C-g' when you are done entering file names to list.

;;; In all cases, when inputting a file or directory name you can use
;;; shell wildcards.

;;; If you use Icicles, then in Icicle mode the following keys are bound
;;; in the minibuffer during completion (`*' means the key requires
;;; library `Bookmark+'):

;;;   M-|       - Open Dired on the file names matching your input
;;;   C-c +     - Create a new directory
;;;  *C-x a +   - Add tags to the current-candidate file
;;;  *C-x a -   - Remove tags from the current-candidate file
;;;  *C-x m     - Access file bookmarks (not just autofiles)"
;;;   (interactive (diredp-dired-files-interactive-spec ""))
;;;   (when (consp arg)
;;;     (let ((buf  (dired-find-buffer-nocreate (car arg)))) ; Respect file list.
;;;       (when buf (kill-buffer buf))))
;;;   (if (fboundp 'pop-to-buffer-same-window)
;;;       (pop-to-buffer-same-window (dired-noselect arg switches))
;;;     (switch-to-buffer (dired-noselect arg switches))))

;;; (defun diredp-dired-files-other-window (arg &optional switches) ; Not bound
;;;   "Same as `diredp-dired-files' except uses another window."
;;;   (interactive (diredp-dired-files-interactive-spec "in other window "))
;;;   (when (consp arg)
;;;     (let ((buf  (dired-find-buffer-nocreate (car arg)))) ; Respect file list.
;;;       (when buf (kill-buffer buf))))
;;;   (dired-other-window arg switches))

;;;###autoload
(defun diredp-dired-for-files (arg &optional switches) ; Bound to `C-x D F'
  "Dired the file names that you enter, in a Dired buffer that you name.
You are prompted for the name of the Dired buffer to use.
You are then prompted for names of files and directories to list,
 which can be located anywhere.
Use `C-g' when you are done.

With a prefix arg you are first prompted for the `ls' switches to use.

See also `dired' (including the advice)."
  (interactive (let ((current-prefix-arg  (if current-prefix-arg 0 -1)))
                 (dired-read-dir-and-switches "" 'READ-EXTRA-FILES-P)))
  (dired arg switches)
  (with-current-buffer (car arg)
    (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t))
    (setq revert-buffer-function  #'diredp-cannot-revert)))

;;;###autoload
(defun diredp-dired-for-files-other-window (arg &optional switches) ; Bound to `C-x 4 D F'
  "Same as `diredp-dired-for-files', except uses another window."
  (interactive (let ((current-prefix-arg  (if current-prefix-arg 0 -1)))
                 (dired-read-dir-and-switches "in other window " 'READ-EXTRA-FILES-P)))
  (dired-other-window arg switches)
  (with-current-buffer (car arg)
    (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t))
    (setq revert-buffer-function  #'diredp-cannot-revert)))

(when (fboundp 'quit-restore-window)    ; Emacs 24+

  ;; Use this for `q' because `diredp-dired-recent-files' creates a new unique buffer name.
  ;;
  (defun diredp-quit-window-kill (&optional window)
    "Quit WINDOW, deleting it, and kill its buffer.
WINDOW must be a live window and defaults to the selected one.

This is similar to the version of `quit-window' that Emacs had before
the introduction of `quit-restore-window'.  It ignores the information
stored in WINDOW's `quit-restore' window parameter.

It deletes the WINDOW more often, rather than switching to another
buffer in it.  If WINDOW is alone in its frame then the frame is
deleted or iconified, according to option `frame-auto-hide-function'."
    (interactive "P")
    (set-window-parameter window 'quit-restore `(frame frame nil ,(current-buffer)))
    (quit-restore-window window 'kill))

  )

(defvar diredp-recent-files-map (let ((map  (make-sparse-keymap)))
                                        (set-keymap-parent map dired-mode-map)
                                        map)
  "Keymap for Dired buffer listing recently visited files.
By default this is the same as its parent, `dired-mode-map', except
that if `diredp-recent-files-quit-kills-flag' is non-nil then `q' is
bound to `diredp-quit-window-kill' (Emacs 24+).")

(defcustom diredp-recent-files-quit-kills-flag t
  "Non-nil means `q' in Dired recently visited files buffer kills buffer.
Non-nil is convenient if you repeat a command that creates such a
buffer, as it won't add yet another one.  But nil is convenient if you
frequently use `C-x b' to revisit an existing such buffer.

Do not set this option using `setq' or similar.  Use
`customize-option' or `customize-set-variable'."
  :type 'boolean :group 'Dired-Plus
  :set (lambda (sym defs)
         (custom-set-default sym defs)
         (when (fboundp 'diredp-quit-window-kill)
           (define-key diredp-recent-files-map [remap quit-window] (and (symbol-value sym)
                                                                        'diredp-quit-window-kill)))))

;;;###autoload
(defun diredp-dired-recent-files (buffer &optional arg files) ; Bound to `C-x D R'
  "Open Dired in BUFFER, showing recently visited files and directories.
You are prompted for BUFFER (default: `Recently Visited Files').

With a numeric prefix arg you can enter names of recent files to
include or exclude.

No prefix arg or a plain prefix arg (`C-u', `C-u C-u', etc.) means
list all of the recently used files.

With a prefix arg:
,* If 0, `-', or plain (`C-u') then you are prompted for the `ls'
  switches to use.
,* If not plain (`C-u') then:
  ,* If >= 0 then the files to include are read, one by one.
  ,* If  < 0 then the files to exclude are read, one by one.

When entering files to include or exclude, use `C-g' to end.

The file listing is sorted by option
`diredp-default-sort-arbitrary-function', if non-nil.  If nil (the
default) then the listing is in reverse chronological order of opening
or writing files you access.

Use \\<dired-mode-map>`\\[revert-buffer]' to revert the buffer, as usual.  If you use it without a
prefix arg then the same files are relisted.  A prefix arg is handled
as for `\\[diredp-dired-recent-files] itself.

When called from Lisp:
 ,* ARG corresponds to the raw prefix arg.
 ,* FILES is passed to `diredp--dired-recent-files-1'.  It is used only
   when the command is used as part of the `revert-buffer-function'."
  (interactive (list (completing-read "Dired (buffer name): " dired-buffers nil nil nil nil
                                      "Recently Visited Files")
                     current-prefix-arg))
  (diredp--dired-recent-files-1 buffer arg files))

;;;###autoload
(defun diredp-dired-recent-files-other-window (buffer &optional arg files) ; Bound to `C-x 4 D R'
  "Same as `diredp-dired-recent-files', but use other window."
  (interactive (list (completing-read "Dired in other window (buffer name): " dired-buffers nil nil nil nil
                                      "Recently Visited Files")
                     current-prefix-arg))
  (diredp--dired-recent-files-1 buffer arg files 'OTHER-WINDOW-P))

(defun diredp--dired-recent-files-1 (buffer arg files &optional other-window-p dirs-p)
  "Helper for `diredp-dired-recent-files(-other-window)."
  (unless (require 'recentf nil t) (error "This command requires library `recentf.el'"))
  (let* ((switches  (and (or (zerop (prefix-numeric-value arg))  (consp arg)  (eq '- arg))
                         (read-string "Dired listing switches: " dired-listing-switches)))
         (bufname   (generate-new-buffer-name buffer))
         (fils      (or files  (diredp-sort-arbitrary (if dirs-p #'diredp-recent-dirs #'diredp-recent-files) arg)))
         (rev-fn    `(lambda (_ __)
                       (message "Reverting...")
                       (kill-buffer)
                       (funcall ,(if dirs-p '#'diredp-dired-recent-dirs '#'diredp-dired-recent-files)
                                ',buffer current-prefix-arg (and (not current-prefix-arg)  ',fils))
                       (message "Reverting...done"))))
    (funcall (if other-window-p #'dired-other-window #'dired) (cons bufname fils) switches)
    (with-current-buffer bufname
      (setq diredp-recent-files-buffer  bufname)
      (use-local-map diredp-recent-files-map)
      (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t))
      (set (make-local-variable 'revert-buffer-function) rev-fn))))

(defun diredp-recent-files (arg)
  "Return a list of recently used files and directories.
ARG is as for `diredp-dired-recent-files'."
  (let ((recent-files  (diredp-remove-if #'diredp-root-directory-p (diredp-delete-dups recentf-list))))
    (if (and arg  (atom arg))
        (diredp-read-include/exclude 'File recent-files (not (natnump (prefix-numeric-value arg))))
      recent-files)))

;;;###autoload
(defun diredp-dired-recent-dirs (buffer &optional arg files) ; Bound to `C-x D r'
  "Open Dired in BUFFER, showing recently visited directories.
Like `diredp-dired-recent-files', but limited to recent directories.
A directory is recent if any of its files is recent."
  (interactive (list (completing-read "Dired (buffer name): " dired-buffers nil nil nil nil
                                      "Recently Visited Directories")
                     current-prefix-arg))
  (diredp--dired-recent-files-1 buffer arg files nil 'DIRS-P))

;;;###autoload
(defun diredp-dired-recent-dirs-other-window (buffer &optional arg files) ; Bound to `C-x 4 D r'
  "Same as `diredp-dired-recent-dirs', but use other window."
  (interactive (list (completing-read "Dired in other window (buffer name): " dired-buffers nil nil nil nil
                                      "Recently Visited Directories")
                     current-prefix-arg))
  (diredp--dired-recent-files-1 buffer arg files 'OTHER-WINDOW-P 'DIRS-P))

(defun diredp-recent-dirs (arg)
  "Return a list of recently used directories.
ARG is as for `diredp-dired-recent-dirs'."
  (let ((recent-dirs  (diredp-remove-if #'diredp-root-directory-p
                                        (diredp-delete-dups
                                         (mapcar (lambda (f/d)
                                                   (if (file-directory-p f/d) f/d (file-name-directory f/d)))
                                                 recentf-list)))))
    (if (and arg  (atom arg))
        (diredp-read-include/exclude 'Dir recent-dirs (not (natnump (prefix-numeric-value arg))))
      recent-dirs)))

;;;###autoload
(defun diredp-do-add-to-recentf (&optional arg) ; Not bound by default
  "Add all marked (or next ARG) files to list of recently used files.
That is, add them from variable `recentf-list'.

\(This does not refresh any Dired buffer listing the recently visited
files.  You can refresh it manually using `\\[revert-buffer]'."
  (interactive "P")
  (unless (require 'recentf nil t) (error "This command requires library `recentf.el'"))
  (diredp-ensure-mode)
  (dired-map-over-marks-check #'diredp-add-file-to-recentf arg 'add\ to\ recentf
                              (diredp-fewer-than-2-files-p arg))
  (diredp-revert-displayed-recentf-buffers))

;;;###autoload
(defun diredp-do-remove-from-recentf (&optional arg) ; Not bound by default
  "Remove all marked (or next ARG) files from list of recently used files.
That is, remove them from variable `recentf-list'.

\(This does not refresh any Dired buffer listing the recently visited
files.  You can refresh it manually using `\\[revert-buffer]'."
  (interactive "P")
  (unless (require 'recentf nil t) (error "This command requires library `recentf.el'"))
  (diredp-ensure-mode)
  (dired-map-over-marks-check #'diredp-remove-file-from-recentf arg 'remove\ from\ recentf
                              (diredp-fewer-than-2-files-p arg))
  (diredp-revert-displayed-recentf-buffers))

;;;###autoload
(defun diredp-add-this-to-recentf ()
  "In Dired, add this file to the list of recently used files."
  (interactive)
  (let ((use-file-dialog  nil)) (diredp-do-add-to-recentf 1)))

;;;###autoload
(defun diredp-remove-this-from-recentf ()
  "In Dired, remove this file from the list of recently used files."
  (interactive)
  (let ((use-file-dialog  nil)) (diredp-do-remove-from-recentf 1)))

;;;###autoload
(defun diredp-add-file-to-recentf (&optional file interactivep) ; Not bound by default
  "Add FILE to the front of `recentf-list'.
If FILE is already present, move it to the front of the list.
In Dired, FILE defaults to the file of the current Dired line."
  (interactive "fFile: \np")
  (setq file  (or file  (and (derived-mode-p 'dired-mode)  (dired-get-file-for-visit))))
  (unless file (error "No file"))
  (recentf-push (recentf-expand-file-name file))
  (when interactivep (diredp-revert-displayed-recentf-buffers))
  nil)                                  ; Return nil for success (cannot fail).

;;;###autoload
(defun diredp-remove-file-from-recentf (&optional file interactivep) ; Not bound by default
  "Remove FILE from `recentf-list'.
In Dired, FILE defaults to the file of the current Dired line.

Interactively: After removing, revert any displayed buffers showing
`recentf-list' (or part of it)."
  (interactive "fFile: \np")
  (setq file  (or file  (and (derived-mode-p 'dired-mode)  (dired-get-file-for-visit))))
  (unless file (error "No file"))
  (let ((memb  (recentf-string-member (recentf-expand-file-name file) recentf-list)))
    (and memb  (setq recentf-list  (delq (car memb) recentf-list))))
  (when interactivep (diredp-revert-displayed-recentf-buffers))
  nil)                                  ; Return nil for success (cannot fail).

(defun diredp-revert-displayed-recentf-buffers ()
  "Revert displayed Dired buffers showing `recentf-list' (or part of it)."
  (let (win)
    (dolist (buf  (buffer-list))
      (when (setq win  (get-buffer-window buf 0))
        (select-window win)
        (when (and (derived-mode-p 'dired-mode)
                   (local-variable-if-set-p 'diredp-recent-files-buffer)
                   diredp-recent-files-buffer)
          (revert-buffer))))))

(defun diredp-read-include/exclude (thing things &optional exclude keep-duplicates-p)
  "Read which THINGs to include (or to EXCLUDE, if non-nil) from list THINGS.
The things are read one by one.  `C-g' stops reading.

THING is a string or symbol naming the type of thing to read, e.g.,
`File' or `Directory'.  It is used only in the prompt, which is THING
followed by \" to exclude\" or \" to include\" and a reminder about `C-g'.

A new list is returned - list THINGS is not modified.

Unless optional arg KEEP-DUPLICATES-P is non-nil, remove duplicates,
keeping only the first of a set of `equal' THINGS."
  (let* ((thgs                    (if exclude (copy-sequence things) ()))
         (prompt                  (format "%s to %s (C-g when done): " thing (if exclude 'EXCLUDE 'INCLUDE)))
         (completion-ignore-case  (or (and (boundp 'read-file-name-completion-ignore-case)
                                           (memq thing '(Dir Directory File "Dir" "Directory" "File")) ; Hack
                                           read-file-name-completion-ignore-case)
                                      completion-ignore-case))
         thing)
    (while (condition-case nil
               (setq thing  (completing-read prompt (mapcar #'list things) nil t))
             (quit nil))
      (if exclude (delete thing thgs)
        (push thing thgs)))
    (unless keep-duplicates-p (setq thgs  (diredp-delete-dups thgs)))
    thgs))

;;; $$$$$$$$
;;; (defun diredp-dired-files-interactive-spec (str)
;;;   "`interactive' spec for `diredp-dired-files' commands.
;;; STR is a string appended to the prompt.
;;; With non-negative prefix arg, read switches.
;;; With non-positive prefix arg, read files and dirs to list and then the
;;;  Dired buffer name.  User uses `C-g' when done reading files and dirs.

;;; If you use Icicles, then in Icicle mode the following keys are bound
;;; in the minibuffer during completion (`*' means the key requires
;;; library `Bookmark+'):

;;;   M-|       - Open Dired on the file names matching your input
;;;   C-c +     - Create a new directory
;;;  *C-x a +   - Add tags to the current-candidate file
;;;  *C-x a -   - Remove tags from the current-candidate file
;;;  *C-x m     - Access file bookmarks (not just autofiles)"
;;;   (list
;;;    (unwind-protect
;;;         (let ((icicle-sort-comparer  (or (and (boundp 'icicle-file-sort) ;; If not reading files
;;;                                               icicle-file-sort)          ;; then dirs first.
;;;                                          (and (> (prefix-numeric-value current-prefix-arg) 0)
;;;                                               'icicle-dirs-first-p)
;;;                                          icicle-sort-comparer))
;;;               (icicle-all-candidates-list-alt-action-fn ; M-|'
;;;                (lambda (files)
;;;                  (let ((enable-recursive-minibuffers  t))
;;;                    (dired-other-window (cons (read-string "Dired buffer name: ") files))))))
;;;           (when (fboundp 'icicle-bind-file-candidate-keys) (icicle-bind-file-candidate-keys))
;;;           (if (> (prefix-numeric-value current-prefix-arg) 0)
;;;               ;; If a dialog box is about to be used, call `read-directory-name' so the dialog
;;;               ;; code knows we want directories.  Some dialog boxes can only select directories
;;;               ;; or files when popped up, not both.
;;;               (if (and (fboundp 'read-directory-name)  (next-read-file-uses-dialog-p))
;;;                   (read-directory-name (format "Dired %s(directory): " str) nil
;;;                                        default-directory nil)
;;;                 (read-file-name (format "Dired %s(directory): " str) nil default-directory nil))
;;;             (let ((insert-default-directory  nil)
;;;                   (files                     ())
;;;                   file)
;;;               (while (condition-case nil ; Use lax completion, to allow wildcards.
;;;                          (setq file  (read-file-name "File or dir (C-g when done): "))
;;;                        (quit nil))
;;;                 (push file files))
;;;               (cons (read-string "Dired buffer name: " nil nil default-directory) files))))
;;;      (when (fboundp 'icicle-unbind-file-candidate-keys)
;;;        (icicle-unbind-file-candidate-keys)))
;;;    (and current-prefix-arg  (natnump (prefix-numeric-value current-prefix-arg))
;;;         (read-string "Dired listing switches: " dired-listing-switches))))

;;;###autoload
(defun diredp-sort-arbitrary-command (sort-function)
  "Sort the current Dired listing of arbitary files.

NOTE:
 This is intended for sorting a list of arbitrary file names, not an
 ordinary Dired listing such as produced by `ls'.

 If the current Dired buffer is *not* already a list of arbitrary file
 names then you are prompted to confirm converting it to such a list.
 If you do so it will no longer use `ls' or `dired-listing-switches'.
 Don't confirm, if you don't want this conversion."
  (interactive
   (if (and (atom dired-directory)
            (not (y-or-n-p "Convert Dired buffer to a list of arbitrary file names? ")))
       (error "OK, canceled")
     (let* ((cands  '(("2: Reverse"              . t)
                      ("3: Nondir Name, A-to-Z"  . diredp-nondir-file-name-less-p)
                      ("4: Nondir Name, Z-to-A"  . diredp-nondir-file-name-more-p)
                      ("5: Full Name, A-to-Z"    . diredp-full-file-name-less-p)
                      ("6: Full Name, Z-to-A"    . diredp-full-file-name-more-p)))
            (order  (completing-read "Sort order: " cands nil t)))
       (list (cdr (assoc order cands))))))
  (let ((buf    (buffer-name))
        (files  (copy-sequence (dired-get-marked-files nil '(64)))))
    (kill-buffer)
    (dired (cons buf (if sort-function
                         (if (functionp sort-function)
                             (sort files sort-function)
                           (nreverse files))
                       files))
           dired-actual-switches)))

;;;###autoload
(defun diredp-dired-union (dired-name dirbufs &optional switches extra) ; Bound to `C-x D U'
  "Create a Dired buffer that is the union of some existing Dired buffers.
With a non-negative prefix arg, you are prompted for `ls' switches.
With a non-positive prefix arg, you are prompted for file and dir
names to add to the listing - see below.

You are prompted for the name of the Dired union buffer.  Completion
against names of existing Dired buffers is available, but you can
enter any other name to create a new Dired buffer of that name.

If the union buffer name you choose names an existing Dired buffer,
then what happens depends on whether that buffer is an ordinary Dired
directory listing or a list of arbitrary file names.  That is, it
depends on whether `dired-directory' is a directory name or a cons of
a Dired buffer name plus file names.

,* If the buffer is an ordinary Dired listing, then it is converted to
  an explicit list of absolute file names, just as if these had been
  chosen individually.  The existing buffer and window are replaced by
  new ones that show the explicit listing.  (This replacement is
  necessary because the list of files contained in an ordinary Dired
  listing cannot be modified.)

,* If the buffer lists arbitrary file names explicitly, then it is
  updated to include also the files from any Dired buffers and any
  additional files that you specify.

If the union buffer name you choose does not name an existing Dired
buffer, then its `default-directory' is the same as the
`default-directory' before invoking the command.

If you use a non-positive prefix arg, then you can next choose
additional file and directory names to add to the listing.  Use `C-g'
when done choosing them.

Any directory names you choose this way are included as single entries
in the listing - the directory contents are not included (these
directories are not unioned).  To instead include the contents of a
directory chosen this way, use a glob pattern: `/*' after the
directory name.

You are then prompted for the Dired buffers to union.  Use `C-g' when
done choosing them.  These Dired listings to union are included in the
order that you chose them, and each entry is listed only once in the
new Dired buffer.

The new Dired listing respects the markings, subdirectory insertions,
and hidden subdirectories of the selected Dired listings.  However, in
case of conflict between marked or unmarked status for the same entry,
the entry is marked.  Similarly, in case of conflict over an included
subdirectory between it being hidden or shown, it is hidden, but its
contained files are also listed.

See also command `diredp-add-to-dired-buffer'.

From Lisp:
 DIRED-NAME is the name of the resulting Dired union buffer.
 DIRBUFS is a list of the names of Dired buffers to union.
 SWITCHES is a string of `ls' switches.
 EXTRA is a list of files & directories to be included in the listing."
  (interactive (diredp-dired-union-interactive-spec "UNION "
                                                    nil
                                                    (and current-prefix-arg
                                                         (<= (prefix-numeric-value current-prefix-arg) 0))))
  (diredp-dired-union-1 dired-name dirbufs switches extra))

;;;###autoload
(defun diredp-dired-union-other-window (dired-name dirbufs &optional switches extra) ; Bound to `C-x 4 D U'
  "Same as `diredp-dired-union', except use other window."
  (interactive (diredp-dired-union-interactive-spec "UNION "
                                                    nil
                                                    (and current-prefix-arg
                                                         (<= (prefix-numeric-value current-prefix-arg) 0))))
  (diredp-dired-union-1 dired-name dirbufs switches extra 'OTHERWIN))

;;;###autoload
(defun diredp-add-to-dired-buffer (dired-name to-add &optional switches) ; Bound to `C-x D A'
  "Add individual file and directory names to a Dired buffer.
You are prompted for the buffer name.
With a prefix arg, you are also prompted for the `ls' switches.

The buffer must either not exist yet or must list arbitrary file and
directory names.  That is, it cannot be an ordinary Dired directory
listing - those cannot be modified.

Any directory names you choose this way are included as single entries
in the listing - the directory contents are not included (these
directories are not unioned).  To instead include the contents of a
directory chosen this way, use a glob pattern: `/*' after the
directory name.

See also command `diredp-dired-union'.

From Lisp:
 DIRED-NAME is the name of the Dired buffer to modify.
 TO-ADD is the list of files and dirs to add to it.
 SWITCHES is the string of `ls' switches."
  ;; Bind `current-prefix-arg' to force reading file/dir names.
  ;; Read `ls' switches too, if user used prefix arg.
  (interactive
   (let* ((current-prefix-arg  (if current-prefix-arg 0 -1))
          (all                 (diredp-dired-union-interactive-spec "add files/dirs "
                                                                    'NO-DIRED-BUFS
                                                                    'READ-EXTRA-FILES-P)))
     (list (nth 0 all) (nth 3 all) (nth 2 all))))
  (diredp-dired-union-1 dired-name () switches to-add))

;;;###autoload
(defun diredp-add-to-dired-buffer-other-window (dired-name to-add &optional switches) ; Bound to `C-x 4 D A'
  "Same as `diredp-add-to-dired-buffer', except use other window."
  ;; Bind `current-prefix-arg' to force reading file/dir names.
  ;; Read `ls' switches too, if user used prefix arg.
  (interactive
   (let* ((current-prefix-arg  (if current-prefix-arg 0 -1))
          (all                 (diredp-dired-union-interactive-spec "add files/dirs "
                                                                    'NO-DIRED-BUFS
                                                                    'READ-EXTRA-FILES-P)))
     (list (nth 0 all) (nth 3 all) (nth 2 all))))
  (diredp-dired-union-1 dired-name () switches to-add 'OTHERWIN))

;;;###autoload
(defun diredp-add-to-this-dired-buffer (dired-name to-add &optional switches) ; Not bound by default
  "Same as `diredp-add-to-dired-buffer' for this Dired buffer."
  ;; Bind `current-prefix-arg' to force reading file/dir names.
  ;; Read `ls' switches too, if user used prefix arg.
  (interactive
   (progn (unless (derived-mode-p 'dired-mode) (error "Not in a Dired buffer"))
          (let* ((current-prefix-arg  (if current-prefix-arg 0 -1))
                 (all                 (diredp-dired-union-interactive-spec "add files/dirs here "
                                                                           'NO-DIRED-BUFS
                                                                           'READ-EXTRA-FILES-P
                                                                           (buffer-name))))
            (list (nth 0 all) (nth 3 all) (nth 2 all)))))
  (diredp-dired-union-1 dired-name () switches to-add))

(defun diredp-dired-union-1 (dired-name dirbufs switches extra &optional otherwin)
  "Helper for `diredp-dired-union' and `diredp-add-to-dired-buffer'.
Non-nil optional OTHERWIN means use other window for the Dired buffer.
See `diredp-dired-union' for the other argument descriptions."
  (let ((dbuf         (get-buffer dired-name))
        (files        extra)
        (marked       ())
        (subdirs      ())
        (hidden-dirs  ())
        hid-here files-here)
    (dolist (buf  (reverse dirbufs))
      (with-current-buffer buf
        (unwind-protect
            (progn (setq hid-here    (save-excursion (dired-remember-hidden))
                         files-here  (if (consp dired-directory)
                                         (reverse (cdr dired-directory)) ; Reverse bc will push.
                                       ()))
                   (unless files-here
                     (save-excursion ; This bit is more or less from `dired-toggle-marks'.
                       (goto-char (point-min))
                       (while (not (eobp))
                         (or (diredp-looking-at-p dired-re-dot)
                             (push (dired-get-filename nil 'NO-ERROR) files-here))
                         (forward-line 1)))
                     (setq files-here  (delq nil files-here)))
                   (dolist (hid-here  hid-here) (push hid-here hidden-dirs))
                   (dolist (sub  (cdr (reverse dired-subdir-alist)))
                     (push (list (car sub)) subdirs))
                   (dolist (mkd  (dired-remember-marks (point-min) (point-max))) ; This unhides.
                     (push (car mkd) marked))
                   (dolist (file  files-here)
                     (when (or (not (file-name-absolute-p file))  (not (member file files)))
                       (push file files))))
          (save-excursion             ; Hide subdirs that were hidden.
            (dolist (dir  hid-here)  (when (dired-goto-subdir dir) (dired-hide-subdir 1)))))))
    ;; For an existing Dired buffer having this name whose `dired-directory' is a cons:
    ;; 1. Include the files and dirs already listed there.
    ;; 2. Kill the current buffer and delete its window.  A new buffer of the same name is created and shown.
    (when dbuf
      (with-current-buffer dbuf
        (when (consp dired-directory) (setq files  (diredp-set-union (cdr dired-directory) files)))
        (let ((win  (get-buffer-window dbuf 0))) (when win (delete-window win)))
        (kill-buffer dbuf)))
    (setq dbuf  (dired-other-window (cons dired-name files) switches))
    (with-current-buffer dbuf
      (let ((inhibit-read-only  t))
        (dired-insert-old-subdirs subdirs)
        (dired-mark-remembered ; Don't really need `expand-file-name' - already abs.
         (mapcar (lambda (mf) (cons (expand-file-name mf dired-directory) 42)) marked))
        (save-excursion
          (dolist (hdir  hidden-dirs)  (when (dired-goto-subdir hdir) (dired-hide-subdir 1))))
        (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t))))))

(defun diredp-dired-union-interactive-spec (string &optional no-dired-bufs read-extra-files-p dired-buffer)
  "Read arguments for `diredp-dired-union' and `diredp-add-to-dired-buffer'.
STRING is appended to the prompt for the listing buffer name.
Non-nil NO-DIRED-BUFS means do not read Dired buffers to union.
Non-nil READ-EXTRA-FILES-P is passed to `dired-read-dir-and-switches',
 and means read extra files to add to the listing.
Non-nil DIRED-BUFFER is passed to `dired-read-dir-and-switches'.
  It is the name of the Dired union buffer."
  (let* ((current-prefix-arg  -1)
         (dir+switches        (dired-read-dir-and-switches string read-extra-files-p dired-buffer))
         (dirname             (car  dir+switches))
         (switches            (cadr dir+switches))
         (dirbufs             ())
         (bufs                ())
         (extra-files         ())
         buf)
    (when (consp dirname) (setq extra-files  (cdr dirname)
                                dirname      (car dirname)))
    (unless no-dired-bufs
      ;; Remove any killed buffers from `dired-buffers'.  Then use all but the target buffer as candidates.
      (dolist (db  dired-buffers)
        (if (buffer-live-p (cdr db))
            (unless (equal dirname (buffer-name (cdr db)))
              (push (cons (buffer-name (cdr db)) (car db)) dirbufs))
          (setq dired-buffers  (delq db dired-buffers))))
      (while (and dirbufs  (condition-case nil
                               (setq buf  (completing-read "Existing Dired buffer to include (C-g when done): "
                                                           dirbufs nil t nil 'buffer-name-history
                                                           (and dirbufs  (car (assoc (buffer-name) dirbufs)))))
                             (quit nil)))
        (push buf bufs)
        (setq dirbufs  (delete (cons buf (with-current-buffer buf (expand-file-name default-directory)))
                               dirbufs)))
      (setq bufs  (nreverse bufs)))
    (list dirname bufs switches extra-files)))

(when (> emacs-major-version 23)        ; `compilation--loc->file-struct'

  (defalias 'diredp-grepped-files-other-window 'diredp-compilation-files-other-window)
  (defun diredp-compilation-files-other-window (&optional switches)
    "Open Dired on the files indicated by compilation (e.g., `grep') hits.
Applies to any `compilation-mode'-derived buffer, such as `*grep*'.
You are prompted for the name of the new Dired buffer.
With a prefix arg you are first prompted for the `ls' switches.

\(However, Emacs bug #20739 means that the switches are ignored.)"
    (interactive (list (and current-prefix-arg  (read-string "Dired listing switches: " dired-listing-switches))))
    (unless (compilation-buffer-p (current-buffer)) (error "Not in a buffer derived from `compilation-mode'"))
    (let ((files  ())
          bufname)
      (save-excursion (goto-char (point-min))
                      (while (condition-case nil (compilation-next-file 1) (error nil))
                        (setq compilation-current-error  (point))
                        (push (diredp-file-for-compilation-hit-at-point) files)))
      (setq files  (nreverse files))
      (dired-other-window
       (cons (setq bufname  (read-string "Dired buffer name: "
                                         nil nil (generate-new-buffer-name default-directory)))
             files)
       switches)
      (with-current-buffer bufname
        (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t)))))

  (defun diredp-file-for-compilation-hit-at-point ()
    "Return the name of the file for the compilation hit at point.
The name is expanded in the directory for the last directory change."
    (let* ((msg         (compilation-next-error 0))
           (loc         (compilation--message->loc msg))
           (filestruct  (compilation--loc->file-struct loc))
           (file        (caar filestruct))
           (dir         (cadr (car filestruct))))
      (when dir (setq file  (expand-file-name file dir)))
      file))
  )

;;;###autoload
(defun diredp-fileset (flset-name)      ; Bound to `C-x D S'
  "Open Dired on the files in fileset FLSET-NAME."
  (interactive
   (progn (unless (require 'filesets nil t) (error "Feature `filesets' not provided"))
          (unless filesets-data (error "`filesets-data' is empty"))
          (list (completing-read "Open Dired on fileset: " filesets-data))))
  (diredp-fileset-1 flset-name))

;;;###autoload
(defun diredp-fileset-other-window (flset-name) ; Bound to `C-x 4 D S'
  "Open Dired in another window on the files in fileset FLSET-NAME."
  (interactive
   (progn (unless (require 'filesets nil t) (error "Feature `filesets' not provided"))
          (unless filesets-data (error "`filesets-data' is empty"))
          (list (completing-read "Open Dired on fileset, in other window: " filesets-data))))
  (diredp-fileset-1 flset-name 'OTHER-WINDOW))

(defun diredp-fileset-1 (flset-name &optional other-window-p)
  "Helper for `diredp-fileset(-other-window)'."
  (let ((flset   (filesets-get-fileset-from-name flset-name))
        (files   ())
        (mode    nil)
        (dirfun  (if other-window-p #'dired-other-window #'dired))
        bufname)
    (unless (or (setq mode  (filesets-entry-mode flset)) ; ("my-fs" (:files "a" "b"))
                (setq flset  (cons "dummy" flset) ; (:files "a" "b")
                      mode   (filesets-entry-mode flset)))
      (error "Bad fileset: %S" flset-name))
    (message "Gathering file names...")
    (dolist (file  (filesets-get-filelist flset mode)) (push file files))
    (funcall dirfun (cons (setq bufname  (generate-new-buffer-name flset-name))
                          (nreverse (mapcar (lambda (file)
                                              (if (file-name-absolute-p file)
                                                  (expand-file-name file)
                                                file))
                                            files))))
    (with-current-buffer bufname
      (when (boundp 'dired-sort-inhibit) (set (make-local-variable 'dired-sort-inhibit) t)))))

;;;###autoload
(defun diredp-dired-this-subdir (&optional tear-off-p msgp)
  "Open Dired for the subdir at or above point.
If point is not on a subdir line, but is in an inserted subdir
listing, then use that subdir.

With a prefix arg:
 If the subdir is inserted and point is in the inserted listing then
 remove that listing and move to the ordinary subdir line.  In other
 words, when in an inserted listing, a prefix arg tears off the
 inserted subdir to its own Dired buffer."
  (interactive "P\np")
  (diredp-ensure-mode)
  (let* ((this-dir       default-directory)
         (this-subdir    (diredp-this-subdir))
         (on-dir-line-p  (atom this-subdir)))
    (unless on-dir-line-p               ; Subdir header line or non-directory file.
      (setq this-subdir  (car this-subdir)))
    (unless (string= this-subdir this-dir)
      (when tear-off-p
        (unless on-dir-line-p
          (dired-kill-subdir)           ; Tear it off.
          (dired-goto-file this-subdir))) ; Move to normal subdir line.
      (dired-other-window this-subdir))))

;;;###autoload
(defun diredp-dired-inserted-subdirs (&optional no-show-p msgp) ; Bound to `C-M-i'
  "Open Dired for each of the subdirs inserted in this Dired buffer.
A separate Dired buffer is used for each of them.
With a prefix arg, create the Dired buffers but do not display them.
Markings and current Dired switches are preserved."
  (interactive "P\np")
  (diredp-ensure-mode)
  (let ((this-dir    default-directory)
        (this-buff   (current-buffer))
        (this-frame  (selected-frame))
        marked)
    (unwind-protect
         (save-selected-window
           (dolist (entry  dired-subdir-alist)
             (unless (string= (car entry) this-dir)
               (setq marked  (with-current-buffer this-buff
                               (dired-remember-marks (dired-get-subdir-min entry) (dired-get-subdir-max entry))))
               (if (not no-show-p)
                   (dired-other-window (car entry) dired-actual-switches)
                 (dired-noselect (car entry) dired-actual-switches)
                 (when msgp (message "Dired buffers created but not shown")))
               (set-buffer this-buff)
               (let ((inhibit-read-only  t))
                 (dired-mark-remembered marked))
               (set-buffer-modified-p nil))))
      (select-frame-set-input-focus this-frame))))


;;; Actions on marked files and subdirs, recursively.

(defun diredp-get-subdirs (&optional ignore-marks-p predicate details)
  "Return subdirs from this Dired buffer and from marked subdirs, recursively.
If optional arg IGNORE-MARKS-P is non-nil then include all
subdirectories.  Otherwise, include only those that are marked.

Non-nil optional arg PREDICATE means include only subdirectory names
for which the PREDICATE returns non-nil.  PREDICATE must accept a file
name as its only required argument.

Optional arg DETAILS is passed to `diredp-get-files'."
  (diredp-get-files ignore-marks-p (if predicate
                                       `(lambda (name) (and (file-directory-p name)  (funcall ,predicate name)))
                                     #'file-directory-p)
                    'INCLUDE-DIRS-P 'DONT-ASKP 'ONLY-MARKED-P details))

(defun diredp-get-files (&optional ignore-marks-p predicate include-dirs-p dont-askp only-marked-p details)
  "Return file names from this Dired buffer and subdirectories, recursively.
The names are those that are marked in the current Dired buffer, or
all files in the directory if none are marked.  Marked subdirectories
are handled recursively in the same way.

If there is some included subdirectory that has a Dired buffer with
marked files, then (unless DONT-ASKP is non-nil) this asks you whether
to use the marked files in Dired buffers, as opposed to using all of
the files in included directories.  To this y-or-n question you can
hit `l' to see the list of files that will be included (using
`diredp-list-files').  In that `l' listing you can mouseover to see
image-file previews or use `RET' or `mouse-2' to visit files.

\(Directories in `icicle-ignored-directories' are skipped, if you use
Icicles.  Otherwise, directories in `vc-directory-exclusion-list' are
skipped.)

Non-nil IGNORE-MARKS-P means ignore all Dired markings: just get all
of the files in the current directory (and all of the subdirectories,
if INCLUDE-DIRS-P is non-nil).

Non-nil PREDICATE means include only file names for which the
PREDICATE returns non-nil.  PREDICATE must accept a file name as its
only required argument.

Non-nil INCLUDE-DIRS-P means include marked subdirectory names (but
also handle those subdirs recursively, picking up their marked files
and subdirs).

Non-nil DONT-ASKP means do not ask the user whether to use marked
instead of all.  Act as if the user was asked and replied `y'.

Non-nil optional arg ONLY-MARKED-P means collect only marked files,
instead of collecting all files if none are marked.  This argument is
ignored if IGNORE-MARKS-P is non-nil.

Optional arg DETAILS is passed to `diredp-y-or-n-files-p'."
  (let ((askp  (list nil)))             ; The cons's car will be set to `t' if need to ask user.
    (if ignore-marks-p
        (diredp-files-within (directory-files default-directory 'FULL diredp-re-no-dot)
                             () nil include-dirs-p predicate)
      ;; Pass FILES and ASKP to `diredp-get-files-for-dir', so we don't have to use them as
      ;; free vars there.  But that means that they each need to be a cons cell that we can
      ;; modify, so we can get back the updated info.
      (let ((files  (list 'DUMMY)))     ; The files picked up will be added to this list.
        (diredp-get-files-for-dir default-directory files askp include-dirs-p only-marked-p)
        (setq files  (cdr files))       ; Remove `DUMMY' from the modifed list.
        (if (or dont-askp
                (not (car askp))
                (diredp-y-or-n-files-p "Use marked (instead of all) in subdir Dired buffers? "
                                       files predicate details))
            (if predicate (diredp-remove-if-not predicate files) files)
          (setq files  ())
          (dolist (file  (diredp-marked-here))
            (if (not (file-directory-p file))
                (when (or (not predicate)  (funcall predicate file))
                  (add-to-list 'files file))
              (when include-dirs-p (setq files  (nconc files (list file))))
              (setq files  (nconc files (diredp-files-within (directory-files file 'FULL diredp-re-no-dot)
                                                             () nil include-dirs-p predicate)))))
          (nreverse files))))))

(defun diredp-get-files-for-dir (directory accum askp &optional include-dirs-p only-marked-p)
  "Return marked file names for DIRECTORY and subdirectories, recursively.
Pick up names of all marked files in DIRECTORY if it has a Dired
buffer, or all files in DIRECTORY if not.  Handle subdirs recursively
\(only marked subdirs, if Dired).

ACCUM is an accumulator list: the files picked up in this call are
nconc'd to it.

ASKP is a one-element list, the element indicating whether to ask the
user about respecting Dired markings.  It is set here to `t' if there
is a Dired buffer for DIRECTORY.

Non-nil optional arg INCLUDE-DIRS-P means include marked subdirectory
names (but also handle those subdirs recursively).

Non-nil optional arg ONLY-MARKED-P means collect only marked files,
instead of collecting all files if none are marked.

If there is more than one Dired buffer for DIRECTORY then raise an
error."
  (let ((dbufs  (dired-buffers-for-dir (expand-file-name directory))))
    (dolist (file  (if (not dbufs)
                       (and (not only-marked-p)  (directory-files directory 'FULL diredp-re-no-dot))
                     (when (cadr dbufs) (error "More than one Dired buffer for `%s'" directory))
                     (unless (equal directory default-directory) (setcar askp  t))
                     (with-current-buffer (car dbufs) (diredp-marked-here only-marked-p 'NO-DOT-DOT))))
      (if (not (file-directory-p file))
          (setcdr (last accum) (list file))
        (when include-dirs-p (setcdr (last accum) (list file)))
        (diredp-get-files-for-dir file accum askp include-dirs-p only-marked-p)))))

(defun diredp-marked-here (&optional only-marked-p no-dot-dot-p)
  "Marked files and subdirs in this Dired buffer, or all if none are marked.
Non-nil optional arg ONLY-MARKED-P means return nil if none are
marked.
Non-nil optional arg NO-DOT-DOT-P means do not include marked `..'."
  ;; If no file is marked, exclude `(FILENAME)': the unmarked file at cursor.
  ;; If there are no marked files as a result, return all files and subdirs in the dir.
  (let* ((dired-marker-char  ?*)
         (ff                 (condition-case nil ; Ignore error if on `.' or `..' and no file is marked.
                                 (dired-get-marked-files
                                  nil nil (and no-dot-dot-p
                                               (lambda (mf) (not (diredp-string-match-p "/\\.\\.$" mf))))
                                  'DISTINGUISH-ONE-MARKED)
                               (error nil))))
    (cond ((eq t (car ff))  (cdr ff))   ; Single marked
          ((cadr ff)        ff)         ; Multiple marked
          (t                (and (not only-marked-p) ; None marked
                                 (directory-files default-directory 'FULL diredp-re-no-dot 'NOSORT))))))

(defun diredp-y-or-n-files-p (prompt files &optional predicate details)
  "PROMPT user with a \"y or n\" question about a list of FILES.
Return t if answer is \"y\".  Otherwise, return nil.

Like `y-or-n-p', but you can also hit `l' to display the list of files
that the confirmation is for, in buffer `*Files'.  In that `'l'
listing you can mouseover to see image-file previews or use `RET' or
`mouse-2' to visit files.

When finished, buffer `*Files*' is killed if it was never shown, or is
hidden and buried otherwise.  Thus, if it was shown then it is still
available to revisit afterward (even if you quit using `C-g').

PREDICATE is passed to `diredp-list-files', to list only file names
for which it returns non-nil.

DETAILS is passed to `diredp-list-files', to show details about FILES."
  (let ((answer     'recenter)
        (orig-echo  (current-message)))
    (cond (noninteractive
           (setq prompt  (concat prompt
                                 (and (not (eq ?\   (aref prompt (1- (length prompt)))))  " ")
                                 "(y or n; l to show file list) "))
           (let ((temp-prompt  prompt))
             (while (not (memq answer '(act skip)))
               (let ((str  (read-string temp-prompt)))
                 (cond ((member str '("y" "Y")) (setq answer  'act))
                       ((member str '("n" "N")) (setq answer  'skip))
                       (t (setq temp-prompt  (concat "Please answer y or n.  " prompt))))))))
          ((if (not (fboundp 'display-popup-menus-p))
               (and window-system  (listp last-nonmenu-event)  use-dialog-box)
             (and (display-popup-menus-p)  (listp last-nonmenu-event)  use-dialog-box))
           (setq answer  (x-popup-dialog t `(,prompt ("Yes" . act) ("No" . skip)))))
          (t
           (let ((list-buf        (generate-new-buffer-name "*Files*"))
                 (list-was-shown  nil))
             (unwind-protect
                 (progn
                   (define-key query-replace-map "l" 'show)
                   (setq prompt  (concat prompt
                                         (and (eq ?\   (aref prompt (1- (length prompt))))
                                              "" " ")
                                         "(y or n; l to show file list) "))
                   (while (let* ((reprompt-actions  '(recenter scroll-up scroll-down
                                                               scroll-other-window scroll-other-window-down))
                                 (key               (let ((cursor-in-echo-area  t))
                                                      (when minibuffer-auto-raise
                                                        (raise-frame (window-frame (minibuffer-window))))
                                                      (if (fboundp 'read-key)
                                                          (read-key (propertize
                                                                     (if (memq answer reprompt-actions)
                                                                         prompt
                                                                       (concat "Please answer y or n.  " prompt))
                                                                     'face 'minibuffer-prompt))
                                                        (read-char-exclusive
                                                         (if (memq answer reprompt-actions)
                                                             prompt
                                                           (concat "Please answer y or n.  " prompt)))))))
                            (setq answer  (lookup-key query-replace-map (vector key) t))
                            (case answer
                              ((skip  act)              nil)
                              (recenter                 (recenter) t)
                              (show                     (diredp-list-files files nil list-buf predicate details)
                                                        (setq list-was-shown  t)) ; Record showing it.
                              (help                     (message "Use `l' to show file list") (sit-for 1))
                              (scroll-up                (condition-case nil (scroll-up-command) (error nil)) t)
                              (scroll-down              (condition-case nil (scroll-down-command) (error nil)) t)
                              (scroll-other-window      (condition-case nil (scroll-other-window) (error nil)) t)
                              (scroll-other-window-down (condition-case nil (scroll-other-window-down nil)
                                                          (error nil)) t)
                              ((exit-prefix  quit)      (signal 'quit nil) t)
                              (t (or (not (eq key ?\e))  (progn (signal 'quit nil) t)))))
                     (ding)
                     (discard-input)))
               (when (get-buffer list-buf)
                 (save-window-excursion (pop-to-buffer list-buf)
                                        (condition-case nil ; Ignore error if user already deleted.
                                            (if (one-window-p) (delete-frame) (delete-window))
                                          (error nil))
                                        (if list-was-shown (bury-buffer list-buf) (kill-buffer list-buf))))
               (define-key query-replace-map "l" nil)))))
    (let ((ret  (eq answer 'act)))
      (unless noninteractive
        (message "%s%c" prompt (if ret ?y ?n)) (sit-for 1)
        (let ((message-log-max  nil))
          (if orig-echo  (message "%s" orig-echo) (message ""))))
      ret)))

(defvar diredp-list-files-map
  (let ((map  (make-sparse-keymap)))
    (define-key map "q"       'quit-window)
    (define-key map "\r"      'diredp-find-line-file-other-window)
    (define-key map [mouse-2] 'diredp-mouse-find-line-file-other-window)
    map)
  "Keymap for `diredp-list-files' output.")
(fset 'diredp-list-files-map diredp-list-files-map)

;;;###autoload
(defun diredp-find-line-file-other-window ()
  "Visit file named by current line, in another window.
The full text of the line is used as the file name."
  (interactive)
  (let ((file  (buffer-substring-no-properties (line-beginning-position) (line-end-position))))
    (when file (find-file-other-window file))))

;;;###autoload
(defun diredp-mouse-find-line-file-other-window (e)
  "Visit file named by clicked line, in another window.
The full text of the line is used as the file name."
  (interactive "e")
  (save-excursion (mouse-set-point e) (diredp-find-line-file-other-window)))

;;;###autoload
(defun diredp-list-marked (&optional arg predicate interactivep details) ; Bound to `C-M-l'
  "List the marked files in this Dired buffer.
A prefix arg specifies files to use instead of the marked files:

 ,* Numeric prefix arg N: The next N files (previous -N, if < 0).
 ,* C-u C-u: All files, but no directories.
 ,* C-u C-u C-u: All files and directories, except `.' and `..'
 ,* C-u C-u C-u C-u: All files and directories, including `.' and `..'
 ,* Any other prefix arg: The current line's file only.

You can use `RET' or `mouse-2' to visit any of the files.
If `tooltip-mode' is on then moving the mouse over image-file names
shows image previews.

When called from Lisp:
 Non-nil optional arg PREDICATE is a file-name predicate.  List only
  the files for which it returns non-nil.
 Non-nil optional arg DETAILS is passed to `diredp-list-files'."
  (interactive (progn (diredp-ensure-mode) (list current-prefix-arg nil t diredp-list-file-attributes)))
  (let ((files  (dired-get-marked-files nil arg predicate nil interactivep)))
    (diredp-list-files files nil nil nil details)))

(defun diredp-list-files (files &optional dir bufname predicate details)
  "Display FILES, a list of file names.  Wildcard patterns are expanded.
The files are shown in a new buffer, `*Files*' by default.

Optional arg DIR serves as the default directory for expanding file
 names that are not absolute.  It defaults to `default-directory'.

Optional arg BUFNAME is the name of the buffer for the display.
 It defaults to `*Files*' (or `*Files*<N>' if `*Files*' exists).

Optional arg PREDICATE is a predicate used to filter FILES: only files
 satisfying PREDICATE are listed.

Non-nil arg DETAILS means show details about each file, in addition to
the file name.  It is passed to `diredp-list-file' (which see).

File names listed are absolute.  Mouseover gives help or an image-file
preview, and you can use `RET' or `mouse-2' to visit files."
  (unless bufname (setq bufname  (generate-new-buffer-name "*Files*")))
  (diredp-with-help-window
   bufname
   (princ "Files\n-----\n\n")
   (let ((all-files-no-wildcards  ())
         file-alist file-dir)
     (dolist (file  files)
       (unless (or (string= file "")    ; Ignore empty file names.
                   (and predicate  (not (funcall predicate file))))
         (if (not (diredp-string-match-p "[[?*]" file))
             (add-to-list 'all-files-no-wildcards (diredp-list-file file details))
           (setq file-dir    (or (file-name-directory file)  default-directory)
                 file-alist  (directory-files-and-attributes file-dir 'FULL "[[?*]" 'NOSORT))
           (dolist (ff  file-alist)
             (add-to-list 'all-files-no-wildcards (diredp-list-file file details))))))
     (save-excursion (dolist (fff  (nreverse all-files-no-wildcards))
                       (princ fff) (terpri)))))
  (with-current-buffer bufname
    (let ((buffer-read-only  nil))
      (save-excursion
        (goto-char (point-min))
        (forward-line 3)
        (while (not (eobp))
          (add-text-properties (line-beginning-position) (line-end-position)
                               '(mouse-face highlight help-echo diredp-mouseover-help dired-filename t
                                            ;; `keymap' does not work for Emacs 20.  Could use `local-map'
                                            ;; but that still leaves `RET' bound to `help-follow'.
                                            keymap diredp-list-files-map))
          (forward-line 1))))
    (set-buffer-modified-p nil)
    (setq buffer-read-only  t)
    (buffer-enable-undo)))

(defun diredp-list-file (file &optional details)
  "Return FILE name, expanded.
Non-nil optional arg DETAILS means append details about FILE to the
returned string.

If DETAILS is a list of file attribute numbers then include only the
values of those attributes.  Otherwise, include all attribute values."
  (let ((file-dir  (and details  (or (file-name-directory file)  default-directory)))
        attrs)
    (setq file  (expand-file-name file file-dir))
    (when (and details  (atom details)) (setq details  '(0 1 2 3 4 5 6 7 8 9 10 11)))
    (concat
     file
     (and details
          (setq attrs  (file-attributes file))
          (concat
           "\n"
           (and (memq 0 details)
                (format " File Type:                  %s\n"
                        (cond ((eq t (nth 0 attrs))  "Directory")
                              ((stringp (nth 0 attrs))  (format "Symbolic link to `%s'" (nth 0 attrs)))
                              (t  "Normal file"))))
           (and (memq 8 details)
                (format " Permissions:                %s\n" (nth 8 attrs)))
           (and (memq 7 details)  (not (eq t (nth 0 attrs)))
                (format " Size in bytes:              %g\n" (nth 7 attrs)))
           (and (memq 4 details)
                (format-time-string " Time of last access:        %a %b %e %T %Y (%Z)\n" (nth 4 attrs)))
           (and (memq 5 details)
                (format-time-string " Time of last modification:  %a %b %e %T %Y (%Z)\n" (nth 5 attrs)))
           (and (memq 6 details)
                (format-time-string " Time of last status change: %a %b %e %T %Y (%Z)\n" (nth 6 attrs)))
           (and (memq 1 details)
                (format " Number of links:            %d\n" (nth 1 attrs)))
           (and (memq 2 details)
                (format " User ID (UID):              %s\n" (nth 2 attrs)))
           (and (memq 3 details)
                (format " Group ID (GID):             %s\n" (nth 3 attrs)))
           (and (memq 10 details)
                (format " Inode:                      %S\n" (nth 10 attrs)))
           (and (memq 11 details)
                (format " Device number:              %s\n" (nth 11 attrs))))))))

(defvar diredp-files-within-dirs-done ()
  "Directories already processed by `diredp-files-within'.")


;; Not used in the `Dired+' code yet.
(defun diredp-directories-within (&optional directory no-symlinks-p predicate)
  "List of accessible directories within DIRECTORY.
Directories in `icicle-ignored-directories' are skipped, if you use
Icicles.  Otherwise, directories in `vc-directory-exclusion-list' are
skipped.

Optional arg DIRECTORY defaults to the value of `default-directory'.
Non-nil optional arg NO-SYMLINKS-P means do not follow symbolic links.
Non-nil optional arg PREDICATE must be a function that accepts a
 file-name argument.  Only directories that satisfy PREDICATE are
 included in the result."
  (unless directory (setq directory  default-directory))
  (let ((dirs  (diredp-files-within (directory-files directory 'FULL diredp-re-no-dot)
                                    () no-symlinks-p 'INCLUDE-DIRS-P
                                    #'file-directory-p)))
    (if predicate (diredp-remove-if-not predicate dirs) dirs)))

;; Args INCLUDE-DIRS-P and PREDICATE are not used in the `Dired+' code yet
;; (except in `diredp-directories-within', which also is not used yet).
;;
(defun diredp-files-within (file-list accum &optional no-symlinks-p include-dirs-p predicate)
  "List of readable files in FILE-LIST, handling directories recursively.
FILE-LIST is a list of file names or a function that returns such.
If a function then invoke it with no args to get the list of files.

Accessible directories in the list of files are processed recursively
to include their files and the files in their subdirectories.  The
directories themselves are not included, unless optional arg
INCLUDE-DIRS-P is non-nil.  (Directories in
`icicle-ignored-directories' are skipped, if you use Icicles.
Otherwise, directories in `vc-directory-exclusion-list' are skipped.)

But if there is a Dired buffer for such a directory, and if FILE-LIST
is a function, then it is invoked in that Dired buffer to return the
list of files to use.  E.g., if FILE-LIST is `dired-get-marked-files'
then only the marked files and subdirectories are included.  If you
have more than one Dired buffer for a directory that is processed
here, then only the first one in `dired-buffers' is used.

The list of files is accumulated in ACCUM, which is used for recursive
calls.

Non-nil optional arg NO-SYMLINKS-P means do not follow symbolic links.

Non-nil optional arg INCLUDE-DIRS-P means include directory names
along with the names of non-directories.

Non-nil optional arg PREDICATE must be a function that accepts a
file-name argument.  Only files (and possibly directories) that
satisfy PREDICATE are included in the result."
  ;; Bind `diredp-files-within-dirs-done' for use as a free var in `diredp-files-within-1'.
  (let ((diredp-files-within-dirs-done  ()))
    (nreverse (diredp-files-within-1 file-list accum no-symlinks-p include-dirs-p predicate))))

;; `diredp-files-within-dirs-done' is free here, bound in `diredp-files-within'.
(defun diredp-files-within-1 (file-list accum no-symlinks-p include-dirs-p predicate)
  "Helper for `diredp-files-within'."
  (let ((files  (if (functionp file-list) (funcall file-list) file-list))
        (res    accum)
        file)
    (when (and files  predicate) (setq files  (diredp-remove-if-not predicate files)))
    (while files
      (setq file  (car files))
      (unless (and no-symlinks-p  (file-symlink-p file))
        (if (file-directory-p file)
            ;; Skip directory if ignored, already treated, or inaccessible.
            (when (and (not (member (file-name-nondirectory file)
                                    (if (boundp 'icicle-ignored-directories)
                                        icicle-ignored-directories
                                      (and (boundp 'vc-directory-exclusion-list)
                                           vc-directory-exclusion-list))))
                       (not (member (file-truename file) diredp-files-within-dirs-done))
                       (file-accessible-directory-p file))
              (setq res  (diredp-files-within-1 (or (and (functionp file-list)
                                                         (dired-buffers-for-dir
                                                          (expand-file-name file)) ; Removes killed buffers.
                                                         (with-current-buffer
                                                             (cdr (assoc (file-name-as-directory file)
                                                                         dired-buffers))
                                                           (funcall file-list)))
                                                    (directory-files file 'FULL diredp-re-no-dot))
                                                res no-symlinks-p include-dirs-p predicate))
              (when include-dirs-p (push file res))
              (push (file-truename file) diredp-files-within-dirs-done))
          (when (file-readable-p file) (push file res))))
      (pop files))
    res))

(defun diredp-remove-if (pred xs)
  "A copy of list XS with no elements that satisfy predicate PRED."
  (let ((result  ()))
    (dolist (x xs) (unless (funcall pred x) (push x result)))
    (nreverse result)))

(defun diredp-remove-if-not (pred xs)
  "A copy of list XS with only elements that satisfy predicate PRED."
  (let ((result  ()))
    (dolist (x xs) (when (funcall pred x) (push x result)))
    (nreverse result)))

(when (> emacs-major-version 21)        ; Emacs 20 has no PREDICATE arg to `read-file-name'.
  (defun diredp-insert-as-subdir (child ancestor &optional in-dired-now-p)
    "Insert the current Dired dir into a Dired listing of an ancestor dir.
Ancestor means parent, grandparent, etc. at any level.
You are prompted for the ancestor directory.
The ancestor Dired buffer is selected.

Markings and switches in the current Dired buffer are preserved for
the subdir listing in the ancestor Dired buffer.

Note: If you use Icicles, then you can use
`icicle-dired-insert-as-subdir' instead: it is a multi-command.  It
does the same thing, but it lets you insert any number of descendant
directories into a given ancestor-directory Dired buffer.

Non-interactively:
 Insert CHILD dir into Dired listing for ANCESTOR dir.

 Non-nil optional arg IN-DIRED-NOW-P means to use the current buffer
 as the Dired buffer from which to pick up markings and switches.
 Otherwise, pick them up from a Dired buffer for CHILD, if there is
 exactly one such buffer."
    (interactive (progn (diredp-ensure-mode)
                        (list default-directory
                              (completing-read
                               "Insert this dir into ancestor dir: "
                               (mapcar #'list (diredp-ancestor-dirs default-directory)))
                              t)))
    (let ((child-dired-buf  (if in-dired-now-p
                                (current-buffer)
                              (dired-buffers-for-dir (expand-file-name child))))
          (switches         ())
          (marked           ()))
      (when (consp child-dired-buf)
        (setq child-dired-buf  (and (= 1 (length child-dired-buf))  (car child-dired-buf))))
      (when child-dired-buf
        (with-current-buffer child-dired-buf
          (setq switches  dired-actual-switches
                marked    (dired-remember-marks (point-min) (point-max)))))
      (dired-other-window ancestor)
      (dired-insert-subdir child switches)
      (when marked (let ((inhibit-read-only  t)) (dired-mark-remembered marked)))
      (set-buffer-modified-p nil))))

(defun diredp-ancestor-dirs (dir)
  "Return a list of the ancestor directories of directory DIR."
  (mapcar #'file-name-as-directory
          (diredp-maplist (lambda (dd) (mapconcat #'identity (reverse dd) "/"))
                          (cdr (nreverse (split-string dir "/" t))))))

(defun diredp-maplist (function list)
  "Map FUNCTION over LIST and its cdrs.
A simple, recursive version of the classic `maplist'."
  (and list  (cons (funcall function list) (diredp-maplist function (cdr list)))))

(defun diredp-existing-dired-buffer-p (buffer-name)
  "Return non-nil if BUFFER-NAME names a live, existing Dired buffer."
  (let ((dbuf  (get-buffer buffer-name)))
    (and dbuf  (buffer-live-p dbuf)  (rassq dbuf dired-buffers))))

;; From `cl-seq.el', function `union', without keyword treatment.
;; (Same as `icicle-set-union' in `icicles-fn.el'.)
(defun diredp-set-union (list1 list2)
  "Combine LIST1 and LIST2 using a set-union operation.
The result list contains all items that appear in either LIST1 or
LIST2.  Comparison is done using `equal'.  This is a non-destructive
function; it copies the data if necessary."
  (cond ((null list1)         list2)
        ((null list2)         list1)
        ((equal list1 list2)  list1)
        (t
         (unless (>= (length list1) (length list2))
           (setq list1  (prog1 list2 (setq list2  list1)))) ; Swap them.
         (while list2
           (unless (member (car list2) list1)  (setq list1  (cons (car list2) list1)))
           (setq list2  (cdr list2)))
         list1)))

(when (fboundp 'file-equal-p)           ; Emacs 24+
  (defun diredp-move-file (file &optional prompt-anyway)
    "Move FILE to associated directory in `diredp-move-file-dirs'.
If no association, or if you use a prefix arg, prompt for directory."
    (interactive (list (dired-get-filename) current-prefix-arg))
    (unless file (error "No file specified"))
    (let* ((file-sans  (file-name-nondirectory file))
           (dir        (file-name-as-directory
                        (or (and (not prompt-anyway)
                                 (cdr (assoc file-sans diredp-move-file-dirs)))
                            (read-directory-name "Move to: ")))))
      (when (file-equal-p dir (file-name-directory file))
        (error "Cannot move to same directory: %s" dir))
      (dired-rename-file file dir nil)
      (dired-add-file (expand-file-name file-sans dir))
      (message "Moved `%s' to `%s'" file-sans dir))))

(defvar diredp-last-copied-filenames ()
  "String list of file names last copied to the `kill-ring'.
Copying is done by `dired-copy-filename-as-kill' and related commands.")

(defvar diredp-filename-separator (copy-sequence "\000") ; "^@"
  ;; Should contain only chars that are invalid in a file name.
  "String used to separate file names in a `kill-ring' entry.")


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Use `diredp-filename-separator', not a space char, as the separator.
;; 2. Put text copied to kill ring in variable `diredp-last-copied-filenames'.
;;
(defun dired-copy-filename-as-kill (&optional arg)
  "Copy names of marked (or next ARG) files into the kill ring.
The names are separated by the value of variable
`diredp-filename-separator'.

With a zero prefix arg, use the absolute file name of each marked file.
With \\[universal-argument], use the file name relative to the Dired buffer's
`default-directory'.  (This still may contain slashes if in a subdirectory.)

If on a subdir headerline, use absolute subdirname instead;
prefix arg and marked files are ignored in this case.

You can then feed the file name(s) to other commands with \\[yank].

The value of global variable `diredp-last-copied-filenames' is updated
to the string list of file name(s), so you can obtain it even after
the kill ring is modified."
  (interactive "P")
  (let* ((num-arg  (prefix-numeric-value arg))
         (string  (or (dired-get-subdir)
                      (mapconcat #'identity
                                 (cond ((not arg)       (dired-get-marked-files 'no-dir))
                                       ((zerop num-arg) (dired-get-marked-files))
                                       ((consp arg)     (dired-get-marked-files t))
                                       (t               (dired-get-marked-files 'no-dir num-arg)))
                                 diredp-filename-separator))))
    (unless (string= "" string)
      (if (eq last-command 'kill-region) (kill-append string nil) (kill-new string))
      (setq diredp-last-copied-filenames  (car kill-ring-yank-pointer))
      (message "%s" string))))

(defun diredp-copy-abs-filenames-as-kill () ; Not bound.
  "Copy absolute names of marked files in Dired to the kill ring.
Also set variable `diredp-last-copied-filenames' to the string that
lists the file names.

This is the same as using a zero prefix arg with command
`dired-copy-filename-as-kill', that is, \\<dired-mode-map>`M-0 \\[dired-copy-filename-as-kill]'."
  (interactive (diredp-ensure-mode))
  (dired-copy-filename-as-kill 0))

(defun diredp-copy-as-kill-from-clipboard (files)
  "Copy file names from clipboard."
  (when (stringp files)
    (setq files  (if (diredp-string-match-p "\n" files)
                     (split-string files "\n" t "\"")
                   (setq files (split-string files "\"" t "\"")))))
  (let ((files-string  (mapconcat
                        (lambda (file)
                          (unless (file-exists-p file) (message (format "No such file: `%s'" file)))
                          file)
                        files
                        diredp-filename-separator)))
    (kill-new files-string)
    (setq diredp-last-copied-filenames  files-string)))

;;;###autoload
(defalias 'diredp-paste-files 'diredp-yank-files) ; Bound to `C-y'.
;;;###autoload
(defun diredp-yank-files (&optional dir no-confirm-p details)
  "Yank (paste) files to the current directory.
With a non-negative prefix arg you are instead prompted for the target
 directory.
With a non-positive prefix arg you can see details about the files if
 you hit `l' when prompted to confirm pasting.  Otherwise you see only
 the file names.  The details you see are defined by option
 `diredp-list-file-attributes'.

The absolute names of the files to be yanked are taken from the
clipboard or, if that's empty, from names you've copied to the kill
ring using \\<dired-mode-map>\ `M-0 \\[dired-copy-filename-as-kill]' or \
\\[diredp-copy-abs-filenames-as-kill].

Those copy-filename commands also:
 ,* Use the value of option `diredp-filename-separator' to separate the
   copied file names.
 ,* Set variable `diredp-last-copied-filenames' to the same string.
   `diredp-yank-files' uses the value of that variable, not whatever
   is currently at the head of the kill ring.

\(To copy file names to the clipboard on MS Windows, you can use Windows
Explorer: Select the file names, then hold `Shift', right-click, and
choose `Copy as Path' from the menu.)

When called from Lisp:

Optional arg NO-CONFIRM-P means do not ask for confirmation to copy.
Optional arg DETAILS is passed to `diredp-y-or-n-files-p'."
  (interactive (list (and current-prefix-arg  (natnump (prefix-numeric-value current-prefix-arg))
                          (expand-file-name (read-directory-name "Yank files to directory: ")))
                     nil
                     (and current-prefix-arg
                          (<= (prefix-numeric-value current-prefix-arg) 0)
                          diredp-list-file-attributes)))
  (setq dir  (or dir  (and (derived-mode-p 'dired-mode)  (dired-current-directory))))
  (unless (file-directory-p dir) (error "Not a directory: `%s'" dir))
  (let* ((ipf-files  (funcall interprogram-paste-function))
         (files      (or ipf-files  diredp-last-copied-filenames)))
    (unless (stringp files)  (error "No copied file names"))
    (when ipf-files (setq files  (diredp-copy-as-kill-from-clipboard files)))
    (setq files  (diredp-delete-if-not (lambda (file) (file-name-absolute-p file))
                                       (split-string files diredp-filename-separator)))
    (unless files  (error "No copied *absolute* file names (Did you use `M-0 w'?)"))
    (if (and (not no-confirm-p)
             (diredp-y-or-n-files-p "Yank files whose names you copied? " files nil details))
        (dired-create-files #'dired-copy-file "Copy" files
                            (lambda (from) (expand-file-name (file-name-nondirectory from) dir)))
      (message "OK, file-yanking canceled"))))

;;;###autoload
(defun diredp-move-files-named-in-kill-ring (&optional dir no-confirm-p details) ; Bound to `C-w'
  "Move files, whose absolute names you copied, to the current directory.
With a non-negative prefix arg you are instead prompted for the target
 directory.
With a non-positive prefix arg you can see details about the files if
 you hit `l' when prompted to confirm pasting.  Otherwise you see only
 the file names.  The details you see are defined by option
 `diredp-list-file-attributes'.

You should have copied the list of file names as a string to the kill
ring using \\<dired-mode-map>`M-0 \\[dired-copy-filename-as-kill]' or \
\\[diredp-copy-abs-filenames-as-kill].
Those commands also set variable `diredp-last-copied-filenames' to the
same string.  `diredp-move-files-named-in-kill-ring' uses the value of
that variable, not whatever is currently at the head of the kill ring.

When called from Lisp:

Optional arg NO-CONFIRM-P means do not ask for confirmation to move.
Optional arg DETAILS is passed to `diredp-y-or-n-files-p'."
  (interactive (list (and current-prefix-arg  (natnump (prefix-numeric-value current-prefix-arg))
                          (expand-file-name (read-directory-name "Move files to directory: ")))
                     nil
                     (and current-prefix-arg
                          (<= (prefix-numeric-value current-prefix-arg) 0)
                          diredp-list-file-attributes)))
  (setq dir  (or dir  (and (derived-mode-p 'dired-mode)  (dired-current-directory))))
  (unless (file-directory-p dir) (error "Not a directory: `%s'" dir))
  (let ((files  diredp-last-copied-filenames))
    (unless (stringp files)  (error "No copied file names"))
    (setq files  (diredp-delete-if-not (lambda (file) (file-name-absolute-p file)) (split-string files)))
    (unless files  (error "No copied (absolute* file names (Did you use `M-0 w'?)"))
    (if (and (not no-confirm-p)
             (diredp-y-or-n-files-p "MOVE files whose names you copied? " files nil details))
        (dired-create-files #'dired-rename-file "Move" files
                            (lambda (from) (expand-file-name (file-name-nondirectory from) dir)))
      (message "OK, file-moves canceled"))))


;;; Commands operating on marked at all levels below (recursively)

(defun diredp-get-confirmation-recursive (&optional type)
  "Get confirmation from user to act on all TYPE here and below.
If TYPE is nil use \"files\" in the confirmation prompt, else use TYPE.
Raise an error if not confirmed.
Raise an error first if not in Dired mode."
  (diredp-ensure-mode)
  (unless (y-or-n-p (format "Act on ALL %s (or all marked if any) in and UNDER this dir? "
                            (or type 'files)))
    (error "OK, canceled")))

;;;###autoload
(when (> emacs-major-version 21)        ; Emacs 22+ has KILL-ROOT parameter.
  (defun diredp-kill-this-tree ()
    "Remove this subdir listing and lower listings."
    (interactive)
    (dired-kill-tree (dired-current-directory) nil 'KILL-ROOT)))

;;;###autoload
(defun diredp-insert-subdirs (&optional switches interactivep) ; Bound to `M-i'
  "Insert the marked subdirectories.
Like using \\<dired-mode-map>`\\[dired-maybe-insert-subdir]' at each marked directory line."
  (interactive (list (and current-prefix-arg
                          (read-string "Switches for listing: "
                                       (or (and (boundp 'dired-subdir-switches)  dired-subdir-switches)
                                           dired-actual-switches)))
                     t))
  (dolist (subdir  (dired-get-marked-files nil
                                           nil
                                           (lambda (fl) (and (file-directory-p fl) ; Exclude `.' and `..'
                                                             (not (diredp-string-match-p "/[.][.]?\\'" fl))))
                                           nil
                                           interactivep))
    (dired-maybe-insert-subdir subdir switches)))

;;;###autoload
(defun diredp-insert-subdirs-recursive (&optional ignore-marks-p details) ; Bound to `M-+ M-i'
  "Insert the marked subdirs, including those in marked subdirs.
Like `diredp-insert-subdirs', but act recursively on subdirs.
The subdirs inserted are those that are marked in the current Dired
buffer, or ALL subdirs in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way (their marked
subdirs are inserted...).

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive 'subdirs)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (dolist (subdir  (diredp-get-files ignore-marks-p #'file-directory-p 'INCLUDE-SUBDIRS-P nil nil details))
    (dired-maybe-insert-subdir subdir)))

;;;###autoload
(defun diredp-do-shell-command-recursive (command &optional ignore-marks-p details) ; Bound to `M-+ !'
  "Run shell COMMAND on the marked files, including those in marked subdirs.
Like `dired-do-shell-command', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive
   (progn (diredp-get-confirmation-recursive)
          (let* ((prompt  "! on *: ")
                 (cmd     (minibuffer-with-setup-hook
                           (lambda ()
                             (set (make-local-variable 'minibuffer-default-add-function)
                                  'minibuffer-default-add-dired-shell-commands))
                           (let ((dired-no-confirm  t))
                             (if (functionp 'dired-guess-shell-command)
                                 ;; Guess cmd based only on files marked in current (top) dir.
                                 (dired-guess-shell-command prompt (dired-get-marked-files t))
                               (read-shell-command prompt nil nil))))))
            (list cmd current-prefix-arg diredp-list-file-attributes))))
  (dired-do-shell-command command nil (diredp-get-files ignore-marks-p nil nil nil nil details)))

(when (fboundp 'dired-do-async-shell-command) ; Emacs 23+

  (defun diredp-do-async-shell-command-recursive (command &optional ignore-marks-p details) ; Bound to `M-+ &'
    "Run async shell COMMAND on marked files, including in marked subdirs.
Like `dired-do-async-shell-command', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive
     (progn (diredp-get-confirmation-recursive)
            (let* ((prompt  "! on *: ")
                   (cmd     (minibuffer-with-setup-hook
                             (lambda ()
                               (set (make-local-variable 'minibuffer-default-add-function)
                                    'minibuffer-default-add-dired-shell-commands))
                             (let ((dired-no-confirm  t))
                               (if (functionp 'dired-guess-shell-command)
                                   ;; Guess cmd based only on files marked in current (top) dir.
                                   (dired-guess-shell-command prompt (dired-get-marked-files t))
                                 (read-shell-command prompt nil nil))))))
              (list cmd current-prefix-arg diredp-list-file-attributes))))
    (dired-do-async-shell-command command nil (diredp-get-files ignore-marks-p nil nil nil nil details))))

;;;###autoload
(defun diredp-do-symlink-recursive (&optional ignore-marks-p details) ; Bound to `M-+ S'
  "Make symbolic links to marked files, including those in marked subdirs.
Like `dired-do-symlink', but act recursively on subdirs to pick up the
files to link.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-create-files-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-do-create-files-recursive #'make-symbolic-link "Symlink" ignore-marks-p details))

(defun diredp-do-relsymlink-recursive (&optional ignore-marks-p details) ; Bound to `M-+ Y'
  "Relative symlink all marked files, including those in marked subdirs into a dir.
Like `dired-do-relsymlink', but act recursively on subdirs to pick up the
files to link.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

For absolute symlinks, use \\[diredp-do-symlink-recursive].

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-create-files-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-do-create-files-recursive #'dired-make-relative-symlink "RelSymLink" ignore-marks-p details))

;;;###autoload
(defun diredp-do-hardlink-recursive (&optional ignore-marks-p details) ; Bound to `M-+ H'
  "Add hard links for marked files, including those in marked subdirs.
Like `dired-do-hardlink', but act recursively on subdirs to pick up the
files to link.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-create-files-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-do-create-files-recursive #'dired-hardlink "Hardlink" ignore-marks-p details))

;;;###autoload
(defun diredp-do-print-recursive (&optional ignore-marks-p details) ; Bound to `M-+ P'
  "Print the marked files, including those in marked subdirs.
Like `dired-do-print', but act recursively on subdirs to pick up the
files to print.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (let* ((file-list  (diredp-get-files ignore-marks-p nil nil nil nil details))
         (command    (dired-mark-read-string
                      "Print %s with: "
                      (mapconcat #'identity
                                 (cons lpr-command (if (stringp lpr-switches) (list lpr-switches) lpr-switches))
                                 " ")
                      'print nil file-list)))
    (dired-run-shell-command (dired-shell-stuff-it command file-list nil))))

;;;###autoload
(defun diredp-image-dired-display-thumbs-recursive (&optional ignore-marks-p append do-not-pop details)
                                        ; Bound to `M-+ C-t d'
  "Display thumbnails of marked files, including those in marked subdirs.
Like `image-dired-display-thumbs', but act recursively on subdirs.
Optional arguments APPEND and DO-NOT-POP are as for
`image-dired-display-thumbs'.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-image-dired-required-msg)
                      (diredp-get-confirmation-recursive)
                      (list current-prefix-arg nil nil diredp-list-file-attributes)))
  (let ((buf  (image-dired-create-thumbnail-buffer))
        thumb-name files dired-buf)
    (setq files      (diredp-get-files ignore-marks-p nil nil nil nil details)
          dired-buf  (current-buffer))
    (with-current-buffer buf
      (let ((inhibit-read-only  t))
        (if append (goto-char (point-max)) (erase-buffer))
        (mapc (lambda (curr-file)
                (setq thumb-name  (image-dired-thumb-name curr-file))
                (if (and (not (file-exists-p thumb-name))
                         (not (= 0 (image-dired-create-thumb curr-file thumb-name))))
                    (message "Thumb could not be created for file %s" curr-file)
                  (image-dired-insert-thumbnail thumb-name curr-file dired-buf)))
              files))
      (case image-dired-line-up-method
        (dynamic      (image-dired-line-up-dynamic))
        (fixed        (image-dired-line-up))
        (interactive  (image-dired-line-up-interactive))
        (none         nil)
        (t            (image-dired-line-up-dynamic))))
    (if do-not-pop
        (display-buffer image-dired-thumbnail-buffer)
      (pop-to-buffer image-dired-thumbnail-buffer))))

;;;###autoload
(defun diredp-image-dired-tag-files-recursive (&optional ignore-marks-p details) ; Bound to `M-+ C-t t'
  "Tag marked files with an `image-dired' tag, including in marked subdirs.
Like `image-dired-tag-files', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-image-dired-required-msg)
                      (diredp-get-confirmation-recursive)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (let ((tag  (read-string "Tags to add (separate tags with a semicolon): ")))
    (image-dired-write-tags (mapcar (lambda (x) (cons x tag))
                                    (diredp-get-files ignore-marks-p nil nil nil nil details)))))

;;;###autoload
(defun diredp-image-dired-delete-tag-recursive (&optional ignore-marks-p details) ; Bound to `M-+ C-t r'
  "Remove `image-dired' tag for marked files, including in marked subdirs.
Like `image-dired-delete-tag', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-image-dired-required-msg)
                      (diredp-get-confirmation-recursive)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (image-dired-remove-tag (diredp-get-files ignore-marks-p nil nil nil nil details)
                          (read-string "Tag to remove: ")))

;;;###autoload
(defun diredp-image-dired-comment-files-recursive (&optional ignore-marks-p details) ; Bound to `M-+ C-t c'
  "Add comment to marked files in dired, including those in marked subdirs.
Like `image-dired-dired-comment-files' but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-image-dired-required-msg)
                      (diredp-get-confirmation-recursive)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (let ((comment  (image-dired-read-comment)))
    (image-dired-write-comments (mapcar (lambda (curr-file) (cons curr-file comment))
                                        (diredp-get-files ignore-marks-p nil nil nil nil details)))))

(when (> emacs-major-version 22)

  (defun diredp-do-decrypt-recursive (&optional ignore-marks-p details) ; Bound to `M-+ : d'
    "Decrypt marked files, including those in marked subdirs.
Like `epa-dired-do-decrypt', but act recursively on subdirs to pick up
the files to decrypt.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (dolist (file  (diredp-get-files ignore-marks-p nil nil nil nil details))
      (epa-decrypt-file (expand-file-name file)))
    (revert-buffer))

  (defun diredp-do-verify-recursive (&optional ignore-marks-p details) ; Bound to `M-+ : v'
    "Verify marked files, including those in marked subdirs.
Like `epa-dired-do-verify', but act recursively on subdirs to pick up
the files to verify.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (dolist (file  (diredp-get-files ignore-marks-p nil nil nil nil details))
      (epa-verify-file (expand-file-name file)))
    (revert-buffer))

  (defun diredp-do-sign-recursive (&optional ignore-marks-p details) ; Bound to `M-+ : s'
    "Sign marked files, including those in marked subdirs.
Like `epa-dired-do-sign', but act recursively on subdirs to pick up
the files to sign.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (dolist (file  (diredp-get-files ignore-marks-p nil nil nil nil details))
      (epa-sign-file (expand-file-name file)
                     (epa-select-keys (epg-make-context) "Select keys for signing.
If none are selected, the default secret key is used.  ")
                     (y-or-n-p "Make a detached signature? ")))
    (revert-buffer))

  (defun diredp-do-encrypt-recursive (&optional ignore-marks-p details) ; Bound to `M-+ : e'
    "Encrypt marked files, including those in marked subdirs.
Like `epa-dired-do-encrypt', but act recursively on subdirs to pick up
the files to encrypt.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (dolist (file  (diredp-get-files ignore-marks-p nil nil nil nil details))
      (epa-encrypt-file (expand-file-name file)
                        (epa-select-keys (epg-make-context) "Select recipients for encryption.
If none are selected, symmetric encryption is performed.  ")))
    (revert-buffer)))

;;;###autoload
(defun diredp-do-bookmark-recursive (&optional ignore-marks-p prefix details) ; Bound to `M-+ M-b'
  "Bookmark the marked files, including those in marked subdirs.
Like `diredp-do-bookmark', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list current-prefix-arg
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            diredp-list-file-attributes)))
  (dolist (file  (diredp-get-files ignore-marks-p nil nil nil nil details))
    (diredp-bookmark prefix file 'NO-MSG-P)))

;;;###autoload
(defun diredp-do-bookmark-dirs-recursive (ignore-marks-p &optional details msgp)
  "Bookmark this Dired buffer and marked subdirectory Dired buffers, recursively.
Create a Dired bookmark for this directory and for each of its marked
subdirectories.  Handle each of the marked subdirectory similarly:
bookmark it and its marked subdirectories, and so on, recursively.
Name each of these Dired bookmarks with the Dired buffer name.

After creating the Dired bookmarks, create a sequence bookmark, named
`DIRBUF and subdirs', where DIRBUF is the name of the original buffer.
This bookmark represents the whole Dired tree rooted in the directory
where you invoked the command.  Jumping to this sequence bookmark
restores all of the Dired buffers making up the tree, by jumping to
each of their bookmarks.

With a prefix arg, bookmark the marked and unmarked subdirectory Dired
buffers, recursively, that is, ignore markings.

Note:

,* If there is more than one Dired buffer for a given subdirectory then
  only the first such is used.

,* This command creates new bookmarks.  It never updates or overwrites
  an existing bookmark.

You need library `Bookmark+' for this command.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-subdirs'."
  (interactive (progn (unless (featurep 'bookmark+)
                        (error "You need library `Bookmark+' for this command"))
                      (diredp-get-confirmation-recursive 'subdirs)
                      (list current-prefix-arg diredp-list-file-attributes t)))
  (diredp-ensure-mode)
  (let ((sdirs   (diredp-get-subdirs ignore-marks-p nil details))
        (snames  ())
        dbufs)
    (when (and msgp  sdirs) (message "Checking descendant directories..."))
    (dolist (dir  (cons default-directory sdirs))
      (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
        (with-current-buffer (car dbufs)
          (let ((bname  (bookmark-buffer-name))
                (count  2))
            (while (and (bmkp-get-bookmark-in-alist bname 'NOERROR)  (setq bname  (format "%s[%d]" bname count))))
            (bookmark-set bname nil nil 'NO-UPDATE-P) ; Inhibit updating displayed list.
            (push bname snames)))))
    (let ((bname  (format "%s and subdirs" (bookmark-buffer-name)))
          (count  2))
      (while (and (bmkp-get-bookmark-in-alist bname 'NOERROR)  (setq bname  (format "%s[%d]" bname count))))
      (bmkp-set-sequence-bookmark bname (nreverse snames) -1 'MSGP))
    (bmkp-refresh/rebuild-menu-list nil)))

;;;###autoload
(defun diredp-do-bookmark-in-bookmark-file-recursive (bookmark-file ; Bound to `M-+ C-M-B', aka `M-+ C-M-S-b')
                                                      &optional prefix ignore-marks-p bfile-bookmarkp details)
  "Bookmark files here and below in BOOKMARK-FILE and save BOOKMARK-FILE.
Like `diredp-do-bookmark-in-bookmark-file', but act recursively on
subdirs.  The files included are those that are marked in the current
Dired buffer, or all files in the directory if none are marked.
Marked subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp:
 ,* Optional arg BFILE-BOOKMARKP non-nil means create a bookmark-file
   bookmark for BOOKMARK-FILE.
 ,* Optional arg DETAILS is passed to `diredp-get-files'."
  (interactive
   (progn (diredp-get-confirmation-recursive)
          (let ((d-r-b-f-args  (diredp-read-bookmark-file-args)))
            (list (car d-r-b-f-args)
                  (cadr d-r-b-f-args)
                  (car (cddr d-r-b-f-args))
                  nil
                  diredp-list-file-attributes))))
  (diredp-do-bookmark-in-bookmark-file bookmark-file prefix nil bfile-bookmarkp
                                       (diredp-get-files ignore-marks-p nil nil nil nil details)))

;;;###autoload
(defun diredp-set-bookmark-file-bookmark-for-marked-recursive (bookmark-file
                                                               &optional prefix ignore-marks-p details)
                                        ; Bound to `M-+ C-M-b'
  "Bookmark the marked files and create a bookmark-file bookmark for them.
Like `diredp-set-bookmark-file-bookmark-for-marked', but act
recursively on subdirs.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-bookmark-in-bookmark-file-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (let ((d-r-b-f-args  (diredp-read-bookmark-file-args)))
                        (list (car d-r-b-f-args)
                              (cadr d-r-b-f-args)
                              (car (cddr d-r-b-f-args))
                              diredp-list-file-attributes))))
  (diredp-ensure-bookmark+)
  (diredp-do-bookmark-in-bookmark-file-recursive
   bookmark-file prefix ignore-marks-p 'CREATE-BOOKMARK-FILE-BOOKMARK details))

;;;###autoload
(defun diredp-do-find-marked-files-recursive (&optional arg details) ; Bound to `M-+ F'
  "Find marked files simultaneously, including those in marked subdirs.
Like `dired-do-find-marked-files', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With (explicit) numeric prefix ARG >= 0, find the files but do not
display them.

With numeric prefix ARG <= 0, ignore all marks - include all files in
this Dired buffer and all subdirs, recursively.

Note that prefix-argument behavior is different for this command than
for `dired-do-find-marked-files'.  In particular, a negative numeric
prefix arg does not cause the files to be shown in separate frames.
Only non-nil `pop-up-frames' (or equivalent configuration) causes
the files to be shown in separate frames.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list current-prefix-arg diredp-list-file-attributes)))
  (let ((narg  (prefix-numeric-value arg)))
    (dired-simultaneous-find-file (diredp-get-files (<= narg 0) nil nil nil nil details)
                                  (and arg  (not (consp arg))  (>= narg 0)  narg))))

(when (fboundp 'dired-do-isearch-regexp) ; Emacs 23+

  (defun diredp-do-isearch-recursive (&optional ignore-marks-p details) ; Bound to `M-+ M-s a C-s'
    "Isearch the marked files, including those in marked subdirs.
With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (multi-isearch-files (diredp-get-files ignore-marks-p nil nil nil nil details)))

  (defun diredp-do-isearch-regexp-recursive (&optional ignore-marks-p details) ; `M-+ M-s a C-M-s'
    "Regexp-Isearch the marked files, including those in marked subdirs.
With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (multi-isearch-files-regexp (diredp-get-files ignore-marks-p nil nil nil nil details))))

(defun diredp-do-search-recursive (regexp &optional ignore-marks-p details) ; Bound to `M-+ A'
  "Regexp-search the marked files, including those in marked subdirs.
With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

Stops when a match is found.
To continue searching for the next match, use `\\[tags-cl-loop-continue]'.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list (read-string "Search marked files (regexp): ")
                            current-prefix-arg
                            diredp-list-file-attributes)))
  (tags-search regexp '(diredp-get-files ignore-marks-p nil nil nil nil details)))

;;;###autoload
(defun diredp-do-query-replace-regexp-recursive (from to &optional arg details) ; Bound to `M-+ Q'
  "Do `query-replace-regexp' on marked files, including in marked subdirs.
Query-replace FROM with TO.

Like `dired-do-query-replace-regexp', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With an (explicit) numeric prefix argument:

,* >= 0 means ignore all marks - include ALL files in this Dired buffer
  and all subdirs, recursively.

,* <= 0 means replace only word-delimited matches.

If you exit (`\\[keyboard-quit]', `RET' or `q'), you can resume the query replacement
using `\\[tags-cl-loop-continue]'.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (let ((common  (query-replace-read-args "Query replace regexp in marked files" t t)))
                        (list (nth 0 common)
                              (nth 1 common)
                              current-prefix-arg
                              diredp-list-file-attributes))))
  (let* ((narg                  (and arg  (prefix-numeric-value arg)))
         (delimited             (and narg  (<= narg 0)))
         (ignore-marks-p        (and narg  (>= narg 0)))
         (files                 (diredp-get-files ignore-marks-p nil nil nil nil details))
         (fit-frame-min-width   30)
         (fit-frame-min-height  15))
    (dolist (file  files)
      (let ((buffer  (get-file-buffer file)))
        (when (and buffer  (with-current-buffer buffer buffer-read-only))
          (error "File `%s' is visited read-only" file))))
    (tags-query-replace from to delimited `',files)))

;;;###autoload
(defun diredp-do-grep-recursive (command-args &optional details) ; Bound to `M+ C-M-g'
  "Run `grep' on marked files, including those in marked subdirs.
Like `diredp-do-grep', but act recursively on subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (unless (if (< emacs-major-version 22)
                                  grep-command
                                (and grep-command  (or (not grep-use-null-device)  (eq grep-use-null-device t))))
                        (grep-compute-defaults))
                      (list (diredp-do-grep-1
                             (diredp-get-files current-prefix-arg nil nil nil nil diredp-list-file-attributes)))))
  (grep command-args))

;;;###autoload
(defun diredp-marked-recursive (dirname &optional ignore-marks-p details) ; Not bound to a key
  "Open Dired on marked files, including those in marked subdirs.
Like `diredp-marked', but act recursively on subdirs.

See `diredp-do-find-marked-files-recursive' for a description of the
files included.  In particular, if no files are marked here or in a
marked subdir, then all files in the directory are included.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, DIRNAME here must be a string, not a cons.  It
is used as the name of the new Dired buffer.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list nil current-prefix-arg diredp-list-file-attributes)))
  (dired (cons (or dirname  (generate-new-buffer-name (buffer-name)))
               (diredp-get-files ignore-marks-p nil nil nil nil details))))

;;;###autoload
(defun diredp-marked-recursive-other-window (dirname &optional ignore-marks-p details) ; Bound to `M-+ C-M-*'
  "Same as `diredp-marked-recursive', but uses a different window.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list nil current-prefix-arg diredp-list-file-attributes)))
  (dired-other-window
   (cons (or dirname  (generate-new-buffer-name (buffer-name)))
         (diredp-get-files ignore-marks-p nil nil nil nil details))))

;;;###autoload
(defun diredp-list-marked-recursive (&optional ignore-marks-p predicate details) ; Bound to `M-+ C-M-l'
  "List the files marked here and in marked subdirs, recursively.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, all marks are ignored: all files in this Dired
buffer and all descendant directories are included.

You can use `RET' or `mouse-2' to visit any of the files.
If `tooltip-mode' is on then moving the mouse over image-file names
shows image previews.

When called from Lisp:
 Non-nil optional arg IGNORE-MARKS-P means ignore marks.
 Non-nil optional arg PREDICATE is a file-name predicate.  List only
  the files for which it returns non-nil.
 Non-nil optional arg DETAILS is passed to `diredp-list-files'."
  (interactive ; No need for `diredp-get-confirmation-recursive' here.
   (progn (diredp-ensure-mode) (list current-prefix-arg nil diredp-list-file-attributes)))
  (let ((files  (diredp-get-files ignore-marks-p predicate))) (diredp-list-files files nil nil nil details)))

;;;###autoload
(defun diredp-flag-auto-save-files-recursive (&optional arg details) ; Bound to `M-+ #'
  "Flag all auto-save files for deletion, including in marked subdirs.
A non-negative prefix arg means to unmark (unflag) them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, flag all in this directory and all
descendant directories.

When called from Lisp, optional arg DETAILS is passed to
`diredp-mark-recursive-1'."
  (interactive (list current-prefix-arg diredp-list-file-attributes))
  (let ((dired-marker-char  dired-del-marker))
    (diredp-mark-recursive-1 arg "auto-save files" "auto-save file" '(diredp-looking-at-p "^.* #.+#$") details)))

(when (fboundp 'char-displayable-p)     ; Emacs 22+

  (defun diredp-change-marks-recursive (old new &optional arg predicate details) ; Bound to `M-+ * c'
    "Change all OLD marks to NEW marks, including those in marked subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

,* A non-positive prefix arg means ignore subdir markings and act
  instead on ALL subdirs.

,* A non-negative prefix arg means do not change marks on subdirs
  themselves.

Note: If there is more than one Dired buffer for a given subdirectory
then only the first such is used.

When called from Lisp:
 Non-nil arg PREDICATE is a file-name predicate.  Act on only the
  files for which it returns non-nil.
 DETAILS is passed to `diredp-get-subdirs'."
    (interactive
     (progn (diredp-get-confirmation-recursive)
            (let* ((cursor-in-echo-area  t)
                   (old                  (progn (message "Change (old mark): ") (read-char)))
                   (new                  (progn (message "Change `%c' marks to (new mark): " old) (read-char))))
              (list old new current-prefix-arg nil diredp-list-file-attributes))))
    (let* ((numarg             (and arg  (prefix-numeric-value arg)))
           (nosubs             (natnump numarg))
           (ignore-marks       (and numarg  (<= numarg 0)))
           (dired-marker-char  new)
           (sdirs              (diredp-get-subdirs ignore-marks predicate details))
           (old-strg           (format "\n%c" old))
           (count              0)
           dbufs)
      (unless (char-displayable-p old) (error "Not a displayable character: `%c'" old))
      (unless (char-displayable-p new) (error "Not a displayable character: `%c'" new))
      (message "Changing mark `%c' to `%c'..." old new)
      (dolist (dir  (cons default-directory sdirs))
        (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
          (with-current-buffer (car dbufs)
            (let ((inhibit-read-only  t)
                  (file               nil))
              (save-excursion
                (goto-char (point-min))
                (while (search-forward old-strg nil t)
                  (save-match-data (setq file  (dired-get-filename 'no-dir 'NO-ERROR)))
                  ;; Do nothing if changing from UNmarked and not on a file or dir name.
                  (unless (and (= old ?   )  (not file))
                    ;; Do nothing if marked subdir and not changing subdir marks.
                    (unless (and nosubs  file  (file-directory-p file))
                      (subst-char-in-region (match-beginning 0) (match-end 0) old new)
                      (setq count  (1+ count))))))))))
      (message "%d mark%s changed from `%c' to `%c'" count (dired-plural-s count) old new)))

  (defun diredp-unmark-all-marks-recursive (&optional arg details) ; Bound to `M-+ U'
    "Remove ALL marks everywhere, including in marked subdirs.
A prefix arg is as for `diredp-unmark-all-files-recursive'.
Note that a negative prefix arg (e.g. `C--') removes all marks from
this Dired buffer and then does the same recursively for each of its
subdirs.

When called from Lisp, optional arg DETAILS is passed to
`diredp-unmark-all-files-recursive'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (diredp-unmark-all-files-recursive ?\r arg details))

  (defun diredp-unmark-all-files-recursive (mark &optional arg predicate details) ; Bound to `M-+ M-DEL'
    "Remove a given mark (or ALL) everywhere, including in marked subdirs.
You are prompted for the mark character to remove.  If you hit `RET'
instead then ALL mark characters are removed.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

,* A non-positive prefix arg means ignore subdir markings and act
  instead on ALL subdirs.

,* A non-negative prefix arg means do not change marks on subdirs
  themselves.

Note: If there is more than one Dired buffer for a given subdirectory
then only the first such is used.

When called from Lisp:
 Non-nil arg PREDICATE is a file-name predicate.  Act on only the
  files for which it returns non-nil.
 DETAILS is passed to `diredp-get-subdirs'."
    (interactive
     (progn (diredp-get-confirmation-recursive)
            (let* ((cursor-in-echo-area  t)
                   (mrk                  (progn (message "Remove marks (RET means all): ") (read-char))))
              (list mrk current-prefix-arg nil diredp-list-file-attributes))))
    (let* ((numarg             (and arg  (prefix-numeric-value arg)))
           (nosubs             (natnump numarg))
           (ignore-marks       (and numarg  (<= numarg 0)))
           (dired-marker-char  ?\  )    ; Unmark
           (sdirs              (diredp-get-subdirs ignore-marks predicate details))
           (mrk-strg           (format "\n%c" mark))
           (count              0)
           dbufs)
      (unless (char-displayable-p mark) (error "Not a displayable character: `%c'" mark))
      (if (eq mark ?\r)
          (message "Unmarking ALL marks here and below...")
        (message "Unmarking mark `%c' here and below..." mark))
      (dolist (dir  (cons default-directory sdirs))
        (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
          (with-current-buffer (car dbufs)
            (let ((inhibit-read-only  t)
                  (file               nil))
              (save-excursion
                (goto-char (point-min))
                (while (if (eq mark ?\r)
                           (re-search-forward dired-re-mark nil t)
                         (search-forward mrk-strg nil t))
                  (save-match-data (setq file  (dired-get-filename 'no-dir 'NO-ERROR)))
                  ;; Do nothing if marked subdir and not changing subdir marks.
                  (unless (and nosubs  file  (file-directory-p file))
                    (subst-char-in-region (match-beginning 0) (match-end 0) (preceding-char) ?\   ))
                  (setq count  (1+ count))))))))
      (message "%d mark%s UNmarked" count (dired-plural-s count))))

  )

(when (and (memq system-type '(windows-nt ms-dos))  (fboundp 'w32-browser))

  (defun diredp-multiple-w32-browser-recursive (&optional ignore-marks-p details)
    "Run Windows apps for with marked files, including those in marked subdirs.
Like `dired-multiple-w32-browser', but act recursively on subdirs.

See `diredp-do-find-marked-files-recursive' for a description of the
files included.  In particular, if no files are marked here or in a
marked subdir, then all files in the directory are included.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
    (interactive (progn (diredp-get-confirmation-recursive)
                        (list current-prefix-arg diredp-list-file-attributes)))
    (let ((files  (diredp-get-files ignore-marks-p nil nil nil nil details)))
      (while files
        (w32-browser (car files))
        (sleep-for w32-browser-wait-time)
        (setq files  (cdr files)))))

  )

;;;###autoload
(defun diredp-copy-filename-as-kill-recursive (&optional arg details) ; Bound to `M-+ M-w'
  "Copy names of marked files here and in marked subdirs, to `kill-ring'.
The names are separated by a space.

Like `dired-copy-filename-as-kill', but act recursively on subdirs.
\(Do not copy subdir names themselves.)

With no prefix arg, use relative file names.
With a zero prefix arg, use absolute file names.
With a plain prefix arg (`C-u'), use names relative to the current
Dired directory.  (This might contain slashes if in a subdirectory.)

If on a subdir headerline, use absolute subdir name instead - prefix
arg and marked files are ignored in this case.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

The names are copied to the kill ring and to variable
`diredp-last-copied-filenames'.

When called from Lisp:
,* ARG is a raw prefix arg
,* DETAILS is passed to `diredp-get-files'."
  (interactive ; No need for `diredp-get-confirmation-recursive' here.
   (progn (diredp-ensure-mode) (list current-prefix-arg diredp-list-file-attributes)))
  (let* ((files   (mapcar (cond ((zerop (prefix-numeric-value arg)) #'identity)
                                ((consp arg) (lambda (fn) (concat (dired-current-directory t)
                                                             (file-name-nondirectory fn))))
                                (t (lambda (fn) (file-name-nondirectory fn))))
                          (diredp-get-files nil nil nil nil nil details)))
         (string  (mapconcat #'identity files diredp-filename-separator)))
    (unless (string= "" string)
      (if (eq last-command 'kill-region) (kill-append string nil) (kill-new string))
      (setq diredp-last-copied-filenames  (car kill-ring-yank-pointer)))
    (message "%s" string)))

;;;###autoload
(defun diredp-copy-abs-filenames-as-kill-recursive (&optional ignore-marks-p details) ; Not bound.
  "Copy absolute names of files marked here and in marked subdirs, recursively.
The names are copied to the kill ring and to variable
`diredp-last-copied-filenames'.

The files whose names are copied are those that are marked in the
current Dired buffer, or all files in the directory if none are
marked.  Marked subdirectories are handled recursively in the same
way.

When called from Lisp, optional arg DETAILS is passed to
`diredp-copy-filename-as-kill-recursive'."
  (interactive                          ; No need for `diredp-get-confirmation-recursive' here.
   (progn (diredp-ensure-mode) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-copy-filename-as-kill-recursive 0 details)
  (setq diredp-last-copied-filenames  (car kill-ring-yank-pointer)))

;;;###autoload
(defun diredp-mark-files-regexp-recursive (regexp
                                           &optional marker-char ignore-marks-p details) ; Bound to `M-+ % m'
  "Mark all files matching REGEXP, including those in marked subdirs.
Like `dired-mark-files-regexp' but act recursively on marked subdirs.

The file names to be matched by this command are always absolute -
they include the full directory.  Note that this does NOT correspond
to the default behavior for `dired-mark-files-regexp'.  The other
matching possibilities offered by `dired-mark-files-regexp' are not
available for this command.

Directories `.' and `..' are never marked.

A non-negative prefix arg means to UNmark the files instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all matching files in this
directory and all descendant directories.

REGEXP is an Emacs regexp, not a shell wildcard.  Thus, use `\\.o$' for
object files--just `.o' will mark more than you might think.

REGEXP is added to `regexp-search-ring', for regexp search.

Note: If there is more than one Dired buffer for a given subdirectory
then only the first such is used.

When called from Lisp, DETAILS is passed to `diredp-get-subdirs'."
  (interactive (let* ((numarg   (and current-prefix-arg  (prefix-numeric-value current-prefix-arg)))
                      (unmark   (and numarg  (>= numarg 0)))
                      (ignorep  (and numarg  (<= numarg 0))))
                 (list (diredp-read-regexp (concat (if unmark "UNmark" "Mark") " files (regexp): "))
                       (and unmark  ?\040)
                       ignorep
                       diredp-list-file-attributes)))
  (add-to-list 'regexp-search-ring regexp) ; Add REGEXP to `regexp-search-ring'.
  (let ((dired-marker-char  (or marker-char  dired-marker-char))
        (sdirs              (diredp-get-subdirs ignore-marks-p nil details))
        (matched            0)
        (changed            0)
        dbufs chg.mtch)
    (message "%s files..." (if (eq ?\040 dired-marker-char) "UNmarking" "Marking"))
    (dolist (dir  (cons default-directory sdirs))
      (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
        (with-current-buffer (car dbufs)
          (setq chg.mtch  (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))
                                               (not (eolp)) ; Empty line
                                               (let ((fn  (dired-get-filename nil 'NO-ERROR)))
                                                 (and fn  (diredp-string-match-p regexp fn))))
                                          "file")
                changed   (+ changed (or (car chg.mtch)  0))
                matched   (+ matched (or (cdr chg.mtch)  0))))))
    (message "%s file%s%s%s newly %s"
             matched
             (dired-plural-s matched)
             (if (not (= matched changed)) " matched, " "")
             (if (not (= matched changed)) changed "")
             (if (eq ?\040 dired-marker-char) "unmarked" "marked"))))

;;;###autoload
(defun diredp-mark-files-containing-regexp-recursive (regexp
                                                      &optional marker-char ignore-marks-p details) ; `M-+ % g'
  "Mark files with contents containing a REGEXP match, including in marked subdirs.
Like `dired-mark-files-containing-regexp' but act recursively on
marked subdirs.

A non-negative prefix arg means to UNmark the files instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all matching files in this
directory and all descendant directories.

REGEXP is added to `regexp-search-ring', for regexp search.

Note: If there is more than one Dired buffer for a given subdirectory
then only the first such is used.

If a file is visited in a buffer and `dired-always-read-filesystem' is
nil, this looks in the buffer without revisiting the file, so the
results might be inconsistent with the file on disk if its contents
have changed since it was last visited.

When called from Lisp, DETAILS is passed to `diredp-get-subdirs'."

  (interactive (let* ((numarg   (and current-prefix-arg  (prefix-numeric-value current-prefix-arg)))
                      (unmark   (and numarg  (>= numarg 0)))
                      (ignorep  (and numarg  (<= numarg 0))))
                 (list (diredp-read-regexp (concat (if unmark "UNmark" "Mark") " files containing (regexp): "))
                       (and unmark  ?\040)
                       ignorep
                       diredp-list-file-attributes)))
  (add-to-list 'regexp-search-ring regexp) ; Add REGEXP to `regexp-search-ring'.
  (let ((dired-marker-char  (or marker-char  dired-marker-char))
        (sdirs              (diredp-get-subdirs ignore-marks-p nil details))
        (matched            0)
        (changed            0)
        dbufs chg.mtch)
    (message "%s files..." (if (eq ?\040 dired-marker-char) "UNmarking" "Marking"))
    (dolist (dir  (cons default-directory sdirs))
      (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
        (with-current-buffer (car dbufs)
          (setq chg.mtch
                (diredp-mark-if
                 (and (not (diredp-looking-at-p dired-re-dot))
                      (not (eolp))
                      (let ((fname  (dired-get-filename nil 'NO-ERROR)))
                        (and fname
                             (file-readable-p fname)
                             (not (file-directory-p fname))
                             (let ((prebuf  (get-file-buffer fname)))
                               (message "Checking %s" fname)
                               ;; For now, do it inside Emacs.  Grep might be better if there are lots of files.
                               (if (and prebuf  (or (not (boundp 'dired-always-read-filesystem))
                                                    (not dired-always-read-filesystem))) ; Emacs 26+
                                   (with-current-buffer prebuf
                                     (save-excursion (goto-char (point-min)) (re-search-forward regexp nil t)))
                                 (with-temp-buffer
                                   (insert-file-contents fname)
                                   (goto-char (point-min))
                                   (re-search-forward regexp nil t)))))))
                 "file")
                changed   (+ changed (or (car chg.mtch)  0))
                matched   (+ matched (or (cdr chg.mtch)  0))))))
    (message "%s file%s%s%s newly %s"
             matched
             (dired-plural-s matched)
             (if (not (= matched changed)) " matched, " "")
             (if (not (= matched changed)) changed "")
             (if (eq ?\040 dired-marker-char) "unmarked" "marked"))))

(defun diredp-mark-extension-recursive (extension &optional arg details) ; Bound to `M-+ * .'
  "Mark all files with a certain EXTENSION, including in marked subdirs.
A `.' is not automatically prepended to the string entered.

This is like `diredp-mark/unmark-extension', but this acts recursively
on marked subdirs, and a non-positive prefix arg acts differently.

A non-negative prefix arg means to unmark them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

Non-interactively, EXTENSION is the extension (a string).  It can also
be a list of extension strings.
Optional argument ARG is the prefix arg.

When called from Lisp, DETAILS is passed to `diredp-mark-files-regexp-recursive'."
  (interactive (let* ((numarg  (and current-prefix-arg  (prefix-numeric-value current-prefix-arg)))
                      (unmark  (and numarg  (>= numarg 0))))
                 (list (diredp-read-regexp (concat (if unmark "UNmark" "Mark") " extension: "))
                       current-prefix-arg
                       diredp-list-file-attributes)))
  (let* ((numarg   (and arg  (prefix-numeric-value arg)))
         (unmark   (and numarg  (>= numarg 0)))
         (ignorep  (and numarg  (<= numarg 0))))
    (or (listp extension)  (setq extension  (list extension)))
    (diredp-mark-files-regexp-recursive (concat ".+[.]\\("
                                                (mapconcat #'regexp-quote extension "\\|")
                                                "\\)$")
                                        (if unmark ?\040 dired-marker-char)
                                        ignorep
                                        details)))

;; This is `read--expression' (from Emacs 24.4+), except that it uses `pp-read-expression-map' if available.
(defun diredp-read-expression (prompt &optional initial-contents)
  (if (fboundp 'minibuffer-with-setup-hook) ; Emacs 22+
      (let ((minibuffer-completing-symbol  t))
        (minibuffer-with-setup-hook
            (lambda ()       ; Vanilla Emacs FIXME: call `emacs-lisp-mode'?
              (when (fboundp 'add-function) ; Emacs 24+
                (add-function :before-until (local 'eldoc-documentation-function)
                              #'elisp-eldoc-documentation-function)
                (eldoc-mode 1))
              (add-hook 'completion-at-point-functions #'elisp-completion-at-point nil t)
              (run-hooks 'eval-expression-minibuffer-setup-hook))
          (read-from-minibuffer prompt initial-contents (if (boundp 'pp-read-expression-map) ;In  `pp+.el'
                                                            pp-read-expression-map
                                                          read-expression-map)
                                t 'read-expression-history)))
    (read-from-minibuffer "Function or sexp: " nil nil nil 'read-expression-history))) ; Emacs 20-21

;; FIXME: Factor out code that is common with `dired-mark-sexp'.
;;
(when (fboundp 'minibuffer-with-setup-hook) ; Emacs 22+

  (defun diredp-mark-sexp-recursive (predicate &optional arg details) ; Bound to `M-+ M-(', `M-+ * ('
    "Mark files here and below for which PREDICATE returns non-nil.
Like `diredp-mark-sexp', but act recursively on subdirs.

A non-negative prefix arg means to unmark those files instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

PREDICATE is a lisp sexp that can refer to the following symbols as
variables:

    `mode'   [string]  file permission bits, e.g. \"-rw-r--r--\"
    `nlink'  [integer] number of links to file
    `size'   [integer] file size in bytes
    `uid'    [string]  owner
    `gid'    [string]  group (If the gid is not displayed by `ls',
                       this will still be set (to the same as uid))
    `time'   [string]  the time that `ls' displays, e.g. \"Feb 12 14:17\"
    `name'   [string]  the name of the file
    `sym'    [string]  if file is a symbolic link, the linked-to name,
                       else \"\"
    `inode'  [integer] the inode of the file (only for `ls -i' output)
    `blks'   [integer] the size of the file for `ls -s' output
                       (ususally in blocks or, with `-k', in Kbytes)
Examples:
  Mark zero-length files: `(equal 0 size)'
  Mark files last modified on Feb 2: `(string-match \"Feb  2\" time)'
  Mark uncompiled Emacs Lisp files (`.el' file without a `.elc' file):
     First, Dired just the source files: `dired *.el'.
     Then, use \\[diredp-mark-sexp-recursive] with this sexp:
          (not (file-exists-p (concat name \"c\")))

There's an ambiguity when a single integer not followed by a unit
prefix precedes the file mode: It is then parsed as inode number
and not as block size (this always works for GNU coreutils ls).

Another limitation is that the uid field is needed for the
function to work correctly.  In particular, the field is not
present for some values of `ls-lisp-emulation'.

This function operates only on the Dired buffer content.  It does not
refer at all to the underlying file system.  Contrast this with
`find-dired', which might be preferable for the task at hand.

When called from Lisp, DETAILS is passed to `diredp-get-subdirs'."
    ;; Using `sym' = "", instead of nil, for non-linked files avoids the trap of
    ;; (string-match "foo" sym) into which a user would soon fall.
    ;; Use `equal' instead of `=' in the example, as it works on integers and strings.
    ;; (interactive "xMark if (vars: inode,blks,mode,nlink,uid,gid,size,time,name,sym): \nP")

    (interactive
     (let* ((numarg  (and current-prefix-arg  (prefix-numeric-value current-prefix-arg)))
            (unmark  (and numarg  (>= numarg 0))))
       (diredp-get-confirmation-recursive)
       (list (diredp-read-expression (format "%s if (Lisp expr): " (if current-prefix-arg "UNmark" "Mark")))
             current-prefix-arg
             diredp-list-file-attributes)))
    (message "%s" predicate)
    (let* ((numarg             (and arg  (prefix-numeric-value arg)))
           (unmark             (and numarg  (>= numarg 0)))
           (ignorep            (and numarg  (<= numarg 0)))
           (dired-marker-char  (if unmark ?\040 dired-marker-char))
           (inode              nil)
           (blks               ())
           (matched            0)
           (changed            0)
           dbufs chg.mtch mode nlink uid gid size time name sym)
      (dolist (dir  (cons default-directory (diredp-get-subdirs ignorep nil details)))
        (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
          (with-current-buffer (car dbufs)
            (setq chg.mtch
                  (diredp-mark-if
                   (save-excursion
                     (and
                      ;; Sets vars INODE BLKS MODE NLINK UID GID SIZE TIME NAME and SYM
                      ;; according to current file line.  Returns `t' for success, nil if
                      ;; there is no file line.  Upon success, these vars are set, to either
                      ;; nil or the appropriate value, so they need not be initialized.
                      ;; Moves point within the current line.
                      (dired-move-to-filename)
                      (let ((mode-len             10) ; Length of `mode' string.
                            ;; As in `dired.el', but with subexpressions \1=inode, \2=blks:
                            ;; GNU `ls -hs' suffixes the block count with a unit and prints it as a float
                            ;; FreeBSD does neither.
                            ;; $$$$$$ (dired-re-inode-size  "\\s *\\([0-9]*\\)\\s *\\([0-9]*\\) ?")
                            (dired-re-inode-size  (if (> emacs-major-version 24)
                                                      "\\=\\s *\\([0-9]+\\s +\\)?\
\\(?:\\([0-9]+\\(?:\\.[0-9]*\\)?[BkKMGTPEZY]?\\)? ?\\)"
                                                    "\\s *\\([0-9]*\\)\\s *\\([0-9]*\\) ?"))
                            pos)
                        (beginning-of-line)
                        (forward-char 2)
                        (search-forward-regexp dired-re-inode-size nil t)
                        ;; `INODE', `BLKS', `MODE'
                        ;; XXX Might be a size not followed by a unit prefix.
                        ;; Could set `blks' to `inode' if it were otherwise nil, with similar reasoning
                        ;; as for setting `gid' to `uid', but it would be even more whimsical.
                        (setq inode  (and (match-string 1)  (string-to-number (match-string 1)))
                              blks   (and (match-string 2)  (if (fboundp 'dired-x--string-to-number) ; Emacs 25+
                                                                (dired-x--string-to-number (match-string 2))
                                                              (string-to-number (match-string 2))))
                              mode   (buffer-substring (point) (+ mode-len (point))))
                        (forward-char mode-len)
                        ;; Skip any extended attributes marker ("." or "+").
                        (unless (eq (char-after) ?\   ) (forward-char 1))
                        (setq nlink  (read (current-buffer))) ; `NLINK'

                        ;; `UID'
                        ;; Another issue is that GNU `ls -n' right-justifies numerical UIDs and GIDs,
                        ;; while FreeBSD left-justifies them, so do not rely on a specific whitespace
                        ;; layout.  Both of them right-justify all other numbers, though.
                        ;; XXX Return a number if the `uid' or `gid' seems to be numerical?
                        ;; $$$$$$ (setq uid  (buffer-substring (+ (point) 1) (progn (forward-word 1) (point))))
                        (setq uid  (buffer-substring (progn (skip-chars-forward " \t")  (point))
                                                     (progn (skip-chars-forward "^ \t") (point))))
                        (cond ((> emacs-major-version 24)
                               (dired-move-to-filename)
                               (save-excursion
                                 (setq time ; `TIME'
                                       ;; The regexp below tries to match from the last digit of the size
                                       ;; field through a space after the date.  Also, dates may have
                                       ;; different formats depending on file age, so the date column need
                                       ;; not be aligned to the right.
                                       (buffer-substring
                                        (save-excursion (skip-chars-backward " \t") (point))
                                        (progn (re-search-backward directory-listing-before-filename-regexp)
                                               (skip-chars-forward "^ \t")
                                               (1+ (point))))

                                       size ; `SIZE'
                                       (dired-x--string-to-number
                                        ;; We know that there's some kind of number before point because
                                        ;; the regexp search above succeeded.  Not worth doing an extra
                                        ;; check for leading garbage.
                                        (buffer-substring (point) (progn (skip-chars-backward "^ \t") (point))))
                                       ;; If no `gid' is displayed, `gid' will be set to `uid' but user
                                       ;; will then not reference it anyway in PREDICATE.

                                       gid ; `GID'
                                       (buffer-substring (progn (skip-chars-backward " \t") (point))
                                                         (progn (skip-chars-backward "^ \t") (point)))))
                               ;; `NAME', `SYM'
                               (setq name  (buffer-substring (point)
                                                             (or (dired-move-to-end-of-filename t)  (point)))
                                     sym   (if (diredp-looking-at-p " -> ")
                                               (buffer-substring (progn (forward-char 4) (point))
                                                                 (line-end-position))
                                             "")))
                              (t
                               (re-search-forward
                                (if (< emacs-major-version 20)
                                    "\\(Jan\\|Feb\\|Mar\\|Apr\\|May\\|Jun\\|Jul\\|Aug\\|Sep\\|Oct\\|Nov\\|Dec\\)"
                                  dired-move-to-filename-regexp))
                               (goto-char (match-beginning 1))
                               (forward-char -1)
                               (setq size ; `SIZE'
                                     (string-to-number (buffer-substring (save-excursion (backward-word 1)
                                                                                         (setq pos  (point)))
                                                                         (point))))
                               (goto-char pos)
                               (backward-word 1)
                               ;; `GID', `TIME', `NAME', `SYM'
                               ;; if no `gid' is displayed, `gid' will be set to `uid' but user will then
                               ;; not reference it anyway in PREDICATE.
                               (setq gid   (buffer-substring (save-excursion (forward-word 1) (point)) (point))
                                     time  (buffer-substring (match-beginning 1) (1- (dired-move-to-filename)))
                                     name  (buffer-substring (point) (or (dired-move-to-end-of-filename t)
                                                                         (point)))
                                     sym   (if (diredp-looking-at-p " -> ")
                                               (buffer-substring (progn (forward-char 4) (point))
                                                                 (line-end-position))
                                             "")))))
                      ;; Vanilla Emacs uses `lexical-binding' = t, and it passes bindings to `eval'
                      ;; as a second arg.  We use `lexical-binding' = nil, and anyway there should
                      ;; be no need to pass the bindings.
                      (eval predicate)))
                   (format "'%s file" predicate)))
            (setq changed   (+ changed (or (car chg.mtch)  0))
                  matched   (+ matched (or (cdr chg.mtch)  0))))))
      (message "%s file%s%s%s newly %s" matched (dired-plural-s matched)
               (if (not (= matched changed)) " matched, " "")
               (if (not (= matched changed)) changed "")
               (if (eq ?\040 dired-marker-char) "unmarked" "marked"))))

  )

;;;###autoload
(defun diredp-mark-autofiles-recursive (&optional arg details) ; Bound to `M-+ * B'
  "Mark all autofiles, including in marked subdirs.
Autofiles are files that have an autofile bookmark.
A non-negative prefix arg means to unmark them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

When called from Lisp, optional arg DETAILS is passed to
`diredp-mark-recursive-1'."
  (interactive (list current-prefix-arg diredp-list-file-attributes))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-recursive-1 arg "autofiles" "autofile"
                           '(and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                             (let ((fname  (dired-get-filename nil 'NO-ERROR)))
                               (and fname  (bmkp-get-autofile-bookmark fname))))
                           details))

;;;###autoload
(defun diredp-mark-executables-recursive (&optional arg details) ; Bound to `M-+ * *'
  "Mark all executable files, including in marked subdirs.
The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

A non-negative prefix arg means to unmark them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

When called from Lisp, optional arg DETAILS is passed to
`diredp-mark-recursive-1'."
  (interactive (list current-prefix-arg diredp-list-file-attributes))
  (diredp-mark-recursive-1 arg "executable files" "executable file" '(diredp-looking-at-p dired-re-exe) details))

;;;###autoload
(defun diredp-mark-directories-recursive (&optional arg details) ; Bound to `M-+ * /'
  "Mark all directories except `.' and `..', including in marked subdirs.
The directories included are those that are marked in the current
Dired buffer, or all subdirs in the directory if none are marked.
Marked subdirectories are handled recursively in the same way.

A non-negative prefix arg means to unmark them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

When called from Lisp, optional arg DETAILS is passed to
`diredp-mark-recursive-1'."
  (interactive (list current-prefix-arg diredp-list-file-attributes))
  (diredp-mark-recursive-1 arg "directories" "directory" '(and (diredp-looking-at-p dired-re-dir)
                                                           (not (diredp-looking-at-p dired-re-dot)))
                           details))
;;;###autoload
(defun diredp-mark-symlinks-recursive (&optional arg details) ; Bound to `M-+ * @'
  "Mark all symbolic links, including in marked subdirs.
The symlinks included are those that are marked in the current Dired
buffer, or all symlinks in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

A non-negative prefix arg means to unmark them instead.

A non-positive prefix arg means to ignore subdir markings and act
instead on ALL subdirs.  That is, mark all in this directory and all
descendant directories.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-subdirs'."
  (interactive (list current-prefix-arg diredp-list-file-attributes))
  (diredp-mark-recursive-1 arg "symlinks" "symbolic link" '(diredp-looking-at-p dired-re-sym) details))

(defun diredp-mark-recursive-1 (arg plural singular predicate-sexp details)
  "Helper for `diredp-mark-*-recursive' commands."
  (let* ((numarg             (and arg  (prefix-numeric-value arg)))
         (unmark             (and numarg  (>= numarg 0)))
         (ignorep            (and numarg  (<= numarg 0)))
         (dired-marker-char  (if unmark ?\040 dired-marker-char))
         (sdirs              (diredp-get-subdirs ignorep nil details))
         (changed            0)
         (matched            0)
         dbufs chg.mtch)
    (message "%s %s..." (if (eq ?\040 dired-marker-char) "UNmarking" "Marking") plural)
    (dolist (dir  (cons default-directory sdirs))
      (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
        (with-current-buffer (car dbufs)
          (setq chg.mtch  (diredp-mark-if (eval predicate-sexp) singular)
                changed   (+ changed (or (car chg.mtch)  0))
                matched   (+ matched (or (cdr chg.mtch)  0))))))
    (message "%s %s%s%s newly %s"
             matched
             (if (= 1 matched) singular plural)
             (if (not (= matched changed)) " matched, " "")
             (if (not (= matched changed)) changed "")
             (if (eq ?\040 dired-marker-char) "unmarked" "marked"))))

;;;###autoload
(defun diredp-capitalize-recursive (&optional ignore-marks-p details) ; Bound to `M-+ % c'
  "Rename marked files, including in marked subdirs, by capitalizing them.
Like `diredp-capitalize', but act recursively on subdirs.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-create-files-non-directory-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-create-files-non-directory-recursive
   #'dired-rename-file #'capitalize "Rename by capitalizing:" ignore-marks-p details))

;;;###autoload
(defun diredp-upcase-recursive (&optional ignore-marks-p details) ; Bound to `M-+ % u'
  "Rename marked files, including in marked subdirs, making them uppercase.
Like `dired-upcase', but act recursively on subdirs.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-create-files-non-directory-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-create-files-non-directory-recursive
   #'dired-rename-file #'upcase "Rename to uppercase:" ignore-marks-p details))

;;;###autoload
(defun diredp-downcase-recursive (&optional ignore-marks-p details) ; Bound to `M-+ % l'
  "Rename marked files, including in marked subdirs, making them lowercase.
Like `dired-downcase', but act recursively on subdirs.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-create-files-non-directory-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-create-files-non-directory-recursive
   #'dired-rename-file #'downcase "Rename to lowercase:" ignore-marks-p details))

;;;###autoload
(defun diredp-do-aggregate-apply-to-marked-recursive (aggregate-fun apply-fun &optional ignore-marks-p details msgp)
  "Aggregate function applications to marked files, including in marked subdirs.
This command prompts you for the aggregate function, AGGREGATE-FUN,
and for the function to apply to each file, APPLY-FUN.

Then it calls `diredp-do-apply-to-marked-recursive', which applies
FILE-FUN to the name of each marked file or dir.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive
   (progn
     (diredp-get-confirmation-recursive)
     (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           (read (completing-read "Apply function (to file): " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           current-prefix-arg
           diredp-list-file-attributes
           t)))
  (diredp-ensure-fn-nonzero-arity aggregate-fun)
  (let ((result  (apply aggregate-fun (diredp-do-apply-to-marked-recursive apply-fun ignore-marks-p details))))
    (when msgp (let ((print-length  nil)
                     (print-level   nil))
                 (message "Result: %S" result)))))

;;; (defun diredp-do-aggregate-invoke-in-marked-recursive (aggregate-fun invoke-fun
;;;                                                                      &optional ignore-marks-p details msgp)
;;;   "Aggregate results of invoking a function in the marked files and dirs.
;;; This command prompts you for the aggregate function, AGGREGATE-FUN,
;;; and for the function to invoke in each marked file or dir, INVOKE-FUN.
;;;
;;; Then it calls `diredp-do-invoke-in-marked-recursive', which calls
;;; INVOKE-FUN at the start of the file, with no args.
;;;
;;; The files included are those that are marked in the current Dired
;;; buffer, or all files in the directory if none are marked.  Marked
;;; subdirectories are handled recursively in the same way.
;;;
;;; With a prefix argument, ignore all marks - include all files in this
;;; Dired buffer and all subdirs, recursively.
;;;
;;; When called from Lisp, optional arg DETAILS is passed to
;;; `diredp-get-files'."
;;;   (interactive
;;;    (progn
;;;      (diredp-get-confirmation-recursive)
;;;      (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
;;;                                   (and (boundp 'function-name-history)  'function-name-history)))
;;;            (read (completing-read "Invoke function (in file): " obarray 'functionp nil nil
;;;                                   (and (boundp 'function-name-history)  'function-name-history)))
;;;            current-prefix-arg
;;;            diredp-list-file-attributes
;;;            t)))
;;;   (diredp-ensure-fn-zero-arity aggregate-fun)
;;;   (let ((result  (apply aggregate-fun (diredp-do-invoke-in-marked-recursive invoke-fun ignore-marks-p details))))
;;;     (when msgp (let ((print-length  nil)
;;;                      (print-level   nil))
;;;                  (message "Result: %S" result)))))

;;;###autoload
(defun diredp-do-aggregate-eval-in-marked-recursive (aggregate-fun sexp &optional ignore-marks-p details msgp)
  "Aggregate results of invoking a function in the marked files and dirs.
This command prompts you for the aggregate function, AGGREGATE-FUN,
and for the sexp to evaluate in each marked file or dir, INVOKE-FUN.

Then it calls `diredp-do-eval-in-marked-recursive', which evaluates
SEXP at the start of the file.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive
   (progn
     (diredp-get-confirmation-recursive)
     (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           (diredp-read-expression "Sexp: ")
           current-prefix-arg
           diredp-list-file-attributes
           t)))
  (diredp-ensure-fn-zero-arity aggregate-fun)
  (let ((result  (apply aggregate-fun (diredp-do-eval-in-marked-recursive sexp ignore-marks-p details))))
    (when msgp (let ((print-length  nil)
                     (print-level   nil))
                 (message "Result: %S" result)))))

(defun diredp-maybe-save-visited (files &optional predicate details)
  "Prompt to save some (or all) modified buffers visiting a file in FILES.
Optional args PREDICATE and DETAILS are passed to
 `diredp-y-or-n-files-p'."
  (let ((modified-bufs  (delq nil (mapcar (lambda (ff)
                                            (if (> emacs-major-version 21)
                                                (find-buffer-visiting ff (lambda (bb) (buffer-modified-p bb)))
                                              (find-buffer-visiting ff)))
                                          files))))
    (when (and modified-bufs
               (diredp-y-or-n-files-p
                "Save modified file buffers now? "
                (setq modified-bufs  (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) modified-bufs)))
                predicate
                details))
      (map-y-or-n-p (lambda (bb) (format "Save `%s'? " (buffer-file-name bb)))
                    (lambda (bb) (with-current-buffer bb (save-buffer)))
                    modified-bufs
                    '("buffer" "buffers" "save")
                    (and (boundp 'save-some-buffers-action-alist)
                         save-some-buffers-action-alist)))))

;;;###autoload
(defun diredp-do-apply-to-marked-recursive (function &optional ignore-marks-p details) ; Bound to `M-+ @ @'
  "Apply FUNCTION to names of marked files, including in marked subdirs.
The absolute file name is passed to FUNCTION.

Like `diredp-do-apply-to-marked' but act recursively on subdirs, and
do no result-logging, error-logging, or echoing.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive
   (progn
     (diredp-get-confirmation-recursive)
     (list (read (completing-read "Apply function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           current-prefix-arg
           diredp-list-file-attributes)))
  (diredp-ensure-fn-nonzero-arity function)
  (let* ((files     (diredp-get-files ignore-marks-p nil nil nil nil details))
         (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs  ())
         (result    ()))
    (diredp-maybe-save-visited files nil details)
    (setq result    (mapcar function files)
          new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (message nil) ; Clear echo area of anything inserted by FUNCTION.
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                details))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))
    result))

;;;###autoload
(defun diredp-do-command-in-marked-recursive (command &optional arg details) ; Bound to `M-+ @ M-x'
  "Invoke Emacs COMMAND in each marked file, including in marked subdirs.
Like ‘diredp-do-command-in-marked’ but act recursively on subdirs.
Errors invoking COMMAND are reported.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

A plain prefix arg (`C-u') means ignore all marks - include all files
in this Dired buffer and all subdirs, recursively.

Any other prefix arg is passed to COMMAND as its prefix arg.  For
example, if COMMAND uses a numeric prefix arg N for repetition then
the effect of COMMAND is repeated N times.

Other than the prefix arg, no arguments are passed to COMMAND.

When called from Lisp, optional arg DETAILS is passed to
‘diredp-get-files’.

Be aware that COMMAND could be invoked in a directory (Dired) buffer.
You may not want to do this if COMMAND modifies the buffer text.
\(But generally this will have little lasting effect - you can just
use `g' in that buffer to revert the listing.)"
  (interactive (progn (diredp-get-confirmation-recursive)
                      (list (diredp-read-command "Invoke Emacs command: ")
                            current-prefix-arg
                            diredp-list-file-attributes)))
  (unless (commandp command) (error "Not a command: `%s'" command))
  (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
              (= 0 (car (func-arity command))))
    (error "Command `%s' cannot accept zero args" command))
  (let* ((ignore-marks-p  (and (consp arg)  (< (car arg) 16)))
         (files           (diredp-get-files ignore-marks-p nil nil nil nil details))
         (count           (length files))
         (fbufs           (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs        (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs        ())
         (failures        ()))
    (diredp-maybe-save-visited files nil details)
    (dolist (file  files)
      (save-selected-window
        (condition-case err
            (with-current-buffer (find-file-noselect file)
              (save-excursion (goto-char (point-min))
                              (let ((current-prefix-arg  (and (not ignore-marks-p)  arg)))
                                (call-interactively command))))
          (error (dired-log "File: %s\n  %s\n" file (error-message-string err))
                 (setq failures  (cons file failures))))))
    (message nil)   ; Clear echo area of anything inserted there by COMMAND.
    (when failures
      (dired-log-summary (format "%d of %d failed" (length failures) count) failures))
    (setq new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                details))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))))

;;;; (defun diredp-do-invoke-in-marked-recursive (function &optional ignore-marks-p details) ; Bound to `M-+ @ M-@'
;;;;   "Invoke FUNCTION in each of the marked files, including in marked subdirs.
;;;; No arguments are passed to FUNCTION.
;;;;
;;;; Like `diredp-do-invoke-in-marked' but act recursively on subdirs, and
;;;; do no result-logging, error-logging, or echoing.
;;;;
;;;; The files included are those that are marked in the current Dired
;;;; buffer, or all files in the directory if none are marked.  Marked
;;;; subdirectories are handled recursively in the same way.
;;;;
;;;; With a prefix argument, ignore all marks - include all files in this
;;;; Dired buffer and all subdirs, recursively.
;;;;
;;;; When called from Lisp, optional arg DETAILS is passed to
;;;; `diredp-get-files'."
;;;;   (interactive
;;;;    (progn
;;;;      (diredp-get-confirmation-recursive)
;;;;      (list (read (completing-read "Invoke function: " obarray 'functionp nil nil
;;;;                                   (and (boundp 'function-name-history)  'function-name-history)))
;;;;            current-prefix-arg
;;;;            diredp-list-file-attributes)))
;;;;   (diredp-ensure-fn-zero-arity function)
;;;;   (let* ((files     (diredp-get-files ignore-marks-p nil nil nil nil details))
;;;;          (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
;;;;          (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
;;;;          (new-bufs  ())
;;;;          (result    ()))
;;;;     (diredp-maybe-save-visited files nil details)
;;;;     (setq result    (mapcar (lambda (file)
;;;;                               (with-current-buffer (find-file-noselect file)
;;;;                                 (save-excursion (goto-char (point-min)) (funcall function))))
;;;;                             files)
;;;;           new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
;;;;     (message nil) ; Clear echo area of anything inserted by invoking FUNCTION.
;;;;     (when (and new-bufs
;;;;                (diredp-y-or-n-files-p
;;;;                 "New buffers of visited files.  Kill some? "
;;;;                 (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
;;;;                 nil
;;;;                 details))
;;;;       (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
;;;;                     #'kill-buffer
;;;;                     new-bufs
;;;;                     '("buffer" "buffers" "kill")
;;;;                     save-some-buffers-action-alist))
;;;;     result))

;;;###autoload
(defun diredp-do-eval-in-marked-recursive (sexp &optional ignore-marks-p details) ; Bound to `M-+ @ M-:'
  "Evaluate SEXP in each of the marked files, including in marked subdirs.
Like `diredp-do-eval-in-marked' but act recursively on subdirs, and do
no result-logging, error-logging, or echoing.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive
   (progn (diredp-get-confirmation-recursive)
          (list (diredp-read-expression "Eval sexp: ")
                current-prefix-arg
                diredp-list-file-attributes)))
  (let* ((files     (diredp-get-files ignore-marks-p nil nil nil nil details))
         (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs  ())
         (result    ()))
    (diredp-maybe-save-visited files nil details)
    (setq result    (mapcar (lambda (file)
                              (with-current-buffer (find-file-noselect file)
                                (save-excursion (goto-char (point-min)) (eval-expression sexp))))
                            files)
          new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (message nil)       ; Clear echo area of anything inserted by evaluating SEXP.
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                details))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))
    result))

;;;###autoload
(defun diredp-do-apply/eval-marked-recursive (fun/sexp &optional arg details) ; Not bound
  "Apply a function to marked files, or evaluate a sexp in them.
Like `diredp-do-apply/eval-marked' but act recursively on subdirs, and do no
result--logging, error-logging or echoing.

The files acted on are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

With a plain prefix ARG (`C-u'), visit each file and eval the sexp or
 invoke the function there.  (The function is passed no arguments.)
Otherwise, apply the function to each file name.

With any other prefix arg, ignore all marks - apply the function to
each file in this Dired buffer and all subdirs, recursively.

When called from Lisp:
 ,* If ARG is `(4)' then invoke the function, or eval the sexp, while
   visiting each file.
 ,* Optional arg DETAILS is passed to `diredp-get-files'."
  (interactive
   (let ((use-no-args-p  (and (consp current-prefix-arg)  (< (car current-prefix-arg) 16))))
     (diredp-get-confirmation-recursive)
     (list (if use-no-args-p
               (diredp-read-expression "Invoke function or eval sexp: ")
             (read (completing-read "Apply function: " obarray 'functionp nil nil
                                    (and (boundp 'function-name-history)  'function-name-history))))
           current-prefix-arg
           diredp-list-file-attributes)))
  (let ((use-no-args-p  (and (consp current-prefix-arg)  (< (car current-prefix-arg) 16))))
    (if use-no-args-p
        (when (functionp fun/sexp)
          (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
                      (= 0 (car (func-arity fun/sexp))))
            (error "Function `%s' cannot accept zero args" fun/sexp))) ; Function to invoke in visited file.
      (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
                  (let ((max  (cdr (func-arity fun/sexp))))
                    (or (eq max 'many)  (> max 0))))
        (error "Function `%s' cannot accept any args" fun/sexp))) ; Function to apply to file name.
    (let* ((files     (diredp-get-files arg nil nil nil nil details)) ; @@@@ is ARG correct here? Copied from
           (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
           (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
           (new-bufs  ())
           (result    ()))
      (diredp-maybe-save-visited files nil details)
      (setq result    (if use-no-args-p
                          (mapcar (lambda (file)
                                    (with-current-buffer (find-file-noselect file)
                                      (save-excursion (goto-char (point-min))
                                                      (if (functionp fun/sexp)
                                                          (funcall fun/sexp)
                                                        (eval-expression fun/sexp)))))
                                  files)
                        (mapcar (lambda (file) (funcall fun/sexp file)) files))
            new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
      (message nil) ; Clear echo area of anything inserted by FUN/SEXP.
      (when (and new-bufs
                 (diredp-y-or-n-files-p
                  "New buffers of visited files.  Kill some? "
                  (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                  nil
                  details))
        (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                      #'kill-buffer
                      new-bufs
                      '("buffer" "buffers" "kill")
                      save-some-buffers-action-alist))
      result)))

;;;###autoload
(defun diredp-do-delete-recursive (arg &optional details) ; Bound to `M-+ D'
  "Delete marked (not flagged) files, including in marked subdirs.
Like `dired-do-delete' but act recursively on subdirs.

The files to be deleted are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files' and `diredp-get-subdirs'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (unless arg
    (ding)
    (message "NOTE: Deletion of files marked `%c' (not those flagged `%c')."
             dired-marker-char dired-del-marker))
  (let* ((files     (diredp-get-files nil nil nil nil 'ONLY-MARKED-P details))
         (count     (length files))
         (trashing  (and (boundp 'delete-by-moving-to-trash)  delete-by-moving-to-trash))
         (succ      0))
    (if (dired-mark-pop-up
         " *Deletions*" 'delete files dired-deletion-confirmer
         (format "%s %s " (if trashing "Trash" "Delete") (dired-mark-prompt arg files)))
        (let ((progress-reporter  (and (fboundp 'make-progress-reporter)
                                       (make-progress-reporter (if trashing "Trashing..." "Deleting...")
                                                               succ
                                                               count)))
              (failures           ()))
          (unless progress-reporter (message "Deleting..."))
          (dolist (file  files)
            (condition-case err
                (progn (if (fboundp 'dired-delete-file) ; Emacs 22+
                           (dired-delete-file file dired-recursive-deletes trashing)
                         ;; This test is equivalent to (and (file-directory-p file)  (not (file-symlink-p file)))
                         ;; but more efficient.
                         (if (eq t (car (file-attributes file))) (delete-directory file) (delete-file file)))
                       (setq succ  (1+ succ))
                       (when (fboundp 'progress-reporter-update)
                         (progress-reporter-update progress-reporter succ)))
              (error (dired-log "%s\n" err) ; Catch errors from failed deletions.
                     (setq failures  (cons file failures))))
            (dired-clean-up-after-deletion file))
          (if failures
              (dired-log-summary (format "%d of %d deletion%s failed"
                                         (length failures) count (dired-plural-s count))
                                 failures)
            (if (fboundp 'progress-reporter-done)
                (progress-reporter-done progress-reporter)
              (message "Deleting...done")))
          (let ((sdirs  (diredp-get-subdirs nil nil details))
                dbufs)
            (dolist (dir  (cons default-directory sdirs))
              (when (setq dbufs  (dired-buffers-for-dir (expand-file-name dir))) ; Dirs with Dired buffers only.
                (with-current-buffer (car dbufs) (dired-revert))))))
      (message "OK. NO deletions performed"))))

;;;###autoload
(defun diredp-do-move-recursive (&optional ignore-marks-p details) ; Bound to `M-+ R'
  "Move marked files, including in marked subdirs, to a given directory.
Like `dired-do-rename', but act recursively on subdirs to pick up the
files to move.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

This means move the marked files of marked subdirs and their marked
subdirs, etc.  It does not mean move or rename the subdirs themselves
recursively.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

Renames any buffers that are visiting the files.

The default suggested for the target directory depends on the value of
`dired-dwim-target', which see."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-do-create-files-recursive #'dired-rename-file "Move" ignore-marks-p details))

;;;###autoload
(defun diredp-do-copy-recursive (&optional ignore-marks-p details) ; Bound to `M-+ C'
  "Copy marked files, including in marked subdirs, to a given directory.
Like `dired-do-copy', but act recursively on subdirs to pick up the
files to copy.

The files included are those that are marked in the current Dired
buffer, or all files in the directory if none are marked.  Marked
subdirectories are handled recursively in the same way.

This means copy the marked files of marked subdirs and their marked
subdirs, etc.  It does not mean copy the subdirs themselves
recursively.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

Preserves the last-modified date when copying, unless
`dired-copy-preserve-time' is nil.

The default suggested for the target directory depends on the value of
`dired-dwim-target', which see.

This command copies symbolic links by creating new ones, like UNIX
command `cp -d'.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-create-files-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (let ((dired-recursive-copies  nil))  ; Doesn't have to be nil, but let's not go overboard now.
    (diredp-do-create-files-recursive #'dired-copy-file "Copy" ignore-marks-p details)))

(defun diredp-do-create-files-recursive (file-creator operation ignore-marks-p &optional details)
  "Create a new file for each marked file, including those in marked subdirs.
Like `dired-do-create-files', but act recursively on subdirs, and
always keep markings.
Prompts for the target directory, in which to create the files.
FILE-CREATOR and OPERATION are as in `dired-create-files'.
Non-nil IGNORE-MARKS-P means ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (lexical-let* ((fn-list     (diredp-get-files ignore-marks-p nil nil nil nil details))
                 (target-dir  (dired-dwim-target-directory))
                 (defaults    (and (fboundp 'dired-dwim-target-defaults) ; Emacs 23+
                                   (dired-dwim-target-defaults fn-list target-dir)))
                 (target      (expand-file-name
                               (if (fboundp 'minibuffer-with-setup-hook) ; Emacs 22+
                                   (minibuffer-with-setup-hook
                                    (lambda ()
                                      (set (make-local-variable 'minibuffer-default-add-function)
                                           nil)
                                      (setq minibuffer-default  defaults))
                                    (funcall (if (fboundp 'read-directory-name)
                                                 #'read-directory-name
                                               #'read-file-name)
                                             (concat operation " files to: ")
                                             default-directory default-directory))
                                 (funcall (if (fboundp 'read-directory-name)
                                              #'read-directory-name
                                            #'read-file-name)
                                          (concat operation "files to: ")
                                          default-directory default-directory)))))
    (unless (file-directory-p target) (error "Target is not a directory: `%s'" target))
    (dired-create-files
     file-creator operation fn-list
     #'(lambda (from) (expand-file-name (file-name-nondirectory from) target))
     ;; Hard-code `*' marker, or else it will be removed in lower dirs because the code uses
     ;; `dired-file-marker', which only works in the current Dired directory.
     ?*)))

(defun diredp-create-files-non-directory-recursive (file-creator basename-constructor operation
                                                    &optional ignore-marks-p details)
  "Apply FILE-CREATOR + BASENAME-CONSTRUCTOR to non-dir part of marked names.
Like `dired-create-files-non-directory', but act recursively on subdirs.

The files acted on are those marked in the current Dired buffer, or
all files in the directory if none are marked.  Marked subdirectories
are handled recursively in the same way.

With non-nil IGNORE-MARKS-P, ignore all marks - include all files in
this Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (let (rename-non-directory-query)
    (dired-create-files
     file-creator
     operation
     (diredp-get-files ignore-marks-p nil nil nil nil details)
     #'(lambda (from)
         (let ((to  (concat (file-name-directory from)
                            (funcall basename-constructor (file-name-nondirectory from)))))
           (and (let ((help-form  (format "\
Type SPC or `y' to %s one file, DEL or `n' to skip to next,
`!' to %s all remaining matches with no more questions."
                                          (downcase operation)
                                          (downcase operation))))
                  (dired-query 'rename-non-directory-query (concat operation " `%s' to `%s'")
                               (dired-make-relative from) (dired-make-relative to)))
                to)))
     ;; Hard-code `*' marker, or else it will be removed in lower dirs because the code uses
     ;; `dired-file-marker', which only works in the current Dired directory.
     ?*)))

(defun diredp-do-chxxx-recursive (attribute-name program op-symbol &optional ignore-marks-p default details)
  "Change attributes of the marked files, including those in marked subdirs.
Refresh their file lines.

Like `dired-do-chxxx', but act recursively on subdirs.  The subdirs
acted on are those that are marked in the current Dired buffer, or all
subdirs in the directory if none are marked.  Marked subdirectories
are handled recursively in the same way.

ATTRIBUTE-NAME is a string describing the attribute to the user.
PROGRAM is the program used to change the attribute.
OP-SYMBOL is the type of operation (for use in `dired-mark-pop-up').
Non-nil IGNORE-MARKS-P means ignore all marks - include all files in this
 Dired buffer and all subdirs, recursively.
DEFAULT is the default value for reading the mark string.
DETAILS is passed to `diredp-get-files' and
 `diredp-do-redisplay-recursive'."
  (let* ((this-buff      (current-buffer))
         (files          (diredp-get-files ignore-marks-p nil nil nil nil details))
         (prompt         (concat "Change " attribute-name " of %s to: "))
         (new-attribute  (if (> emacs-major-version 22)
                             (dired-mark-read-string prompt nil op-symbol ignore-marks-p files default)
                           (dired-mark-read-string prompt nil op-symbol ignore-marks-p files)))
         (operation      (concat program " " new-attribute))
         failures)
    (setq failures  (dired-bunch-files 10000 (function dired-check-process)
                                       (append (list operation program)
                                               (unless (string-equal new-attribute "")
                                                 (if (equal attribute-name "Timestamp")
                                                     (list "-t" new-attribute)
                                                   (list new-attribute)))
                                               (and (diredp-string-match-p "gnu" system-configuration)
                                                    '("--"))) ; --------------------------------
                                       files))
    (with-current-buffer this-buff (diredp-do-redisplay-recursive details 'MSGP))
    (when failures (dired-log-summary (format "%s: error" operation) nil))))

;;;###autoload
(defun diredp-do-chmod-recursive (&optional ignore-marks-p details) ; Bound to `M-+ M'
  "Change the mode of the marked files, including those in marked subdirs.
Symbolic modes like `g+w' are allowed.

Note that marked subdirs are not changed.  Their markings are used only
to indicate that some of their files are to be changed.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files' and `diredp-do-redisplay-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (let* ((files    (diredp-get-files ignore-marks-p nil nil nil nil details))
         (modestr  (and (stringp (car files))  (nth 8 (file-attributes (car files)))))
         (default  (and (stringp modestr)
                        (string-match "^.\\(...\\)\\(...\\)\\(...\\)$" modestr)
                        (replace-regexp-in-string "-" "" (format "u=%s,g=%s,o=%s"
                                                                 (match-string 1 modestr)
                                                                 (match-string 2 modestr)
                                                                 (match-string 3 modestr)))))
         (modes    (if (> emacs-major-version 22)
                       (dired-mark-read-string
                        "Change mode of marked files here and below to: " nil 'chmod nil files default)
                     (dired-mark-read-string
                      "Change mode of marked files here and below to: " nil 'chmod nil files))))
    (when (equal modes "") (error "No file mode specified"))
    (dolist (file  files)
      (set-file-modes file (or (and (diredp-string-match-p "^[0-7]+" modes)  (string-to-number modes 8))
                               (file-modes-symbolic-to-number modes (file-modes file)))))
    (diredp-do-redisplay-recursive details 'MSGP)))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-do-chgrp-recursive (&optional ignore-marks-p details)
    "Change the group of the marked (or next ARG) files.
With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-chxxx-recursive'."
    (interactive (list current-prefix-arg diredp-list-file-attributes))
    (diredp-do-chxxx-recursive "Group" "chgrp" 'chgrp ignore-marks-p nil details)))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-do-chown-recursive (&optional ignore-marks-p details)
    "Change the owner of the marked (or next ARG) files.
With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-chxxx-recursive'."
    (interactive (list current-prefix-arg diredp-list-file-attributes))
    (diredp-do-chxxx-recursive "Owner" dired-chown-program 'chown ignore-marks-p nil details)))

;;;###autoload
(defun diredp-do-touch-recursive (&optional ignore-marks-p details)
  "Change the timestamp of marked files, including those in marked subdirs.
This calls `touch'.  Like `dired-do-touch', but act recursively on
subdirs.  The subdirs inserted are those that are marked in the
current Dired buffer, or all subdirs in the directory if none are
marked.  Marked subdirectories are handled recursively in the same
way.

With a prefix argument, ignore all marks - include all files in this
Dired buffer and all subdirs, recursively.

When called from Lisp, optional arg DETAILS is passed to
`diredp-do-chxxx-recursive'."
  (interactive (progn (diredp-get-confirmation-recursive) (list current-prefix-arg diredp-list-file-attributes)))
  (diredp-do-chxxx-recursive "Timestamp" (if (boundp 'dired-touch-program)
                                             dired-touch-program ; Emacs 22+
                                           "touch")
                             'touch
                             ignore-marks-p
                             (format-time-string "%Y%m%d%H%M.%S" (current-time))
                             details))

;;;###autoload
(defun diredp-do-redisplay-recursive (&optional details msgp)
  "Redisplay marked file lines, including those in marked subdirs.
Non-nil MSGP means show status messages.
Like `dired-do-redisplay' with no args, but act recursively on
subdirs.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (progn (diredp-ensure-mode)
                      (unless (y-or-n-p "Act on all marked file lines in and UNDER this dir? ")
                        (error "OK, canceled"))
                      (list diredp-list-file-attributes t)))
  (when msgp (message "Redisplaying..."))
  (dolist (dir  (cons default-directory
                      (diredp-get-files nil #'file-directory-p 'INCLUDE-SUBDIRS 'DONT-ASK nil details)))
    (with-current-buffer (dired-noselect dir)
      ;; `message' is much faster than making `dired-map-over-marks' show progress
      (dired-uncache (if (consp dired-directory) (car dired-directory) dired-directory))
      (dired-map-over-marks
       (let ((fname                    (dired-get-filename))
             ;; Postpone readin hook till we map over all marked files (Bug#6810).
             (dired-after-readin-hook  nil))
         (message "Redisplaying... %s" fname)
         (dired-update-file-line fname))
       nil)
      (run-hooks 'dired-after-readin-hook)
      (dired-move-to-filename)))
  (when msgp (message "Redisplaying...done")))

;;;###autoload
(defun diredp-change-ls-switches (switches)
  "Change `ls' switches for the current Dired buffer.
The prompt for the new switches shows the current switches, for info.
Possible default values (`M-n') are, in order:
 1. `dired-listing-switches' - your default switches for Dired
 2. `dired-subdir-switches' - your switches for subdir listings
 3. Current switches for this buffer (just reverts the listing)"
  (interactive
   (list (read-string
          (format "New ls switches - must contain -l (current: %s): " dired-actual-switches)
          nil
          'diredp-switches-history
          (diredp-delete-dups (delq nil (list dired-listing-switches dired-subdir-switches dired-actual-switches )))
          t)))
  (dired-sort-other switches))


;;; `diredp-marked(-other-window)' tries to treat SWITCHES, but SWITCHES seems to be ignored
;;; by `dired' when the DIRNAME arg is a cons, at least on MS Windows.  I filed Emacs bug #952
;;; on 2008-09-10, but this doesn't work in Emacs 20, 21, 22, or 23, so I don't know if it will
;;; ever be fixed.  If it is declared a non-bug and it doesn't work on any platforms, then I'll
;;; remove SWITCHES here, alas.

;;;###autoload
(defun diredp-marked (dirname &optional n switches) ; Not bound
  "Open Dired on only the marked files or the next N files.
With a non-zero numeric prefix arg N, use the next abs(N) files.
A plain (`C-u'), zero, or negative prefix arg prompts for listing
switches as in command `dired'.

Note that the marked files can include files in inserted
subdirectories, so the Dired buffer that is opened can contain files
from multiple directories in the same tree."
  (interactive (progn (diredp-ensure-mode)
                      (let ((num  (and current-prefix-arg
                                       (atom current-prefix-arg)
                                       (not (zerop (prefix-numeric-value current-prefix-arg)))
                                       (abs (prefix-numeric-value current-prefix-arg)))))
                        (list (cons (generate-new-buffer-name (buffer-name)) (dired-get-marked-files t num))
                              num
                              (and current-prefix-arg ; Switches
                                   (or (consp current-prefix-arg)
                                       (< (prefix-numeric-value current-prefix-arg) 0))
                                   (read-string "Dired listing switches: " dired-listing-switches))))))
  (unless (or n  (save-excursion (goto-char (point-min))
                                 (and (re-search-forward (dired-marker-regexp) nil t)
                                      (re-search-forward (dired-marker-regexp) nil t))))
    (error "No marked files"))
  (dired dirname switches))

;;;###autoload
(defun diredp-marked-other-window (dirname &optional n switches) ; Bound to `C-M-*'
  "Same as `diredp-marked', but uses a different window."
  (interactive (progn (diredp-ensure-mode)
                      (let ((num  (and current-prefix-arg
                                       (atom current-prefix-arg)
                                       (not (zerop (prefix-numeric-value current-prefix-arg)))
                                       (abs (prefix-numeric-value current-prefix-arg)))))
                        (list (cons (generate-new-buffer-name (buffer-name)) (dired-get-marked-files t num))
                              num
                              (and current-prefix-arg ; Switches
                                   (or (consp current-prefix-arg)
                                       (< (prefix-numeric-value current-prefix-arg) 0))
                                   (read-string "Dired listing switches: " dired-listing-switches))))))
  (unless (or n  (save-excursion (goto-char (point-min))
                                 (and (re-search-forward (dired-marker-regexp) nil t)
                                      (re-search-forward (dired-marker-regexp) nil t))))
    (error "No marked files"))
  (dired-other-window dirname switches))


;; Similar to `dired-mark-extension' in `dired-x.el'.
;; The difference is that this uses prefix arg to unmark, not to determine the mark character.
;;;###autoload
(defun diredp-mark/unmark-extension (extension &optional unmark-p) ; Bound to `* .'
  "Mark all files with a certain EXTENSION for use in later commands.
A `.' is not automatically prepended to the string entered.
Non-nil prefix argument UNMARK-P means unmark instead of mark.

Non-interactively, EXTENSION is the extension (a string).  It can also
  be a list of extension strings.
Optional argument UNMARK-P is the prefix arg."
  (interactive (list (diredp-read-regexp (concat (if current-prefix-arg "UNmark" "Mark") "ing extension: "))
                     current-prefix-arg))
  (or (listp extension)  (setq extension  (list extension)))
  (dired-mark-files-regexp (concat ".";; Do not match names with nothing but an extension
                                   "\\("
                                   (mapconcat #'regexp-quote extension "\\|")
                                   "\\)$")
                           (and current-prefix-arg  ?\040)))

(defun diredp-mark-files-tagged-all/none (tags &optional none-p unmarkp prefix)
  "Mark or unmark files tagged with all or none of TAGS.
TAGS is a list of strings, the tag names.
NONEP non-nil means mark/unmark files that have none of the TAGS.
UNMARKP non-nil means unmark; nil means mark.
PREFIX non-nil is the prefix of the autofile bookmarks to check.

As a special case, if TAGS is empty, then mark or unmark the files
that have any tags at all, or if NONEP is non-nil then mark or unmark
those that have no tags at all."
  (let ((dired-marker-char  (if unmarkp ?\040 dired-marker-char)))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                         (let* ((fname     (dired-get-filename nil 'NO-ERROR))
                                (bmk       (and fname  (bmkp-get-autofile-bookmark fname nil prefix)))
                                (btgs      (and bmk  (bmkp-get-tags bmk)))
                                (presentp  nil)
                                (allp      (and btgs  (catch 'diredp-m-f-t-an
                                                        (dolist (tag  tags)
                                                          (setq presentp  (assoc-default tag btgs nil t))
                                                          (unless (if none-p (not presentp) presentp)
                                                            (throw 'diredp-m-f-t-an nil)))
                                                        t))))
                           (if (null tags)
                               (if none-p (not btgs) btgs)
                             allp)))
                    (if none-p "no-tags-matching file" "all-tags-matching file"))))

(defun diredp-mark-files-tagged-some/not-all (tags &optional notallp unmarkp prefix)
  "Mark or unmark files tagged with any or not all of TAGS.
TAGS is a list of strings, the tag names.
NOTALLP non-nil means mark/unmark files that do not have all TAGS.
UNMARKP non-nil means unmark; nil means mark.
PREFIX non-nil is the prefix of the autofile bookmarks to check.

As a special case, if TAGS is empty, then mark or unmark the files
that have any tags at all, or if NOTALLP is non-nil then mark or
unmark those that have no tags at all."
  (let ((dired-marker-char  (if unmarkp ?\040 dired-marker-char)))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                         (let* ((fname     (dired-get-filename nil 'NO-ERROR))
                                (bmk       (and fname
                                                (bmkp-get-autofile-bookmark fname nil prefix)))
                                (btgs      (and bmk  (bmkp-get-tags bmk)))
                                (presentp  nil)
                                (allp      (and btgs  (catch 'diredp-m-f-t-sna
                                                        (dolist (tag  tags)
                                                          (setq presentp  (assoc-default tag btgs nil t))
                                                          (when (if notallp (not presentp) presentp)
                                                            (throw 'diredp-m-f-t-sna t)))
                                                        nil))))
                           (if (null tags) (if notallp (not btgs) btgs) allp)))
                    (if notallp "some-tags-not-matching file" "some-tags-matching file"))))

;;;###autoload
(defun diredp-mark-files-tagged-all (tags &optional none-p prefix) ; `T m *'
  "Mark all files that are tagged with *each* tag in TAGS.
As a special case, if TAGS is empty, then mark the files that have
 any tags at all (i.e., at least one tag).
With a prefix arg, mark all that are *not* tagged with *any* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-all/none tags none-p nil prefix))

;;;###autoload
(defun diredp-mark-files-tagged-none (tags &optional allp prefix) ; `T m ~ +'
  "Mark all files that are not tagged with *any* tag in TAGS.
As a special case, if TAGS is empty, then mark the files that have
 no tags at all.
With a prefix arg, mark all that are tagged with *each* tag in TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-all/none tags (not allp) nil prefix))

;;;###autoload
(defun diredp-mark-files-tagged-some (tags &optional somenotp prefix) ; `T m +'
  "Mark all files that are tagged with *some* tag in TAGS.
As a special case, if TAGS is empty, then mark the files that have
 any tags at all (i.e., at least one tag).
With a prefix arg, mark all that are *not* tagged with *all* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-some/not-all tags somenotp nil prefix))

;;;###autoload
(defun diredp-mark-files-tagged-not-all (tags &optional somep prefix) ; `T m ~ *'
  "Mark all files that are not tagged with *all* TAGS.
As a special case, if TAGS is empty, then mark the files that have
 no tags at all.
With a prefix arg, mark all that are tagged with *some* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-some/not-all tags (not somep) nil prefix))

;;;###autoload
(defun diredp-mark-files-tagged-regexp (regexp &optional notp prefix) ; `T m %'
  "Mark files that have at least one tag that matches REGEXP.
With a prefix arg, mark all that are tagged but have no matching tags.
You need library `bookmark+.el' to use this command."
  (interactive (list (read-string "Regexp: ")
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                       (lexical-let* ((fname  (dired-get-filename nil 'NO-ERROR))
                                      (bmk    (and fname
                                                   (bmkp-get-autofile-bookmark fname nil prefix)))
                                      (btgs   (and bmk  (bmkp-get-tags bmk)))
                                      (anyp   (and btgs  (bmkp-some #'(lambda (tag)
                                                                        (diredp-string-match-p
                                                                         regexp
                                                                         (bmkp-tag-name tag)))
                                                                    btgs))))
                         (and btgs  (if notp (not anyp) anyp))))
                  "some-tag-matching-regexp file"))

;;;###autoload
(defun diredp-unmark-files-tagged-regexp (regexp &optional notp prefix) ; `T u %'
  "Unmark files that have at least one tag that matches REGEXP.
With a prefix arg, unmark all that are tagged but have no matching tags.
You need library `bookmark+.el' to use this command."
  (interactive (list (read-string "Regexp: ")
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (let ((dired-marker-char  ?\040))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                         (lexical-let* ((fname  (dired-get-filename nil 'NO-ERROR))
                                        (bmk    (and fname  (bmkp-get-autofile-bookmark fname nil prefix)))
                                        (btgs   (and bmk  (bmkp-get-tags bmk)))
                                        (anyp   (and btgs (bmkp-some #'(lambda (tag)
                                                                         (diredp-string-match-p
                                                                          regexp
                                                                          (bmkp-tag-name tag)))
                                                                     btgs))))
                           (and btgs  (if notp (not anyp) anyp))))
                    "some-tag-matching-regexp file")))

;;;###autoload
(defun diredp-unmark-files-tagged-all (tags &optional none-p prefix) ; `T u *'
  "Unmark all files that are tagged with *each* tag in TAGS.
As a special case, if TAGS is empty, then unmark the files that have
 any tags at all (i.e., at least one tag).
With a prefix arg, unmark all that are *not* tagged with *any* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-all/none tags none-p 'UNMARK prefix))

;;;###autoload
(defun diredp-unmark-files-tagged-none (tags &optional allp prefix) ; `T u ~ +'
  "Unmark all files that are *not* tagged with *any* tag in TAGS.
As a special case, if TAGS is empty, then unmark the files that have
 no tags at all.
With a prefix arg, unmark all that are tagged with *each* tag in TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-all/none tags (not allp) 'UNMARK prefix))

;;;###autoload
(defun diredp-unmark-files-tagged-some (tags &optional somenotp prefix) ; `T u +'
  "Unmark all files that are tagged with *some* tag in TAGS.
As a special case, if TAGS is empty, then unmark the files that have
 any tags at all.
With a prefix arg, unmark all that are *not* tagged with *all* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-some/not-all tags somenotp 'UNMARK prefix))

;;;###autoload
(defun diredp-unmark-files-tagged-not-all (tags &optional somep prefix) ; `T u ~ *'
  "Unmark all files that are *not* tagged with *all* TAGS.
As a special case, if TAGS is empty, then unmark the files that have
 no tags at all.
With a prefix arg, unmark all that are tagged with *some* TAGS.
You need library `bookmark+.el' to use this command."
  (interactive (list (and (fboundp 'bmkp-read-tags-completing)  (bmkp-read-tags-completing))
                     current-prefix-arg
                     (and diredp-prompt-for-bookmark-prefix-flag
                          (read-string "Prefix for autofile bookmark names: "))))
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark-files-tagged-some/not-all tags (not somep) 'UNMARK prefix))

;;;###autoload
(defun diredp-do-tag (tags &optional prefix arg) ; `T > +'
  "Tag the marked (or the next prefix argument) files.
You need library `bookmark+.el' to use this command.

Hit `RET' to enter each tag, then hit `RET' again after the last tag.
You can use completion to enter each tag.  Completion is lax: you are
not limited to existing tags.

TAGS is a list of strings.  PREFIX is as for `diredp-do-bookmark'.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (bmkp-read-tags-completing)
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for autofile bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((pref  prefix)) #'(lambda () (diredp-tag tags pref)))
                              arg 'tag (diredp-fewer-than-2-files-p arg)))

(defun diredp-tag (tags &optional prefix)
  "Add tags to the file or directory named on the current line.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (bmkp-autofile-add-tags file tags nil prefix)
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-tag (event)      ; Not bound
  "In Dired, add some tags to this file.
Like `diredp-do-tag', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-tag (bmkp-read-tags-completing) prefix)) 1 'tag t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-do-untag (tags &optional prefix arg) ; `T > -'
  "Remove some tags from the marked (or the next prefix arg) files.
You need library `bookmark+.el' to use this command.

Hit `RET' to enter each tag, then hit `RET' again after the last tag.
You can use completion to enter each tag.  Completion is lax: you are
not limited to existing tags.

TAGS is a list of strings.  PREFIX is as for `diredp-do-bookmark'.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (bmkp-read-tags-completing)
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((pref  prefix)) #'(lambda () (diredp-untag tags pref)))
                              arg 'untag (diredp-fewer-than-2-files-p arg)))

(defun diredp-untag (tags &optional prefix)
  "Remove some tags from the file or directory named on the current line.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (bmkp-autofile-remove-tags file tags nil prefix)
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-untag (event)    ; Not bound
  "In Dired, remove some tags from this file.
Like `diredp-do-untag', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (lexical-let* ((bmk   (bmkp-get-autofile-bookmark  (dired-get-filename) nil prefix))
                   (btgs  (and bmk  (bmkp-get-tags bmk))))
      (unless btgs (error "File has no tags to remove"))
      (dired-map-over-marks-check #'(lambda () (diredp-untag (bmkp-read-tags-completing btgs) prefix)) 1 'untag t)))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-do-remove-all-tags (&optional prefix arg) ; `T > 0'
  "Remove all tags from the marked (or the next prefix arg) files.
You need library `bookmark+.el' to use this command.

PREFIX is as for `diredp-do-bookmark'.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            current-prefix-arg)))
  (lexical-let ((pref  prefix))
    (dired-map-over-marks-check #'(lambda () (diredp-remove-all-tags pref)) arg 'remove-all-tags
                                (diredp-fewer-than-2-files-p arg))))

(defun diredp-remove-all-tags (&optional prefix)
  "Remove all tags from the file or directory named on the current line.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (bmkp-remove-all-tags (bmkp-autofile-set file nil prefix))
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-remove-all-tags (event) ; Not bound
  "In Dired, remove all tags from the marked (or next prefix arg) files.
Like `diredp-do-remove-all-tags', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-remove-all-tags prefix)) 1 'remove-all-tags t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-do-paste-add-tags (&optional prefix arg) ; `T > p', `T > C-y'
  "Add previously copied tags to the marked (or next prefix arg) files.
The tags were previously copied from a file to `bmkp-copied-tags'.
You need library `bookmark+.el' to use this command.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for autofile bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((pref  prefix))
                                #'(lambda () (diredp-paste-add-tags pref)))
                              arg 'paste-add-tags
                              (diredp-fewer-than-2-files-p arg)))

(defun diredp-paste-add-tags (&optional prefix)
  "Add previously copied tags to the file or directory on the current line.
The tags were previously copied from a file to `bmkp-copied-tags'.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (bmkp-autofile-add-tags file bmkp-copied-tags nil prefix)
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-paste-add-tags (event) ; Not bound
  "In Dired, add previously copied tags to this file.
The tags were previously copied from a file to `bmkp-copied-tags'.
Like `diredp-do-paste-add-tags', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-paste-add-tags prefix))
                                1 'paste-add-tags t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-do-paste-replace-tags (&optional prefix arg) ; `T > q'
  "Replace tags for marked (or next prefix arg) files with copied tags.
The tags were previously copied from a file to `bmkp-copied-tags'.
You need library `bookmark+.el' to use this command.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for autofile bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((pref  prefix))
                                #'(lambda () (diredp-paste-replace-tags pref)))
                              arg 'paste-replace-tags (diredp-fewer-than-2-files-p arg)))

(defun diredp-paste-replace-tags (&optional prefix)
  "Replace tags for this file or dir with tags copied previously.
The tags were previously copied from a file to `bmkp-copied-tags'.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (progn (bmkp-remove-all-tags (bmkp-autofile-set file nil prefix))
               (bmkp-autofile-add-tags file bmkp-copied-tags nil prefix))
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-paste-replace-tags (event) ; Not bound
  "In Dired, replace tags for this file with tags copied previously.
The tags were previously copied from a file to `bmkp-copied-tags'.
Like `diredp-do-paste-replace-tags', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-paste-replace-tags prefix))
                                1 'paste-replace-tags t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-do-set-tag-value (tag value &optional prefix arg) ; `T > v'
  "Set TAG value to VALUE, for the marked (or next prefix arg) files.
This does not change the TAG name.
You need library `bookmark+.el' to use this command.

PREFIX is as for `diredp-do-bookmark'.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (bmkp-read-tag-completing)
                            (read (read-string "Value: "))
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((tg    tag)
                                            (val   value)
                                            (pref  prefix))
                                #'(lambda () (diredp-set-tag-value tg val pref)))
                              arg 'set-tag-value (diredp-fewer-than-2-files-p arg)))

(defun diredp-set-tag-value (tag value &optional prefix)
  "Set TAG value to VALUE for this file or directory.
This does not change the TAG name.
You need library `bookmark+.el' to use this function.
The bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Return nil for success, file name otherwise."
  (bookmark-maybe-load-default-file)
  (let ((file  (dired-get-file-for-visit))
        failure)
    (condition-case err
        (bmkp-set-tag-value (bmkp-autofile-set file nil prefix) tag value)
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;;;###autoload
(defun diredp-mouse-do-set-tag-value (event) ; Not bound
  "In Dired, set the value of a tag for this file.
This does not change the tag name.
Like `diredp-do-set-tag-value', but invoked using the mouse.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-set-tag-value (bmkp-read-tag-completing)
                                                                   (read (read-string "Value: "))
                                                                   prefix))
                                1 'set-tag-value t))
  (diredp-previous-line 1))


;; Define these even if `Bookmark+' is not loaded.
;;;###autoload
(defun diredp-mark-autofiles ()         ; Bound to `* B'
  "Mark all autofiles, that is, files that have an autofile bookmark."
  (interactive)
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark/unmark-autofiles))

;;;###autoload
(defun diredp-unmark-autofiles ()
  "Unmark all autofiles, that is, files that have an autofile bookmark."
  (interactive)
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (diredp-mark/unmark-autofiles t))

;;;###autoload
(defun diredp-mark/unmark-autofiles (&optional unmarkp)
  "Mark all autofiles, or unmark if UNMARKP is non-nil."
  (let ((dired-marker-char  (if unmarkp ?\040 dired-marker-char)))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))  (not (eolp))
                         (let ((fname  (dired-get-filename nil 'NO-ERROR)))
                           (and fname  (bmkp-get-autofile-bookmark fname))))
                    "autofile")))

(when (and (fboundp 'bmkp-get-autofile-bookmark) ; Defined in `bookmark+-1.el'.
           (fboundp 'hlt-highlight-region)) ; Defined in `highlight.el'.

  (defun diredp-highlight-autofiles ()
    "Highlight files that are autofile bookmarks.
Highlighting uses face `diredp-autofile-name'."
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward dired-move-to-filename-regexp nil t)
        ;; If Dired details are hidden the match data gets changed.
        (let* ((bmk    (save-match-data
                         (bmkp-get-autofile-bookmark (buffer-substring (match-end 0) (line-end-position)))))
               (tags  (and bmk  (bmkp-get-tags bmk))))
          (when bmk
            (hlt-highlight-region (match-end 0) (line-end-position)
                                  (if tags
                                      'diredp-tagged-autofile-name
                                    'diredp-autofile-name)))))))

  (cond ((fboundp 'define-minor-mode)
         ;; Emacs 21+.  Use `eval' so that even if the library is byte-compiled with Emacs 20,
         ;; loading it into Emacs 21+ will define variable `diredp-highlight-autofiles-mode'.
         (eval '(define-minor-mode diredp-highlight-autofiles-mode
                 "Toggle automatic highlighting of autofile bookmarks.
When you turn this on, it ensures that your bookmark file is loaded.

NOTE: This mode is ON BY DEFAULT.  More precisely, when `dired+.el' is
loaded (for the first time per Emacs session), the mode is turned ON.
To prevent this and have the mode OFF by default, you must do one of
the following:

 ,* Put (diredp-highlight-autofiles-mode -1) in your init file, AFTER
   it loads `dired+.el'.

 ,* Customize option `diredp-highlight-autofiles-mode' to `nil', AND
   ensure that your `custom-file' (or the `custom-saved-variables'
   part of your init file) is evaluated before `dired+.el' is loaded.

You need libraries `Bookmark and `highlight.el' for this command."
                 :init-value t :global t :group 'Dired-Plus :require 'dired+
                 (if (not diredp-highlight-autofiles-mode)
                     (remove-hook 'dired-after-readin-hook #'diredp-highlight-autofiles)
                   (add-hook 'dired-after-readin-hook #'diredp-highlight-autofiles)
                   (bookmark-maybe-load-default-file))
                 (when (derived-mode-p 'dired-mode) (dired-revert nil nil))
                 (when (interactive-p)
                   (message "Dired highlighting of autofile bookmarks is now %s"
                            (if diredp-highlight-autofiles-mode "ON" "OFF"))))))
        (t;; Emacs 20.
         (defun diredp-highlight-autofiles-mode (&optional arg)
           "Toggle automatic highlighting of autofile bookmarks.
When you turn this on, it ensures that your bookmark file is loaded.

NOTE: This mode is ON BY DEFAULT.  More precisely, when `dired+.el' is
loaded (for the first time per Emacs session), the mode is turned ON.
To prevent this and have the mode OFF by default, you must do one of
the following:

 ,* Put (diredp-highlight-autofiles-mode -1) in your init file, AFTER
   it loads `dired+.el'.

 ,* Customize option `diredp-highlight-autofiles-mode' to `nil', AND
   ensure that your `custom-file' (or the `custom-saved-variables'
   part of your init file) is evaluated before `dired+.el' is loaded.

You need libraries `Bookmark and `highlight.el' for this command."
           (interactive (list (or current-prefix-arg  'toggle)))
           (setq diredp-highlight-autofiles-mode  (if (eq arg 'toggle)
                                                      (not diredp-highlight-autofiles-mode)
                                                    (> (prefix-numeric-value arg) 0)))
           (if (not diredp-highlight-autofiles-mode)
               (remove-hook 'dired-after-readin-hook #'diredp-highlight-autofiles)
             (add-hook 'dired-after-readin-hook #'diredp-highlight-autofiles)
             (bookmark-maybe-load-default-file))
           (when (derived-mode-p 'dired-mode) (dired-revert nil nil))
           (when (interactive-p) (message "Dired highlighting of autofile bookmarks is now %s"
                                          (if diredp-highlight-autofiles-mode "ON" "OFF"))))))

  ;; Turn it ON BY DEFAULT.
  (unless (or (boundp 'diredp-loaded-p)  (get 'diredp-highlight-autofiles-mode 'saved-value))
    (diredp-highlight-autofiles-mode 1))
  )

;;;###autoload
(defun diredp-do-bookmark (&optional prefix arg) ; Bound to `M-b'
  "Bookmark the marked (or the next prefix argument) files.
Each bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Interactively, you are prompted for the PREFIX if
 `diredp-prompt-for-bookmark-prefix-flag' is non-nil.
The bookmarked position is the beginning of the file.
If you use library `bookmark+.el' then the bookmark is an autofile.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (progn (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            current-prefix-arg)))
  (dired-map-over-marks-check (lexical-let ((pref  prefix))
                                #'(lambda () (diredp-bookmark pref nil 'NO-MSG-P)))
                              arg 'bookmark (diredp-fewer-than-2-files-p arg)))

;;;###autoload
(defun diredp-mouse-do-bookmark (event) ; Not bound
  "In Dired, bookmark this file.  See `diredp-do-bookmark'.
Like `diredp-do-bookmark', but invoked using the mouse."
  (interactive "e")
  (lexical-let ((mouse-pos         (event-start event))
                (dired-no-confirm  t)
                (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                        (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'(lambda () (diredp-bookmark prefix nil)) nil 'bookmark t))
  (diredp-previous-line 1))

(defun diredp-bookmark (&optional prefix file no-msg-p)
  "Bookmark the file or directory FILE.
If you use library `bookmark+.el' then the bookmark is an autofile.
Return nil for success or the file name otherwise.

The bookmark name is the (non-directory) file name, prefixed by
 optional arg PREFIX (a string) if non-nil.

FILE defaults to the file name on the current Dired line.

Non-nil optional arg NO-MSG-P means do not show progress messages."
  (bookmark-maybe-load-default-file)
  (let ((fil      (or file  (dired-get-file-for-visit)))
        (failure  nil))
    (condition-case err
        (if (fboundp 'bmkp-autofile-set) ; Bookmark+ - just set an autofile bookmark.
            (bmkp-autofile-set fil nil prefix nil (not no-msg-p))
          ;; Vanilla `bookmark.el' (or very old Bookmark+ version).
          (let ((bookmark-make-record-function
                 (cond ((and (require 'image nil t)  (require 'image-mode nil t)
                             (condition-case nil (image-type fil) (error nil)))
                        ;; Last two lines of function are from `image-bookmark-make-record'.
                        ;; But don't use that directly, because it uses
                        ;; `bookmark-make-record-default', which gets nil for `filename'.
                        (lambda ()
                          `((filename   . ,fil)
                            (position   . 0)
                            ;; NEED to keep this part of code sync'd with `bmkp-make-record-for-target-file'.
                            (image-type . ,(image-type fil))
                            (handler    . image-bookmark-jump)))) ; In `image-mode.el'.
                       (t
                        (lambda ()
                          `((filename . ,fil)
                            (position . 0)))))))
            (bookmark-store (concat prefix (file-name-nondirectory fil)) (cdr (bookmark-make-record)) nil)))
      (error (setq failure  (error-message-string err))))
    (if (not failure)
        nil                             ; Return nil for success.
      (if (fboundp 'bmkp-autofile-set)
          (dired-log failure)
        (dired-log "Failed to create bookmark for `%s':\n%s\n" fil failure))
      (dired-make-relative fil))))      ; Return file name for failure.

;;;###autoload
(defun diredp-set-bookmark-file-bookmark-for-marked (bookmark-file ; Bound to `C-M-b'
                                                     &optional prefix arg)
  "Bookmark the marked files and create a bookmark-file bookmark for them.
The bookmarked position is the beginning of the file.
Jumping to the bookmark-file bookmark loads the set of file bookmarks.
You need library `bookmark+.el' to use this command.

Each bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Interactively, you are prompted for PREFIX if
 `diredp-prompt-for-bookmark-prefix-flag' is non-nil.

A prefix argument ARG specifies files to use instead of those marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories.

You are also prompted for the bookmark file, BOOKMARK-FILE.  The
default is `.emacs.bmk' in the current directory, but you can enter
any file name, anywhere.

The marked-file bookmarks are added to file BOOKMARK-FILE, but this
command does not make BOOKMARK-FILE the current bookmark file.  To
make it current, just jump to the bookmark-file bookmark created by
this command.  That bookmark (which bookmarks BOOKMARK-FILE) is
defined in that current bookmark file.

Example:

 Bookmark file `~/.emacs.bmk' is current before invoking this command.
 The current (Dired) directory is `/foo/bar'.
 The marked files are bookmarked in the (possibly new) bookmark file
   `/foo/bar/.emacs.bmk'.
 The bookmarks for the marked files have names prefixed by `FOOBAR '.
 The name of the bookmark-file bookmark is `Foobar Files'.
 Bookmark `Foobar Files' is itself in bookmark file `~/.emacs.bmk'.
 Bookmark file `~/.emacs.bmk' is current after invoking this command.

You are prompted for the name of the bookmark-file bookmark, the
BOOKMARK-FILE for the marked-file bookmarks, and a PREFIX string for
each of the marked-file bookmarks.

See also command `diredp-do-bookmark-in-bookmark-file'."
  (interactive (diredp-read-bookmark-file-args))
  (diredp-ensure-bookmark+)
  (diredp-do-bookmark-in-bookmark-file bookmark-file prefix arg 'CREATE-BOOKMARK-FILE-BOOKMARK))

;;;###autoload
(defun diredp-do-bookmark-in-bookmark-file (bookmark-file ; Bound to `C-M-B' (aka `C-M-S-b')
                                            &optional prefix arg bfile-bookmarkp files)
  "Bookmark marked files in BOOKMARK-FILE and save BOOKMARK-FILE.
The files bookmarked are the marked files, by default.
The bookmarked position is the beginning of the file.
You are prompted for BOOKMARK-FILE.  The default is `.emacs.bmk' in
the current directory, but you can enter any file name, anywhere.
You need library `bookmark+.el' to use this command.

The marked files are bookmarked in file BOOKMARK-FILE, but this
command does not make BOOKMARK-FILE the current bookmark file.  To
make it current, use `\\[bmkp-switch-bookmark-file]' (`bmkp-switch-bookmark-file').

Each bookmark name is the non-directory portion of the file name,
 prefixed by PREFIX if it is non-nil.
Interactively, you are prompted for PREFIX if
 `diredp-prompt-for-bookmark-prefix-flag' is non-nil.

Interactively, a prefix argument ARG specifies the files to use
instead of those marked.

 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories.

See also command `diredp-set-bookmark-file-bookmark-for-marked'.

Non-interactively:

 ,* Non-nil BFILE-BOOKMARKP means create a bookmark-file bookmark for
   BOOKMARK-FILE.
 ,* Non-nil FILES is the list of files to bookmark."
  (interactive (diredp-read-bookmark-file-args))
  (diredp-ensure-bookmark+)
  (let ((bfile-exists-p  (file-readable-p bookmark-file)))
    (unless bfile-exists-p (bmkp-empty-file bookmark-file))
    (unless bmkp-current-bookmark-file (setq bmkp-current-bookmark-file  bookmark-default-file))
    (let ((old-bmkp-current-bookmark-file  bmkp-current-bookmark-file))
      (unwind-protect
           (progn (bmkp-switch-bookmark-file bookmark-file) ; Changes `*-current-bookmark-file'.
                  (if files
                      (dolist (file  files)  (diredp-bookmark prefix file 'NO-MSG-P))
                    (dired-map-over-marks-check
                     (lexical-let ((pref  prefix)) #'(lambda () (diredp-bookmark pref nil 'NO-MSG-P)))
                     arg 'bookmark (diredp-fewer-than-2-files-p arg)))
                  (bookmark-save)
                  (unless bfile-exists-p (revert-buffer)))
        (unless (bmkp-same-file-p old-bmkp-current-bookmark-file  bmkp-current-bookmark-file)
          (bmkp-switch-bookmark-file old-bmkp-current-bookmark-file 'NO-MSG))))
    (when bfile-bookmarkp (bmkp-set-bookmark-file-bookmark bookmark-file))))

(defun diredp-read-bookmark-file-args ()
  "Read args for `diredp-do-bookmark-in-bookmark-file' and similar."
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (list (let* ((insert-default-directory  t)
               (bmk-file                  (expand-file-name
                                           (read-file-name
                                            "Use bookmark file (default is in CURRENT dir): " nil
                                            (if (or (> emacs-major-version 23)
                                                    (and (= emacs-major-version 23)  (> emacs-minor-version 1)))
                                                (list ".emacs.bmk" bookmark-default-file)
                                              ".emacs.bmk")))))
          bmk-file)
        (and diredp-prompt-for-bookmark-prefix-flag  (read-string "Prefix for autofile bookmark names: "))
        current-prefix-arg))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; Allows for consp `dired-directory' too.
;;
(defun dired-buffers-for-dir (dir &optional file)
  "Return a list of buffers that Dired DIR (top level or in-situ subdir).
If FILE is non-nil, include only those whose wildcard pattern (if any)
matches FILE.
The list is in reverse order of buffer creation, most recent last.
As a side effect, killed Dired buffers for DIR are removed from
`dired-buffers'."
  (setq dir  (file-name-as-directory dir))
  (let (result buf)
    (dolist (elt  dired-buffers)
      (setq buf  (cdr elt))
      (cond ((null (buffer-name buf))   ; Buffer is killed - clean up.
             (setq dired-buffers  (delq elt dired-buffers)))
            ((dired-in-this-tree dir (car elt))
             (with-current-buffer buf
               (and (assoc dir dired-subdir-alist)
                    (or (null file)
                        (if (stringp dired-directory)
                            ;; Allow for consp `dired-directory' too.
                            (let ((wildcards  (file-name-nondirectory (if (consp dired-directory)
                                                                          (car dired-directory)
                                                                        dired-directory))))
                              (or (zerop (length wildcards))
                                  (diredp-string-match-p (dired-glob-regexp wildcards) file)))
                          (member (expand-file-name file dir) (cdr dired-directory))))
                    (setq result  (cons buf result)))))))
    result))


;; If you use library `files+.el', you need not use these commands
;; explicitly, because that library redefines `find-file-read-args' to
;; do the same thing, in Dired mode.  These are provided here in case
;; you want to bind them directly - for example, in case your code
;; does not use `find-file-read-args'.
;;
;;;###autoload
(defun diredp-find-a-file (filename &optional wildcards) ; Not bound
  "`find-file', but use file on current line as default (`M-n')."
  (interactive (diredp-find-a-file-read-args "Find file: " nil))
  (find-file filename wildcards))

;;;###autoload
(defun diredp-find-a-file-other-frame (filename &optional wildcards) ; Not bound
  "`find-file-other-frame', but use file under cursor as default (`M-n')."
  (interactive (diredp-find-a-file-read-args "Find file: " nil))
  (find-file-other-frame filename wildcards))

;;;###autoload
(defun diredp-find-a-file-other-window (filename &optional wildcards) ; Not bound
  "`find-file-other-window', but use file under cursor as default (`M-n')."
  (interactive (diredp-find-a-file-read-args "Find file: " nil))
  (find-file-other-window filename wildcards))

;;;###autoload
(defun diredp-find-a-file-read-args (prompt mustmatch) ; Not bound
  (list (lexical-let ((find-file-default  (abbreviate-file-name (dired-get-file-for-visit))))
          (minibuffer-with-setup-hook (lambda ()
                                        (setq minibuffer-default  find-file-default))
                                      (read-file-name prompt nil default-directory mustmatch)))
        t))

;;;###autoload
(defun diredp-find-file-reuse-dir-buffer () ; Not bound
  "Like `dired-find-file', but reuse Dired buffers.
Unlike `dired-find-alternate-file' this does not use
`find-alternate-file' unless (1) the target is a directory that is not
yet visited as a Dired buffer, and (2) the current (Dired) buffer is
not visited also in some other window (possibly in an iconified
frame)."
  (interactive)
  (set-buffer-modified-p nil)
  (let ((file  (dired-get-file-for-visit)))
    (diredp--reuse-dir-buffer-helper file)))

;;;###autoload
(defun diredp-mouse-find-file-reuse-dir-buffer (event &optional find-file-func find-dir-func) ; Not bound
  "Like `dired-mouse-find-file', but reuse Dired buffers.
Unlike `dired-find-alternate-file' this does not use
`find-alternate-file' unless (1) the target is a directory that is not
yet visited as a Dired buffer, and (2) the current (Dired) buffer is
not visited also in some other window (possibly in an iconified
frame).

Non-nil optional args FIND-FILE-FUNC and FIND-DIR-FUNC specify
functions to visit the file and directory, respectively.
Defaults: `find-file' and `dired', respectively."
  (interactive "e")
  (let (window pos file)
    (save-excursion
      (setq window  (posn-window (event-end event))
            pos     (posn-point (event-end event)))
      (unless (windowp window) (error "No file chosen"))
      (set-buffer (window-buffer window))
      (goto-char pos)
      (setq file  (dired-get-file-for-visit)))
    (select-window window)
    (diredp--reuse-dir-buffer-helper file find-file-func find-dir-func)))

(defun diredp--reuse-dir-buffer-helper (file &optional find-file-func find-dir-func other-window)
  "Helper for commands `diredp-*-reuse-dir-buffer' commands.
Non-nil optional args FIND-FILE-FUNC and FIND-DIR-FUNC specify
functions to visit the file and directory, respectively.
Defaults: `find-file' and `dired', respectively.

Unlike `dired-find-alternate-file' this does not use
`find-alternate-file' unless (1) the target is a directory that is not
yet visited as a Dired buffer, and (2) the current (Dired) buffer is
not visited also in some other window (possibly in an iconified
frame)."
  (setq find-file-func  (or find-file-func (if other-window #'find-file-other-window #'find-file))
        find-dir-func   (or find-dir-func  (if other-window #'dired-other-window #'dired)))
  (let (;; This binding prevents problems with preserving point in windows displaying Dired buffers, because
        ;; reverting a Dired buffer empties it, which changes the places where the markers used by
        ;; `switch-to-buffer-preserve-window-point' point.
        (switch-to-buffer-preserve-window-point  (and (boundp 'switch-to-buffer-preserve-window-point) ; Emacs 24+
                                                      (or (not (boundp 'dired-auto-revert-buffer))
                                                          (not dired-auto-revert-buffer))
                                                      switch-to-buffer-preserve-window-point))
        (find-file-run-dired                     t)
        (wins                                    ())
        (alt-find-file-func                      (if other-window
                                                     #'find-alternate-file-other-window
                                                   #'find-alternate-file))
        dir-bufs)
    (if (or (not (file-directory-p file)) ; New is a not a directory
            (dired-buffers-for-dir file) ; or there is a Dired buffer for it, even as a subdir.
            (and (setq dir-bufs  (dired-buffers-for-dir default-directory)) ; Dired bufs for current (old).
                 (progn
                   (dolist (buf  dir-bufs)
                     (setq wins  (append wins (get-buffer-window-list buf 'NOMINI 0))))
                   (setq wins  (delq nil wins))
                   (cdr wins))))        ; More than one window showing current Dired buffer.
        (if (file-directory-p file)
            (or (and (cdr dired-subdir-alist)  (dired-goto-subdir file)) ; New is a subdir inserted in current
                (funcall find-dir-func file))
          (funcall find-file-func (file-name-sans-versions file t)))
      (funcall alt-find-file-func (file-name-sans-versions file t)))))

;;;###autoload
(defalias 'toggle-diredp-find-file-reuse-dir 'diredp-toggle-find-file-reuse-dir)
;;;###autoload
(defun diredp-toggle-find-file-reuse-dir (force-p) ; Bound to `C-M-R' (aka `C-M-S-r')
  "Toggle whether Dired `find-file' commands reuse directories.
This applies also to `dired-w32-browser' commands and
`diredp-up-directory'.

A prefix arg specifies directly whether or not to reuse.
 If its numeric value is non-negative then reuse; else do not reuse.

To set the behavior as a preference (default behavior), put this in
your ~/.emacs, where VALUE is 1 to reuse or -1 to not reuse:

 (diredp-toggle-find-file-reuse-dir VALUE)

Note: This affects only these commands:

  `dired-find-file'
  `dired-mouse-find-file'

It does not affect the corresponding `-other-window' commands.  Note
too that, by default, mouse clicks to open files or directories open
in another window: command `diredp-mouse-find-file-other-window', not
`dired-mouse-find-file'.  If you want a mouse click to reuse a
directory then bind `mouse-2' to `dired-mouse-find-file' instead."
  (interactive "P")
  (if force-p                           ; Force.
      (if (natnump (prefix-numeric-value force-p))
          (diredp-make-find-file-keys-reuse-dirs)
        (diredp-make-find-file-keys-not-reuse-dirs))
    (if (where-is-internal 'dired-find-file dired-mode-map 'ascii)
        (diredp-make-find-file-keys-reuse-dirs)
      (diredp-make-find-file-keys-not-reuse-dirs))))

(defun diredp-make-find-file-keys-reuse-dirs ()
  "Make find-file keys reuse Dired buffers."
  (substitute-key-definition 'diredp-up-directory 'diredp-up-directory-reuse-dir-buffer dired-mode-map)
  (substitute-key-definition 'dired-find-file 'diredp-find-file-reuse-dir-buffer dired-mode-map)
  (substitute-key-definition 'dired-mouse-find-file 'diredp-mouse-find-file-reuse-dir-buffer dired-mode-map)
  ;; These commands are defined in `w32-browser.el' (for use with MS Windows).
  (substitute-key-definition 'dired-w32-browser 'dired-w32-browser-reuse-dir-buffer dired-mode-map)
  (substitute-key-definition 'dired-mouse-w32-browser 'dired-mouse-w32-browser-reuse-dir-buffer dired-mode-map)
  (message "Reusing Dired buffers is now ON"))

(defun diredp-make-find-file-keys-not-reuse-dirs ()
  "Make find-file keys not reuse Dired buffers (i.e. act normally)."
  (substitute-key-definition 'diredp-up-directory-reuse-dir-buffer 'diredp-up-directory dired-mode-map)
  (substitute-key-definition 'diredp-find-file-reuse-dir-buffer 'dired-find-file dired-mode-map)
  (substitute-key-definition 'diredp-mouse-find-file-reuse-dir-buffer 'dired-mouse-find-file dired-mode-map)
  ;; These commands are defined in `w32-browser.el' (for use with MS Windows).
  (substitute-key-definition 'dired-w32-browser-reuse-dir-buffer 'dired-w32-browser dired-mode-map)
  (substitute-key-definition 'dired-mouse-w32-browser-reuse-dir-buffer 'dired-mouse-w32-browser dired-mode-map)
  (message "Reusing Dired buffers is now OFF"))

;;;###autoload
(defun diredp-omit-marked ()            ; Not bound
  "Omit lines of marked files.  Return the number of lines omitted."
  (interactive)
  (let ((old-modified-p  (buffer-modified-p))
        count)
    (when (interactive-p) (message "Omitting marked lines..."))
    (setq count  (dired-do-kill-lines nil "Omitted %d line%s."))
    (set-buffer-modified-p old-modified-p) ; So no `%*' appear in mode-line.
    count))

;;;###autoload
(defun diredp-omit-unmarked ()          ; Not bound
  "Omit lines of unmarked files.  Return the number of lines omitted."
  (interactive)
  (let ((old-modified-p  (buffer-modified-p))
        count)
    (dired-toggle-marks)
    (message "Omitting unmarked lines...")
    (setq count  (diredp-omit-marked))
    (dired-toggle-marks)                ; Marks all except `.', `..'
    (set-buffer-modified-p old-modified-p) ; So no `%*' appear in mode-line.
    count))

;;;###autoload
(defun diredp-ediff (file2)             ; Bound to `='
  "Compare file at cursor with file FILE2 using `ediff'.
FILE2 defaults to the file at the cursor as well.  If you enter just a
directory name for FILE2, then the file at the cursor is compared with
a file of the same name in that directory.  FILE2 is the second file
given to `ediff'; the file at the cursor is the first.

Try to guess a useful default value for FILE2, as follows:

,* If the mark is active, use the file at mark.
,* Else if the file at cursor is a autosave file or a backup file, use
  the corresponding base file.
,* Else if there is any backup file for the file at point, use the
  newest backup file for it.
,* Else use the file at point."
  (interactive (progn (require 'ediff)
                      (list (ediff-read-file-name ; In `ediff-util.el'.
                             (format "Compare %s with" (dired-get-filename t))
                             (dired-current-directory)
                             (let* ((file           (dired-get-filename))
                                    (file-sans-dir  (file-name-nondirectory file))
                                    (file-dir       (file-name-directory file))
                                    (file-at-mark   (and transient-mark-mode
                                                         mark-active
                                                         (save-excursion (goto-char (mark t))
                                                                         (dired-get-filename t 'NO-ERROR))))
                                    (last-backup    (file-newest-backup file)))
                               (cond
                                 (file-at-mark)
                                 ((auto-save-file-name-p file-sans-dir)
                                  (expand-file-name (substring file-sans-dir 1 -1) file-dir))
                                 ((backup-file-name-p file-sans-dir)
                                  (expand-file-name (file-name-sans-versions file-sans-dir) file-dir))
                                 (last-backup)
                                 (t file)))))))
  (ediff-files (dired-get-filename) file2)) ; In `ediff.el'.

(defun diredp-fewer-than-N-files-p (arg n)
  "Return non-nil iff fewer than N files are to be treated by dired.
More precisely, return non-nil iff ARG is nil and fewer than N
files are marked, or the absolute value of ARG is less than N."
  (if arg
      (and (integerp arg)  (< (abs arg) n)) ; Next or previous file (or none).
    (not (save-excursion                ; Fewer than two marked files.
           (goto-char (point-min))
           (re-search-forward (dired-marker-regexp) nil t n)))))

(defun diredp-fewer-than-2-files-p (arg)
  "Return non-nil iff fewer than two files are to be treated by dired.
More precisely, return non-nil iff ARG is nil and fewer than two
files are marked, or ARG is -1, 0 or 1."
  (diredp-fewer-than-N-files-p arg 2))

(defun diredp-fewer-than-echo-limit-files-p (arg)
  "Return non-nil iff < `diredp-do-report-echo-limit' files marked.
More precisely, return non-nil iff ARG is nil and fewer than two
files are marked, or ARG is -1, 0 or 1."
  (diredp-fewer-than-N-files-p arg diredp-do-report-echo-limit))

;;;###autoload
(defun diredp-do-aggregate-apply-to-marked (aggregate-fun &optional mark-arg msgp)
  "Aggregate results of applying a function to the marked files and dirs.
This command prompts you for the aggregate function, AGGREGATE-FUN.

Then it calls `diredp-do-apply-to-marked', which prompts you for a
function to apply to the name of each marked file or dir.

A prefix arg acts like the ARG argument of `dired-get-marked-files'.
In particular, `C-u C-u' operates on all files in the Dired buffer."
  (interactive
   (progn
     (diredp-ensure-mode)
     (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           current-prefix-arg
           t)))
  (diredp-ensure-fn-nonzero-arity aggregate-fun)
  (let ((result  (apply aggregate-fun (let ((current-prefix-arg  mark-arg))
                                        (call-interactively #'diredp-do-apply-to-marked)))))
    (when msgp (message "Result: %S" result))))

;;; (defun diredp-do-aggregate-invoke-in-marked (aggregate-fun &optional mark-arg msgp)
;;;   "Aggregate results of invoking a function in the marked files and dirs.
;;; This command prompts you for the aggregate function, AGGREGATE-FUN.
;;;
;;; Then it calls `diredp-do-invoke-in-marked', which prompts you for a
;;; function to invoke in each marked file or dir.
;;;
;;; A prefix arg acts like the ARG argument of `dired-get-marked-files'.
;;; In particular, `C-u C-u' operates on all files in the Dired buffer."
;;;   (interactive
;;;    (progn
;;;      (diredp-ensure-mode)
;;;      (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
;;;                                   (and (boundp 'function-name-history)  'function-name-history)))
;;;            current-prefix-arg
;;;            t)))
;;;   (diredp-ensure-fn-nonzero-arity aggregate-fun)
;;;   (let ((result  (apply aggregate-fun (let ((current-prefix-arg  mark-arg))
;;;                                         (call-interactively #'diredp-do-invoke-in-marked)))))
;;;     (when msgp (message "Result: %S" result))))

;;;###autoload
(defun diredp-do-aggregate-eval-in-marked (aggregate-fun &optional mark-arg msgp)
  "Aggregate results of evaluating a sexp in the marked files and dirs.
This command prompts you for the aggregate function, AGGREGATE-FUN.

Then it calls `diredp-do-eval-in-marked', which prompts you for a Lisp
sexp to evaluate in each marked file or dir.

A prefix arg acts like the ARG argument of `dired-get-marked-files'.
In particular, `C-u C-u' operates on all files in the Dired buffer."
  (interactive
   (progn
     (diredp-ensure-mode)
     (list (read (completing-read "Aggregate function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           current-prefix-arg
           t)))
  (diredp-ensure-fn-nonzero-arity aggregate-fun)
  (let ((result  (apply aggregate-fun (let ((current-prefix-arg  mark-arg))
                                        (call-interactively #'diredp-do-eval-in-marked)))))
    (when msgp (message "Result: %S" result))))

;;;###autoload
(defun diredp-do-apply-to-marked (function &optional arg) ; Bound to `@ @'
  "Apply FUNCTION to the absolute name of each marked file.
Return a list of the results.

You are prompted for FUNCTION.

A prefix arg behaves according to the ARG argument of
`dired-get-marked-files'.  In particular, `C-u C-u' operates on all
files in the Dired buffer.

If you use multiple `C-u' as prefix arg then many files might be acted
on, and some of them might already be visited in modified buffers.  If
the function you apply modifies file content, and you want to save any
such buffers before using this command, then use \\[save-some-buffers]
first.

The result returned for each file is logged by `dired-log'.  Use `?'
to see all such results and any error messages.  If there are fewer
marked files than `diredp-do-report-echo-limit' then each result is
also echoed momentarily."
  (interactive
   (progn
     (diredp-ensure-mode)
     (list (read (completing-read "Apply function: " obarray 'functionp nil nil
                                  (and (boundp 'function-name-history)  'function-name-history)))
           current-prefix-arg)))
  (diredp-ensure-fn-nonzero-arity function)
  (let* ((files     (dired-get-marked-files nil arg nil nil 'NO-ERROR))
         (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs  ())
         (result    ()))
    ;; FIXME
    ;; We do this for recursive version.  But here it means an additional `dired-map-over-marks'.  Optimize?
    (diredp-maybe-save-visited files nil diredp-list-file-attributes)
    (setq result    (save-selected-window
                      (diredp-map-over-marks-and-report #'diredp-apply-to-this-file
                                                        arg
                                                        'apply\ function\ to
                                                        (diredp-fewer-than-2-files-p arg)
                                                        function
                                                        (or (diredp-prefix-arg-all-files arg)  arg)
                                                        (diredp-fewer-than-echo-limit-files-p arg)))
          new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (message nil) ; Clear echo area of anything inserted by evaluating SEXP.
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                diredp-list-file-attributes))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))
    result))

;;;###autoload
(defun diredp-do-command-in-marked (command &optional arg) ; Bound to `@ M-x'
  "Invoke Emacs COMMAND in each marked file.
Visit each marked file at its beginning, then invoke COMMAND.
You are prompted for the COMMAND.

Only explicitly marked files are used.  A prefix arg has no effect on
which files are used.

A prefix arg is passed to COMMAND as its prefix arg.  For example, if
COMMAND uses a numeric prefix arg N for repetition then the effect of
COMMAND is repeated N times.

Other than the prefix arg, no arguments are passed to COMMAND.

If any of the marked files are already visited in modified buffers
then you are prompted to save them first.

If after invoking COMMAND in all of the marked files new buffers have
been created to visit some of them then you are prompted to kill those
buffers.

An errors are logged by `dired-log'.  Use `?'  to see the error
messages.

Be aware that COMMAND could be invoked in a directory (Dired) buffer.
You may not want to do this if COMMAND modifies the buffer text.
\(But generally this will have little lasting effect - you can just
use `g' in that buffer to revert the listing.)"
  (interactive (progn (diredp-ensure-mode)
                      (list (diredp-read-command "Invoke command: ") current-prefix-arg)))
  (unless (commandp command) (error "Not a command: `%s'" command))
  (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
              (= 0 (car (func-arity command))))
    (error "Command `%s' cannot accept zero args" command))
  (let* ((files     (dired-get-marked-files nil nil nil nil 'NO-ERROR)) ; nil for 2nd argument
         (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs  ()))
    ;; FIXME
    ;; We do this for recursive version.  But here it means an additional `dired-map-over-marks'.  Optimize?
    (diredp-maybe-save-visited files nil diredp-list-file-attributes)
    (save-selected-window
      (dired-map-over-marks-check #'diredp-invoke-command
                                  nil   ; nil for 2nd argument
                                  'invoke\ command\ within
                                  (diredp-fewer-than-2-files-p nil) ; nil for argument
                                  command
                                  arg))
    (setq new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (sit-for 2) ; Show echo area message from `dired-map-over-marks-check'
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                diredp-list-file-attributes))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))))

;;; (defun diredp-do-invoke-in-marked (function &optional arg) ; Bound to `@ M-@'
;;;   "Invoke FUNCTION in each marked file, passing it no arguments.
;;; Return a list of the results.
;;;
;;; You are prompted for FUNCTION.
;;;
;;; A prefix arg behaves according to the ARG argument of
;;; `dired-get-marked-files'.  In particular, `C-u C-u' operates on all
;;; files in the Dired buffer.
;;;
;;; If you use multiple `C-u' as prefix arg then many files might be acted
;;; on, and some of them might already be visited in modified buffers.  If
;;; the function you apply modifies file content, and you want to save any
;;; such buffers before using this command, then use \\[save-some-buffers]
;;; first.
;;;
;;; The result returned for each file is logged by `dired-log'.  Use `?'
;;; to see all such results and any error messages.  If there are fewer
;;; marked files than `diredp-do-report-echo-limit' then each result is
;;; also echoed momentarily."
;;;   (interactive
;;;    (progn
;;;      (diredp-ensure-mode)
;;;      (list (read (completing-read "Invoke function: " obarray 'functionp nil nil
;;;                                   (and (boundp 'function-name-history)  'function-name-history)))
;;;            current-prefix-arg)))
;;;   (diredp-ensure-fn-zero-arity function)
;;;   (let* ((files     (dired-get-marked-files nil arg nil nil 'NO-ERROR))
;;;          (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
;;;          (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
;;;          (new-bufs  ())
;;;          (result    ()))
;;;     ;; FIXME
;;;     ;; We do this for recursive version.  But here it means an additional `dired-map-over-marks'.  Optimize?
;;;     (diredp-maybe-save-visited files nil diredp-list-file-attributes)
;;;     (setq result  (save-selected-window
;;;                     (diredp-map-over-marks-and-report #'diredp-invoke/eval-in-this-file
;;;                                                       arg
;;;                                                       'invoke\ function\ within
;;;                                                       (diredp-fewer-than-2-files-p arg)
;;;                                                       function
;;;                                                       (diredp-fewer-than-echo-limit-files-p arg)))
;;;           new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
;;;     (message nil) ; Clear echo area of anything inserted by evaluating SEXP.
;;;     (when (and new-bufs
;;;                (diredp-y-or-n-files-p
;;;                 "New buffers of visited files.  Kill some? "
;;;                 (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
;;;                 nil
;;;                 diredp-list-file-attributes))
;;;       (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
;;;                     #'kill-buffer
;;;                     new-bufs
;;;                     '("buffer" "buffers" "kill")
;;;                     save-some-buffers-action-alist))
;;;     result))

;;;###autoload
(defun diredp-do-eval-in-marked (sexp &optional arg) ; Bound to `@ M-:'
  "Evaluate an Emacs-Lisp SEXP in each marked file.
Visit each marked file at its beginning, then evaluate SEXP.
Return a list of the results.

You are prompted for the SEXP.

The result returned for each file is logged by `dired-log'.  Use `?'
to see all such results and any error messages.  If there are fewer
marked files than `diredp-do-report-echo-limit' then each result is
also echoed momentarily.

A prefix argument behaves according to the ARG argument of
`dired-get-marked-files'.  In particular, `C-u C-u' operates on all
files in the Dired buffer."
  (interactive (progn (diredp-ensure-mode)
                      (list (diredp-read-expression "Eval sexp: ") current-prefix-arg)))
  (let* ((files     (dired-get-marked-files nil arg nil nil 'NO-ERROR))
         (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
         (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
         (new-bufs  ())
         (result    ()))
    ;; FIXME
    ;; We do this for recursive version.  But here it means an additional `dired-map-over-marks'.  Optimize?
    (diredp-maybe-save-visited files nil diredp-list-file-attributes)
    (setq result    (save-selected-window
                      (diredp-map-over-marks-and-report #'diredp-eval-in-this-file
                                                        arg
                                                        'eval\ lisp\ sexp
                                                        (diredp-fewer-than-2-files-p arg)
                                                        sexp
                                                        (diredp-fewer-than-echo-limit-files-p arg)))
          new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
    (message nil) ; Clear echo area of anything inserted by evaluating SEXP.
    (when (and new-bufs
               (diredp-y-or-n-files-p
                "New buffers of visited files.  Kill some? "
                (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                nil
                diredp-list-file-attributes))
      (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                    #'kill-buffer
                    new-bufs
                    '("buffer" "buffers" "kill")
                    save-some-buffers-action-alist))
    result))

;;;###autoload
(defun diredp-do-apply/eval-marked (fun/sexp &optional arg) ; Not bound
  "Apply a function to the marked files, or evaluate a sexp in them.
Return a list of the results.

You are prompted for the function or sexp.

With a plain prefix ARG (`C-u'), visit each marked file and eval the
 sexp or invoke the function there.  (The function is passed no
 arguments.)
Otherwise, apply the function to each file name.

Any prefix arg other than a single `C-u' behaves according to the ARG
argument of `dired-get-marked-files'.  In particular:
 ,* `C-u C-u' operates on all files in the Dired buffer.
 ,* To apply a function to just the file of the current line, ignoring
   ally marks, use a numeric prefix arg of 1 (e.g. `M-1`).

If you use multiple `C-u' as prefix arg then many files might be acted
on, and some of them might already be visited in modified buffers.  If
the function you apply modifies file content, and you want to save any
such buffers before using this command, then use \\[save-some-buffers]
first.

The result returned for each file is logged by `dired-log'.  Use `?'
to see all such results and any error messages.  If there are fewer
marked files than `diredp-do-report-echo-limit' then each result is
also echoed momentarily.

When called from Lisp, if ARG is `(4)' then eval the sexp or invoke
the function while visiting each file."
  (interactive
   (let ((use-no-args-p  (and (consp current-prefix-arg)  (< (car current-prefix-arg) 16))))
     (diredp-ensure-mode)
     (list (if use-no-args-p
               (diredp-read-expression "Invoke function or eval sexp: ")
             (read (completing-read "Apply function: " obarray 'functionp nil nil
                                    (and (boundp 'function-name-history)  'function-name-history))))
           current-prefix-arg)))
  (let ((use-no-args-p  (and (consp arg)  (< (car arg) 16))))
    (if (not use-no-args-p)
        (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
                    (let ((max  (cdr (func-arity fun/sexp))))
                      (or (eq max 'many)  (> max 0))))
          (error "Function `%s' cannot accept any args" fun/sexp))
      (setq arg  nil)
      (when (functionp fun/sexp)
        (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
                    (= 0 (car (func-arity fun/sexp))))
          (error "Function `%s' cannot accept zero args" fun/sexp))))
    (let* ((files     (dired-get-marked-files nil arg nil nil 'NO-ERROR))
           (fbufs     (delq nil (mapcar #'find-buffer-visiting files)))
           (mod-bufs  (diredp-remove-if-not #'buffer-modified-p fbufs))
           (new-bufs  ())
           (result    ()))
      ;; FIXME
      ;; We do this for recursive version.  But here it means an additional `dired-map-over-marks'.  Optimize?
      (diredp-maybe-save-visited files nil diredp-list-file-attributes)
      (setq result    (save-selected-window
                        (diredp-map-over-marks-and-report
                         (if use-no-args-p
                             #'diredp-invoke/eval-in-this-file
                           #'diredp-apply-to-this-file)
                         arg
                         (if use-no-args-p 'invoke/eval\ within 'apply\ function\ to)
                         (diredp-fewer-than-2-files-p arg)
                         fun/sexp
                         (diredp-fewer-than-echo-limit-files-p arg)))
            new-bufs  (diredp-set-difference (delq nil (mapcar #'find-buffer-visiting files)) fbufs nil))
      (message nil) ; Clear echo area of anything inserted by evaluating SEXP.
      (when (and new-bufs
                 (diredp-y-or-n-files-p
                  "New buffers of visited files.  Kill some? "
                  (delq nil (mapcar (lambda (bb) (buffer-file-name bb)) new-bufs))
                  nil
                  diredp-list-file-attributes))
        (map-y-or-n-p (lambda (bb) (format "Kill new buffer `%s'? " (buffer-file-name bb)))
                      #'kill-buffer
                      new-bufs
                      '("buffer" "buffers" "kill")
                      save-some-buffers-action-alist))
      result)))

(defun diredp-apply-to-this-file (function arg &optional echop)
  "Apply FUNCTION to the file or directory name on this line.
Log the result returned or any error.
ARG is a raw prefix arg.  If prefix arg is multiple `C-u' then ARG is
 passed to `diredp-get-file-or-dir-name'.
Non-nil optional arg ECHOP means also echo the result."
  (diredp-ensure-fn-nonzero-arity function)
  (let ((file     (or (dired-get-filename nil 'NO-ERROR) ; Explicitly marked or integer ARG
                      (diredp-get-file-or-dir-name arg))) ; Multi C-u
        (failure  nil)
        result)
    (condition-case err
        (setq result  (funcall function file))
      (error (setq failure  (error-message-string err))))
    (diredp-report-file-result file result failure echop)))

(defun diredp-invoke-command (command arg)
  "Visit the file or directory of this line, and invoke COMMAND.
COMMAND is invoked at the beginning of the buffer.  It is passed only
ARG, a raw prefix arg.

Be aware that COMMAND could be invoked in a directory (Dired) buffer.
You may not want to do this if COMMAND modifies the buffer text.
\(But generally this will have little lasting effect - you can just
use `g' in that buffer to revert the listing.)"
  (unless (commandp command) (error "Not a command: `%s'" command))
  (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
              (= 0 (car (func-arity command))))
    (error "Command `%s' cannot accept zero args" command))
  (let* ((file     (dired-get-filename nil 'NO-ERROR)) ; Explicitly marked or integer ARG
         (failure  (not (file-exists-p file))))
    (unless failure
      (condition-case err
          (save-selected-window
            (with-current-buffer (find-file-noselect file)
              (save-excursion (goto-char (point-min))
                              (let ((current-prefix-arg  arg)) (call-interactively command)))))
        (error (setq failure  (format "File: %s\n  %s\n" file (error-message-string err))))))
    (if (not failure)
        nil                             ; Return nil for success.
      (dired-log failure)
      (dired-make-relative file))))     ; Return file name for failure.

;; This function is not used.
;;
(defun diredp-invoke-in-this-file (function arg &optional echop)
  "Visit the file or directory of this line, and invoke FUNCTION.
Log the result returned or any error.
FUNCTION is invoked at the file beginning.  It is passed no args.
ARG is a raw prefix arg.  If prefix arg is multiple `C-u' then ARG is
 passed to `diredp-get-file-or-dir-name'.
Non-nil optional arg ECHOP means also echo the result."
  (diredp-ensure-fn-zero-arity function)
  (let* ((file     (or (dired-get-filename nil 'NO-ERROR) ; Explicitly marked or integer ARG
                       (diredp-get-file-or-dir-name arg))) ; Multi C-u
         (failure  (not (file-exists-p file)))
         result)
    (unless failure
      (condition-case err
          (with-current-buffer (find-file-noselect file)
            (save-excursion
              (goto-char (point-min))
              (setq result  (funcall function))))
        (error (setq failure  (error-message-string err)))))
    (diredp-report-file-result file result failure echop)))

(defun diredp-eval-in-this-file (sexp arg &optional echop)
  "Visit file or directory of this line, and evaluate Lisp SEXP.
Log the result returned or any error.
SEXP is evaluated at the beginning of the file.
ARG is a raw prefix arg.  If prefix arg is multiple `C-u' then ARG is
 passed to `diredp-get-file-or-dir-name'.
Non-nil optional arg ECHOP means also echo the result."
  (let* ((file     (or (dired-get-filename nil 'NO-ERROR) ; Explicitly marked or integer ARG
                       (diredp-get-file-or-dir-name arg))) ; Multi C-u
         (failure  (not (file-exists-p file)))
         result)
    (unless failure
      (condition-case err
          (with-current-buffer (find-file-noselect file)
            (save-excursion (goto-char (point-min))
                            (setq result  (eval-expression sexp))))
        (error (setq failure  (error-message-string err)))))
    (diredp-report-file-result file result failure echop)))

(defun diredp-invoke/eval-in-this-file (fun/sexp arg &optional echop)
  "Invoke/eval FUN/SEXP while visiting file of this line at position 1.
Log the result returned or any error.
FUN/SEXP is a function or a sexp.  The function is passed no args.
ARG is a raw prefix arg.  If prefix arg is multiple `C-u' then ARG is
 passed to `diredp-get-file-or-dir-name'.
Non-nil optional arg ECHOP means also echo the result."
  (when (functionp fun/sexp)
    (unless (or (not (fboundp 'func-arity)) ; Emacs < 26
                (= 0 (car (func-arity fun/sexp))))
      (error "Function `%s' cannot accept zero args" fun/sexp)))
  (let* ((file     (or (dired-get-filename nil 'NO-ERROR) ; Explicitly marked or integer ARG
                       (diredp-get-file-or-dir-name arg)))
         (failure  (not (file-exists-p file)))
         result)
    (unless failure
      (condition-case err
          (with-current-buffer (find-file-noselect file)
            (save-excursion
              (goto-char (point-min))
              (setq result  (if (functionp fun/sexp) (funcall fun/sexp) (eval-expression fun/sexp)))))
        (error (setq failure  (error-message-string err)))))
    (diredp-report-file-result file result failure echop)))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Redisplay only if at most one file is being treated.
;; 2. Doc string reflects `Dired+'s version of `dired-map-over-marks-check'.
;;
;;;###autoload
(defun dired-do-compress (&optional arg) ; Bound to `Z'
  "Compress or uncompress marked (or next prefix argument) files.
A prefix argument ARG specifies files to use instead of marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive "P")
  (dired-map-over-marks-check #'dired-compress arg 'compress (diredp-fewer-than-2-files-p arg)))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Redisplay only if at most one file is being treated.
;; 2. Doc string reflects `Dired+'s version of `dired-map-over-marks-check'.
;;
;;;###autoload
(defun dired-do-byte-compile (&optional arg) ; Bound to `B'
  "Byte compile marked Emacs Lisp files.
A prefix argument ARG specifies files to use instead of marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (let* ((arg  current-prefix-arg)
                      (C-u  (and (consp arg)  arg)))
                 (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                 (list arg)))
  (dired-map-over-marks-check #'dired-byte-compile arg 'byte-compile (diredp-fewer-than-2-files-p arg)))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Redisplay only if at most one file is being treated.
;; 2. Doc string reflects `Dired+' version of `dired-map-over-marks-check'.
;;
;;;###autoload
(defun dired-do-load (&optional arg)    ; Bound to `L'
  "Load the marked Emacs Lisp files.
A prefix argument ARG specifies files to use instead of marked.
 An integer means use the next ARG files (previous -ARG, if < 0).
 `C-u': Use the current file (whether or not any are marked).
 `C-u C-u': Use all files in Dired, except directories.
 `C-u C-u C-u': Use all files and directories, except `.' and `..'.
 `C-u C-u C-u C-u': Use all files and all directories."
  (interactive (let* ((arg  current-prefix-arg)
                      (C-u  (and (consp arg)  arg)))
                 (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                 (list arg)))
  (dired-map-over-marks-check #'dired-load arg 'load (diredp-fewer-than-2-files-p arg)))


(when (fboundp 'multi-isearch-files)

  ;; REPLACE ORIGINAL in `dired.el':
  ;;
  ;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
  ;; 2. Added optional arg INTERACTIVEP.
  ;; 3. Do not raise error if no files when not INTERACTIVEP.
  ;;
  (defun dired-do-isearch (&optional arg interactivep)
    "Search for a string through all marked files using Isearch.
A prefix argument ARG specifies files to use instead of those marked.
 ,* An integer means use the next ARG files (previous -ARG, if < 0).
 ,* Two or more `C-u' (e.g. `C-u C-u') means ignore any marks and use
   all files in the Dired buffer.
 ,* Any other prefix arg means use the current file.
When invoked interactively, raise an error if no files are marked."
    (interactive (let* ((arg  current-prefix-arg)
                        (C-u  (and (consp arg)  arg)))
                   (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                   (list arg t)))
    (multi-isearch-files (dired-get-marked-files nil arg 'dired-nondirectory-p nil interactivep)))


  ;; REPLACE ORIGINAL in `dired.el':
  ;;
  ;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
  ;; 2. Added optional arg INTERACTIVEP.
  ;; 3. Do not raise error if no files when not INTERACTIVEP.
  ;;
  (defun dired-do-isearch-regexp (&optional arg interactivep)
    "Search for a regexp through all marked files using Isearch.
A prefix arg behaves as follows:
 ,* An integer means use the next ARG files (previous -ARG, if < 0).
 ,* Two or more `C-u' (e.g. `C-u C-u') means ignore any marks and use
   all files in the Dired buffer.
 ,* Any other prefix arg means use the current file.
When invoked interactively, raise an error if no files are marked."
    (interactive (let* ((arg  current-prefix-arg)
                        (C-u  (and (consp arg)  arg)))
                   (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                   (list arg t)))
    (multi-isearch-files-regexp (dired-get-marked-files nil arg 'dired-nondirectory-p nil interactivep)))

  )


;; REPLACE ORIGINAL in `dired-aux.el':
;;
;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
;; 2. Added optional arg INTERACTIVEP.
;; 3. Do not raise error if no files when not INTERACTIVEP.
;; 4. Works also for Emacs < 27.
;;
;;;###autoload
(defun dired-do-search (regexp &optional arg interactivep)
  "Search through all marked files for a match for REGEXP.
Stops when a match is found.
To continue searching for next match, use:
 ,* `\\[filecl-loop-continue]'  (Emacs 27+) or
 ,* `\\[tags-cl-loop-continue]' (older Emacs versions)

A prefix arg behaves as follows:
 ,* An integer means use the next ARG files (previous -ARG, if < 0).
 ,* Two or more `C-u' (e.g. `C-u C-u') means ignore any marks and use
   all files in the Dired buffer.
 ,* Any other prefix arg means use the current file.

When invoked interactively, raise an error if no files are marked."
  (interactive (let* ((arg  current-prefix-arg)
                      (C-u  (and (consp arg)  arg)))
                 (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                 (list (diredp-read-regexp "Search marked files (regexp): ")
                       arg
                       t)))
  (if (< emacs-major-version 27)
      (tags-search regexp `(dired-get-marked-files nil ',arg #'dired-nondirectory-p nil ,interactivep))
    (filecl-loop-initialize-search
     regexp `(dired-get-marked-files nil ',arg #'dired-nondirectory-p nil ,interactivep) 'default)
    (filecl-loop-continue)))


;; REPLACE ORIGINAL in `dired-aux.el':
;;
;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
;; 2. Added optional arg INTERACTIVEP.
;; 3. Do not raise error if no files when not INTERACTIVEP.
;;
;;;###autoload
(defun dired-do-query-replace-regexp (from to &optional arg interactivep)
  "Do `query-replace-regexp' of FROM with TO, on all marked files.
NOTE: A prefix arg for this command acts differently than for other
commands, so that you can use it to request word-delimited matches.

With a prefix argument:
 ,* An odd number of plain `C-u': act on the marked files, but replace
   only word-delimited matches.
 ,* More than one plain `C-u': act on all files, ignoring whether any
   are marked.
 ,* Any other prefix arg: Act on the next numeric-prefix files.

So for example:
 ,* `C-u C-u C-u': act on all files, replacing word-delimited matches.
 ,* `C-u 4': act on the next 4 files.  `C-4' means the same thing.
 ,* `C-u': act on the marked files, replacing word-delimited matches.

When invoked interactively, raise an error if no files are marked.

If you exit (\\[keyboard-quit], RET or q), you can resume the query replace
with the command \\[tags-cl-loop-continue]."
  (interactive (let ((common  (query-replace-read-args "Query replace regexp in marked files" t t)))
                 (list (nth 0 common)
                       (nth 1 common)
                       current-prefix-arg
                       t)))
  (let* ((argnum     (and (consp arg)  (prefix-numeric-value arg)))
         (delimited  (and argnum  (eq (logand (truncate (log argnum 4)) 1) 1))) ; Odd number of plain `C-u'.
         (all        (and argnum  (> argnum 4))) ; At least 3 plain `C-u'.
         (dgmf-arg   (dired-get-marked-files nil
                                             (if (and arg  (atom arg)) (abs arg) (and all  '(16)))
                                             'dired-nondirectory-p
                                             nil
                                             interactivep)))
    (dolist (file  dgmf-arg)
      (let ((buffer  (get-file-buffer file)))
        (when (and buffer  (with-current-buffer buffer buffer-read-only))
          (error "File `%s' is visited read-only" file))))
    (if (< emacs-major-version 27)
        (tags-query-replace from to delimited `',dgmf-arg)
      (filecl-loop-initialize-replace from to `',dgmf-arg (and (not (equal from (downcase from)))  'default) delimited)
      (filecl-loop-continue))))


(when (fboundp 'xref-collect-matches)   ; Emacs 25+


  ;; REPLACE ORIGINAL in `dired-aux.el':
  ;;
  ;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
  ;; 2. Added optional arg INTERACTIVEP.
  ;; 3. Do not raise error if no files when not INTERACTIVEP.
  ;; 4. Works also for Emacs < 27.
  ;;
  (defun dired-do-find-regexp (regexp &optional arg interactivep)
    "Find all matches for REGEXP in all marked files.
For any marked directory, all of its files are searched recursively.
However, files matching `grep-find-ignored-files' and subdirectories
matching `grep-find-ignored-directories' are skipped in the marked
directories.

A prefix arg behaves as follows:
 ,* An integer means use the next ARG files (previous -ARG, if < 0).
 ,* Two or more `C-u' (e.g. `C-u C-u') means ignore any marks and use
   all files in the Dired buffer.
 ,* Any other prefix arg means use the current file.

When invoked interactively, raise an error if no files are marked.

REGEXP should use constructs supported by your local `grep' command."
    (interactive (let* ((arg  current-prefix-arg)
                        (C-u  (and (consp arg)  arg)))
                   (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                   (list (diredp-read-regexp "Search marked files (regexp): ")
                         arg
                         t)))
    (require 'grep)
    (when (> emacs-major-version 26) (require 'xref)) ; Emacs 27+
    (defvar grep-find-ignored-files)
    (if (> emacs-major-version 26)
        (declare-function rgrep-find-ignored-directories "grep" (dir))
      (defvar grep-find-ignored-directories))
    (let* ((marked    (dired-get-marked-files nil arg nil nil interactivep))
           (ignores   (nconc (mapcar #'file-name-as-directory
                                     (if (> emacs-major-version 26)
                                         (rgrep-find-ignored-directories default-directory)
                                       grep-find-ignored-directories))
                             grep-find-ignored-files))
           (xrefs-26  (and (< emacs-major-version 27)
                           (mapcan (lambda (file)
                                     (xref-collect-matches
                                      regexp "*" file (and (file-directory-p file)  ignores)))
                                   marked)))
           (fetcher   (and (> emacs-major-version 26)
                           `(lambda ()
                              (let ((files  ())
                                    (xrefs  ()))
                                (mapc (lambda (file)
                                        (if (file-directory-p file)
                                            (setq files  (nconc (project--files-in-directory file ignores "*")
                                                                files))
                                          (push file files)))
                                      (nreverse ',marked))
                                (setq xrefs  (xref-matches-in-files regexp files))
                                (when (and (null xrefs)  `,interactivep)
                                  (diredp-user-error "No matches for: %s" regexp))
                                xrefs)))))
      (if fetcher
          (xref--show-xrefs fetcher nil) ; Emacs 27+
        (if xrefs-26                     ; Emacs < 27
            (xref--show-xrefs xrefs-26 nil t)
          (when interactivep (diredp-user-error "No matches for: %s" regexp))))))


  ;; REPLACE ORIGINAL in `dired-aux.el':
  ;;
  ;; 1. Added optional arg ARG, so you can act on next ARG files or on all files.
  ;; 2. Added optional arg INTERACTIVEP.
  ;; 3. Do not raise error if no files when not INTERACTIVEP.
  ;;
;;;###autoload
  (defun dired-do-find-regexp-and-replace (from to &optional arg interactivep)
    "Replace matches of FROM with TO, in all marked files.
For any marked directory, matches in all of its files are replaced,
recursively.  However, files matching `grep-find-ignored-files'
and subdirectories matching `grep-find-ignored-directories' are skipped
in the marked directories.

A prefix arg behaves as follows:
 ,* An integer means use the next ARG files (previous -ARG, if < 0).
 ,* Two or more `C-u' (e.g. `C-u C-u') means ignore any marks and use
   all files in the Dired buffer.
 ,* Any other prefix arg means use the current file.

When invoked interactively, raise an error if no files are marked.

REGEXP should use constructs supported by your local `grep' command."
    (interactive (let* ((common  (query-replace-read-args "Query replace regexp in marked files" t t))
                        (arg     current-prefix-arg)
                        (C-u     (and (consp arg)  arg)))
                   (when (and C-u  (> (prefix-numeric-value arg) 16)) (setq arg  '(16)))
                   (list (nth 0 common)
                         (nth 1 common)
                         arg
                         t)))
    (with-current-buffer (dired-do-find-regexp from arg interactivep)
      (xref-query-replace-in-results from to)))

  )

;;;###autoload
(defun diredp-do-grep (command-args)    ; Bound to `C-M-g'
  "Run `grep' on marked (or next prefix arg) files.
A prefix argument behaves according to the ARG argument of
`dired-get-marked-files'.  In particular, `C-u C-u' operates on all
files in the Dired buffer."
  (interactive (progn (unless (if (< emacs-major-version 22)
                                  grep-command
                                (and grep-command  (or (not grep-use-null-device)  (eq grep-use-null-device t))))
                        (grep-compute-defaults))
                      (list (diredp-do-grep-1))))
  (grep command-args))

;; Optional arg FILES is no longer used.  It was used in `diredp-do-grep' before the
;; new `dired-get-marked-files'.
(defun diredp-do-grep-1 (&optional files)
  "Helper function for `diredp-do-grep'.
Non-nil optional arg FILES are the files to grep, overriding the files
choice described for `diredp-do-grep'."
  (let ((default  (and (fboundp 'grep-default-command)
                       (if (fboundp 'grepp-default-regexp-fn) ; In `grep+.el'.
                           (grep-default-command (funcall (grepp-default-regexp-fn)))
                         (grep-default-command)))))
    (read-from-minibuffer
     "grep <pattern> <files> :  "
     (let ((up-to-files  (concat grep-command "   ")))
       (cons (concat up-to-files
                     (mapconcat #'identity
                                (or files  (mapcar 'shell-quote-argument
                                                   (dired-get-marked-files nil current-prefix-arg)))
                                " "))
             (- (length up-to-files) 2)))
     nil nil 'grep-history default)))

(when (memq system-type '(windows-nt ms-dos))
  (define-derived-mode diredp-w32-drives-mode fundamental-mode "Drives"
    "Mode for Dired buffer listing MS Windows drives (local or remote)."
    (setq buffer-read-only  t)))

;; The next two commands were originally taken from Emacs Wiki, page WThirtyTwoBrowseNetDrives:
;; https://www.emacswiki.org/emacs/WThirtyTwoBrowseNetDrives.  They are referred to there as
;; commands `show-net-connections' and `netdir'.  I am hoping that the contributor (anonymous)
;; does not mind my adapting them and including them in `Dired+'.

(when (memq system-type '(windows-nt ms-dos))
  (defun diredp-w32-list-mapped-drives () ; Not bound
    "List network connection information for shared MS Windows resources.
This just invokes the Windows `NET USE' command."
    (interactive)
    (shell-command "net use")
    (display-buffer "*Shell Command Output*")))

(when (memq system-type '(windows-nt ms-dos))
  (defun diredp-w32-drives (&optional other-window-p) ; Bound to `:/'
    "Visit a list of MS Windows drives for use by Dired.
With a prefix argument use another window for the list.
In the list, use `mouse-2' or `RET' to open Dired for a given drive.

The drives listed are the remote drives currently available, as
determined by the Windows command `NET USE', plus the local drives
specified by option `diredp-w32-local-drives', which you can
customize.

Note: When you are in Dired at the root of a drive (e.g. directory
      `C:/'), command `diredp-up-directory' invokes this command.
      So you can use `\\[diredp-up-directory]' to go up to the list of drives."
    (interactive "P")
    (require 'widget)
    (let ((drive              (copy-sequence diredp-w32-local-drives))
          (inhibit-read-only  t))
      (with-temp-buffer
        (insert (shell-command-to-string "net use"))
        (goto-char (point-min))
        (while (re-search-forward "[A-Z]: +\\\\\\\\[^ ]+" nil t nil)
          (setq drive  (cons (split-string (match-string 0)) drive))))
      (if other-window-p
          (pop-to-buffer "*Windows Drives*")
        (if (fboundp 'pop-to-buffer-same-window)
            (pop-to-buffer-same-window "*Windows Drives*")
          (switch-to-buffer "*Windows Drives*")))
      (erase-buffer)
      (widget-minor-mode 1)
      (dolist (drv  (sort drive (lambda (a b) (string-lessp (car a) (car b)))))
        (lexical-let ((drv  drv))
          (widget-create 'push-button
                         :notify (lambda (widget &rest ignore) (dired (car drv)))
                         (concat (car drv) "  " (cadr drv))))
        (widget-insert "\n"))
      (goto-char (point-min))
      (diredp-w32-drives-mode))))

;; $$$$$$ NO LONGER USED.  Was used in `diredp-do-grep(-1)' before new `dired-get-marked-files'.
(defun diredp-all-files ()
  "List of all files shown in current Dired buffer.
Directories are not included."
  (let ((pos    (make-marker))
        (files  ())
        file)
    (save-excursion
      (goto-char (point-min)) (beginning-of-line)
      (while (not (eobp))
        (beginning-of-line)
        (while (and (not (eobp))  (dired-between-files))  (forward-line 1))
        (save-excursion (forward-line 1) (move-marker pos (1+ (point))))
        (setq file  (dired-get-filename nil 'NO-ERROR)) ; Non-nil second arg means "also . and ..".
        (when file                      ; Remove directory portion if in same directory.
          (setq file  (dired-get-filename (dired-in-this-tree file default-directory) 'NO-ERROR)))
        (unless (or (not file)  (file-directory-p file))  (push file files))
        (goto-char pos))
      (move-marker pos nil))
    (setq files  (sort files (if (and (featurep 'ls-lisp)
                                      (not (symbol-value 'ls-lisp-use-insert-directory-program)))
                                 'ls-lisp-string-lessp
                               (if case-fold-search
                                   (lambda (s1 s2) (string-lessp (upcase s1) (upcase s2)))
                                 'string-lessp))))))

(when (fboundp 'read-char-choice)       ; Emacs 24+


  ;; REPLACE ORIGINAL in `dired-aux.el'
  ;;
  ;; `l' lists the files involved and prompts again.
  ;;
  (defun dired-query (sym prompt &rest args)
    "Format PROMPT with ARGS, query user, and store the result in SYM.
The return value is either nil or t.

The user can type:
 `y' or `SPC' to accept once
 `n' or `DEL' to skip once
 `!' to accept this and subsequent queries
 `l' list the files, showing details per `diredp-list-file-attributes'
 `q' or `ESC' to decline this and subsequent queries

If SYM is already bound to a non-nil value, this function may return
automatically without querying the user.  If SYM is `!', return t; if
SYM is `q' or ESC, return nil."
    (let* ((char            (symbol-value sym))
           (char-choices    '(?y ?\   ?n ?\177 ?! ?l ?q ?\e)) ; Use ?\  , not ?\s, for Emacs 20 byte-compiler.
           (list-buf        (generate-new-buffer-name "*Files*"))
           (list-was-shown  nil))
      (unwind-protect
           (cond ((eq char ?!) t)       ; Accept, and don't ask again.
                 ((memq char '(?q ?\e)) nil) ; Skip, and don't ask again.
                 (t                     ; No previous answer - ask now
                  (setq prompt  (concat (apply (if (fboundp 'format-message) #'format-message #'format)
                                               prompt
                                               args)
                                        (if help-form
                                            (format " [Type ynlq! or %s] " (key-description (vector help-char)))
                                          " [Type y, n, l, q or !] ")))
                  (set sym (setq char  (read-char-choice prompt char-choices)))
                  (when (eq char ?l)    ; List files and prompt again.
                    (diredp-list-files args nil nil nil diredp-list-file-attributes)
                    (set sym (setq char  (read-char-choice prompt char-choices))))
                  (and (memq char '(?y ?\   ?!))  t))) ; Use ?\  , not ?\s, for Emacs 20.
        (when (get-buffer list-buf)
          (save-window-excursion
            (pop-to-buffer list-buf)
            (condition-case nil         ; Ignore error if user already deleted.
                (if (one-window-p) (delete-frame) (delete-window))
              (error nil))
            (if list-was-shown (bury-buffer list-buf) (kill-buffer list-buf)))))))

  )

(unless (fboundp 'read-char-choice)     ; Emacs 20-23 (modified the Emacs 23 version).  Needs `dired-query-alist'.


  ;; REPLACE ORIGINAL in `dired-aux.el'
  ;;
  ;; 1. `l' lists the files involved and prompts again.
  ;; 2. Compatible with older Emacs versions (before Emacs 24): can use `dired-query-alist'.
  ;;
  (defun dired-query (qs-var qs-prompt &rest qs-args)
    "Query user and return nil or t.
The user can type:
 `y' or `SPC' to accept once
 `n' or `DEL' to skip once
 `!' to accept this and subsequent queries
 `l' list the files, showing details per `diredp-list-file-attributes'
 `q' or `ESC' to decline this and subsequent queries

Store answer in symbol VAR (which must initially be bound to nil).
Format PROMPT with ARGS.
Binding variable `help-form' will help the user who types the help key."
    (let* ((char               (symbol-value qs-var))
           (dired-query-alist  (cons '(?l . l) dired-query-alist))
           (action             (cdr (assoc char dired-query-alist))))
      (cond ((eq 'yes action) t)        ; Accept, and don't ask again.
            ((eq 'no action) nil)       ; Skip, and don't ask again.
            (t                          ; No lasting effects from last time we asked - ask now.
             (let ((cursor-in-echo-area  t)
                   (executing-kbd-macro  executing-kbd-macro)
                   (qprompt              (concat qs-prompt
                                                 (if help-form
                                                     (format " [Type ynl!q or %s] "
                                                             (key-description (char-to-string help-char)))
                                                   " [Type y, n, l, q or !] ")))
                   done result elt)
               (while (not done)
                 (apply #'message qprompt qs-args)
                 (setq char  (set qs-var (read-event)))
                 (when (eq char ?l)     ; List files and prompt again.
                   (diredp-list-files qs-args nil nil nil diredp-list-file-attributes)
                   (apply #'message qprompt qs-args)
                   (setq char  (set qs-var (read-event))))
                 (if (numberp char)
                     (cond ((and executing-kbd-macro (= char -1))
                            ;; `read-event' returns -1 if we are in a keyboard macro and there are no more
                            ;; events in the macro.  Try to get an event interactively.
                            (setq executing-kbd-macro  nil))
                           ((eq (key-binding (vector char)) 'keyboard-quit) (keyboard-quit))
                           (t (setq done  (setq elt  (assoc char dired-query-alist)))))))
               ;; Display the question with the answer.
               (message "%s" (concat (apply #'format qprompt qs-args) (char-to-string char)))
               (memq (cdr elt) '(t y yes)))))))

  )


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; 1. Use `diredp-this-subdir' instead of `dired-get-filename'.
;; 2. If on a subdir listing header line or a non-dir file in a subdir listing, go to
;;    the line for the subdirectory in the parent directory listing.
;; 3. Fit one-window frame after inserting subdir.
;;
;;;###autoload
(defun dired-maybe-insert-subdir (dirname &optional switches no-error-if-not-dir-p)
                                        ; Bound to `i'
  "Move to Dired subdirectory line or subdirectory listing.
This bounces you back and forth between a subdirectory line and its
inserted listing header line.  Using it on a non-directory line in a
subdirectory listing acts the same as using it on the subdirectory
header line.

,* If on a subdirectory line, then go to the subdirectory's listing,
  creating it if not yet present.

,* If on a subdirectory listing header line or a non-directory file in
  a subdirectory listing, then go to the line for the subdirectory in
  the parent directory listing.

,* If on a non-directory file in the top Dired directory listing, do
  nothing.

Subdirectories are listed in the same position as for `ls -lR' output.

With a prefix arg, you can edit the `ls' switches used for this
listing.  Add `R' to the switches to expand the directory tree under a
subdirectory.

Dired remembers switches specified with a prefix arg, so reverting the
buffer does not reset them.  However, you might sometimes need to
reset some subdirectory switches after using \\<dired-mode-map>`\\[dired-undo]'.  You can reset all
subdirectory switches to the default value using
`\\[dired-reset-subdir-switches]'.
See Info node `(emacs) Subdir switches' for more details."
  (interactive (list (diredp-this-subdir)
                     (and current-prefix-arg
                          (read-string "Switches for listing: "
                                       (or (and (boundp 'dired-subdir-switches)  dired-subdir-switches)
                                           dired-actual-switches)))))
  (let ((opoint    (point))
        (filename  dirname))
    (cond ((consp filename)             ; Subdir header line or non-directory file.
           (setq filename  (car filename))
           (if (assoc filename dired-subdir-alist)
               (dired-goto-file filename) ;  Subdir header line.
             (dired-insert-subdir (substring (file-name-directory filename) 0 -1))))
          (t
           ;; We don't need a marker for opoint as the subdir is always
           ;; inserted *after* opoint.
           (setq dirname  (file-name-as-directory dirname))
           (or (and (not switches)  (dired-goto-subdir dirname))
               (dired-insert-subdir dirname switches no-error-if-not-dir-p))
           ;; Push mark so that it's easy to go back.  Do this after the
           ;; insertion message so that the user sees the `Mark set' message.
           (push-mark opoint)
           (when (and (get-buffer-window (current-buffer)) ; Fit one-window frame.
                      (fboundp 'fit-frame-if-one-window)) ; In `autofit-frame.el'.
             (fit-frame-if-one-window))))))

(defun diredp-this-subdir ()
  "This line's filename, if directory, or `dired-current-directory' list.
If on a directory line, then return the directory name.
Else return a singleton list of a directory name, which is as follows:
  If on a subdirectory header line (either of the two lines), then use
  that subdirectory name.  Else use the parent directory name."
  (or (let ((file  (dired-get-filename nil 'NO-ERROR)))
        (and file
             (file-directory-p file)
             (not (member (file-relative-name file (file-name-directory (directory-file-name file)))
                          '("." ".." "./" "../")))
             file))
      (list (dired-current-directory))))


;; REPLACE ORIGINAL in `dired-aux.el'
;;
;; 1. Added optional arg FROM, which is also listed by `l' when prompted.
;; 2. Added missing doc string.
;;
(defun dired-handle-overwrite (to &optional from)
  "Save old version of file TO that is to be overwritten.
`dired-overwrite-confirmed' and `overwrite-backup-query' are fluid vars
from `dired-create-files'.

Optional arg FROM is a file being copied or renamed to TO.  It is used
only when a user hits `l' to list files when asked whether to
overwrite."
  (let (backup)
    (when (and dired-backup-overwrite
               dired-overwrite-confirmed
               (setq backup (car (find-backup-file-name to)))
               (or (eq 'always dired-backup-overwrite)
                   (dired-query 'overwrite-backup-query "Make backup for existing file `%s'? " to from)))
      (rename-file to backup 0)         ; Confirm overwrite of old backup.
      (dired-relist-entry backup))))


(when (fboundp 'dired-copy-file-recursive) ; Emacs 22+


  ;; REPLACE ORIGINAL in `dired-aux.el'
  ;;
  ;; 1. Pass also FROM to `dired-handle-overwrite', so `l' lists it too.
  ;; 2. Added missing doc string.
  ;;
  (defun dired-copy-file (from to ok-if-already-exists)
    "Copy file FROM to location TO.
Non-nil arg OK-IF-ALREADY-EXISTS is passed to `copy-file' or
 `make-symbolic-link'.
Preserves the last-modified date when copying, unless
`dired-copy-preserve-time' is nil."
    (dired-handle-overwrite to from)
    (dired-copy-file-recursive from to ok-if-already-exists dired-copy-preserve-time t dired-recursive-copies))


  ;; REPLACE ORIGINAL in `dired-aux.el'
  ;;
  ;; 1. Pass also FROM to `dired-handle-overwrite', so `l' lists it too.
  ;; 2. Added missing doc string.
  ;;
  (defun dired-copy-file-recursive (from to ok-if-already-exists &optional keep-time top recursive)
    "Copy file FROM to location TO, handling directories in FROM recursively.
Non-nil arg OK-IF-ALREADY-EXISTS is passed to `copy-file' or
 `make-symbolic-link'.
Non-nil optional arg KEEP-TIME is passed to `copy-file' or
 `copy-directory'.
Non-nil optional arg TOP means do not bother with `dired-handle-overwrite'.
Non-nil optional arg RECURSIVE means recurse on any directories in
 FROM, after confirmation if RECURSIVE is not `always'."
    (when (and (eq t (car (file-attributes from)))  (file-in-directory-p to from))
      (error "Cannot copy `%s' into its subdirectory `%s'" from to))
    (let ((attrs  (file-attributes from)))
      (if (and recursive
               (eq t (car attrs))
               (or (eq recursive 'always)  (yes-or-no-p (format "Recursive copies of %s? " from))))
          (copy-directory from to keep-time)
        (or top  (dired-handle-overwrite to from))
        (condition-case err
            (if (stringp (car attrs))   ; It is a symlink
                (make-symbolic-link (car attrs) to ok-if-already-exists)
              (copy-file from to ok-if-already-exists keep-time))
          (file-date-error
           (push (dired-make-relative from) dired-create-files-failures)
           (dired-log "Can't set date on %s:\n%s\n" from err))))))

  )


;; REPLACE ORIGINAL in `dired-aux.el'
;;
;; 1. Pass also FILE to `dired-handle-overwrite', so `l' lists it too.
;; 2. Added missing doc string.
;;
(defun dired-rename-file (file newname ok-if-already-exists)
  "Rename FILE to NEWNAME.
Non-nil arg OK-IF-ALREADY-EXISTS is passed to `rename-file'."
  (dired-handle-overwrite newname file)
  (when (fboundp 'dired-maybe-create-dirs) (dired-maybe-create-dirs (file-name-directory newname))) ; Emacs 27+
  (rename-file file newname ok-if-already-exists) ; Error is caught in `-create-files'.
  ;; Silently rename the visited file of any buffer visiting this file.
  (and (get-file-buffer file)  (with-current-buffer (get-file-buffer file) (set-visited-file-name newname nil t)))
  (dired-remove-file file)
  ;; See if it's an inserted subdir, and rename that, too.
  (when (file-directory-p file)         ; Emacs bug #32899
    (dired-rename-subdir file newname)))


;; REPLACE ORIGINAL in `dired-aux.el'
;;
;; Pass also FILE to `dired-handle-overwrite', so `l' lists it too.
;;
(defun dired-hardlink (file newname &optional ok-if-already-exists)
  "Give FILE additional name NEWNAME.
Non-nil arg OK-IF-ALREADY-EXISTS is passed to `add-name-to-file'."
  (dired-handle-overwrite newname file)
  (add-name-to-file file newname ok-if-already-exists) ; Error is caught in -create-files'.
  (dired-relist-file file))             ; Update the link count.


;; REPLACE ORIGINAL in `dired.el'.
;;
;; No-op: does nothing now.
;;
(defun dired-insert-subdir-validate (dirname &optional switches))


;;; $$$$$$$$
;;; ;; REPLACE ORIGINAL in `dired-aux.el'.
;;; ;;
;;; ;; 1. Do not require that DIRNAME be in the current directory tree (no error if not).
;;; ;; 2. Use `dolist' instead of `mapcar'.
;;; ;;
;;; (defun dired-insert-subdir-validate (dirname &optional switches)
;;;   "Raise an error if it is invalid to insert DIRNAME with SWITCHES."
;;; ;;; (or (dired-in-this-tree dirname (expand-file-name default-directory)) ; REMOVED
;;; ;;;     (error  "%s: not in this directory tree" dirname))
;;;   (let ((real-switches  (or switches  (and (boundp 'dired-subdir-switches) ; Emacs 22+
;;;                                            dired-subdir-switches))))
;;;     (when real-switches
;;;       (let (case-fold-search)
;;;         (dolist (switchs  '("F" "b"))   ; Switches that matter for `dired-get-filename'.
;;;           (unless (eq (null (diredp-string-match-p switchs real-switches))
;;;                       (null (diredp-string-match-p switchs dired-actual-switches)))
;;;             (error "Can't have dirs with and without `-%s' switches together" switchs)))))))


;; REPLACE ORIGINAL in `dired-aux.el'.
;;
;; If NEW-DIR is not a descendant of a directory in the buffer, put it at eob.
;;
(defun dired-insert-subdir-newpos (new-dir)
  "Move to the proper position for inserting NEW-DIR, and return it.
Respect the order within each directory tree.  But if NEW-DIR is not a
descendant of any directory in the buffer, then put it at the end."
  (let ((alist  dired-subdir-alist)
        elt dir new-pos)
    (while alist
      (setq elt    (car alist)
            alist  (cdr alist)
            dir    (car elt))
      (if (dired-tree-lessp dir new-dir)
          (setq new-pos  (dired-get-subdir-max elt) ; Position NEW-DIR after DIR.
                alist    ())
        (setq new-pos  (point-max))))
    (goto-char new-pos))
  (unless (eobp) (forward-line -1))
  (insert "\n")
  (point))


;; Provide Emacs 27+ handling of hiding subdir listings.
;;
;; Except for `diredp--add-dired-to-invisibility-hook', these are from vanilla Emacs 27.1, `dired.el' and
;; `dired-aux.el' - no changes, except as noted.
;;
;; The non-"internal" ones here (no `--') OVERRIDE any versions from earlier Emacs versions.  Earlier Emacs versions
;; used selective display, which is extremely slow (pretty much hangs Emacs) for a large subdir listing.
;;
(when (< emacs-major-version 27)

  (defun diredp--add-dired-to-invisibility-hook ()
    (when (and (< emacs-major-version 22)  (eq buffer-invisibility-spec t))
      (setq buffer-invisibility-spec (list t)))
    (add-to-invisibility-spec '(dired . t)))
  (add-hook 'dired-mode-hook 'diredp--add-dired-to-invisibility-hook)

  (defun dired--find-hidden-pos (start end) ; Emacs 27.1 `dired.el'
    (text-property-any start end 'invisible 'dired))

  (defun dired--hidden-p (&optional pos) ; Emacs 27.1 `dired.el'
    (eq (get-char-property (or pos  (point)) 'invisible) 'dired))

  (defun dired--hide (start end)        ; Emacs 27.1 `dired.el'
    ;; The old code used selective-display which only works at
    ;; a line-granularity, so it used start and end positions that were
    ;; approximate ("anywhere on the line is fine").
    (save-excursion
      (put-text-property (progn (goto-char start) (line-end-position))
                         (progn (goto-char end)   (line-end-position))
                         'invisible 'dired)))

  ;; Fixed to support older Emacs versions, which don't have `remove-list-of-text-properties'.
  (defun dired--unhide (start end)      ; From Emacs 27.1 `dired.el'.
    ;; The Emacs < 27 code used selective-display which only works at a line-granularity, so it used start and end
    ;; positions that were approximate ("anywhere on the line is fine").
    ;;
    ;; FIXME: This also removes other invisible properties!
    (save-excursion
      (remove-text-properties (progn (goto-char start) (line-end-position))
                              (progn (goto-char end) (line-end-position))
                              '(invisible _DUMMY))))

  (defun dired-remember-marks (beg end) ; Emacs 27.1 `dired.el'
    "Return alist of files and their marks, from BEG to END."
    (if (dired--find-hidden-pos (point-min) (point-max))
        (dired--unhide (point-min) (point-max))) ;Must unhide to make this work.
    (let (fil chr alist)
      (save-excursion
        (goto-char beg)
        (while (re-search-forward dired-re-mark end t)
          (when (setq fil  (dired-get-filename nil t))
            (setq chr    (preceding-char)
                  alist  (cons (cons fil chr) alist)))))
      alist))

  (defun dired-unhide-subdir ()         ; Emacs 27.1 `dired-aux.el'
    (with-silent-modifications
      (dired--unhide (dired-subdir-min) (dired-subdir-max))))

  (defun dired-subdir-hidden-p (dir)    ; Emacs 27.1 `dired-aux.el'
    (save-excursion
      (dired-goto-subdir dir)
      (dired--hidden-p)))

  ;; Fixed to support older Emacs versions.
  ;;
  (defun dired-add-entry (filename &optional marker-char relative) ; Emacs 27.1 `dired-aux.el'
    "Add a new dired entry for FILENAME.
Optionally mark it with MARKER-CHAR (a character, else uses
`dired-marker-char').  Note that this adds the entry `out of order'
if files are sorted by time, etc.
Skips files that match `dired-trivial-filenames'.
Exposes hidden subdirectories if a file is added there.

If `dired-x' is loaded and `dired-omit-mode' is enabled, skips
files matching `dired-omit-regexp'."
    (if (or (not (featurep 'dired-x))
            (and (boundp 'dired-omit-mode) ; Emacs 22+.
                 (not dired-omit-mode))
            ;; Avoid calling `ls' for files that are going to be omitted anyway.
            (let ((omit-re  (dired-omit-regexp)))
              (or (string= omit-re "")
                  (not (diredp-string-match-p omit-re (cond ((eq 'no-dir dired-omit-localp) filename)
                                                            ((eq t dired-omit-localp) (dired-make-relative filename))
                                                            (t (dired-make-absolute
                                                                filename (file-name-directory filename)))))))))
        ;; Do it!
        (progn
          (setq filename  (directory-file-name filename))
          ;; Entry is always for files, even if they happen to also be directories.
          (let* ((opoint     (point))
                 (cur-dir    (dired-current-directory))
                 (directory  (if relative cur-dir (file-name-directory filename)))
                 reason)
            (setq filename  (if relative (file-relative-name filename directory) (file-name-nondirectory filename))
                  reason    (catch 'not-found
                              (if (string= directory cur-dir)
                                  (progn
                                    (end-of-line)
                                    (when (dired--hidden-p) (dired-unhide-subdir))
                                    ;; Where we should be, unless point is before subdir line or its total line.
                                    (let ((p  (dired-after-subdir-garbage cur-dir)))
                                      (when (< (point) p) (goto-char p))))
                                ;; Else try to find correct place to insert
                                (if (dired-goto-subdir directory)
                                    (progn                    ; Unhide if necessary
                                      (when (dired--hidden-p) ; Point is at end of subdir line.
                                        (dired-unhide-subdir))
                                      ;; Found - skip subdir and `total' line and uninteresting files like . and ..
                                      ;; This had better not move into the next subdir!
                                      (dired-goto-next-nontrivial-file))
                                  ;; Not found
                                  (throw 'not-found "Subdir not found")))
                              (let (buffer-read-only  opoint)
                                (beginning-of-line)
                                (setq opoint  (point))
                                ;; Don't expand `.'.  Show just the file name within directory.
                                (let ((default-directory  directory))
                                  (dired-insert-directory
                                   directory (concat dired-actual-switches " -d") (list filename)))
                                (goto-char opoint)
                                ;; Put in desired marker char.
                                (when marker-char
                                  (let ((dired-marker-char  (if (integerp marker-char)
                                                                marker-char
                                                              dired-marker-char)))
                                    (dired-mark nil)))
                                ;; Compensate for a bug in `ange-ftp'.  It inserts the file's absolute name, rather
                                ;; than the relative one.  That may be hard to fix since it is probably
                                ;; controlled by something in FTP.
                                (goto-char opoint)
                                (let ((inserted-name  (dired-get-filename 'verbatim)))
                                  (if (file-name-directory inserted-name)
                                      (let (props)
                                        (end-of-line)
                                        (forward-char (- (length inserted-name)))
                                        (setq props  (text-properties-at (point)))
                                        (delete-char (length inserted-name))
                                        (let ((pt  (point)))
                                          (insert filename)
                                          (set-text-properties pt (point) props))
                                        (forward-char 1))
                                    (forward-line 1)))
                                (forward-line -1)
                                (if dired-after-readin-hook
                                    ;; The subdir-alist is not affected...
                                    (save-excursion ; ...so we can run it right now:
                                      (save-restriction
                                        (beginning-of-line)
                                        (narrow-to-region (point) (line-beginning-position 2))
                                        (run-hooks 'dired-after-readin-hook))))
                                (dired-move-to-filename))
                              ;; Return nil if all went well
                              nil))
            (when reason (goto-char opoint)) ; don't move away on failure
            (not reason)))                   ; return t on success, else nil
      ;; Don't do it (`dired-omit-mode').
      ;; Return t for success (perhaps we should return `file-exists-p').
      t))

  ;; Fixed to support older Emacs versions: Don't use `pcase-dolist'.
  ;;
  (defun dired-remember-hidden ()       ; Emacs 27.1 `dired.el'
    "Return a list of names of subdirs currently hidden."
    (let (result)
      ;; ORIGINAL:
      ;;       (pcase-dolist (`(,dir . ,pos) dired-subdir-alist)
      ;;         (goto-char pos)
      ;;         (end-of-line)
      ;;         (when (dired--hidden-p) (push dir result)))
      ;;       result))
      (let (dir pos)
        (dolist (dir.pos  dired-subdir-alist)
          (setq dir  (car dir.pos)
                pos  (cdr dir.pos))
          (goto-char pos)
          (end-of-line)
          (when (dired--hidden-p) (push dir result)))
        result)))

  (defun dired-move-to-end-of-filename (&optional no-error) ; Emacs 27.1 `dired.el'
    ;; Assumes point is at beginning of filename,
    ;; thus the rwx bit re-search-backward below will succeed in *this*
    ;; line if at all.  So, it should be called only after
    ;; (dired-move-to-filename t).
    ;; On failure, signals an error (with non-nil NO-ERROR just returns nil).
    ;; This is the UNIX version.
    (if (get-text-property (point) 'dired-filename)
        (goto-char (next-single-property-change (point) 'dired-filename))
      (let ((opoint  (point))
            (used-F  (dired-check-switches dired-actual-switches "F" "classify"))
            (eol     (line-end-position))
            (hidden  (dired--hidden-p))
            file-type executable symlink)
        (if hidden
            nil
          (save-excursion               ; Find out what kind of file this is.
            ;; Restrict permission bits to non-blank, otherwise this matches one char too early (looking backward):
            ;; "l---------" (some systems make symlinks that way)
            ;; "----------" (plain file with zero perms)
            (if (re-search-backward dired-permission-flags-regexp nil t)
                (setq file-type   (char-after (match-beginning 1))
                      symlink     (eq file-type ?l)
                      ;; Only with -F we need to know whether it's an executable
                      executable  (and used-F  (string-match
                                                "[xst]" ;; execute bit set anywhere?
                                                (concat (match-string 2) (match-string 3) (match-string 4)))))
              (unless no-error (error "No file on this line"))))
          ;; Move point to end of name:
          (if symlink
              (when (search-forward " -> " eol t)
                (forward-char -4)
                (and used-F  dired-ls-F-marks-symlinks  (eq (preceding-char) ?@) ; `ls' really marked the link
                     (forward-char -1)))
            ;; Else not a symbolic link, `ls -lF' marks dirs, sockets, fifos and executables with exactly one
            ;; trailing char.  (Executable bits on symlinks don't mean a thing, even to `ls', but we know it's
            ;; not a symlink.)
            (goto-char eol)
            (and used-F  (or (memq file-type '(?d ?s ?p))  executable)
                 (forward-char -1))))
        (or no-error
            (not (eq opoint (point)))
            (error "%s" (if hidden
                            (substitute-command-keys "File line is hidden, type \\[dired-hide-subdir] to unhide")
                          "No file on this line")))
        (if (eq opoint (point)) nil (point)))))

  (unless (fboundp 'dired-check-switches)                       ; < Emacs 24
    (defun dired-check-switches (switches short &optional long) ; Emacs 27.1 `dired.el'
      "Return non-nil if the string SWITCHES matches LONG or SHORT format."
      (let (case-fold-search)
        (and (stringp switches)
             (diredp-string-match-p (concat "\\(\\`\\| \\)-[[:alnum:]]*" short
                                            (if long (concat "\\|--" long "\\>") ""))
                                    switches)))))

  (defun dired-hide-subdir (arg)        ; Emacs 27.1 `dired-aux.el'
    "Hide or unhide the current subdirectory and move to next directory.
Optional prefix arg is a repeat factor.
Use \\[dired-hide-all] to (un)hide all directories."
    (interactive "p")
    (with-silent-modifications
      (while (>=  (setq arg  (1- arg)) 0)
        (let* ((cur-dir   (dired-current-directory))
               (hidden-p  (dired-subdir-hidden-p cur-dir))
               (elt       (assoc cur-dir dired-subdir-alist))
               (end-pos   (1- (dired-get-subdir-max elt)))
               buffer-read-only)
          ;; Keep header line visible, hide rest
          (goto-char (cdr elt))
          (end-of-line)
          (if hidden-p (dired--unhide (point) end-pos) (dired--hide (point) end-pos)))
        (dired-next-subdir 1 t))))

  (defun dired-hide-all (&optional ignored) ; Emacs 27.1 `dired-aux.el'
    "Hide all subdirectories, leaving only their header lines.
If there is already something hidden, make everything visible again.
Use \\[dired-hide-subdir] to (un)hide a particular subdirectory."
    (interactive "P")
    (with-silent-modifications
      (if (text-property-any (point-min) (point-max) 'invisible 'dired)
          (dired--unhide (point-min) (point-max))
        (let ((pos  (point-max)))        ; Position of end of last directory
          (dolist (subdir dired-subdir-alist)
            (let ((start  (cdr subdir))  ; Position of prev dir
                  (end    (save-excursion
                            (goto-char pos) ; Current dir.  We're somewhere on current dir's line.
                            (forward-line -1)
                            (point))))
              (dired--hide start end))
            (setq pos  (cdr subdir))))))) ; Previous dir gets current dir
  )

;; This is like `dired-hide-subdir' in `dired-aux.el', except:
;;
;; 1. Plain prefix arg means invoke `dired-hide-all'.  Added optional arg NEXT.
;; 2. Do not move to the next subdir.
;;
;;;###autoload
(defun diredp-hide-subdir-nomove (arg &optional next) ; Bound to `$'
    "Hide or unhide the current directory.
Unlike `dired-hide-subdir', this does not advance the cursor to the
next directory header line.

With a plain prefix arg (`C-u'), invoke `dired-hide-all' to hide or
 show everything.
With a numeric prefix arg N, hide this subdirectory and the next N-1
 subdirectories."
    (interactive "P")
    (if (consp arg)
        (dired-hide-all 'IGNORED) ; Arg needed for older Emacs versions.
      (setq arg  (prefix-numeric-value arg))
      (with-silent-modifications
        (while (>=  (setq arg  (1- arg)) 0)
          (let* ((cur-dir   (dired-current-directory))
                 (hidden-p  (dired-subdir-hidden-p cur-dir))
                 (elt       (assoc cur-dir dired-subdir-alist))
                 (end-pos   (1- (dired-get-subdir-max elt)))
                 buffer-read-only)
            (goto-char (cdr elt)) ; Keep header line visible, hide rest
            (end-of-line)
            (if hidden-p
                (dired--unhide (point) end-pos)
              (dired--hide (point) end-pos)))
          (when next (dired-next-subdir 1 t))))))

;;; ----------------------
;;; If we instead renamed `diredp-hide-subdir-nomove' to `dired-hide-subdir' as a replacement,
;;; then we would define things this way:
;;;
;;;
;;; ;; REPLACE ORIGINAL in `dired-aux.el'.
;;; ;;
;;; ;; 1. Plain prefix arg means invoke `dired-hide-all'.  Added optional arg NEXT.
;;; ;;
;;; ;; 2. Do not move to the next subdir.
;;; ;;
;;; ;; 3. Modified to work with also with older Emacs versions.
;;; ;;
;;; (defun dired-hide-subdir (arg &optional next)
;;;   "Hide or unhide the current directory.
;;; Unlike `diredp-hide-subdir-goto-next', this does not advance the
;;; cursor to the next directory header line.
;;;
;;; With a plain prefix arg (`C-u'), invoke `dired-hide-all' to hide or
;;;  show everything.
;;; With a numeric prefix arg N, hide this subdirectory and the next N-1
;;;  subdirectories."
;;;   (interactive "P")
;;;   (dired-hide-check)
;;;   (if (consp arg)
;;;       (dired-hide-all 'IGNORED)         ; Arg needed for older Emacs versions.
;;;     (setq arg  (prefix-numeric-value arg))
;;;     (let ((modflag  (buffer-modified-p)))
;;;       (while (>=  (setq arg  (1- arg)) 0)
;;;         (let* ((cur-dir   (dired-current-directory))
;;;                (hidden-p  (dired-subdir-hidden-p cur-dir))
;;;                (elt       (assoc cur-dir dired-subdir-alist))
;;;                (end-pos   (1- (dired-get-subdir-max elt)))
;;;                buffer-read-only)
;;;           (goto-char (dired-get-subdir-min elt)) ; Keep header line visible, hide rest
;;;           (skip-chars-forward "^\n\r")
;;;           (if hidden-p
;;;               (subst-char-in-region (point) end-pos ?\r ?\n)
;;;             (subst-char-in-region (point) end-pos ?\n ?\r)))
;;;         (when next (dired-next-subdir 1 t)))
;;;       (if (fboundp 'restore-buffer-modified-p)
;;;           (restore-buffer-modified-p modflag)
;;;         (set-buffer-modified-p modflag)))))
;;;
;;; (defun diredp-hide-subdir-goto-next (arg)
;;;   "Hide or unhide current directory and move to next directory header line."
;;;   (interactive "P")
;;;   (dired-hide-subdir arg 'NEXT))
;;; ----------------------



;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; When `diredp-omit-lines-regexp' is non-nil, call `dired-omit-expunge' again to omit matching lines.
;;
(when (fboundp 'define-minor-mode)      ; Emacs 22+

  ;; Macro `define-minor-mode' is not defined in Emacs 20, so in order to be able to byte-compile
  ;; this file in Emacs 20, prohibit byte-compiling of the `define-minor-mode' call.
  ;;
  (eval '(define-minor-mode dired-omit-mode
           "Toggle omission of uninteresting files in Dired (Dired-Omit mode).
With prefix argument ARG, enable Dired-Omit mode if ARG is positive,
and disable it otherwise.

If called from Lisp, enable the mode if ARG is omitted or nil.

Dired-Omit mode is a buffer-local minor mode.

When enabled in a Dired buffer, Dired does not list files whose
filenames match regexp `dired-omit-files', files ending with
extensions in `dired-omit-extensions', or files listed on lines
matching `diredp-omit-lines-regexp'.

To enable omitting in every Dired buffer, you can put this in
your init file:

  (add-hook \\='dired-mode-hook (lambda () (dired-omit-mode)))

See Info node `(dired-x) Omitting Variables' for more information."
           nil nil nil :group 'Dired-Plus
           (if (not dired-omit-mode)
               (revert-buffer)
             (let ((dired-omit-size-limit  nil)
                   (file-count             0))
               ;; Omit by file-name match, then omit by line match.
               ;; Use count of file-name match as INIT-COUNT for line match.
               ;; Return total count.  (Return value is not used anywhere, so far).
               (setq file-count  (dired-omit-expunge))
               (when diredp-omit-lines-regexp (dired-omit-expunge diredp-omit-lines-regexp 'LINEP file-count))))))

  (unless (boundp 'dired-omit-verbose)  ; Not in Emacs < 24.
    (defvar dired-omit-verbose t
      "When non-nil, show messages when omitting files.
When nil, don't show messages."))


  ;; REPLACE ORIGINAL in `dired-x.el'.
  ;;
  ;; Added optional args LINEP and INIT-COUNT.
  ;;
  (defun dired-omit-expunge (&optional regexp linep init-count)
    "Erase all unmarked files whose names match REGEXP.
With a prefix arg (non-nil LINEP when called from Lisp), match REGEXP
against the whole line.  Otherwise, match it against the file name.

If REGEXP is nil, use `dired-omit-files', and also omit file names
ending in `dired-omit-extensions'.

Do nothing if REGEXP is the empty string, `dired-omit-mode' is nil, or
if called from Lisp and buffer is bigger than `dired-omit-size-limit'.

Optional arg INIT-COUNT is an initial count tha'is added to the number
of lines omitted by this invocation of `dired-omit-expunge', in the
status message."
    (interactive "sOmit files (regexp): \nP")
    (when (and (symbolp regexp)  (boundp regexp)) (setq regexp  (symbol-value regexp)))
    ;; Bind `dired-marker-char' to `dired-omit-marker-char', then call `dired-do-kill-lines'.
    (if (and dired-omit-mode
             (or (called-interactively-p 'interactive)
                 (not dired-omit-size-limit)
                 (< (buffer-size) dired-omit-size-limit)
                 (progn
                   (when dired-omit-verbose
                     (message "Not omitting: directory larger than %d characters." dired-omit-size-limit))
                   (setq dired-omit-mode  nil)
                   nil)))
        (let ((omit-re         (or regexp  (dired-omit-regexp)))
              (old-modified-p  (buffer-modified-p))
              (count           (or init-count  0)))
          (unless (string= omit-re "")
            (let ((dired-marker-char  dired-omit-marker-char))
              (when dired-omit-verbose (message "Omitting..."))
              (if (not (if linep
                           (dired-mark-if (and (= (following-char) ?\   ) ; Not already marked
                                               (string-match-p omit-re (buffer-substring
                                                                        (line-beginning-position)
                                                                        (line-end-position))))
                                          nil)
                         (dired-mark-unmarked-files
                          omit-re nil nil dired-omit-localp
                          (dired-omit-case-fold-p (if (stringp dired-directory)
                                                      dired-directory
                                                    (car dired-directory))))))
                  (when dired-omit-verbose (message "(Nothing to omit)"))
                (setq count  (+ count
                                (dired-do-kill-lines nil (if dired-omit-verbose "Omitted %d line%s" "") init-count)))
                (force-mode-line-update))))
          ;; Try to preserve modified state of buffer, so `%*' doesn't appear in `mode-line'.
          (set-buffer-modified-p (and old-modified-p  (save-excursion (goto-char (point-min))
                                                                      (re-search-forward dired-re-mark nil t))))
          count))))


;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; Fix the `interactive' spec.  This is the Emacs 24+ version, provided for earlier versions.
;;
(unless (> emacs-major-version 23)
  (defun dired-mark-unmarked-files (regexp msg &optional unflag-p localp)
    "Mark unmarked files matching REGEXP, displaying MSG.
REGEXP is matched against the entire file name.  When called
interactively, prompt for REGEXP.
With prefix argument, unflag all those files.

Non-interactively:
 Returns t if any work was done, nil otherwise.
 Optional fourth argument LOCALP is as in `dired-get-filename'."
    (interactive (list (diredp-read-regexp "Mark unmarked files matching regexp (default all): ")
                       nil
                       current-prefix-arg
                       nil))
    (let ((dired-marker-char  (if unflag-p ?\   dired-marker-char))
          (unmarkedp          (eq (char-after) ?\   )))
      (diredp-mark-if (and (if unflag-p (not unmarkedp) unmarkedp) ; Fixes Emacs bug #27465.
                           (let ((fn  (dired-get-filename localp 'NO-ERROR))) ; Uninteresting
                             (and fn  (diredp-string-match-p regexp fn))))
                      msg))))


;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; 1. Call `dired-get-marked-files' with original ARG, to get its multi-`C-u' behavior.
;; 2. Doc string updated to reflect change to `dired-simultaneous-find-file'.
;; 3. Added optional arg INTERACTIVEP.
;; 4. Do not raise error if no files when not INTERACTIVEP.
;;
;;;###autoload
(defun dired-do-find-marked-files (&optional arg interactivep) ; Bound to `F'
  "Find marked files, displaying all of them simultaneously.
With no prefix argument:

,* If `pop-up-frames' is nil then split the current window across all
  marked files, as evenly as possible.  Remaining lines go to the
  bottom-most window.  The number of files that can be displayed this
  way is restricted by the height of the current window and
  `window-min-height'.

,* If `pop-up-frames' is non-nil then show each marked file in a
  separate frame (not window).

With a prefix argument:

,* One or more plain `C-u' behaves as for `dired-get-marked-files'.
  In particular, `C-u C-u' means ignore any markings and operate on
  ALL files and directories (except `.' and `..') in the Dired buffer.

,* A numeric prefix arg >= 0 means just find (visit) the marked files -
  do not show them.

,* A numeric prefix arg < 0 means show each marked file in a separate
  frame (not window).  (This is the same behavior as no prefix arg
  with non-nil `pop-up-frames'.)

Note that a numeric prefix argument acts differently with this command
than it does with other `dired-do-*' commands: it does NOT act on the
next or previous (abs ARG) files, ignoring markings.

To keep the Dired buffer displayed, split the window (e.g., `C-x 2')
first.  To show only the marked files, type `\\[delete-other-windows]' first.

When invoked interactively, raise an error if no files are marked."
  (interactive "P\np")
  (dired-simultaneous-find-file
   (dired-get-marked-files nil (and (consp arg)  arg) nil nil interactivep)
   (and arg  (not (consp arg))  (prefix-numeric-value arg))))


;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; Use separate frames instead of windows if `pop-up-frames' is non-nil,
;; or if prefix arg is negative.
;;
(defun dired-simultaneous-find-file (file-list option)
  "Visit all files in list FILE-LIST and display them simultaneously.
With non-nil OPTION >= 0, the files are found (visited) but not shown.

If `pop-up-frames' is non-nil or if OPTION < 0, use a separate frame
for each file.  (See also option `diredp-max-frames'.)

Otherwise, the current window is split across all files in FILE-LIST,
as evenly as possible.  Remaining lines go to the bottom-most window.
The number of files that can be displayed this way is restricted by
the height of the current window and the value of variable
`window-min-height'."
  ;; This is not interactive because it is usually too clumsy to specify FILE-LIST interactively unless via dired.
  (let (size)
    (cond ((and option  (natnump option))
           (while file-list (find-file-noselect (car file-list)) (pop file-list)))
          ((or pop-up-frames  option)
           (let ((nb-files  (length file-list)))
             (when (and (> nb-files diredp-max-frames)
                        (not (y-or-n-p (format "Really show %d files in separate frames? " nb-files))))
               (error "OK, canceled"))
             (while file-list (find-file-other-frame (car file-list)) (pop file-list))))
          (t
           (setq size  (/ (window-height) (length file-list)))
           (when (> window-min-height size) (error "Too many files to show simultaneously"))
           (find-file (car file-list))
           (pop file-list)
           (while file-list
             ;; Vertically split off a window of desired size. Upper window will have SIZE lines.
             ;; Select lower (larger) window.  We split it again.
             (select-window (split-window nil size))
             (find-file (car file-list))
             (pop file-list))))))


;;;;;; REPLACE ORIGINAL in both `dired.el' and `dired-x.el':
;;;;;;
;;;;;; 1. This incorporates the `dired-x.el' change to the `dired.el'
;;;;;;    definition.  This version works with or without using dired-x.
;;;;;;    The `dired-x.el' version respects the var `dired-find-subdir'.
;;;;;;    When `dired-find-subdir' is non-nil, this version is the same
;;;;;;    as the `dired-x.el' version, except that a bug is corrected:
;;;;;;    Whenever the argument to `dired-find-buffer-nocreate' is a cons,
;;;;;;    the call to `dired-buffers-for-dir' gave a wrong type error.
;;;;;;    This has been avoided by not respecting `dired-find-subdir'
;;;;;;    whenever `dired-find-buffer-nocreate' is a cons.
;;;;;;    For the case when `dired-find-subdir' is nil, see #2, below.
;;;;;;
;;;;;; 2. Unless `dired-find-subdir' is bound and non-nil:
;;;;;;    If both DIRNAME and `dired-directory' are conses, then only
;;;;;;    compare their cars (directories), not their explicit file lists
;;;;;;    too.  If equal, then update `dired-directory's file list to that
;;;;;;    of DIRNAME.
;;;;;;
;;;;;;    This prevents `dired-internal-noselect' (which is currently
;;;;;;    `dired-find-buffer-nocreate's only caller) from creating a new
;;;;;;    buffer in this case whenever a different set of files is present
;;;;;;    in the cdr of DIRNAME and DIRNAME represents the same buffer as
;;;;;;    `dired-directory'.
;;;;;;
;;;;;;    If only one of DIRNAME and `dired-directory' is a cons, then
;;;;;;    this returns nil.
;;;;;;;###autoload
;;;;(defun dired-find-buffer-nocreate (dirname &optional mode)
;;;;  (let ((atomic-dirname-p  (atom dirname)))
;;;;    (if (and (boundp 'dired-find-subdir) dired-find-subdir atomic-dirname-p)
;;;;        ;; This is the `dired-x.el' change:
;;;;        (let* ((cur-buf (current-buffer))
;;;;               (buffers (nreverse (dired-buffers-for-dir dirname)))
;;;;               (cur-buf-matches (and (memq cur-buf buffers)
;;;;                                     ;; Files list (wildcards) must match, too:
;;;;                                     (equal dired-directory dirname))))
;;;;          (setq buffers  (delq cur-buf buffers)) ; Avoid using same buffer---
;;;;          (or (car (sort buffers (function dired-buffer-more-recently-used-p)))
;;;;              (and cur-buf-matches cur-buf))) ; ---unless no other possibility.
;;;;      ;; Comment from `dired.el':
;;;;      ;;  This differs from `dired-buffers-for-dir' in that it doesn't consider
;;;;      ;;  subdirs of `default-directory' and searches for the first match only.
;;;;      (let ((blist dired-buffers)       ; was (buffer-list)
;;;;            found)
;;;;        (or mode (setq mode  'dired-mode))
;;;;        (while blist
;;;;          (if (null (buffer-name (cdr (car blist))))
;;;;              (setq blist  (cdr blist))
;;;;            (save-excursion
;;;;              (set-buffer (cdr (car blist)))
;;;;              (if (not (and (eq major-mode mode)
;;;;                            ;; DIRNAME and `dired-directory' have the same dir,
;;;;                            ;; and if either of them has an explicit file list,
;;;;                            ;; then both of them do.  In that case, update
;;;;                            ;; `dired-directory's file list from DIRNAME.
;;;;                            (if atomic-dirname-p
;;;;                                (and (atom dired-directory) ; Both are atoms.
;;;;                                     (string= (file-truename dirname)
;;;;                                              (file-truename dired-directory)))
;;;;                              (and (consp dired-directory) ; Both are conses.
;;;;                                   (string=
;;;;                                    (file-truename (car dirname))
;;;;                                    (file-truename (car dired-directory)))
;;;;                                   ;; Update `dired-directory's file list.
;;;;                                   (setq dired-directory  dirname)))))
;;;;                  (setq blist  (cdr blist))
;;;;                (setq found  (cdr (car blist)))
;;;;                (setq blist  nil)))))
;;;;        found))))


;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; Require confirmation.  Fixes Emacs bug #13561.
;;
(defun dired-do-run-mail ()
  "If `dired-bind-vm' is non-nil, call `dired-vm', else call `dired-rmail'."
  (interactive)
  (unless (y-or-n-p "Read all marked mail folders? ") (error "OK, canceled"))
  (if dired-bind-vm
      ;; Read mail folder using vm.
      (dired-vm)
    ;; Read mail folder using rmail.
    (dired-rmail)))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Put `mouse-face' on whole line, not just file name.
;; 2. Add text property `dired-filename' to only the file name.
;; 3. Show image-file preview on mouseover, if `tooltip-mode'
;;    and if `diredp-image-preview-in-tooltip'.
;;
(defun dired-insert-set-properties (beg end)
  "Add various text properties to the lines in the region.
Highlight entire line upon mouseover.
Add text property `dired-filename' to the file name.
Handle `dired-hide-details-mode' invisibility spec (Emacs 24.4+)."
  (let ((inhibit-field-text-motion  t)) ; Just in case.
    (save-excursion
      (goto-char beg)
      (while (< (point) end)
        (condition-case nil
            (cond ((dired-move-to-filename)
                   (add-text-properties (line-beginning-position) (line-end-position)
                                        '(mouse-face highlight help-echo diredp-mouseover-help))
                   (put-text-property
                    (point) (save-excursion (dired-move-to-end-of-filename) (point))
                    'dired-filename t)
                   (when (fboundp 'dired-hide-details-mode) ; Emacs 24.4+
                     (put-text-property (+ (line-beginning-position) 1) (1- (point))
                                        'invisible 'dired-hide-details-detail)
                     (dired-move-to-end-of-filename)
                     (when (< (+ (point) 4) (line-end-position))
                       (put-text-property (+ (point) 4) (line-end-position)
                                          'invisible 'dired-hide-details-link))))
                  ((fboundp 'dired-hide-details-mode) ; Emacs 24.4+
                   (unless (or (diredp-looking-at-p "^$")  (diredp-looking-at-p dired-subdir-regexp))
                     (put-text-property (line-beginning-position) (1+ (line-end-position))
                                        'invisible 'dired-hide-details-information))))
          (error nil))
        (forward-line 1)))))

(defun diredp-mouseover-help (window buffer pos)
  "Show `help-echo' help for a file name, in Dired.
If `tooltip-mode' is on and `diredp-image-preview-in-tooltip' says to
show an image preview, then do so.  Otherwise, show text help."
  (let ((image-dired-thumb-width   (or (and (wholenump diredp-image-preview-in-tooltip)
                                            diredp-image-preview-in-tooltip)
                                       image-dired-thumb-width))
        (image-dired-thumb-height  (or (and (wholenump diredp-image-preview-in-tooltip)
                                            diredp-image-preview-in-tooltip)
                                       image-dired-thumb-height))
        file)
    (or (and (boundp 'tooltip-mode)  tooltip-mode
             (fboundp 'image-file-name-regexp) ; Emacs 22+, `image-file.el'.
             diredp-image-preview-in-tooltip
             (condition-case nil
                 (and (with-current-buffer buffer
                        (save-excursion (goto-char pos)
                                        (diredp-string-match-p
                                         (image-file-name-regexp)
                                         (setq file  (if (derived-mode-p 'dired-mode)
                                                         (dired-get-filename nil 'NO-ERROR)
                                                       ;; Make it work also for `diredp-list-files' listings.
                                                       (buffer-substring-no-properties (line-beginning-position)
                                                                                       (line-end-position)))))))
                      (or (not diredp-auto-focus-frame-for-thumbnail-tooltip-flag)
                          (progn (select-frame-set-input-focus (window-frame window)) t))
                      (let ((img-file  (if (eq 'full diredp-image-preview-in-tooltip)
                                           file
                                         (diredp-image-dired-create-thumb file))))
                        (propertize " " 'display (create-image img-file))))
               (error nil)))
        (if (fboundp 'describe-file)    ; Library `help-fns+.el'
            "mouse-2: visit in another window, C-h RET: describe"
          "mouse-2: visit this file/dir in another window"))))

;; `dired-hide-details-mode' enhancements.
(when (fboundp 'dired-hide-details-mode) ; Emacs 24.4+

  (defun diredp-hide-details-if-dired ()
    "In Dired mode hide details.  Outside Dired, do nothing."
    (when (derived-mode-p 'dired-mode) (dired-hide-details-mode 1)))

  ;; Use `eval' of list so file byte-compiled in Emacs 20 will be OK in later versions.
  (eval '(define-globalized-minor-mode global-dired-hide-details-mode
          dired-hide-details-mode diredp-hide-details-if-dired))

  (eval '(define-minor-mode dired-hide-details-mode
          "Hide details in Dired mode."
          (and diredp-hide-details-propagate-flag  diredp-hide-details-last-state)
          :group 'dired
          (unless (derived-mode-p 'dired-mode) (error "Not a Dired buffer"))
          (dired-hide-details-update-invisibility-spec)
          (setq diredp-hide-details-toggled  t)
          (when diredp-hide-details-propagate-flag
            (setq diredp-hide-details-last-state  dired-hide-details-mode))
          (if dired-hide-details-mode
              (add-hook 'wdired-mode-hook 'dired-hide-details-update-invisibility-spec nil t)
            (remove-hook 'wdired-mode-hook 'dired-hide-details-update-invisibility-spec t))))

  (defun diredp-hide/show-details ()
    "Hide/show details according to user options.
If `diredp-hide-details-propagate-flag' is non-nil and details have
never been hidden in the buffer, then hide/show according to your last
hide/show choice in any other Dired buffer or, if no last choice,
according to option `diredp-hide-details-initially-flag'."
    (unless (or diredp-hide-details-toggled ; No op if hide/show already set.
                (buffer-narrowed-p))    ; No-op when showing just newly copied file etc.
      (cond (diredp-hide-details-propagate-flag
             (dired-hide-details-mode (if diredp-hide-details-last-state 1 -1)))
            (diredp-hide-details-initially-flag
             (dired-hide-details-mode 1)))))

  (add-hook 'dired-after-readin-hook #'diredp-hide/show-details)

  (defun diredp-fit-frame-unless-buffer-narrowed ()
    "Fit frame unless Dired buffer is narrowed.
Requires library `autofit-frame.el'."
    (when (and (get-buffer-window (current-buffer))  (not (buffer-narrowed-p)))
      (fit-frame-if-one-window)))

  ;; Fit frame only if not narrowed.  Put it on this hook because `dired-hide-details-mode' is
  ;; invoked from `dired-after-readin-hook' via `diredp-hide/show-details', even for an update
  ;; such as copying a file, where buffer is narrowed when invoked.
  (when (fboundp 'fit-frame-if-one-window) ; In `autofit-frame.el'.
    (add-hook 'dired-hide-details-mode-hook #'diredp-fit-frame-unless-buffer-narrowed)))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; Reset `mode-line-process' to nil.
;;
(when (< emacs-major-version 21)
  (or (fboundp 'old-dired-revert)  (fset 'old-dired-revert (symbol-function 'dired-revert)))
  (defun dired-revert (&optional arg noconfirm)
    (setq mode-line-process  nil)        ; Set by, e.g., `find-dired'.
    (old-dired-revert arg noconfirm)))

(defun diredp-cannot-revert (_ignore-auto _noconfirm)
  "`revert-buffer-function' for Dired listing of arbitrary files.
Just raise an error."
  (error "Cannot revert Dired buffer with arbitrary listing"))

;; Like `dired-up-directory', but go up to MS Windows drive if in top-level directory.
;;
;;;###autoload
(defun diredp-up-directory (&optional other-window) ; Bound to `^'
  "Run Dired on parent directory of current directory.
Find the parent directory either in this buffer or another buffer.
Creates a buffer if necessary.

With a prefix arg, Dired the parent directory in another window.

On MS Windows, if you are already at the root directory, invoke
`diredp-w32-drives' to visit a navigable list of Windows drives."
  (interactive "P")
  (let* ((dir  (dired-current-directory))
         (up   (file-name-directory (directory-file-name dir))))
    (or (dired-goto-file (directory-file-name dir))
        ;; Only try `dired-goto-subdir' if buffer has more than one dir.
        (and (cdr dired-subdir-alist)  (dired-goto-subdir up))
        (progn (if other-window (dired-other-window up) (dired up))
               (dired-goto-file dir))
        (and (memq system-type '(windows-nt ms-dos))  (diredp-w32-drives other-window)))))

;;;###autoload
(defun diredp-up-directory-reuse-dir-buffer (&optional other-window) ; Not bound
  "Like `diredp-up-directory', but reuse Dired buffers.
With a prefix arg, Dired the parent directory in another window.

On MS Windows, moving up from a root Dired buffer does not kill that
buffer (the Windows drives buffer is not really a Dired buffer)."
  (interactive "P")
  (let* ((dir      (dired-current-directory))
         (dirfile  (directory-file-name dir))
         (up       (file-name-directory dirfile)))
    (or (dired-goto-file dirfile)
        ;; Only try `dired-goto-subdir' if buffer has more than one dir.
        (and (cdr dired-subdir-alist)  (dired-goto-subdir up)) ; It is a subdir inserted in current Dired.
        (progn (diredp--reuse-dir-buffer-helper up nil nil other-window)
               (dired-goto-file dir))
        (and (memq system-type '(windows-nt ms-dos))  (diredp-w32-drives other-window)))))

;; Differs from `dired-next-line' in both wraparound and respect of `goal-column'.
;;
;;;###autoload
(defun diredp-next-line (arg)           ; Bound to `SPC', `n', `C-n', `down'
  "Move down lines then position cursor at filename.
If `goal-column' is non-nil then put the cursor at that column.
Optional prefix ARG says how many lines to move; default is one line.

If `diredp-wrap-around-flag' is non-nil then wrap around if none is
found before the buffer end (buffer beginning, if ARG is negative).
Otherwise, just move to the buffer limit."
  (interactive (let ((narg  (prefix-numeric-value current-prefix-arg)))
                 (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
                 (list narg)))          ; Equivalent to "^p"
  (let* ((line-move-visual  nil)
         ;; (goal-column       nil)

         ;; Use `condition-case' and `(progn... t)' because Emacs < 22 `line-move' has no
         ;; NO-ERROR arg and it always returns nil.
         (no-more           (or (not (condition-case nil (progn (line-move arg) t) (error nil)))
                                (if (< arg 0) (bobp) (eobp)))))
    (when (and diredp-wrap-around-flag  no-more)
      (let ((diredp-wrap-around-flag  nil))
        (goto-char (if (< arg 0) (point-max) (point-min)))
        (diredp-next-line arg)))
    ;; We never want to move point into an invisible line.
    (while (and (fboundp 'invisible-p)  ; Emacs 22+
                (invisible-p (point))
                (not (if (and arg  (< arg 0)) (bobp) (eobp))))
      (forward-char (if (and arg  (< arg 0)) -1 1)))
    (unless goal-column (dired-move-to-filename))))

;; In Emacs < 22, `C-p' does not wrap around, because it never moves to the first header line.
;;;###autoload
(defun diredp-previous-line (arg)       ; Bound to `p', `C-p', `up'
  "Move up lines then position cursor at filename.
If `goal-column' is non-nil then put the cursor at that column.
Optional prefix ARG says how many lines to move; default is one line.

If `diredp-wrap-around-flag' is non-nil then wrap around if none is
found before the buffer beginning (buffer end, if ARG is negative).
Otherwise, just move to the buffer limit."
  (interactive (let ((narg  (prefix-numeric-value current-prefix-arg)))
                 (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
                 (list narg)))          ; Equivalent to "^p"
  (diredp-next-line (- (or arg  1))))

;;;###autoload
(defun diredp-next-dirline (arg &optional opoint) ; Bound to `>'
  "Goto ARGth next directory file line.
If `diredp-wrap-around-flag' is non-nil then wrap around if none is
found before the buffer beginning (buffer end, if ARG is negative).
Otherwise, raise an error or, if NO-ERROR-IF-NOT-FOUND is nil, return
nil."
  (interactive (let ((narg  (prefix-numeric-value current-prefix-arg)))
                 (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
                 (list narg)))          ; Equivalent to "^p"
  (or opoint  (setq opoint  (point)))
  (if (if (> arg 0)
          (re-search-forward dired-re-dir nil t arg)
        (beginning-of-line)
        (re-search-backward dired-re-dir nil t (- arg)))
      (dired-move-to-filename)          ; user may type `i' or `f'
    (if diredp-wrap-around-flag
        (let ((diredp-wrap-around-flag  nil))
          (goto-char (if (< arg 0) (point-max) (point-min)))
          (diredp-next-dirline arg opoint))
      (goto-char opoint)
      (error "No more subdirectories"))))

;;;###autoload
(defun diredp-prev-dirline (arg)        ; Bound to `<'
  "Goto ARGth previous directory file line."
  (interactive (let ((narg  (prefix-numeric-value current-prefix-arg)))
                 (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
                 (list narg)))          ; Equivalent to "^p"
  (diredp-next-dirline (- arg)))

;;;###autoload
(defun diredp-next-subdir (arg &optional no-error-if-not-found no-skip) ; Bound to `C-M-n'
  "Go to the next subdirectory, regardless of level.
If ARG = 0 then go to this directory's header line.

If `diredp-wrap-around-flag' is non-nil then wrap around if none is
found before the buffer end (buffer beginning, if ARG is negative).
Otherwise, raise an error or, if NO-ERROR-IF-NOT-FOUND is nil, return
nil.

Non-nil NO-SKIP means do not move to end of header line, and return
the position moved to so far."
  (interactive (let ((narg  (prefix-numeric-value current-prefix-arg)))
                 (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
                 (list narg)))          ; Equivalent to "^p"
  (let ((this-dir  (dired-current-directory))
        pos index)
    ;; `nth' with negative arg does not return nil but the first element
    (setq index  (if diredp-wrap-around-flag
                     (mod (- (dired-subdir-index this-dir) arg) (length dired-subdir-alist))
                   (- (dired-subdir-index this-dir) arg))
          pos    (and (>= index 0)  (dired-get-subdir-min (nth index dired-subdir-alist))))
    (if pos
        (progn (goto-char pos)
               (or no-skip  (skip-chars-forward "^\n\r"))
               (point))
      (if no-error-if-not-found
          nil                           ; Return nil if not found
        (error "%s directory" (if (> arg 0) "Last" "First"))))))

;;;###autoload
(defun diredp-prev-subdir (arg &optional no-error-if-not-found no-skip) ; Bound to `C-M-p'
  "Go to the previous subdirectory, regardless of level.
When called interactively and not on a subdir line, go to this subdir's line.
Otherwise, this is a mirror image of `diredp-next-subdir'."
  ;;(interactive "^p")
  (interactive
   (list (if current-prefix-arg
             (let ((narg  (prefix-numeric-value current-prefix-arg)))
               (when (and (boundp 'shift-select-mode)  shift-select-mode) (handle-shift-selection)) ; Emacs 23+
               narg)                    ; Equivalent to "^p"
           ;; If on subdir start already then do not stay there.
           (if (dired-get-subdir) 1 0))))
  (diredp-next-subdir (- arg) no-error-if-not-found no-skip))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Test also ./ and ../, in addition to . and .., for error "Cannot operate on `.' or `..'".
;; 2. Hack for Emacs 20-22, to expand `~/...'.
;;
(defun dired-get-filename (&optional localp no-error-if-not-filep)
  "In Dired, return name of file mentioned on this line.
Value returned normally includes the directory name.

Optional arg LOCALP:
 nil:           return the absolute file name.
 `no-dir':      do not include directory name in result.
 `verbatim':    return the name exactly as it occurs in the buffer.
 Other non-nil: construct the name relative to `default-directory',
  which still might contain slashes if point is in a subdirectory.

Non-nil optional arg NO-ERROR-IF-NOT-FILEP means treat `.' and `..' as
regular filenames and return nil if there is no filename on this line.
Otherwise, an error occurs in these cases."
  (let ((case-fold-search  nil)
        (already-absolute  nil)
        file p1 p2)
    (save-excursion (when (setq p1  (dired-move-to-filename (not no-error-if-not-filep)))
                      (setq p2  (dired-move-to-end-of-filename no-error-if-not-filep))))
    ;; nil if no file on this line but `no-error-if-not-filep' is t:
    (when (setq file  (and p1  p2  (buffer-substring p1 p2)))
      ;; Get rid of the mouse-face property that file names have.
      (set-text-properties 0 (length file) nil file)

      ;; Unquote names quoted by `ls' or by `dired-insert-directory'.
      ;; Prior to Emacs 23.3, this code was written using `read' (see commented code below),
      ;; because that is faster than substituting \007 (4 chars) -> ^G (1 char) etc. in a cl-loop.
      ;; Unfortunately, that implementation required hacks such as dealing with filenames
      ;; with quotation marks in their names.
      (while (string-match (if (> emacs-major-version 21)
                               "\\(?:[^\\]\\|\\`\\)\\(\"\\)" ; Shy group: Emacs 22+.
                             "\\([^\\]\\|\\`\\)\\(\"\\)")
                           file)
        (setq file  (replace-match "\\\"" nil t file 1)))

      ;; $$$ This was the code for that unquoting prior to Emacs 23.3:
      ;; (setq file  (read (concat "\"" ; Some `ls -b' do not escape quotes.  But GNU `ls' is OK.
      ;;                           (or (dired-string-replace-match
      ;;                                "\\([^\\]\\|\\`\\)\"" file "\\1\\\\\"" nil t)
      ;;                               file)
      ;;                           "\"")))

      ;; This sexp was added by Emacs 24, to fix bug #10469:
      ;; Unescape any spaces escaped by `ls -b'.
      ;; Other `-b' quotes, such as \t and \n, work transparently.
      (when (dired-switches-escape-p dired-actual-switches)
        (let ((start  0)
              (rep    "")
              (shift  -1))
          (when (eq localp 'verbatim)  (setq rep    "\\\\"
                                             shift  +1))
          (while (string-match "\\(\\\\\\) " file start)
            (setq file   (replace-match rep nil t file 1)
                  start  (+ shift (match-end 0))))))

      ;; $$$ This sexp was added by Emacs 23.3.
      (when (memq system-type '(windows-nt ms-dos))
        (save-match-data
          (let ((start  0))
            (while (string-match "\\\\" file start)
              (aset file (match-beginning 0) ?/)
              (setq start  (match-end 0))))))

      ;; $$$ This sexp was added by Emacs 23.3.
      ;; Hence we don't need to worry about converting `\\' back to `\'.
      (setq file  (read (concat "\"" file "\"")))

      ;; Above `read' returns a unibyte string if FILE contains eight-bit-control/graphic chars.
      (when (and (fboundp 'string-to-multibyte) ; Emacs 22
                 enable-multibyte-characters
                 (not (multibyte-string-p file)))
        (setq file  (string-to-multibyte file))))
    (and file
         (file-name-absolute-p file)
         ;; A relative file name can start with ~.  Do not treat it as absolute in this context.
         (not (eq (aref file 0) ?~))
         (setq already-absolute  t))
    (cond ((null file) nil)
          ((eq localp 'verbatim) file)
          ;; This is the essential `Dired+' change: Added ./ and ../, not just . and ..
          ((and (not no-error-if-not-filep)  (member file '("." ".." "./" "../")))
           (error "Cannot operate on `.' or `..'"))
          ((and (eq localp 'no-dir)  already-absolute)
           (file-name-nondirectory file))
          (already-absolute
           (let ((handler  (find-file-name-handler file nil)))
             ;; check for safe-magic property so that we won't
             ;; put /: for names that don't really need them.
             ;; For instance, .gz files when auto-compression-mode is on.
             (if (and handler  (not (get handler 'safe-magic)))
                 (concat "/:" file)
               file)))
          ((eq localp 'no-dir) file)
          ((equal (dired-current-directory) "/")
           (setq file  (concat (dired-current-directory localp) file))
           (let ((handler  (find-file-name-handler file nil)))
             ;; check for safe-magic property so that we won't
             ;; put /: for names that don't really need them.
             ;; For instance, .gz files when auto-compression-mode is on.
             (if (and handler  (not (get handler 'safe-magic)))
                 (concat "/:" file)
               file)))
          ;; Ugly hack for Emacs < 23, for which `ls-lisp-insert-directory' can insert a subdir
          ;; using `~/...'.  Expand `~/' for return value.
          ((and (< emacs-major-version 23)  file  (file-name-absolute-p file)
                (eq (aref file 0) ?~))
           (expand-file-name file))
          (t
           (concat (dired-current-directory localp) file)))))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Made it a command.
;; 2. Use `forward-line' instead of `beginning-of-line'.
;;
(defun dired-move-to-filename (&optional raise-error eol)
  "Move to the beginning of the file name on the current line.
Return the position of the file-name beginning, or nil if none found.

Non-nil RAISE-ERROR means raise an error if no file name is found.
Non-nil EOL is the search limit.  Default: `line-end-position'."
  (interactive)
  (unless eol (setq eol  (line-end-position)))
  (forward-line 0)
  (let ((change (next-single-property-change (point) 'dired-filename nil eol)))
    (cond ((and change (< change eol))
           (goto-char change))
          ((re-search-forward directory-listing-before-filename-regexp eol t)
           (goto-char (match-end 0)))
          ((re-search-forward dired-permission-flags-regexp eol t)
           ;; There *is* a file.  Our regexp-from-hell just failed to find it.
           (when raise-error (error "Unrecognized line!  Check `directory-listing-before-filename-regexp'"))
           (beginning-of-line)
           nil)
          (raise-error (error "No file on this line")))))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; 1. Fixes Emacs bug #7126: Did not work with arbitrary file list (cons arg to `dired').
;; 2. Remove `/' from directory name before comparing with BASE.
;;
(when (< emacs-major-version 24)
  (defun dired-goto-file (file)         ; Bound to `j'
    "Go to line describing file FILE in this Dired buffer.
FILE must be an absolute file name.
Return buffer position on success, else nil."
    ;; Loses if FILE contains control chars like "\007" for which `ls' inserts "?" or "\\007"
    ;; into the buffer, so we won't find it in the buffer.
    (interactive (prog1                 ; Let push-mark display its message
                     (list (expand-file-name (read-file-name "Goto file: " (dired-current-directory))))
                   (push-mark)))
    (unless (file-name-absolute-p file) (error "File name `%s' is not absolute" file))
    (setq file  (directory-file-name file)) ; does no harm if no directory
    (let* ((case-fold-search  nil)
           (dir               (file-name-directory file))
           (found             nil))
      ;; `Dired+': Added this sexp.
      (save-excursion
        (goto-char (point-min))
        (let ((search-string  (replace-regexp-in-string "\^m" "\\^m" file nil t))
              (here           nil))
          (setq search-string  (replace-regexp-in-string "\\\\" "\\\\" search-string nil t))

          ;; Escape whitespace.  Added per Emacs 24 addition in `unless' code below:
          (when (and (dired-switches-escape-p dired-actual-switches)
                     (diredp-string-match-p "[ \t\n]" search-string))
            ;; FIXME: fix this for all possible file names (embedded control chars etc).
            ;;        Need to escape everything that `ls -b' escapes.
            (setq search-string  (replace-regexp-in-string " " "\\ "  search-string nil t)
                  search-string  (replace-regexp-in-string "\t" "\\t" search-string nil t)
                  search-string  (replace-regexp-in-string "\n" "\\n" search-string nil t)))

          ;; Use HERE to ensure we do not keep searching for a directory entry.
          (while (and (not (eobp))  (not found)  (not (equal here (point))))
            (setq here  (point))
            (if (search-forward (concat " " search-string) nil 'NO-ERROR)
                ;; Must move to filename since an (actually correct) match could have been
                ;; elsewhere on the line (e.g. "-" would match somewhere in permission bits).
                (setq found  (dired-move-to-filename))
              ;; If this isn't the right line, move forward to avoid trying this line again.
              (forward-line 1)))))

      (unless found
        (save-excursion
          ;; The difficulty here is to get the result of `dired-goto-subdir' without really
          ;; calling it, if we don't have any subdirs.
          (when (if (string= dir (expand-file-name default-directory))
                    (goto-char (point-min))
                  (and (cdr dired-subdir-alist)  (dired-goto-subdir dir)))
            (let ((base      (file-name-nondirectory file))
                  (boundary  (dired-subdir-max))
                  search-string)
              (setq search-string  (replace-regexp-in-string "\^m" "\\^m" base nil t)
                    search-string  (replace-regexp-in-string "\\\\" "\\\\" search-string nil t))
              ;; Escape whitespace.  Sexp added by Emacs 24:
              (when (and (dired-switches-escape-p dired-actual-switches)
                         (diredp-string-match-p "[ \t\n]" search-string))
                ;; FIXME: fix this for all possible file names (embedded control chars etc).
                ;;        Need to escape everything that `ls -b' escapes.
                (setq search-string  (replace-regexp-in-string " " "\\ " search-string nil t)
                      search-string  (replace-regexp-in-string "\t" "\\t" search-string nil t)
                      search-string  (replace-regexp-in-string "\n" "\\n" search-string nil t)))
              (while (and (not found)
                          ;; Filenames are preceded by SPC.  This makes the search faster
                          ;; (e.g. for the filename "-"!).
                          (search-forward (concat " " search-string) boundary 'move))
                ;; `Dired+': Remove `/' from filename, then compare with BASE.
                ;; Match could have BASE just as initial substring or
                ;; or in permission bits or date or not be a proper filename at all.
                (if (and (dired-get-filename 'no-dir 'NO-ERROR)
                         (equal base (directory-file-name (dired-get-filename 'no-dir 'NO-ERROR))))
                    ;; Must move to filename since an (actually correct) match could have been
                    ;; elsewhere on the line (e.g. "-" would match somewhere in permission bits).
                    (setq found  (dired-move-to-filename))
                  ;; If this is not the right line, move forward to avoid trying this line again.
                  (forward-line 1)))))))
      (and found  (goto-char found))))) ; Return buffer position, or nil if not found.


;; REPLACE ORIGINAL in `dired.el'.
;;
;; If destination is in a hidden dir listing, open that listing and move to destination in it.
;;
(unless (< emacs-major-version 24)
  (defun dired-goto-file (file)
    "Go to line describing file FILE in this Dired buffer.
FILE must be an absolute file name.
Return buffer position on success, else nil."
    ;; Loses if FILE contains control chars like "\007" for which `ls' inserts "?" or "\\007"
    ;; into the buffer, so we won't find it in the buffer.
    (interactive (prog1 (list (expand-file-name (read-file-name "Goto file: " (dired-current-directory))))
                   (push-mark)))        ; Let push-mark display its message.
    (unless (file-name-absolute-p file) (error "File name `%s' is not absolute" file))
    (setq file  (directory-file-name file)) ; Does no harm if not a directory
    (let* ((case-fold-search  nil)
           (dir               (file-name-directory file))
           (found
            (or
             ;; First, look for a listing under the absolute name.
             (save-excursion (goto-char (point-min)) (dired-goto-file-1 file file (point-max)))
             ;; Else look for it as a relative name.  The difficulty is to get the result
             ;; of `dired-goto-subdir' without calling it, if we don't have any subdirs.
             (save-excursion
               (when (if (string= dir (expand-file-name default-directory))
                         (goto-char (point-min))
                       (and (cdr dired-subdir-alist)  (dired-goto-subdir dir)))
                 (when (dired-subdir-hidden-p (dired-current-directory))
                   (diredp-hide-subdir-nomove 1)) ; Open hidden parent directory.
                 (dired-goto-file-1 (file-name-nondirectory file) file (dired-subdir-max)))))))
      (and found  (goto-char found))))) ; Return buffer position, or nil if not found.


;; REPLACE ORIGINAL in `dired.el':
;;
;; 1. Display a message to warn that flagged, not marked, files will be deleted.
;; 2. Use `diredp-internal-do-deletions', so it works with all Emacs versions.
;;
;;;###autoload
(defun dired-do-flagged-delete (&optional no-msg) ; Bound to `x'
  "In Dired, delete the files flagged for deletion.
NOTE: This deletes flagged, not marked, files.
If arg NO-MSG is non-nil, no message is displayed.

User option `dired-recursive-deletes' controls whether deletion of
non-empty directories is allowed."
  (interactive)
  (unless no-msg
    (ding)
    (message "NOTE: Deletion of files flagged `%c' (not those marked `%c')"
             dired-del-marker dired-marker-char)
    ;; Too slow/annoying, but without it the message is never seen: (sit-for 2)
    )
  (let* ((dired-marker-char  dired-del-marker)
         (regexp             (dired-marker-regexp))
         (case-fold-search   nil))
    (if (save-excursion (goto-char (point-min)) (re-search-forward regexp nil t))
        (diredp-internal-do-deletions
         ;; This cannot move point since last arg is nil.
         (dired-map-over-marks (cons (dired-get-filename) (point)) nil)
         nil
         'USE-TRASH-CAN)                ; This arg is for Emacs 24+ only.
      (unless no-msg (message "(No deletions requested.)")))))


;; REPLACE ORIGINAL in `dired.el':
;;
;; 1. Display a message to warn that marked, not flagged, files will be deleted.
;; 2. Use `diredp-internal-do-deletions', so it works with all Emacs versions.
;;
;;;###autoload
(defun dired-do-delete (&optional arg)  ; Bound to `D'
  "Delete all marked (or next ARG) files.
NOTE: This deletes marked, not flagged, files.
`dired-recursive-deletes' controls whether deletion of
non-empty directories is allowed."
  (interactive "P")
  ;; This is more consistent with the file-marking feature than
  ;; `dired-do-flagged-delete'.  But it can be confusing to the user,
  ;; especially since this is usually bound to `D', which is also the
  ;; `dired-del-marker'.  So offer this warning message:
  (unless arg
    (ding)
    (message "NOTE: Deletion of files marked `%c' (not those flagged `%c')."
             dired-marker-char dired-del-marker))
  (diredp-internal-do-deletions
   ;; This can move point if ARG is an integer.
   (dired-map-over-marks (cons (dired-get-filename) (point)) arg)
   arg
   'USE-TRASH-CAN))                     ; This arg is for Emacs 24+ only.

(defun diredp-internal-do-deletions (file-alist arg &optional trash)
  "`dired-internal-do-deletions', but for any Emacs version.
FILE-ALIST is an alist of files to delete, with their buffer positions.
ARG is the prefix arg.  Filenames are absolute.
Non-nil TRASH means use the trash can."
  ;; \(car FILE-ALIST) *must* be the *last* (bottommost) file in the dired
  ;; buffer.  That way as changes are made in the buffer they do not shift
  ;; the lines still to be changed, so the (point) values in FILE-ALIST
  ;; stay valid.  Also, for subdirs in natural order, a subdir's files are
  ;; deleted before the subdir itself - the other way around would not work."
  (setq file-alist  (delq nil file-alist)) ; nils could come from `dired-map-over-marks'.
  (if (> emacs-major-version 23)
      (dired-internal-do-deletions file-alist arg trash)
    (dired-internal-do-deletions file-alist arg)))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Put window point at bob.  Fixes bug #12281.
;;
(when (and (> emacs-major-version 22)  (or (< emacs-major-version 24)
                                           (and (= emacs-major-version 24)  (= emacs-minor-version 1))))
  (defun dired-pop-to-buffer (buf)
    "Pop up buffer BUF in a way suitable for Dired."
    (let ((split-window-preferred-function
           (lambda (window)
             (or (and (let ((split-height-threshold  0)) (window-splittable-p (selected-window)))
                      ;; Try to split the selected window vertically if that's possible.  (Bug#1806)
                      (if (fboundp 'split-window-below) (split-window-below) (split-window-vertically)))
                 (split-window-sensibly window))))
          pop-up-frames)
      (pop-to-buffer (get-buffer-create buf)))
    (set-window-start (selected-window) (point-min))
    (when dired-shrink-to-fit
      ;; Try to not delete window when we want to display less than `window-min-height' lines.
      (fit-window-to-buffer (get-buffer-window buf) nil 1))))


;; REPLACE ORIGINAL in `dired.el':
;;
;; 1. Delete the window or frame popped up, afterward, and bury its buffer.
;;    Fixes Emacs bug #7533.
;;
;; 2, If buffer is shown in a separate frame, do not show a menu bar for that frame.
;;
(defun dired-mark-pop-up (buffer-or-name op-symbol files function &rest args)
  "Return FUNCTION's result on ARGS after showing which files are marked.
Displays the file names in a buffer named BUFFER-OR-NAME, the default
name being \" *Marked Files*\".  The buffer is not shown if there is
just one file, `dired-no-confirm' is t, or OP-SYMBOL is a member of
the list in `dired-no-confirm'.  Uses function `dired-pop-to-buffer'
to show the buffer.

The window is not shown if there is just one file, `dired-no-confirm'
is `t', or OP-SYMBOL is a member of `dired-no-confirm'.

FILES is the list of marked files.  It can also be (t FILENAME)
in the case of one marked file, to distinguish that from using
just the current file.

FUNCTION should not manipulate the files.  It should just read input
\(an argument or confirmation)."
  (unless buffer-or-name (setq buffer-or-name  " *Marked Files*"))
  (let (result)
    (if (or (eq dired-no-confirm t)
            (memq op-symbol dired-no-confirm)
            ;; If FILES defaulted to the current line's file.
            (= (length files) 1))
        (setq result  (apply function args))
      (with-current-buffer (get-buffer-create buffer-or-name)
        (erase-buffer)
        ;; Handle (t FILE) just like (FILE), here.  That value is used (only in some cases),
        ;; to mean just one file that was marked, rather than the current-line file.
        (dired-format-columns-of-files (if (eq (car files) t) (cdr files) files))
        (remove-text-properties (point-min) (point-max)
                                '(mouse-face nil help-echo nil)))
      (unwind-protect
           (save-window-excursion
             ;; Do not show menu bar, if buffer is popped up in a separate frame.
             (let ((special-display-frame-alist  (cons '(menu-bar-lines . 0)
                                                       special-display-frame-alist))
                   (default-frame-alist          (cons '(menu-bar-lines . 0)
                                                       default-frame-alist)))
               (dired-pop-to-buffer buffer-or-name)
               ;; Work around Emacs 22 bug in `dired-pop-to-buffer', which can exit with Dired buffer current.
               (set-buffer buffer-or-name)
               (goto-char (point-min)))
             (setq result  (apply function args)))
        (save-excursion
          (condition-case nil           ; Ignore error if user already deleted window.
              (progn (select-window (get-buffer-window buffer-or-name 0))
                     (if (one-window-p) (delete-frame) (delete-window)))
            (error nil)))
        (bury-buffer buffer-or-name)))
    result))


;; REPLACE ORIGINAL in `dired.el':
;;
;; 1. Prefix arg has more possibilities.
;; 2, Added optional arg NAME-FORM, so you can mark/unmark matching different file-name forms.
;; 3. Push REGEXP onto `regexp-search-ring'.
;;
;;;###autoload
(defun dired-mark-files-regexp (regexp &optional marker-char name-form)
  "Mark all file names matching REGEXP for use in later commands.
`.' and `..' are never marked or unmarked by this command.

Whether to mark or unmark, and what form of file name to match, are
governed by the prefix argument.  For this, a plain (`C-u') or a
double-plain (`C-u C-u') prefix arg is considered only as such - it is
not considered numerically.

Whether to mark or unmark:

 - No prefix arg, a positive arg, or a negative arg means MARK.

 - Plain (`C-u'), double-plain (`C-u C-u'), or zero (e.g. `M-0' means
   UNMARK.

The form of the file names used for matching:

 - No prefix arg (to mark) or a plain prefix arg (`C-u', to unmark)
   means use the relative file name (no directory part).

 - A positive arg (e.g. `M-9', to mark) or a double plain arg (`C-u
   C-u', to unmark) means construct the file name relative to
   `default-directory'.

   For an entry in an inserted subdir listing, this means prefix the
   relative file name (no directory part) with the subdir name
   relative to `default-directory'.

 - A negative arg (e.g. `M--', to mark) or a zero arg (e.g. `M-0'), to
   unmark) means use the absolute file name, that is, including all
   directory components.

Note that the default matching behavior of this command is different
for Dired+ than it is for vanilla Emacs.  Using a positive prefix arg
or a double plain prefix arg (`C-u C-u') gives you the same behavior
as vanilla Emacs (marking or unmarking, respectively): matching
against names that are relative to the `default-directory'.

What Dired+ offers in addition is the possibility to match against
names that are relative (have no directory part - e.g. no prefix arg
or a single `C-u', to mark & unmark, respectively), or absolute (`M--'
or `M-0', respectively).

The default behavior uses relative names because this
is likely to be the more common use case.  But matching against
absolute names gives you more flexibility.

REGEXP is an Emacs regexp, not a shell wildcard.  Thus, use `\\.o$'
for object files--just `.o' might mark more than you might expect.
REGEXP is added to `regexp-search-ring', for subsequent regexp search.

When called from Lisp:

 MARKER-CHAR is the marker character - used for `dired-marker-char'.

 NAME-FORM determines the form of file name matched against REGEXP:

   ,* nil:           names that are relative to `default-directory'
   ,* `no-dir':      relative names (no directory part)
   ,* Other non-nil: absolute names

   (NAME-FORM differs from the LOCALP arg of `dired-get-filename' in
   that the nil and other non-nil cases are swapped.  This is
   unfortunate, but it is to keep nil NAME-FORM compatible with the
   vanilla Emacs behavior, where this arg does not exist.)"
  (interactive (let* ((raw      current-prefix-arg)
                      (C-u      (and (consp raw)  (= 4 (car raw))))
                      (C-u-C-u  (and (consp raw)  (= 16 (car raw))))
                      (num      (and raw  (prefix-numeric-value raw)))
                      (type     (cond ((or (not raw)  C-u)  'no-dir) ; no prefix arg, `C-u' (no dir)
                                      ((> num 0)            nil) ; `M-9', `C-u C-u' (rel to default dir)
                                      (t                    t)))) ; `M--', `M-0' (absolute)
                 (list (diredp-read-regexp (concat (if (or (consp raw)  (and num  (zerop num)))
                                                       "UNmark"
                                                     "Mark")
                                                   (format " files (regexp matching %s): "
                                                           (case type
                                                             ((nil)   "names with default dir")
                                                             (no-dir  "relative names - no dir")
                                                             (t       "absolute names")))))
                       (and raw  (or C-u  C-u-C-u  (zerop num))  ?\040)
                       type)))
  (add-to-list 'regexp-search-ring regexp) ; Add REGEXP to `regexp-search-ring'.
  (let ((dired-marker-char  (or marker-char  dired-marker-char)))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))
                         (not (eolp))   ; Empty line
                         (let ((fn  (dired-get-filename (case name-form
                                                          ((nil)   t)
                                                          (no-dir  'no-dir)
                                                          (t       nil))
                                                        'NO-ERROR)))
                           (and fn  (diredp-string-match-p regexp fn))))
                    "file")))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Use `diredp-mark-if', not `dired-mark-if'.
;;
;;;###autoload
(defun dired-mark-files-containing-regexp (regexp &optional marker-char)
  "Mark files with contents containing a REGEXP match.
A prefix argument means unmark them instead.
`.' and `..' are never marked.

If a file is visited in a buffer and `dired-always-read-filesystem' is
nil, this looks in the buffer without revisiting the file, so the
results might be inconsistent with the file on disk if its contents
have changed since it was last visited."
  (interactive
   (list (diredp-read-regexp (concat (if current-prefix-arg "Unmark" "Mark") " files containing (regexp): ")
                             nil 'dired-regexp-history)
         (and current-prefix-arg  ?\040)))
  (let ((dired-marker-char  (or marker-char  dired-marker-char)))
    (diredp-mark-if (and (not (diredp-looking-at-p dired-re-dot))
                         (not (eolp))
                         (let ((fname  (dired-get-filename nil 'NO-ERROR)))
                           (when (and fname  (file-readable-p fname)  (not (file-directory-p fname)))
                             (let ((prebuf  (get-file-buffer fname)))
                               (message "Checking %s" fname)
                               ;; For now, do it inside Emacs.  Grep might be better if there are lots of files.
                               (if (and prebuf  (or (not (boundp 'dired-always-read-filesystem))
                                                    (not dired-always-read-filesystem))) ; Emacs 26+
                                   (with-current-buffer prebuf
                                     (save-excursion (goto-char (point-min)) (re-search-forward regexp nil t)))
                                 (with-temp-buffer
                                   (insert-file-contents fname)
                                   (goto-char (point-min))
                                   (re-search-forward regexp nil t)))))))
                    "file")))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Use `diredp-mark-if', not `dired-mark-if'.
;;
;;;###autoload
(defun dired-mark-symlinks (unflag-p)
  "Mark all symbolic links.
With prefix argument, unmark or unflag all those files."
  (interactive "P")
  (let ((dired-marker-char  (if unflag-p ?\040 dired-marker-char)))
    (diredp-mark-if (diredp-looking-at-p dired-re-sym) "symbolic link")))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Use `diredp-mark-if', not `dired-mark-if'.
;;
;;;###autoload
(defun dired-mark-directories (unflag-p)
  "Mark all directory file lines except `.' and `..'.
With prefix argument, unmark or unflag the files instead."
  (interactive "P")
  (let ((dired-marker-char  (if unflag-p ?\040 dired-marker-char)))
    (diredp-mark-if (and (diredp-looking-at-p dired-re-dir)  (not (diredp-looking-at-p dired-re-dot)))
                    "directory" "directories")))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Use `diredp-mark-if', not `dired-mark-if'.
;;
;;;###autoload
(defun dired-mark-executables (unflag-p)
  "Mark all executable files.
With prefix argument, unmark or unflag the files instead."
  (interactive "P")
  (let ((dired-marker-char  (if unflag-p ?\040 dired-marker-char)))
    (diredp-mark-if (diredp-looking-at-p dired-re-exe) "executable file")))


;; REPLACE ORIGINAL in `dired.el':
;;
;; Use `diredp-mark-if', not `dired-mark-if'.
;;
;;;###autoload
(defun dired-flag-auto-save-files (&optional unflag-p)
  "Flag for deletion files whose names suggest they are auto save files.
A prefix argument says to unmark or unflag the files instead."
  (interactive "P")
  (let ((dired-marker-char  (if unflag-p ?\040 dired-del-marker)))
    (diredp-mark-if
     ;; It is less than general to check for # here, but it's the only way this runs fast enough.
     (and (save-excursion (end-of-line)
                          (or (eq (preceding-char) ?#)
                              ;; Handle executables in case of -F option.  Need not worry about the other kinds
                              ;; of markings that -F makes, since they won't appear on real auto-save files.
                              (and (eq (preceding-char) ?*)
                                   (progn (forward-char -1) (eq (preceding-char) ?#)))))
          (not (diredp-looking-at-p dired-re-dir))
          (let ((fname  (dired-get-filename t 'NO-ERROR)))
            (and fname  (auto-save-file-name-p (file-name-nondirectory fname)))))
     "auto-save file")))

;;;###autoload
(defun diredp-capitalize (&optional arg) ; Bound to `% c'
  "Rename all marked (or next ARG) files by capitalizing them.
Makes the first char of the name uppercase and the others lowercase."
  (interactive "P")
  (dired-rename-non-directory #'capitalize "Rename by capitalizing:" arg))

;; This is more useful than a single-file version of `dired-do-delete'.
;;;###autoload
(defun diredp-delete-this-file (&optional use-trash-can) ; Bound to `C-k', `delete'
  "In Dired, delete this file, upon confirmation.
This uses `delete-file'.
If the file is a symlink, remove the symlink.  If the file has
multiple names, it continues to exist with the other names.

For Emacs 24 and later, a prefix arg means that if
`delete-by-moving-to-trash' is non-nil then trash the file instead of
deleting it."
  (interactive "P")
  (let ((file  (dired-get-filename)))
    (if (not (yes-or-no-p (format "%s file `%s'? " (if (and use-trash-can  delete-by-moving-to-trash)
                                                       "Trash"
                                                     "Permanently delete")
                                  file)))
        (message "OK - canceled")
      (if (> emacs-major-version 23) (delete-file file use-trash-can) (delete-file file))
      (revert-buffer))))

;;; Versions of `dired-do-*' commands for just this line's file.
;;;###autoload
(defun diredp-capitalize-this-file ()   ; Bound to `M-c'
  "In Dired, rename this file by capitalizing it.
Makes the first char of the name uppercase and the others lowercase."
  (interactive) (diredp-capitalize 1))

;;;###autoload
(defun diredp-downcase-this-file ()     ; Bound to `M-l'
  "In Dired, rename this file to lower case."
  (interactive) (dired-downcase 1))

;;;###autoload
(defun diredp-upcase-this-file ()       ; Bound to `M-u'
  "In Dired, rename this file to upper case."
  (interactive) (dired-upcase 1))

;;;###autoload
(defun diredp-rename-this-file ()       ; Bound to `r'
  "In Dired, rename this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-rename 1)))

(when (fboundp 'epa-dired-do-encrypt)   ; Emacs 23+
  (defun diredp-decrypt-this-file ()
    "In Dired, decrypt this file."
    (interactive)
    (let ((use-file-dialog  nil)) (epa-dired-do-decrypt 1)))

  (defun diredp-encrypt-this-file ()
    "In Dired, encrypt this file."
    (interactive)
    (let ((use-file-dialog  nil)) (epa-dired-do-encrypt 1)))

  (defun diredp-verify-this-file ()
    "In Dired, verify this file."
    (interactive)
    (let ((use-file-dialog  nil)) (epa-dired-do-verify 1)))

  (defun diredp-sign-this-file ()
    "In Dired, sign this file."
    (interactive)
    (let ((use-file-dialog  nil)) (epa-dired-do-sign 1))))

;;;###autoload
(defun diredp-copy-this-file ()         ; Not bound
  "In Dired, copy this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-copy 1)))

;;;###autoload
(defun diredp-relsymlink-this-file ()   ; Bound to `y'
  "In Dired, make a relative symbolic link to file on cursor line."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-relsymlink 1)))

;;;###autoload
(defun diredp-symlink-this-file ()      ; Not bound
  "In Dired, make a symbolic link to this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-symlink 1)))

;;;###autoload
(defun diredp-hardlink-this-file ()     ; Not bound
  "In Dired, add a name (hard link) to this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-hardlink 1)))

;;;###autoload
(defun diredp-print-this-file ()        ; Bound to `M-p'
  "In Dired, print this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-print 1)))

;;;###autoload
(defun diredp-grep-this-file ()         ; Not bound
  "In Dired, grep this file."
  (interactive)
  (unless (and grep-command  (or (< emacs-major-version 22)
                                 (not grep-use-null-device)
                                 (eq grep-use-null-device t)))
    (grep-compute-defaults))
  (grep (diredp-do-grep-1 (list (dired-get-filename t)))))

;;;###autoload
(defun diredp-compress-this-file ()     ; Bound to `z'
  "In Dired, compress or uncompress this file."
  (interactive)
  (let ((use-file-dialog  nil)) (dired-do-compress 1)))

;;;###autoload
(defun diredp-async-shell-command-this-file (command filelist) ; Not bound
  "Run a shell COMMAND asynchronously on the file on the Dired cursor line.
Like `diredp-shell-command-this-file', but adds `&' at the end of
COMMAND to execute it asynchronously.  The command output appears in
buffer `*Async Shell Command*'."
  (interactive (list (dired-read-shell-command (concat "& on " "%s: ") 1 (list (dired-get-filename t)))
                     (list (dired-get-filename t))))
  (unless (diredp-string-match-p "&[ \t]*\\'" command) (setq command  (concat command " &")))
  (dired-do-shell-command command 1 filelist))

;;;###autoload
(defun diredp-shell-command-this-file (command filelist) ; Not bound
  "In Dired, run a shell COMMAND on this file."
  (interactive (list (dired-read-shell-command (concat "! on " "%s: ") 1 (list (dired-get-filename t)))
                     (list (dired-get-filename t))))
  (dired-do-shell-command command 1 filelist))

;;;###autoload
(defun diredp-bookmark-this-file (&optional prefix) ; Bound to `C-B' (`C-S-b')
  "In Dired, bookmark this file.
See `diredp-do-bookmark'."
  (interactive (progn (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: ")))))
  (diredp-do-bookmark prefix 1))

;;;###autoload
(defun diredp-tag-this-file (tags &optional prefix) ; Bound to `T +'
  "In Dired, add some tags to this file.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (bmkp-read-tags-completing)
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: ")))))
  (diredp-do-tag tags prefix 1))

;;;###autoload
(defun diredp-untag-this-file (tags &optional prefix arg) ; Bound to `T -'
  "In Dired, remove some tags from this file.
With a prefix arg, remove all tags from the file.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (let* ((pref  (and diredp-prompt-for-bookmark-prefix-flag
                                         (read-string "Prefix for bookmark name: ")))
                             (bmk   (bmkp-get-autofile-bookmark (dired-get-filename) nil pref))
                             (btgs  (and bmk  (bmkp-get-tags bmk))))
                        (unless btgs (error "File has no tags to remove"))
                        (list (if current-prefix-arg btgs (bmkp-read-tags-completing btgs))
                              pref
                              current-prefix-arg))))
  (diredp-do-untag tags prefix 1))

;;;###autoload
(defun diredp-remove-all-tags-this-file (&optional prefix msgp) ; Bound to `T 0'
  "In Dired, remove all tags from this file.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            'MSG)))
  (bookmark-maybe-load-default-file)
  (diredp-do-remove-all-tags prefix 1))

;;;###autoload
(defun diredp-paste-add-tags-this-file (&optional prefix msgp) ; Bound to `T p', `T C-y'
  "In Dired, add previously copied tags to this file.
See `diredp-paste-add-tags'.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            'MSG)))
  (bookmark-maybe-load-default-file)
  (diredp-do-paste-add-tags prefix 1))

;;;###autoload
(defun diredp-paste-replace-tags-this-file (&optional prefix msgp) ; Bound to `T q'
  "In Dired, replace tags for this file with previously copied tags.
See `diredp-paste-replace-tags'.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            'MSG)))
  (bookmark-maybe-load-default-file)
  (diredp-do-paste-add-tags prefix 1))

;;;###autoload
(defun diredp-set-tag-value-this-file (tag value &optional prefix msgp) ; Bound to `T v'
  "In Dired, Set value of TAG to VALUE for this file.
See `diredp-set-tag-value'.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (bmkp-read-tag-completing)
                            (read (read-string "Value: "))
                            (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            'MSG)))
  (bookmark-maybe-load-default-file)
  (diredp-do-set-tag-value tag value prefix 1))

;;;###autoload
(defun diredp-copy-tags-this-file (&optional prefix msgp) ; Bound to `T c', `T M-w'
  "In Dired, copy the tags from this file, so you can paste them to another.
See `diredp-copy-tags'.
You need library `bookmark+.el' to use this command."
  (interactive (progn (diredp-ensure-bookmark+)
                      (diredp-ensure-mode)
                      (list (and diredp-prompt-for-bookmark-prefix-flag
                                 (read-string "Prefix for bookmark name: "))
                            'MSG)))
  (bookmark-maybe-load-default-file)
  (let ((bmk  (bmkp-get-autofile-bookmark  (dired-get-filename) nil prefix)))
    (and bmk  (bmkp-copy-tags bmk msgp))))

;;;###autoload
(defun diredp-mouse-copy-tags (event)   ; Not bound
  "In Dired, copy the tags from this file, so you can paste them to another.
You need library `bookmark+.el' to use this command."
  (interactive "e")
  (let ((mouse-pos         (event-start event))
        (dired-no-confirm  t)
        (prefix            (and diredp-prompt-for-bookmark-prefix-flag
                                (read-string "Prefix for bookmark name: "))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (diredp-copy-tags-this-file prefix 'MSG))
  (diredp-previous-line 1))

(when (fboundp 'describe-file)          ; In `help-fns+.el' or `help+20.el'.
  (defun diredp-describe-file (&optional internal-form-p) ; Bound to `C-h RET', `C-h C-RET'
    "In Dired, describe this file or directory.
You need library `help-fns+.el' to use this command.
If the file has an autofile bookmark and you use library `Bookmark+',
then show also the bookmark information (tags etc.).  In this case, a
prefix arg shows the internal form of the bookmark."
    (interactive "P")
    (describe-file (dired-get-filename nil 'NO-ERROR) internal-form-p))

  (defun diredp-mouse-describe-file (event &optional internal-form-p) ; Not bound
    "Describe the clicked file.
You need library `help-fns+.el' to use this command.
If the file has an autofile bookmark and you use library `Bookmark+',
then show also the bookmark information (tags etc.).  In this case, a
prefix arg shows the internal form of the bookmark."
    (interactive "e\nP")
    (let (file)
      (with-current-buffer (window-buffer (posn-window (event-end event)))
        (save-excursion (goto-char (posn-point (event-end event)))
                        (setq file  (dired-get-filename nil 'NO-ERROR))))
      (describe-file file internal-form-p))))

;; Define these even if `Bookmark+' is not loaded.
;;;###autoload
(defalias 'diredp-show-metadata 'diredp-describe-autofile)
;;;###autoload
(defun diredp-describe-autofile (&optional internal-form-p)
  "Show the metadata for the file of the current line.
The file must name an autofile bookmark.  The metadata is the bookmark
information.

With a prefix argument, show the internal definition of the bookmark.

You need library `bookmark+.el' for this command."
  (interactive "P")
  (diredp-ensure-bookmark+)
  (diredp-ensure-mode)
  (let ((bmk  (save-match-data
                (bmkp-get-autofile-bookmark (dired-get-filename nil 'NO-ERROR)))))
    (unless bmk (error "Not on an autofile bookmark"))
    (save-selected-window (if internal-form-p
                              (bmkp-describe-bookmark-internals bmk)
                            (bmkp-describe-bookmark bmk)))))

(defun diredp-mouse-describe-autofile (event &optional internal-form-p) ; Not bound
  "Show the metadata for the file whose name you click.
The file must name an autofile bookmark.  The metadata is the bookmark
information.

With a prefix argument, show the internal definition of the bookmark.

You need library `bookmark+.el' for this command."
  (interactive "e\nP")
  (diredp-ensure-bookmark+)
  (let (file)
    (with-current-buffer (window-buffer (posn-window (event-end event)))
      (diredp-ensure-mode)
      (save-excursion (goto-char (posn-point (event-end event)))
                      (setq file  (dired-get-filename nil 'NO-ERROR))))
    (let ((bmk  (save-match-data (bmkp-get-autofile-bookmark file))))
      (unless bmk (error "Not an autofile bookmark"))
      (save-selected-window (if internal-form-p
                                (bmkp-describe-bookmark-internals bmk)
                              (bmkp-describe-bookmark bmk))))))

;;;###autoload
(defalias 'diredp-show-metadata-for-marked 'diredp-describe-marked-autofiles)
;;;###autoload
(defun diredp-describe-marked-autofiles (&optional internal-form-p interactivep details)
  "Show metadata for the marked files.
If no file is marked, describe ALL autofiles in this directory.
With a prefix argument, show the internal (Lisp) form of the metadata.
When invoked interactively, raise an error if no files are marked.
You need library `bookmark+.el' for this command.

When called from Lisp, optional arg DETAILS is passed to
`diredp-get-files'."
  (interactive (list current-prefix-arg t diredp-list-file-attributes))
  (diredp-ensure-bookmark+)
  (let ((help-xref-following  nil))
    (help-setup-xref (list `(lambda (_buf)
                             (with-current-buffer ,(current-buffer) (diredp-describe-marked-autofiles)))
                           internal-form-p)
                     (if (or (> emacs-major-version 23)
                             (and (= emacs-major-version 23)  (> emacs-minor-version 1)))
                         (called-interactively-p 'interactive)
                       (interactive-p))))
  (diredp-with-help-window "*Help*"
    (let ((marked  (dired-get-marked-files nil nil nil 'DISTINGUISH-ONE-MARKED interactivep)))
      (unless (cdr marked)
        (message "Describing ALL autofiles here (none are marked)...")
        (setq marked  (diredp-get-files 'IGNORE-MARKS-P nil nil nil nil details)))
      (if (eq t (car marked))
          (diredp-describe-autofile internal-form-p)
        (dolist (bmk  (delq nil (mapcar #'bmkp-get-autofile-bookmark marked)))
          (if internal-form-p
              (let* ((bname      (bmkp-bookmark-name-from-record bmk))
                     (help-text  (format "%s\n%s\n\n%s"
                                         bname (make-string (length bname) ?-) (pp-to-string bmk))))
                (princ help-text) (terpri))
            (princ (bmkp-bookmark-description bmk)) (terpri)))))))

;;;###autoload
(defun diredp-byte-compile-this-file () ; Bound to `b'
  "In Dired, byte compile the (Lisp source) file on the cursor line."
  (interactive) (dired-do-byte-compile 1))

;;;###autoload
(defun diredp-load-this-file ()         ; Not bound
  "In Dired, load this file."
  (interactive) (dired-do-load 1))

;;;###autoload
(defun diredp-chmod-this-file ()        ; Bound to `M-m'
  "In Dired, change the mode of this file."
  (interactive) (dired-do-chmod 1))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-chgrp-this-file ()      ; Not bound
    "In Dired, change the group of this file."
    (interactive) (dired-do-chgrp 1)))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-chown-this-file ()      ; Not bound
    "In Dired, change the owner of this file."
    (interactive) (dired-do-chown 1)))

(when (fboundp 'dired-do-touch)
  (defun diredp-touch-this-file ()        ; Not bound
    "In Dired, `touch' (change the timestamp of) this file."
    (interactive) (dired-do-touch 1)))


;; REPLACE ORIGINAL in `dired-x.el'.
;;
;; 1. Variable (symbol) `s' -> `blks'.
;; 2. Fixes to remove leading space from `uid' and allow `.' in `gid'.
;; 3. Cleaned up doc string and code a bit.
;;
;;;###autoload
(defun dired-mark-sexp (predicate &optional unmark-p) ; Bound to `M-(', `* ('
  "Mark files for which PREDICATE returns non-nil.
With a prefix arg, unmark or unflag those files instead.

PREDICATE is a lisp sexp that can refer to the following symbols as
variables:

    `mode'   [string]  file permission bits, e.g. \"-rw-r--r--\"
    `nlink'  [integer] number of links to file
    `size'   [integer] file size in bytes
    `uid'    [string]  owner
    `gid'    [string]  group (If the gid is not displayed by `ls',
                       this will still be set (to the same as uid))
    `time'   [string]  the time that `ls' displays, e.g. \"Feb 12 14:17\"
    `name'   [string]  the name of the file
    `sym'    [string]  if file is a symbolic link, the linked-to name,
                       else \"\"
    `inode'  [integer] the inode of the file (only for `ls -i' output)
    `blks'   [integer] the size of the file for `ls -s' output
                       (ususally in blocks or, with `-k', in Kbytes)
Examples:
  Mark zero-length files: `(equal 0 size)'
  Mark files last modified on Feb 2: `(string-match \"Feb  2\" time)'
  Mark uncompiled Emacs Lisp files (`.el' file without a `.elc' file):
     First, Dired just the source files: `dired *.el'.
     Then, use \\[dired-mark-sexp] with this sexp:
          (not (file-exists-p (concat name \"c\")))

There's an ambiguity when a single integer not followed by a unit
prefix precedes the file mode: It is then parsed as inode number
and not as block size (this always works for GNU coreutils ls).

Another limitation is that the uid field is needed for the
function to work correctly.  In particular, the field is not
present for some values of `ls-lisp-emulation'.

This function operates only on the Dired buffer content.  It does not
refer at all to the underlying file system.  Contrast this with
`find-dired', which might be preferable for the task at hand."
  ;; Using `sym' = "", instead of nil, for non-linked files avoids the trap of
  ;; (string-match "foo" sym) into which a user would soon fall.
  ;; Use `equal' instead of `=' in the example, as it works on integers and strings.
  (interactive "xMark if (vars: inode,blks,mode,nlink,uid,gid,size,time,name,sym): \nP")
  (message "%s" predicate)
  (let ((dired-marker-char  (if unmark-p ?\040 dired-marker-char))
        (inode              nil)
        (blks               ())
        mode nlink uid gid size time name sym)
    (diredp-mark-if
     (save-excursion
       (and
        ;; Sets vars INODE BLKS MODE NLINK UID GID SIZE TIME NAME and SYM
        ;; according to current file line.  Returns `t' for success, nil if
        ;; there is no file line.  Upon success, these vars are set, to either
        ;; nil or the appropriate value, so they need not be initialized.
        ;; Moves point within the current line.
        (dired-move-to-filename)
        (let ((mode-len             10) ; Length of mode string.
              ;; As in `dired.el', but with subexpressions \1=inode, \2=blks:
              ;; GNU `ls -hs' suffixes the block count with a unit and prints it as a float; FreeBSD does neither.
              ;; $$$$$$ (dired-re-inode-size  "\\s *\\([0-9]*\\)\\s *\\([0-9]*\\) ?")
              (dired-re-inode-size (if (> emacs-major-version 24)
                                       "\\=\\s *\\([0-9]+\\s +\\)?\
\\(?:\\([0-9]+\\(?:\\.[0-9]*\\)?[BkKMGTPEZY]?\\)? ?\\)"
                                     "\\s *\\([0-9]*\\)\\s *\\([0-9]*\\) ?"))
              pos)
          (beginning-of-line)
          (forward-char 2)
          (search-forward-regexp dired-re-inode-size nil t)
          ;; XXX Might be a size not followed by a unit prefix.  Could set `blks' to `inode' if it were otherwise
          ;; nil, with similar reasoning as for setting `gid' to `uid', but it would be even more whimsical.
          (setq inode  (and (match-string 1)  (string-to-number (match-string 1)))
                blks   (and (match-string 2)  (if (fboundp 'dired-x--string-to-number)
                                                  (dired-x--string-to-number (match-string 2)) ; Emacs 25+
                                                (string-to-number (match-string 2))))
                mode   (buffer-substring (point) (+ mode-len (point))))
          (forward-char mode-len)
          (unless (eq (char-after) ?\   ) (forward-char 1)) ; Skip any extended attributes marker ("." or "+").
          (setq nlink  (read (current-buffer)))
          ;; Karsten Wenger <kw@cis.uni-muenchen.de> fixed uid.

          ;; Another issue is that GNU `ls -n' right-justifies numerical UIDs and GIDs, while FreeBSD
          ;; left-justifies them, so do not rely on a specific whitespace layout.  Both of them right-justify all
          ;; other numbers, though.
          ;; XXX Return a number if the `uid' or `gid' seems to be numerical?
          ;; $$$$$$ (setq uid  (buffer-substring (+ (point) 1) (progn (forward-word 1) (point))))
          (setq uid  (buffer-substring (progn (skip-chars-forward " \t")  (point))
                                       (progn (skip-chars-forward "^ \t") (point))))
          (cond ((> emacs-major-version 24)
                 (dired-move-to-filename)
                 (save-excursion
                   (setq time
                         ;; The regexp below tries to match from the last digit of the size field through a
                         ;; space after the date.  Also, dates may have different formats depending on file age,
                         ;; so the date column need not be aligned to the right.
                         (buffer-substring (save-excursion (skip-chars-backward " \t") (point))
                                           (progn (re-search-backward directory-listing-before-filename-regexp)
                                                  (skip-chars-forward "^ \t")
                                                  (1+ (point))))
                         size
                         (dired-x--string-to-number
                          ;; We know that there's some kind of number before point because the regexp search
                          ;; above succeeded.  Not worth doing an extra check for leading garbage.
                          (buffer-substring (point) (progn (skip-chars-backward "^ \t") (point))))
                         ;; If no `gid' is displayed, `gid' will be set to `uid' but user will then not reference
                         ;; it anyway in PREDICATE.
                         gid
                         (buffer-substring (progn (skip-chars-backward " \t") (point))
                                           (progn (skip-chars-backward "^ \t") (point)))))
                 (setq name  (buffer-substring (point) (or (dired-move-to-end-of-filename t)  (point)))
                       sym   (if (diredp-looking-at-p " -> ")
                                 (buffer-substring (progn (forward-char 4) (point)) (line-end-position))
                               "")))
                (t
                 (re-search-forward
                  (if (< emacs-major-version 20)
                      "\\(Jan\\|Feb\\|Mar\\|Apr\\|May\\|Jun\\|Jul\\|Aug\\|Sep\\|Oct\\|Nov\\|Dec\\)"
                    dired-move-to-filename-regexp))
                 (goto-char (match-beginning 1))
                 (forward-char -1)
                 (setq size  (string-to-number (buffer-substring (save-excursion (backward-word 1)
                                                                                 (setq pos  (point)))
                                                                 (point))))
                 (goto-char pos)
                 (backward-word 1)
                 ;; if no `gid' is displayed, `gid' will be set to `uid' but user will then not reference
                 ;; it anyway in PREDICATE.
                 (setq gid   (buffer-substring (save-excursion (forward-word 1) (point)) (point))
                       time  (buffer-substring (match-beginning 1) (1- (dired-move-to-filename)))
                       name  (buffer-substring (point) (or (dired-move-to-end-of-filename t)  (point)))
                       sym   (if (diredp-looking-at-p " -> ")
                                 (buffer-substring (progn (forward-char 4) (point)) (line-end-position))
                               "")))))
        ;; Vanilla Emacs uses `lexical-binding' = t, and it passes bindings to `eval' as a second arg.
        ;; We use `lexical-binding' = nil, and anyway there should be no need to pass the bindings.
        (eval predicate)))
     (format "'%s file" predicate))))

(defun diredp-this-file-marked-p (&optional mark-char)
  "Return non-nil if the file on this line is marked.
Optional arg MARK-CHAR is the type of mark to check.
 If nil, then if the file has any mark, including `D', it is marked."
  (and (dired-get-filename t 'NO-ERROR)  (save-excursion
                                           (beginning-of-line)
                                           (if mark-char
                                               (diredp-looking-at-p
                                                (concat "^" (regexp-quote (char-to-string mark-char))))
                                             (not (diredp-looking-at-p "^ "))))))

(defun diredp-this-file-unmarked-p (&optional mark-char)
  "Return non-nil if the file on this line is unmarked.
Optional arg MARK-CHAR is the type of mark to check.
 If nil, then if the file has no mark, including `D', it is unmarked.
 If non-nil, then it is unmarked for MARK-CHAR if it has no mark or
 it has any mark except MARK-CHAR."
  (and (dired-get-filename t 'NO-ERROR)  (save-excursion
                                           (beginning-of-line)
                                           (if mark-char
                                               (not (diredp-looking-at-p
                                                     (concat "^" (regexp-quote (char-to-string mark-char)))))
                                             (diredp-looking-at-p "^ ")))))

(put 'diredp-mark 'interactive-only t)
;;;###autoload
(defun diredp-mark (arg &optional char) ; Bound to `m', `* m'
  "Mark current line, lines in active region, or lines in a listing.
If the region is active and nonempty:
 ,* Mark the lines in the region.
 ,* With a prefix arg, you are prompted for the CHAR to mark with.

If cursor is on a listing header line (main dir or a subdir):
 ,* Mark all lines in that listing except dirs `.' and `..'.
 ,* With a prefix arg, you are prompted for the CHAR to mark with.

Otherwise, with numeric prefix arg N, mark the next N lines.

Use \\<dired-mode-map>`\\[dired-unmark-all-files]' to remove marks everywhere, \
or `\\[dired-unmark]' on a listing header
line to remove marks in the listing."
  (interactive "P")
  (let ((dired-marker-char  dired-marker-char))
    (cond ((diredp-nonempty-region-p)
           (when arg
             (when (< emacs-major-version 28) (message nil)) ; Workaround for bug #46243.
             (setq dired-marker-char  (read-char "Mark region lines with char: ")))
           (diredp-mark-region-files))
          ((dired-get-subdir)
           (when arg
             (when (< emacs-major-version 28) (message nil)) ; Workaround for bug #46243.
             (setq dired-marker-char  (read-char "Mark subdir lines with char: ")))
           (save-excursion (dired-mark-subdir-files)))
          (t
           (let ((inhibit-read-only  t))
             (dired-repeat-over-lines
              (prefix-numeric-value arg)
              (lambda () (delete-char 1) (insert dired-marker-char))))))))

;;;###autoload
(defun diredp-mark-with-char (char &optional arg) ; Not bound, except in menus
  "Mark this line with CHAR.
With numeric prefix arg N, mark the next N lines."
  ;; Need workaround for Emacs < 28 - see Emacs bug #46243.
  ;; (interactive "cMark this line with char: \np")
  (interactive
   (progn (when (< emacs-major-version 28) (message nil)) ; Workaround for bug #46243.
          (list (read-char "Mark this line with char: ")
                (prefix-numeric-value current-prefix-arg))))
  (let ((dired-marker-char  char)) (dired-mark arg)))

;;;###autoload
(defun diredp-mark-region-files-with-char (char &optional unmark-p) ; Not bound, except in menus
  "Mark lines in active region with CHAR.
With non-nil prefix arg, unmark CHAR instead."
  ;; Need workaround for Emacs < 28 - see Emacs bug #46243.
  ;;(interactive "cMark region with char: \nP")
  (interactive
   (progn (when (< emacs-major-version 28) (message nil)) ; Workaround for bug #46243.
          (list (read-char "Mark region with char: ") current-prefix-arg)))
  (let ((dired-marker-char  char)
        (beg                        (min (point) (mark)))
        (end                        (max (point) (mark)))
        (inhibit-field-text-motion  t)) ; Just in case.
    (setq beg  (save-excursion (goto-char beg) (line-beginning-position))
          end  (save-excursion (goto-char end) (when (and (bolp) (> end beg)) (backward-char)) (line-end-position)))
    (let ((dired-marker-char  (if unmark-p ?\040 dired-marker-char)))
      (diredp-mark-if (and (<= (point) end)  (>= (point) beg)  (diredp-this-file-unmarked-p)) "region file"))))

;;;###autoload
(defun diredp-mark-region-files (&optional unmark-p) ; Not bound, except in menus
  "Mark all of the files in the current region (if it is active).
With non-nil prefix arg, unmark them instead."
  (interactive "P")
  (let ((beg                        (min (point) (mark)))
        (end                        (max (point) (mark)))
        (inhibit-field-text-motion  t)) ; Just in case.
    (setq beg  (save-excursion (goto-char beg) (line-beginning-position))
          end  (save-excursion (goto-char end) (when (and (bolp) (> end beg)) (backward-char)) (line-end-position)))
    (let ((dired-marker-char  (if unmark-p ?\040 dired-marker-char)))
      (diredp-mark-if (and (<= (point) end)  (>= (point) beg)  (diredp-this-file-unmarked-p)) "region file"))))

;;;###autoload
(defun diredp-unmark-region-files (&optional mark-p) ; Not bound, except in menus
  "Unmark all of the files in the current region (if it is active).
With non-nil prefix arg, mark them instead."
  (interactive "P")
  (let ((beg                        (min (point) (mark)))
        (end                        (max (point) (mark)))
        (inhibit-field-text-motion  t)) ; Just in case.
    (setq beg  (save-excursion (goto-char beg) (line-beginning-position))
          end  (save-excursion (goto-char end) (when (and (bolp) (> end beg)) (backward-char)) (line-end-position)))
    (let ((dired-marker-char  (if mark-p dired-marker-char ?\040)))
      (diredp-mark-if (and (<= (point) end)  (>= (point) beg)  (diredp-this-file-marked-p)) "region file"))))

;;;###autoload
(defun diredp-flag-region-files-for-deletion () ; Not bound
  "Flag all of the files in the current region (if it is active) for deletion."
  (interactive)
  (let ((beg                        (min (point) (mark)))
        (end                        (max (point) (mark)))
        (inhibit-field-text-motion  t)) ; Just in case.
    (setq beg  (save-excursion (goto-char beg) (line-beginning-position))
          end  (save-excursion (goto-char end) (when (and (bolp) (> end beg)) (backward-char)) (line-end-position)))
    (let ((dired-marker-char  dired-del-marker))
      (diredp-mark-if (and (<= (point) end)  (>= (point) beg)  (diredp-this-file-unmarked-p ?\D))
                      "region file"))))

;;;###autoload
(defun diredp-toggle-marks-in-region (beg end) ; Not bound
  "Toggle marks in the region."
  (interactive "r")
  (save-excursion
    (save-restriction
      (if (not (fboundp 'dired-toggle-marks))
          ;; Pre-Emacs 22.  Use bol, eol.  If details hidden, show first.
          (let ((details-hidden-p  (and (boundp 'dired-details-state)  (eq 'hidden dired-details-state))))
            (widen)
            (when details-hidden-p (dired-details-show))
            (goto-char beg)
            (setq beg  (line-beginning-position))
            (goto-char end)
            (when (and (bolp) (> end beg)) (backward-char))
            (setq end  (line-end-position))
            (narrow-to-region beg end)
            (dired-toggle-marks)
            (when details-hidden-p (dired-details-hide)))
        (narrow-to-region beg end)
        (dired-toggle-marks))))
  (when (and (get-buffer-window (current-buffer))  (fboundp 'fit-frame-if-one-window))
    (fit-frame-if-one-window)))


;;; Mouse 3 menu.
;;;;;;;;;;;;;;;;;

(defvar diredp-file-line-overlay nil)

;;;###autoload
(defun diredp-mouse-3-menu (event)      ; Bound to `mouse-3'
  "Dired pop-up `mouse-3' menu, for files in selection or current line."
  (interactive "e")
  (if (not (and (fboundp 'mouse3-dired-use-menu)  (diredp-nonempty-region-p)))
      ;; No `mouse3.el' or no region.
      (if (diredp-nonempty-region-p)
          ;; Region
          (let ((reg-choice  (x-popup-menu
                              event
                              (list "Files in Region"
                                    (list ""
                                          '("Mark" . diredp-mark-region-files)
                                          '("Mark with Char" . diredp-mark-region-files-with-char) ; But bug #46243.
                                          '("Unmark" . diredp-unmark-region-files)
                                          '("Toggle Marked/Unmarked" .
                                            diredp-toggle-marks-in-region)
                                          '("Flag for Deletion" .
                                            diredp-flag-region-files-for-deletion))))))
            (when reg-choice (call-interactively reg-choice)))
        ;; Single file/dir (no region).
        (let ((mouse-pos                  (event-start event))
              ;; Do not use `save-excursion', because some commands will move point on purpose.
              ;; Just save original point and return to it unless MOVEP is set to non-nil.
              (opoint                     (point))
              (movep                      nil)
              (inhibit-field-text-motion  t) ; Just in case.
              choice bol  eol  file/dir-name)
          (with-current-buffer (window-buffer (posn-window mouse-pos))
            (goto-char (posn-point mouse-pos))
            (setq bol  (line-beginning-position)
                  eol  (line-end-position))
            (unwind-protect
                 (when (setq file/dir-name  (and (not (eobp))  (dired-get-filename nil 'NO-ERROR)))
                   (if diredp-file-line-overlay ; Don't re-create if exists.
                       (move-overlay diredp-file-line-overlay bol eol (current-buffer))
                     (setq diredp-file-line-overlay  (make-overlay bol eol))
                     (overlay-put diredp-file-line-overlay 'face 'region))
                   (sit-for 0)
                   (let ((map
                          (easy-menu-create-menu
                           "This File"
                           `(
                             ("Bookmark" :visible (featurep 'bookmark+)
                              ["Bookmark..." diredp-bookmark-this-file]
                              ["Add Tags..." diredp-tag-this-file
                               :visible (featurep 'bookmark+)]
                              ["Remove Tags..." diredp-untag-this-file
                               :visible (featurep 'bookmark+)]
                              ["Remove All Tags" diredp-remove-all-tags-this-file
                               :visible (featurep 'bookmark+)]
                              ["Copy Tags" diredp-copy-tags-this-file
                               :visible (featurep 'bookmark+)]
                              ["Paste Tags (Add)" diredp-paste-add-tags-this-file
                               :visible (featurep 'bookmark+)]
                              ["Paste Tags (Replace)" diredp-paste-replace-tags-this-file
                               :visible (featurep 'bookmark+)]
                              ["Set Tag Value..." diredp-set-tag-value-this-file
                               :visible (featurep 'bookmark+)]
                              )
                             ["Describe" ',(if (if (> emacs-major-version 21)
                                                   (require 'help-fns+ nil t)
                                                 (require 'help+20 nil t))
                                               'diredp-describe-file
                                               'diredp-describe-autofile)] ; Requires `bookmark+.el'
                             ;; Stuff from `Marks' menu.
                             ["Mark"  diredp-mark
                              :visible (not (eql (dired-file-marker file/dir-name)
                                             dired-marker-char))]
                             ["Mark with Char..."  diredp-mark-with-char] ; But see bug #46243.
                             ["Unmark" dired-unmark
                              :visible (dired-file-marker file/dir-name)]
                             ["Flag for Deletion" dired-flag-file-deletion
                              :visible (not (eql (dired-file-marker file/dir-name)
                                             dired-del-marker))]
                             ["Delete..." diredp-delete-this-file]
                             "--"       ; ------------------------------------------------------
                             ;; Stuff from `Single' / `Multiple' menus.
                             ["Open" dired-find-file]
                             ["Open in Other Window" dired-find-file-other-window]
                             ["Open in Other Frame" diredp-find-file-other-frame]
                             ["Open Associated Windows App" dired-w32-browser
                              :visible (featurep 'w32-browser)]
                             ["Open in Windows Explorer" dired-w32explore
                              :visible (featurep 'w32-browser)]
                             ["View (Read Only)" dired-view-file]
                             ["--" 'ignore ; -------------------------------------------------
                              :visible (or (atom (diredp-this-subdir)) ; Subdir line.
                                        (not (equal (expand-file-name (dired-current-directory))
                                              (expand-file-name default-directory))))] ; Not top.
                             ["Insert This Subdir"
                              (lambda () (interactive)
                                      (call-interactively #'dired-maybe-insert-subdir)
                                      (setq movep  t))
                              :visible (and (atom (diredp-this-subdir))
                                        (not (assoc (file-name-as-directory (diredp-this-subdir))
                                              dired-subdir-alist)))
                              :enable (atom (diredp-this-subdir))]
                             ["Go To Inserted Subdir"
                              (lambda () (interactive)
                                      (call-interactively #'dired-maybe-insert-subdir)
                                      (setq movep  t))
                              :visible (and (atom (diredp-this-subdir))
                                        (assoc (file-name-as-directory (diredp-this-subdir))
                                         dired-subdir-alist))
                              :enable (atom (diredp-this-subdir))
                              :keys "i"]
                             ["Remove This Inserted Subdir" dired-kill-subdir
                              :visible (not (equal
                                             (expand-file-name (dired-current-directory))
                                             (expand-file-name default-directory)))] ; In subdir, not top.
                             ["Remove This Inserted Subdir and Lower" diredp-kill-this-tree
                              :visible (and (fboundp 'diredp-kill-this-tree)
                                        (not (equal
                                              (expand-file-name (dired-current-directory))
                                              (expand-file-name default-directory))))] ; In subdir, not top.
                             ["Dired This Inserted Subdir (Tear Off)"
                              (lambda () (interactive) (diredp-dired-this-subdir t))
                              :visible (not (equal (expand-file-name (dired-current-directory))
                                             (expand-file-name default-directory)))] ; In subdir, not top.
                             "--"       ; ------------------------------------------------------
                             ["Compare..." diredp-ediff]
                             ["Diff..." dired-diff]
                             ["Diff with Backup" dired-backup-diff]

                             ["Bookmark..." diredp-bookmark-this-file
                              :visible (not (featurep 'bookmark+))]
                             "--"       ; ------------------------------------------------------
                             ["Rename to..." diredp-rename-this-file]
                             ["Capitalize" diredp-capitalize-this-file]
                             ["Upcase" diredp-upcase-this-file]
                             ["Downcase" diredp-downcase-this-file]
                             "--"       ; ------------------------------------------------------
                             ["Copy to..." diredp-copy-this-file]
                             ["Symlink to (Relative)..." diredp-relsymlink-this-file]
                             ["Symlink to..." diredp-symlink-this-file]
                             ["Hardlink to..." diredp-hardlink-this-file]
                             "--"       ; ------------------------------------------------------
                             ["Load" diredp-load-this-file]
                             ["Byte-Compile" diredp-byte-compile-this-file]
                             ["Asynchronous Shell Command..."
                              diredp-async-shell-command-this-file]
                             ["Shell Command..." diredp-shell-command-this-file]
                             ["Compress/Uncompress" diredp-compress-this-file]
                             ["Print..." diredp-print-this-file]
                             ["Add To Recent Visits" diredp-add-this-to-recentf
                              :visible (featurep 'recentf)]
                             ["Remove From Recent Visits" diredp-remove-this-from-recentf
                              :visible (featurep 'recentf)]
                             ["Grep" diredp-grep-this-file]
                             "--"       ; ------------------------------------------------------
                             ["Change Timestamp..." diredp-touch-this-file]
                             ["Change Mode..." diredp-chmod-this-file]
                             ["Change Group..." diredp-chgrp-this-file
                              :visible (fboundp 'diredp-chgrp-this-file)]
                             ["Change Owner..." diredp-chown-this-file
                              :visible (fboundp 'diredp-chown-this-file)]))))
                     (when diredp-file-line-overlay
                       (delete-overlay diredp-file-line-overlay))
                     (setq choice  (x-popup-menu event map))
                     (when choice (call-interactively (lookup-key map (apply 'vector choice))))))
              (unless movep (goto-char opoint))))))
    ;; `mouse3.el' and active region.
    (unless (eq mouse3-dired-function 'mouse3-dired-use-menu)
      (funcall #'mouse3-dired-use-menu)
      (revert-buffer))
    (let ((last-command  'mouse-save-then-kill)) (mouse-save-then-kill event))))


;; REPLACE ORIGINAL in `dired.el' for Emacs 20.
;;
;; Allow `.' and `..', by using non-nil second arg to `dired-get-filename'.
;;
(when (< emacs-major-version 21)
  (defun dired-find-file ()             ; Bound to `RET'
    "In Dired, visit the file or directory named on this line."
    (interactive)
    (let* ((dgf-result  (or (dired-get-filename nil 'NO-ERROR)  (error "No file on this line")))
           (file-name   (file-name-sans-versions dgf-result t)))
      (if (file-exists-p file-name)
          (find-file file-name)
        (error (if (file-symlink-p file-name)
                   "File is a symlink to a nonexistent target"
                 "File no longer exists; type `g' to update Dired buffer"))))))

;;;###autoload
(defun diredp-find-file-other-frame ()  ; Bound to `C-o'
  "In Dired, visit this file or directory in another frame."
  (interactive)
  (find-file-other-frame (file-name-sans-versions (dired-get-filename nil 'NO-ERROR) t)))

;;;###autoload
(defun diredp-mouse-find-file-other-frame (event) ; Bound to `M-mouse-2'
  "In Dired, visit file or directory clicked on in another frame."
  (interactive "e")
  (let ((pop-up-frames  t)) (dired-mouse-find-file-other-window event)))


;; REPLACE ORIGINAL in `dired.el'.
;;
;; Allow `.' and `..', by using non-nil second arg to `dired-get-filename'.
;;
;;;###autoload
(defun dired-mouse-find-file-other-window (event) ; Bound to `mouse-2'
  "In Dired, visit the file or directory name you click on."
  (interactive "e")
  (let (file)
    (with-current-buffer (window-buffer (posn-window (event-end event)))
      (save-excursion (goto-char (posn-point (event-end event)))
                      (setq file  (dired-get-filename nil 'NO-ERROR))))
    (unless (stringp file) (error "No file here"))
    (select-window (posn-window (event-end event)))
    (find-file-other-window (file-name-sans-versions file t))))

;;;###autoload
(defun diredp-mouse-view-file (event)   ; Not bound
  "Examine this file in view mode, returning to Dired when done.
When file is a directory, show it in this buffer if it is inserted;
otherwise, display it in another buffer."
  (interactive "e")
  (let (file)
    (with-current-buffer (window-buffer (posn-window (event-end event)))
      (save-excursion (goto-char (posn-point (event-end event)))
                      (setq file  (dired-get-filename nil 'NO-ERROR))))
    (select-window (posn-window (event-end event)))
    (if (file-directory-p file)
        (or (and (cdr dired-subdir-alist)  (dired-goto-subdir file))  (dired file))
      (view-file file))))               ; In `view.el'.

;;;###autoload
(defun diredp-mouse-ediff (event)       ; Not bound
  "Compare this file (pointed by mouse) with file FILE2 using `ediff'.
FILE2 defaults to this file as well.  If you enter just a directory
name for FILE2, then this file is compared with a file of the same
name in that directory.  FILE2 is the second file given to `ediff';
this file is the first given to it."
  (interactive "e")
  (require 'ediff)
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (call-interactively 'diredp-ediff)))

;;;###autoload
(defun diredp-mouse-diff (event &optional switches) ; Not bound
  "Compare this file (pointed by mouse) with file FILE2 using `diff'.
FILE2 defaults to the file at the mark.  This file is the first file
given to `diff'.  With prefix arg, prompt for second arg SWITCHES,
which are options for `diff'."
  (interactive "e")
  (let ((default    (and (mark t)  (save-excursion (goto-char (mark t))
                                                   (dired-get-filename t 'NO-ERROR))))
        (mouse-pos  (event-start event)))
    (require 'diff)
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (let ((file2  (read-file-name (format "Diff %s with: %s"
                                          (dired-get-filename t)
                                          (if default (concat "(default " default ") ") ""))
                                  (dired-current-directory) default t)))
      (setq switches  (and current-prefix-arg
                           (if (fboundp 'icicle-read-string-completing) ; In `icicles-fn.el'
                               (icicle-read-string-completing "Options for diff: "
                                                              (if (stringp diff-switches)
                                                                  diff-switches
                                                                (mapconcat #'identity diff-switches " "))
                                                              (lambda (c)
                                                                (diredp-string-match-p "switches"
                                                                                       (symbol-name c))))
                             (read-string "Options for diff: " (if (stringp diff-switches)
                                                                   diff-switches
                                                                 (mapconcat #'identity diff-switches " "))))))
      (diff file2 (dired-get-filename t) switches))))

;;;###autoload
(defun diredp-mouse-backup-diff (event) ; Not bound
  "Diff this file with its backup file or vice versa.
Use the latest backup, if there are several numerical backups.
If this file is a backup, diff it with its original.
The backup file is the first file given to `diff'.
With prefix arg, prompt for SWITCHES which are the options for `diff'."
  (interactive "e")
  (let ((switches   (and current-prefix-arg
                         (if (fboundp 'icicle-read-string-completing) ; In `icicles-fn.el'
                             (icicle-read-string-completing "Options for diff: "
                                                            (if (stringp diff-switches)
                                                                diff-switches
                                                              (mapconcat #'identity diff-switches " "))
                                                            (lambda (c)
                                                              (diredp-string-match-p "switches"
                                                                                     (symbol-name c))))
                           (read-string "Options for diff: " (if (stringp diff-switches)
                                                                 diff-switches
                                                               (mapconcat #'identity diff-switches " "))))))
        (mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (diff-backup (dired-get-filename) switches)))

;;;###autoload
(defun diredp-mouse-mark (event)        ; Not bound
  "In Dired, mark this file.
If on a subdir headerline, mark all its files except `.' and `..'.

Use \\[dired-unmark-all-files] to remove all marks,
and \\[dired-unmark] on a subdir to remove the marks in this subdir."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (if (and (cdr dired-subdir-alist)  (dired-get-subdir))
      (save-excursion (dired-mark-subdir-files))
    (let ((buffer-read-only  nil))
      (dired-repeat-over-lines 1 #'(lambda () (delete-char 1) (insert dired-marker-char)))
      (diredp-previous-line 1))))

;;;###autoload
(defun diredp-mouse-unmark (event)      ; Not bound
  "In Dired, unmark this file.
If looking at a subdir, unmark all its files except `.' and `..'."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (let ((dired-marker-char  ?\040)) (dired-mark nil))
  (diredp-previous-line 1))

;;; This can be bound to [C-down-mouse-1] to give behavior similar to Windows Explorer.
;;; However, Emacs generally uses [C-down-mouse-1] for `mouse-buffer-menu'.
;;;###autoload
(defun diredp-mouse-mark/unmark (event) ; Not bound
  "Mark/unmark file or directory at mouse EVENT."
  (interactive "e")
  (let* ((mouse-pos                  (event-start event))
         (inhibit-field-text-motion  t) ; Just in case.
         (file/dir-name              (with-current-buffer (window-buffer (posn-window mouse-pos))
                                       (save-excursion
                                         (goto-char (posn-point mouse-pos))
                                         (and (not (eobp))  (dired-get-filename nil 'NO-ERROR))))))
    ;; Return nil iff not on a file or directory name.
    (and file/dir-name  (cond ((dired-file-marker file/dir-name)
                               (diredp-mouse-unmark event)
                               (message "Unmarked: %s" file/dir-name))
                              (t
                               (diredp-mouse-mark event)
                               (message "Marked: %s" file/dir-name))))))

;; This can be bound to [S-mouse-1] to give behavior similar to Windows Explorer.
;; If you do that, consider binding `diredp-mouse-mark/unmark' to `C-mouse-1'.
;; Alternatively, just bind `diredp-mouse-mark/unmark-mark-region-files' to [S-mouse-1].
;;;###autoload
(defun diredp-mouse-mark-region-files (event) ; Bound to `S-mouse-1'
  "Mark files between point and the mouse."
  (interactive "e")
  (call-interactively 'mouse-save-then-kill)
  (diredp-mark-region-files))

;; This can be bound to [S-mouse-1] to give behavior similar to Windows Explorer.
;; If you don't bind `diredp-mouse-mark/unmark' to, for instance, `C-mouse-1', then
;; Consider binding this to [S-mouse-1].
;;;###autoload
(defun diredp-mouse-mark/unmark-mark-region-files (event) ; Not bound
  "Mark/unmark file or mark files in region.
If the file the cursor is on is marked, then mark all files between it
 and the line clicked (included).
Otherwise (cursor's file is unmarked):
 If the file clicked is marked, then unmark it.
 If it is unmarked, then mark it."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    ;; If same click same line as cursor, or cursor's line is marked,
    ;; Then toggle the clicked line's mark.
    ;; Else mark all files in region between point and clicked line (included).
    (if (or (eq (count-lines (point-min) (posn-point mouse-pos))
                (count-lines (point-min) (point)))
            (equal dired-marker-char (dired-file-marker (dired-get-filename nil 'NO-ERROR))))
        (diredp-mouse-mark/unmark event)
      (call-interactively 'mouse-save-then-kill)
      (diredp-mark-region-files))))

;;;###autoload
(defun diredp-mouse-flag-file-deletion (event) ; Not bound
  "In Dired, flag this file for deletion.
If on a subdir headerline, mark all its files except `.' and `..'."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (let ((dired-marker-char  dired-del-marker)) (dired-mark 1))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-mouse-do-copy (event)     ; Not bound
  "In Dired, copy this file.
This normally preserves the last-modified date when copying."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-do-create-files 'copy #'dired-copy-file (if dired-copy-preserve-time "Copy [-p]" "Copy")
                         1 dired-keep-marker-copy))

;;;###autoload
(defun diredp-mouse-do-rename (event)   ; Not bound
  "In Dired, rename this file."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-do-create-files 'move #'dired-rename-file "Move" 1 dired-keep-marker-rename "Rename"))

;;;###autoload
(defun diredp-mouse-upcase (event)      ; Not bound
  "In Dired, rename this file to upper case."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-rename-non-directory #'upcase "Rename to uppercase:" nil))

;;;###autoload
(defun diredp-mouse-downcase (event)    ; Not bound
  "In Dired, rename this file to lower case."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-rename-non-directory #'downcase "Rename to lowercase:" nil))

;;;###autoload
(defun diredp-mouse-do-delete (event)   ; Not bound
  "In Dired, delete this file, upon confirmation."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (diredp-internal-do-deletions (dired-map-over-marks (cons (dired-get-filename) (point)) 1)
                                1
                                'USE-TRASH-CAN) ; This arg is for Emacs 24+ only.
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-mouse-do-shell-command (event) ; Not bound
  "Run a shell COMMAND on this file.
If there is output, it goes to a separate buffer.

No automatic redisplay of Dired buffers is attempted, as there's no
telling what files the command may have changed.  Type
\\[dired-do-redisplay] to redisplay.

The shell command has the top level directory as working directory, so
output files usually are created there instead of in a subdir."
  ;;Functions dired-run-shell-command and dired-shell-stuff-it do the
  ;;actual work and can be redefined for customization.
  (interactive "e")
  (lexical-let ((mouse-pos  (event-start event))
                (command    (dired-read-shell-command "! on %s: " nil (dired-get-marked-files t nil))))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-bunch-files (- 10000 (length command))
                       (lambda (&rest files) (dired-run-shell-command (dired-shell-stuff-it command files t 1)))
                       nil
                       (dired-get-marked-files t 1))))

;;;###autoload
(defun diredp-mouse-do-symlink (event)  ; Not bound
  "Make symbolic link to this file."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-do-create-files 'symlink #'make-symbolic-link "Symlink" 1 dired-keep-marker-symlink))

;;;###autoload
(defun diredp-mouse-do-hardlink (event) ; Not bound
  "Make hard link (alias) to this file."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-do-create-files 'hardlink #'add-name-to-file "Hardlink" 1 dired-keep-marker-hardlink))

;;;###autoload
(defun diredp-mouse-do-print (event)    ; Not bound
  "Print this file.
Uses the shell command coming from variables `lpr-command' and
`lpr-switches' as default."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (let* ((file     (dired-get-filename))
         (command  (dired-mark-read-string
                    "Print %s with: " (apply 'concat lpr-command " " lpr-switches) 'print 1 (list file))))
    (dired-run-shell-command (dired-shell-stuff-it command (list file) nil))))

;;;###autoload
(defun diredp-mouse-do-grep (event)     ; Not bound
  "Run grep against this file."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (unless grep-command (grep-compute-defaults))
  (grep (diredp-do-grep-1 (list (dired-get-filename t)))))

;;;###autoload
(defun diredp-mouse-do-compress (event) ; Not bound
  "Compress or uncompress this file."
  (interactive "e")
  (let ((mouse-pos         (event-start event))
        (dired-no-confirm  t))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'dired-compress 1 'compress t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-mouse-do-byte-compile (event) ; Not bound
  "Byte compile this file."
  (interactive "e")
  (let ((mouse-pos         (event-start event))
        (dired-no-confirm  t))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'dired-byte-compile 1 'byte-compile t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-mouse-do-load (event)     ; Not bound
  "Load this Emacs Lisp file."
  (interactive "e")
  (let ((mouse-pos         (event-start event))
        (dired-no-confirm  t))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos))
    (dired-map-over-marks-check #'dired-load 1 'load t))
  (diredp-previous-line 1))

;;;###autoload
(defun diredp-mouse-do-chmod (event)    ; Not bound
  "Change the mode of this file.
This calls chmod, so symbolic modes like `g+w' are allowed."
  (interactive "e")
  (let ((mouse-pos  (event-start event)))
    (select-window (posn-window mouse-pos))
    (goto-char (posn-point mouse-pos)))
  (dired-do-chxxx "Mode" "chmod" 'chmod 1)
  (diredp-previous-line 1))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-mouse-do-chgrp (event)  ; Not bound
    "Change the group of this file."
    (interactive "e")
    (let ((mouse-pos  (event-start event)))
      (select-window (posn-window mouse-pos))
      (goto-char (posn-point mouse-pos)))
    (dired-do-chxxx "Group" "chgrp" 'chgrp 1)
    (diredp-previous-line 1)))

(unless (memq system-type '(windows-nt ms-dos))
  (defun diredp-mouse-do-chown (event)  ; Not bound
    "Change the owner of this file."
    (interactive "e")
    (let ((mouse-pos  (event-start event)))
      (select-window (posn-window mouse-pos))
      (goto-char (posn-point mouse-pos)))
    (dired-do-chxxx "Owner" dired-chown-program 'chown 1)
    (diredp-previous-line 1)))


;;; Breadcrumbs

(when (fboundp 'define-minor-mode)      ; Emacs 22+

  ;; Macro `define-minor-mode' is not defined in Emacs 20, so in order to be able to byte-compile
  ;; this file in Emacs 20, prohibit byte-compiling of the `define-minor-mode' call.
  ;;
  (eval '(define-minor-mode diredp-breadcrumbs-in-header-line-mode
          "Toggle the use of breadcrumbs in Dired header line.
With arg, show breadcrumbs iff arg is positive."
          :init-value nil :group 'header-line :group 'Dired-Plus
          (unless (derived-mode-p 'dired-mode)
            (error "You must be in Dired or a mode derived from it to use this command"))
          (if diredp-breadcrumbs-in-header-line-mode
              (diredp-set-header-line-breadcrumbs)
            (setq header-line-format  (default-value 'header-line-format)))))

  (defun diredp-set-header-line-breadcrumbs ()
    "Show a header line with breadcrumbs to parent directories."
    (let ((parent  (diredp-parent-dir default-directory))
          (dirs    ())
          (text    ""))
      (while parent
        (push parent dirs)
        (setq parent  (diredp-parent-dir parent)))
      (dolist (dir  dirs)
        (let* ((crumbs-map    (make-sparse-keymap))
               (menu-map      (make-sparse-keymap "Breadcrumbs in Header Line"))
               ;; The next three are for showing the root as absolute and the rest as relative.
               (rootp         (diredp-root-directory-p dir))
               (parent-rootp  (and (not rootp)  (diredp-root-directory-p (diredp-parent-dir dir))))
               (rdir          dir))
          ;; (define-key crumbs-map [header-line mouse-3] menu-map)
          (unless rootp (setq rdir  (file-name-nondirectory (directory-file-name dir))))
          (when dir
            (setq rdir  (propertize rdir
                                    'local-map (progn (define-key crumbs-map [header-line mouse-1]
                                                        `(lambda () (interactive)
                                                          (dired ,dir dired-actual-switches)))
                                                      (define-key crumbs-map [header-line mouse-2]
                                                        `(lambda () (interactive)
                                                          (dired-other-window ,dir dired-actual-switches)))
                                                      crumbs-map)
                                    'mouse-face 'mode-line-highlight
                                    ;;'help-echo "mouse-1: Dired; mouse-2: Dired in other window; mouse-3: Menu"))
                                    'help-echo "mouse-1: Dired; mouse-2: Dired in other window"))
            (setq text  (concat text (if (or rootp  parent-rootp) " "  " / ") rdir)))))
      (make-local-variable 'header-line-format)
      (setq header-line-format  text)))

  ;; Users can do this.
  ;;
  ;; (add-hook 'dired-before-readin-hook 'diredp-breadcrumbs-in-header-line-mode)

  )


;;; `Dired+' Help

;;;###autoload
(defun diredp-describe-mode (&optional buffer)
  "Describe Dired mode, including Dired+ features.
This is `describe-mode' plus a description of Dired+ features.
For just the latter, use \\<dired-mode-map>`\\[diredp-dired-plus-help]'."
  (interactive "@")
  (unless (derived-mode-p 'dired-mode)
    (error "Use `diredp-dired-plus-help' if you want information about Dired+"))
  (with-current-buffer (or buffer  (current-buffer)) (describe-mode))
  (with-current-buffer (get-buffer-create "*Help*")
    (save-excursion
      (goto-char (point-min))
      (diredp-dired-plus-help-link)
      (let ((buffer-read-only  nil)) (insert "\n"))
      (when (re-search-forward "Keybindings:\nkey\\s-+binding\n---\\s-+-------" nil t)
        (goto-char (match-beginning 0))
        (let ((buffer-read-only  nil))
          (insert "\f\n")
          (diredp-dired-plus-description+links)
          (insert "\f\n"))))))

;;;###autoload
(defun diredp-dired-plus-help ()
  "Describe Dired+."
  (interactive "@")
  (diredp-with-help-window "*Help*" (diredp-dired-plus-description+links)))

(defun diredp-dired-plus-description+links ()
  "Insert Dired+ help text in `*Help*'."
  (with-current-buffer (get-buffer-create "*Help*")
    (let ((buffer-read-only  nil))
      (save-restriction
        (narrow-to-region (point) (point))
        (diredp-dired-plus-help-link)
        (insert (diredp-dired-plus-description))
        (goto-char (point-max))
        (insert "\n")
        (diredp-dired-plus-help-link)))))

(when (and (> emacs-major-version 21)
           (require 'help-mode nil t)
           (get 'help-xref 'button-category-symbol)) ; `button.el'
  (define-button-type 'diredp-help-button
      :supertype 'help-xref
      'help-function #'(lambda () (browse-url "https://www.emacswiki.org/emacs/DiredPlus"))
      'help-echo
      (purecopy "mouse-2, RET: Dired+ documentation on the Emacs Wiki (requires \
Internet access)")))

(defun diredp-dired-plus-help-link ()
  "Add Web link for Dired+ help, and reminder about sending bug report."
  ;; Don't bother to do this for Emacs 21.3.  Its `help-insert-xref-button' is different.
  (when (and (> emacs-major-version 21)
             (require 'help-mode nil t)
             (fboundp 'help-insert-xref-button)) ; `help-mode.el'.
    (let ((buffer-read-only  nil))
      (help-insert-xref-button "[Dired+ Help on the Web]" 'diredp-help-button)
      (insert (substitute-command-keys
               "\t\tSend a Dired+ bug report:\n\t\t\t\t\t`\\[diredp-send-bug-report]'\n")))))

(defun diredp-dired-plus-description ()
  "Dired+ description."
  (substitute-command-keys
   (concat
    "\\<dired-mode-map>\
              Dired+ Features
              ---------------

To see or customize the  Dired+ options or faces, use
`M-x customize-option diredp TAB' or `M-x customize-face diredp TAB'.

Most keys listed here are in addition to those for vanilla Dired.

Menus
-----

Many Dired+ actions are available from the menu-bar menus and the
`mouse-3' context menu.  This may include commands shown here as not
being bound to keys (i.e., listed as `M-x ...').

General Here
------------

"
    (and (fboundp 'diredp-w32-drives)
         "  \\[diredp-w32-drives]\t\t- Go up to a list of MS Windows drives
")
    (and (fboundp 'dired-hide-details-mode)
         "  \\[dired-hide-details-mode]\t\t- Hide/show details
")

    "  \\[revert-buffer]\t\t- Refresh (sync and show all)
  \\[diredp-toggle-find-file-reuse-dir]\t- Toggle reusing directories
"
    "  \\[diredp-marked-other-window]\t\t- Open Dired on marked files here
  \\[diredp-dired-inserted-subdirs]\t\t- Dired separately each subdir inserted here
"
    (and (featurep 'bookmark+)
         "  \\[diredp-highlight-autofiles-mode]\t- Toggle autofile highlighting

")

    "General Globally
----------------

\\<global-map>\
  \\[diredp-add-to-dired-buffer]\t- Add files to a Dired buffer
  \\[diredp-fileset]\t- Open Dired on files in a fileset
  \\[diredp-dired-recent-files]\t- Open Dired on recently used files and dirs
  \\[diredp-dired-recent-dirs]\t- Open Dired on recently used dirs
  \\[diredp-dired-union]\t- Create union of some Dired buffers
  \\[diredp-dired-for-files]\t- Open Dired on files located anywhere
\\<dired-mode-map>\

Mouse
-----

  \\[diredp-mouse-3-menu]\t- Context-sensitive menu
"

    (and (where-is-internal 'diredp-mouse-describe-file dired-mode-map)
         "  \\[diredp-mouse-describe-file]\t- Describe file
")

    (and (where-is-internal 'diredp-mouse-describe-autofile dired-mode-map)
         "  \\[diredp-mouse-describe-autofile]\t- Describe autofile
")

    "  \\[diredp-mouse-mark-region-files]\t\t- Mark all in region
"

    (and (fboundp 'dired-mouse-w32-browser) ; In `w32-browser.el'.
         (where-is-internal 'dired-mouse-w32-browser dired-mode-map)
         "  \\[dired-mouse-w32-browser]\t\t- MS Windows `Open' action
")
    (and (fboundp 'dired-mouse-w32-browser-reuse-dir-buffer) ; In `w32-browser.el'.
         (where-is-internal 'dired-mouse-w32-browser-reuse-dir-buffer dired-mode-map)
         "  \\[dired-mouse-w32-browser-reuse-dir-buffer]\t- MS Windows `Open' action
")

    (and (where-is-internal 'dired-mouse-find-file dired-mode-map)
         "  \\[dired-mouse-find-file]\t- Open in this window
")
    (and (where-is-internal 'diredp-mouse-find-file-reuse-dir-buffer dired-mode-map)
         "  \\[diredp-mouse-find-file-reuse-dir-buffer]\t- Open in this window
")

    (and (where-is-internal 'dired-mouse-find-file-other-window dired-mode-map)
         "  \\[dired-mouse-find-file-other-window]\t\t- Open in another window
")

    "  \\[diredp-mouse-find-file-other-frame]\t\t- Open in another frame
"

    "
Marking
-------

  \\[diredp-mark]\t\t- Mark this line or those in region or subdir listing
  \t\t  Prefix arg (region/subdir): mark with a given char
  \\[dired-unmark]\t\t- Unmark this line
  \\[dired-toggle-marks]\t\t- Toggle marked/unmarked
  \\[dired-mark-sexp]\t\t- Mark all satisfying a predicate
  \\[dired-unmark-all-marks]\t\t- Unmark all
  \\[diredp-mark/unmark-extension]\t\t- Mark/unmark all that have a given extension
  \\[dired-mark-files-regexp]\t\t- Mark/unmark files with names matching a regexp
  \\[dired-mark-files-containing-regexp]\t\t- Mark/unmark files containing a regexp match
"

    (and (fboundp 'dired-mark-omitted)  ; In `dired-x.el' Emacs 22+.
         "  \\[dired-mark-omitted]\t\t- Mark omitted
")

    "  \\[diredp-mark-files-tagged-regexp]\t\t- Mark those with a tag that matches a regexp
  \\[diredp-unmark-files-tagged-regexp]\t\t- Unmark those with a tag that matches a regexp
  \\[diredp-mark-files-tagged-all]\t\t- Mark those with all of the given tags
  \\[diredp-unmark-files-tagged-all]\t\t- Unmark those with all of the given tags
  \\[diredp-mark-files-tagged-some]\t\t- Mark those with some of the given tags
  \\[diredp-unmark-files-tagged-some]\t\t- Unmark those with some of the given tags
  \\[diredp-mark-files-tagged-not-all]\t- Mark those without some of the given tags
  \\[diredp-unmark-files-tagged-not-all]\t- Unmark those without some of the given tags
  \\[diredp-mark-files-tagged-none]\t- Mark those with none of the given tags
  \\[diredp-unmark-files-tagged-none]\t- Unmark those with none of the given tags
"

    "
Current file/subdir (current line)
----------------------------------

  \\[diredp-describe-file]\t- Describe
  \\[dired-find-file]\t\t- Open
"
    (and (fboundp 'dired-mouse-w32-browser) ; In `w32-browser.el'.
         (where-is-internal 'dired-mouse-w32-browser dired-mode-map)
         "  \\[dired-mouse-w32-browser]\t- MS Windows `Open' action
  \\[dired-w32explore]\t- MS Windows Explorer
")

    "  \\[diredp-byte-compile-this-file]\t\t- Byte-compile
  \\[diredp-compress-this-file]\t\t- Compress/uncompress
  \\[diredp-print-this-file]\t\t- Print
  \\[diredp-relsymlink-this-file]\t\t- Create relative symlink
  \\[diredp-delete-this-file]\t\t- Delete (with confirmation)
  \\[diredp-rename-this-file]\t\t- Rename
  \\[diredp-capitalize-this-file]\t\t- Capitalize (rename)
  \\[diredp-upcase-this-file]\t\t- Rename to uppercase
  \\[diredp-downcase-this-file]\t\t- Rename to lowercase
  \\[diredp-ediff]\t\t- Ediff
  \\[diredp-bookmark-this-file]\t\t- Bookmark
"
    (and (featurep 'bookmark+)
         "  \\[diredp-tag-this-file]\t\t- Add some tags to this file/dir
  \\[diredp-untag-this-file]\t\t- Remove some tags from this file/dir
  \\[diredp-remove-all-tags-this-file]\t\t- Remove all tags from this file/dir
  \\[diredp-copy-tags-this-file]\t\t- Copy the tags from this file/dir
  \\[diredp-paste-add-tags-this-file]\t\t- Paste (add) copied tags to this file/dir
  \\[diredp-paste-replace-tags-this-file]\t\t- Paste (replace) tags for this file/dir
  \\[diredp-set-tag-value-this-file]\t\t- Set a tag value for this file/dir
")

    (and (fboundp 'dired-mouse-w32-browser-reuse-dir-buffer) ; In `w32-browser.el'.
         (where-is-internal 'dired-mouse-w32-browser-reuse-dir-buffer dired-mode-map)
         "  \\[dired-mouse-w32-browser-reuse-dir-buffer]\t- MS Windows `Open' action
  \\[dired-w32explore]\t- MS Windows Explorer
")

    "
Marked (or next prefix arg) files & subdirs here
------------------------------------------------
"
    (and (fboundp 'dired-multiple-w32-browser) ; In `w32-browser.el'.
         "
  \\[dired-multiple-w32-browser]\t- MS Windows `Open' action
")


    "  \\[diredp-marked-other-window]\t\t- Dired marked files and directories
  \\[diredp-list-marked]\t\t- List marked files and directories
  \\[diredp-insert-subdirs]\t\t- Insert marked subdirectories

  \\[dired-copy-filename-as-kill]\t\t- Copy names for pasting
  M-o \\[dired-copy-filename-as-kill]\t\t- Copy absolute names for pasting
  \\[diredp-yank-files]\t\t- Paste files whose absolute names you copied
  \\[dired-do-find-marked-files]\t\t- Visit
  \\[dired-do-print]\t\t- Print
  \\[dired-do-copy]\t\t- Copy
  \\[dired-do-rename]\t\t- Rename/move
  \\[dired-do-touch]\t- Touch (update timestamp)
  \\[dired-do-chmod]\t\t- Change mode

  \\[diredp-do-grep]\t\t- Run `grep'
  \\[dired-do-search]\t\t- Search
"
    (and (fboundp 'dired-do-find-regexp) ; Emacs 25+
         "  \\[dired-do-find-regexp]\t\t- Search using `find'
")

    (if (fboundp 'dired-do-query-replace-regexp) ; Emacs 22+
        "  \\[dired-do-query-replace-regexp]\t\t- Query-replace
"
      "  \\[dired-do-query-replace]\t\t- Query-replace
")

    (and (fboundp 'dired-do-find-regexp-and-replace)
         "  \\[dired-do-find-regexp-and-replace]\t\t- Query-replace using `find'
")

    (and (fboundp 'dired-do-isearch)
         "  \\[dired-do-isearch]\t- Isearch
  \\[dired-do-isearch-regexp]\t- Regexp isearch
")

    "  \\[dired-do-compress]\t\t- Compress
  \\[dired-do-byte-compile]\t\t- Byte-compile
  \\[dired-do-load]\t\t- Load (Emacs Lisp)
"

    (and (fboundp 'dired-do-async-shell-command)
         "  \\[dired-do-async-shell-command]\t\t- Run shell command asynchronously
")

    "  \\[dired-do-shell-command]\t\t- Run shell command

  \\[diredp-do-apply-to-marked]\t\t- Apply Lisp function to file or dir name
  \\[diredp-do-command-in-marked]\t\t- Invoke command or keyboard macro in file or dir
  \\[diredp-do-eval-in-marked]\t\t- Eval Lisp sexp in file or dir

  \\[diredp-omit-marked]\t- Omit
  \\[diredp-omit-unmarked]\t- Omit unmarked
  \\[diredp-do-add-to-recentf]\t\t- Add to recently visited
  \\[diredp-do-remove-from-recentf]\t- Remove from recently visited
"

    (and (featurep 'bookmark+)
         "
  \\[diredp-do-tag]\t\t- Add some tags to marked
  \\[diredp-do-untag]\t\t- Remove some tags from marked
  \\[diredp-do-remove-all-tags]\t\t- Remove all tags from marked
  \\[diredp-do-paste-add-tags]\t- Paste (add) copied tags to marked
  \\[diredp-do-paste-replace-tags]\t\t- Paste (replace) tags for marked
  \\[diredp-do-set-tag-value]\t\t- Set a tag value for marked
  \\[diredp-mark-files-tagged-regexp]\t\t- Mark those with a tag that matches a regexp
  \\[diredp-mark-files-tagged-all]\t\t- Mark those with all of the given tags
  \\[diredp-mark-files-tagged-some]\t\t- Mark those with some of the given tags
  \\[diredp-mark-files-tagged-not-all]\t- Mark those without some of the given tags
  \\[diredp-mark-files-tagged-none]\t- Mark those with none of the given tags
  \\[diredp-unmark-files-tagged-regexp]\t\t- Unmark those with a tag that matches a regexp
  \\[diredp-unmark-files-tagged-all]\t\t- Unmark those with all of the given tags
  \\[diredp-unmark-files-tagged-some]\t\t- Unmark those with some of the given tags
  \\[diredp-unmark-files-tagged-not-all]\t- Unmark those without some of the given tags
  \\[diredp-unmark-files-tagged-none]\t- Unmark those with none of the given tags")

    "

  \\[diredp-do-bookmark]\t\t- Bookmark
"

    (and (featurep 'bookmark+)
         "  \\[diredp-set-bookmark-file-bookmark-for-marked]\t\t- \
Bookmark and create bookmark-file bookmark
  \\[diredp-do-bookmark-in-bookmark-file]\t- Bookmark in specific bookmark file
")

    "
Here and below (in marked subdirs)
----------------------------------
"
    (and (fboundp 'dired-multiple-w32-browser) ; In `w32-browser.el'.
         "
  \\[diredp-multiple-w32-browser-recursive]\t- MS Windows `Open' action
")

    "  \\[diredp-marked-recursive-other-window]\t\t- Dired
  \\[diredp-list-marked-recursive]\t\t- List marked files and directories
  \\[diredp-insert-subdirs-recursive]\t\t- Insert marked subdirectories

  \\[diredp-copy-filename-as-kill-recursive]\t\t- Copy names for pasting
  \\[diredp-do-find-marked-files-recursive]\t\t\t- Visit
  \\[diredp-do-print-recursive]\t\t\t- Print
  \\[diredp-do-copy-recursive]\t\t\t- Copy
  \\[diredp-do-move-recursive]\t\t\t- Move
  \\[diredp-do-touch-recursive]\t\t- Touch (update timestamp)
  \\[diredp-do-chmod-recursive]\t\t\t- Change mode

  \\[diredp-do-symlink-recursive]\t\t\t- Add symbolic links
  \\[diredp-do-relsymlink-recursive]\t\t\t- Add relative symbolic links
  \\[diredp-do-hardlink-recursive]\t\t\t- Add hard links

  \\[diredp-capitalize-recursive]\t\t- Capitalize
  \\[diredp-downcase-recursive]\t\t- Downcase
  \\[diredp-upcase-recursive]\t\t- Upcase
"
  (and (fboundp 'epa-dired-do-encrypt)   ; Emacs 23+
       "
  \\[diredp-do-encrypt-recursive]\t\t- Encrypt
  \\[diredp-do-decrypt-recursive]\t\t- Decrypt
  \\[diredp-do-sign-recursive]\t\t- Sign
  \\[diredp-do-verify-recursive]\t\t- Verify
")

  "
  \\[diredp-do-grep-recursive]\t\t- `grep'
  \\[diredp-do-search-recursive]\t\t\t- Search
  \\[diredp-do-query-replace-regexp-recursive]\t\t\t- Query-replace
  \\[diredp-do-isearch-recursive]\t\t- Isearch
  \\[diredp-do-isearch-regexp-recursive]\t- Regexp isearch
"
    (and (fboundp 'diredp-do-async-shell-command-recursive) ; Emacs 23+
         "
  \\[diredp-do-async-shell-command-recursive]\t\t\t- Run shell command asynchronously
")

    "  \\[diredp-do-shell-command-recursive]\t\t\t- Run shell command

  \\[diredp-do-apply-to-marked-recursive]\t\t\t- Apply Lisp function to file or dir name
  \\[diredp-do-command-in-marked-recursive]\t\t- Invoke command or keyboard macro in file/dir
  \\[diredp-do-eval-in-marked-recursive]\t\t\t- Eval Lisp sexp in file or dir

  \\[diredp-image-dired-comment-files-recursive]\t\t- Add image comment
  \\[diredp-image-dired-display-thumbs-recursive]\t\t- Show thumbnail images
  \\[diredp-image-dired-tag-files-recursive]\t\t- Tag images
  \\[diredp-image-dired-delete-tag-recursive]\t\t- Delete image tags

  \\[diredp-do-bookmark-recursive]\t\t- Bookmark
"
    (and (featurep 'bookmark+)
         "  \\[diredp-do-bookmark-in-bookmark-file-recursive]\t\t- Bookmark in bookmark file
  \\[diredp-set-bookmark-file-bookmark-for-marked-recursive]\t\t- Create bookmark-file bookmark
")

    "
  \\[diredp-mark-directories-recursive]\t\t- Mark directories
  \\[diredp-mark-executables-recursive]\t\t- Mark executables
  \\[diredp-mark-symlinks-recursive]\t\t- Mark symbolic links
  \\[diredp-mark-files-containing-regexp-recursive]\t\t- Mark content regexp matches
  \\[diredp-mark-files-regexp-recursive]\t\t- Mark filename regexp matches
"
    (and (featurep 'bookmark+)
         "  \\[diredp-mark-autofiles-recursive]\t\t- Mark autofiles
")
    "  \\[diredp-flag-auto-save-files-recursive]\t\t\t- Flag auto-save
  \\[diredp-do-delete-recursive]\t\t\t- Delete marked (not flagged)
  \\[diredp-change-marks-recursive]\t\t- Change marks
  \\[diredp-unmark-all-files-recursive]\t\t- Remove a given mark
  \\[diredp-unmark-all-marks-recursive]\t\t\t- Remove all marks
"
    (and (featurep 'bookmark+)
"

Tagging
-------

  \\[diredp-tag-this-file]\t\t- Add some tags to this file/dir
  \\[diredp-untag-this-file]\t\t- Remove some tags from this file/dir
  \\[diredp-remove-all-tags-this-file]\t\t- Remove all tags from this file/dir
  \\[diredp-copy-tags-this-file]\t\t- Copy the tags from this file/dir
  \\[diredp-paste-add-tags-this-file]\t\t- Paste (add) copied tags to this file/dir
  \\[diredp-paste-replace-tags-this-file]\t\t- Paste (replace) tags for this file/dir
  \\[diredp-set-tag-value-this-file]\t\t- Set a tag value for this file/dir
  \\[diredp-do-tag]\t\t- Add some tags to marked
  \\[diredp-do-untag]\t\t- Remove some tags from marked
  \\[diredp-do-remove-all-tags]\t\t- Remove all tags from marked
  \\[diredp-do-paste-add-tags]\t- Paste (add) copied tags to marked
  \\[diredp-do-paste-replace-tags]\t\t- Paste (replace) tags for marked
  \\[diredp-do-set-tag-value]\t\t- Set a tag value for marked
  \\[diredp-mark-files-tagged-regexp]\t\t- Mark those with a tag that matches a regexp
  \\[diredp-mark-files-tagged-all]\t\t- Mark those with all of the given tags
  \\[diredp-mark-files-tagged-some]\t\t- Mark those with some of the given tags
  \\[diredp-mark-files-tagged-not-all]\t- Mark those without some of the given tags
  \\[diredp-mark-files-tagged-none]\t- Mark those with none of the given tags
  \\[diredp-unmark-files-tagged-regexp]\t\t- Unmark those with a tag that matches a regexp
  \\[diredp-unmark-files-tagged-all]\t\t- Unmark those with all of the given tags
  \\[diredp-unmark-files-tagged-some]\t\t- Unmark those with some of the given tags
  \\[diredp-unmark-files-tagged-not-all]\t- Unmark those without some of the given tags
  \\[diredp-unmark-files-tagged-none]\t- Unmark those with none of the given tags
")

    "
Bookmarking
-----------

  \\[diredp-bookmark-this-file]\t\t- Bookmark this file/dir
  \\[diredp-do-bookmark]\t\t- Bookmark marked"

    (and (featurep 'bookmark+)
         "
  \\[diredp-set-bookmark-file-bookmark-for-marked]\t\t- \
Bookmark marked and create bookmark-file bookmark
  \\[diredp-do-bookmark-in-bookmark-file]\t- Bookmark marked, in specific bookmark file
")

    "  \\[diredp-do-bookmark-recursive]\t- Bookmark marked, here and below
"
    (and (featurep 'bookmark+)
         "  \\[diredp-do-bookmark-in-bookmark-file-recursive]\t- \
Bookmark marked, here and below, in specific file
  \\[diredp-set-bookmark-file-bookmark-for-marked-recursive]\t- \
Set bookmark-file bookmark for marked here and below
")

    )))

(when (> emacs-major-version 21)
  (defun diredp-nb-marked-in-mode-name ()
    "Show number of marked, flagged, and current-list lines in mode-line.
\(Flagged means flagged for deletion.)
If the current line is marked/flagged and there are others
marked/flagged after it then show `N/M', where `N' is the number
marked/flagged through the current line and `M' is the total number
marked/flagged.

If the current line is for a file then show `L/T', where `L' is the
line number in the current listing and `T' is the number of files in
that listing.  If option `diredp-count-.-and-..-flag' is non-nil then
count also `.' and `..'.

Also abbreviate `mode-name', using \"Dired/\" instead of \"Dired by\"."
    (let ((mname  (format-mode-line mode-name)))
      ;; Property `dired+-mode-name' indicates whether `mode-name' has been changed.
      (unless (get-text-property 0 'dired+-mode-name mname)
        (save-match-data
          (setq mode-name
                `(,(propertize (if (string-match "^[dD]ired \\(by \\)?\\(.*\\)" mname)
                                   (format "Dired/%s" (match-string 2 mname))
                                 mname)
                               'dired+-mode-name t)
                  (:eval (let* ((dired-marker-char  (if (eq ?D dired-marker-char)
                                                        ?* ; `dired-do-flagged-delete' binds it.
                                                      dired-marker-char))
                                (marked-regexp      (dired-marker-regexp))
                                (nb-marked          (count-matches marked-regexp
                                                                   (point-min) (point-max))))
                           (if (not (> nb-marked 0))
                               ""
                             (propertize
                              (format " %s%d%c"
                                      (save-excursion
                                        (forward-line 0)
                                        (if (diredp-looking-at-p (concat marked-regexp ".*"))
                                            (format "%d/" (1+ (count-matches
                                                               marked-regexp
                                                               (point-min) (point))))
                                          ""))
                                      nb-marked dired-marker-char)
                              'face 'diredp-mode-line-marked 'dired+-mode-name t))))
                  (:eval (let* ((flagged-regexp  (let ((dired-marker-char  dired-del-marker))
                                                   (dired-marker-regexp)))
                                (nb-flagged      (count-matches flagged-regexp
                                                                (point-min) (point-max))))
                           (if (not (> nb-flagged 0))
                               ""
                             (propertize
                              (format " %s%dD"
                                      (save-excursion
                                        (forward-line 0)
                                        (if (diredp-looking-at-p (concat flagged-regexp ".*"))
                                            (format "%d/" (1+ (count-matches
                                                               flagged-regexp
                                                               (point-min) (point))))
                                          ""))
                                      nb-flagged)
                              'face 'diredp-mode-line-flagged))))
                  (:eval (save-excursion
                           (let ((this   0)
                                 (total  0)
                                 (o-pt   (line-beginning-position))
                                 (e-pt   (or (condition-case nil
                                                 (let ((diredp-wrap-around-flag  nil))
                                                   (save-excursion
                                                     (diredp-next-subdir 1)
                                                     (line-beginning-position)))
                                               (error nil))
                                             (save-excursion (goto-char (point-max)) (line-beginning-position)))))
                             (when dired-subdir-alist (dired-goto-subdir (dired-current-directory)))
                             (while (and (<= (point) e-pt)
                                         (< (point) (point-max))) ; Hack to work around Emacs display-engine bug.
                               (when (condition-case nil
                                         (dired-get-filename nil diredp-count-.-and-..-flag)
                                       (error nil))
                                 (when (<= (line-beginning-position) o-pt) (setq this  (1+ this)))
                                 (setq total  (1+ total)))
                               (forward-line 1))
                             (if (not (> this 0)) (format " %d" total) (format " %d/%d" this total)))))))))))

  (add-hook 'dired-after-readin-hook 'diredp-nb-marked-in-mode-name)
  ;; This one is needed for `find-dired', because it does not call `dired-readin'.
  (add-hook 'dired-mode-hook         'diredp-nb-marked-in-mode-name))

;;;###autoload
(defun diredp-send-bug-report ()
  "Send a bug report about a Dired+ problem."
  (interactive)
  (browse-url (format (concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
Dired+ bug: \
&body=Describe bug below, using a precise recipe that starts with `emacs -Q' or `emacs -q'.  \
File `dired+.el' has a header `Update #' that you can use to identify it.\
%%0A%%0AEmacs version: %s.")
                      (emacs-version))))

(defun diredp-visit-ignore-regexp ()    ; Taken from `image-file-name-regexp'.
  "Return a regular expression matching file names to skip.
This is used by `dired-visit-(next|previous)'."
  (let ((exts-regexp  (and diredp-visit-ignore-extensions
                           (concat "\\." (regexp-opt (nconc (mapcar #'upcase diredp-visit-ignore-extensions)
                                                            diredp-visit-ignore-extensions)
                                                     t)
                                   "\\'"))))
    (if diredp-visit-ignore-regexps
        (mapconcat #'identity (if exts-regexp
                                  (cons exts-regexp diredp-visit-ignore-regexps)
                                diredp-visit-ignore-regexps)
                   "\\|")
      exts-regexp)))

;;;###autoload
(defun diredp-visit-next-file (&optional arg) ; Bound to `C-down'
  "Move down a line and visit its file in another window.
With numeric prefix arg N, move down N-1 lines first.

After moving N lines, skip any lines with file names that match either
`diredp-visit-ignore-extensions' or `diredp-visit-ignore-regexps'.

Kill the last buffer visited by a `dired-visit-*' command."
  (interactive "p")
  (dired-next-line arg)
  (while (diredp-string-match-p (diredp-visit-ignore-regexp) (dired-get-file-for-visit))
    (dired-next-line 1))
  (diredp-visit-this-file))

;;;###autoload
(defun diredp-visit-previous-file (&optional arg) ; Bound to `C-up'
  "Move up a line and visit its file in another window.
With numeric prefix arg N, move up N-1 lines first.

After moving N lines, skip any lines with file names that match either
`diredp-visit-ignore-extensions' or `diredp-visit-ignore-regexps'.

Kill the last buffer visited by a `dired-visit-*' command."
  (interactive "p")
  (dired-previous-line arg)
  (while (diredp-string-match-p (diredp-visit-ignore-regexp) (dired-get-file-for-visit))
    (dired-previous-line 1))
  (diredp-visit-this-file))

;;;###autoload
(defun diredp-visit-this-file ()        ; Bound to `e' (replaces `dired-find-file' binding)
  "View the file on this line in another window in the same frame.
If it was not already shown there then kill the previous buffer
visited by a `dired-visit-*' command.

If it was already shown there, and if it and Dired are the only
windows there, then delete its window (toggle : show/hide the file)."
  (interactive)
  (let ((file   (dired-get-file-for-visit))
        (obuf   (current-buffer))
        (shown  nil)
        fwin)
    (unless (or (and (fboundp 'window-parent)  (window-parent))
                (not (one-window-p 'NOMINI)))
      (split-window))
    (save-selected-window
      (other-window 1)
      (setq fwin  (selected-window))
      (unless (or (setq shown  (or (equal (current-buffer) (get-file-buffer file))
                                   (memq (current-buffer) (dired-buffers-for-dir file))))
                  (equal obuf (current-buffer)))
        (kill-buffer (current-buffer))))
    (if shown
        (when (= 2 (count-windows 'NOMINI)) (delete-window fwin))
      (set-window-buffer fwin (find-file-noselect file)))))

;;; Key Bindings.


;; Menu Bar.
;; New order is (left -> right):
;;
;;     Dir  Regexp  Mark  Multiple  Single

;; Get rid of menu bar predefined in `dired.el'.
(define-key dired-mode-map [menu-bar] nil)
;; Get rid of Edit menu bar menu to save space.
(define-key dired-mode-map [menu-bar edit] 'undefined)


;; `Single' menu.
;;
;; REPLACE ORIGINAL `Immediate' menu in `dired.el'.
;;
(defvar diredp-menu-bar-single-menu (make-sparse-keymap "Single"))
(define-key dired-mode-map [menu-bar immediate] (cons "Single" diredp-menu-bar-single-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-immediate-menu 'diredp-menu-bar-single-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-immediate-menu 'diredp-menu-bar-single-menu "2017-04-09")

(if (fboundp 'diredp-describe-file)
    (define-key diredp-menu-bar-single-menu [diredp-describe-file]
      '(menu-item "Describe" diredp-describe-file
        :help "Describe the file or directory at cursor"))
  (define-key diredp-menu-bar-single-menu [diredp-describe-autofile]
    '(menu-item "Describe" diredp-describe-autofile
      :help "Describe the autofile at cursor"
      :enable (featurep 'bookmark+))))
(define-key diredp-menu-bar-single-menu [separator-describe] '("--")) ; ---------------------

(when (fboundp 'diredp-chown-this-file)
  (define-key diredp-menu-bar-single-menu [chown]
    '(menu-item "Change Owner..." diredp-chown-this-file
      :help "Change the owner of file at cursor")))
(when (fboundp 'diredp-chgrp-this-file)
  (define-key diredp-menu-bar-single-menu [chgrp]
    '(menu-item "Change Group..." diredp-chgrp-this-file
      :help "Change the group of file at cursor")))
(define-key diredp-menu-bar-single-menu [chmod]
  '(menu-item "Change Mode..." diredp-chmod-this-file
    :help "Change mode (attributes) of file at cursor"))
(when (fboundp 'dired-do-touch)         ; Emacs 22+
  (define-key diredp-menu-bar-single-menu [touch]
    '(menu-item "Change Timestamp (`touch')..." diredp-touch-this-file
      :help "Change the timestamp of file at cursor, using `touch'")))
(define-key diredp-menu-bar-single-menu [separator-change] '("--")) ; -----------------------

(define-key diredp-menu-bar-single-menu [print]
  '(menu-item "Print..." diredp-print-this-file
    :help "Print file at cursor, supplying print command"))
(define-key diredp-menu-bar-single-menu [grep]
  '(menu-item "Grep..." diredp-grep-this-file :help "Grep file at cursor"))
(define-key diredp-menu-bar-single-menu [compress]
  '(menu-item "Compress/Uncompress" diredp-compress-this-file
    :help "Compress/uncompress file at cursor"))
(define-key diredp-menu-bar-single-menu [command]
  '(menu-item "Shell Command..." diredp-shell-command-this-file
    :help "Run a shell command on file at cursor"))
(define-key diredp-menu-bar-single-menu [diredp-async-shell-command-this-file]
  '(menu-item "Asynchronous Shell Command..." diredp-async-shell-command-this-file
    :help "Run a shell command asynchronously on file at cursor"))
(define-key diredp-menu-bar-single-menu [compile]
  '(menu-item "Byte Compile" diredp-byte-compile-this-file
    :help "Byte-compile this Emacs Lisp file"))
(define-key diredp-menu-bar-single-menu [load]
  '(menu-item "Load" diredp-load-this-file
    :help "Load this Emacs Lisp file"))

(when (fboundp 'mkhtml-dired-files)     ; In `mkhtml.el'.
  (define-key diredp-menu-bar-single-menu [mkhtml-dired-files]
    '(menu-item "Create HTML" mkhtml-dired-files
      :help "Create an HTML file corresponding to file at cursor")))
(define-key diredp-menu-bar-single-menu [separator-misc] '("--")) ; -------------------------

(define-key diredp-menu-bar-single-menu [delete]
  '(menu-item "Delete" diredp-delete-this-file :help "Delete file at cursor"))
(define-key diredp-menu-bar-single-menu [separator-delete] '("--")) ; -----------------------

(define-key diredp-menu-bar-single-menu [backup-diff]
  '(menu-item "Diff with Backup" dired-backup-diff
    :help "Diff file at cursor with its latest backup"))
(define-key diredp-menu-bar-single-menu [diff]
  '(menu-item "Diff..." dired-diff
    :help "Compare file at cursor with another file using `diff'"))
(define-key diredp-menu-bar-single-menu [ediff]
  '(menu-item "Compare..." diredp-ediff :help "Compare file at cursor with another file"))
(define-key diredp-menu-bar-single-menu [separator-diff] '("--")) ; -------------------------

(define-key diredp-menu-bar-single-menu [diredp-kill-this-tree]
  '(menu-item "Remove This Inserted Subdir and Lower" diredp-kill-this-tree
    :visible (and (fboundp 'diredp-kill-this-tree)
              (not (equal
                    (expand-file-name (dired-current-directory))
                    (expand-file-name default-directory)))))) ; In subdir, not top.
(define-key diredp-menu-bar-single-menu [dired-kill-subdir]
  '(menu-item "Remove This Inserted Subdir" dired-kill-subdir
    :visible (not (equal (expand-file-name (dired-current-directory))
                         (expand-file-name default-directory))))) ; In subdir, not top.
(define-key diredp-menu-bar-single-menu [diredp-dired-this-subdir]
  '(menu-item "Dired This Inserted Subdir (Tear Off)"
    (lambda () (interactive) (diredp-dired-this-subdir t))
    :visible (and (cdr dired-subdir-alist) ; First is current dir.  Must have at least one more.
              (not (equal (expand-file-name (dired-current-directory))
                          (expand-file-name default-directory)))) ; Must be sub, not top.
    :help "Open Dired for subdir at or above point, tearing it off if inserted"))
(define-key diredp-menu-bar-single-menu [insert-subdir]
  '(menu-item "Insert This Subdir" dired-maybe-insert-subdir
    :visible (and (atom (diredp-this-subdir))
              (not (assoc (file-name-as-directory (diredp-this-subdir)) dired-subdir-alist)))
    :enable (atom (diredp-this-subdir))
    :help "Insert a listing of this subdirectory"))
(define-key diredp-menu-bar-single-menu [goto-subdir]
  '(menu-item "Go To Inserted Subdir" dired-maybe-insert-subdir
    :visible (and (atom (diredp-this-subdir))
              (assoc (file-name-as-directory (diredp-this-subdir)) dired-subdir-alist))
    :enable (atom (diredp-this-subdir))
    :help "Go to the inserted listing of this subdirectory"))
(define-key diredp-menu-bar-single-menu [separator-subdir] '("--" ; ------------------------
            :visible (or (atom (diredp-this-subdir)) ; Subdir line.
                         (not (equal (expand-file-name (dired-current-directory))
                                     (expand-file-name default-directory)))))) ; Not top.

(define-key diredp-menu-bar-single-menu [view]
  '(menu-item "View (Read Only)" dired-view-file
    :help "Examine file at cursor in read-only mode"))
(define-key diredp-menu-bar-single-menu [display]
  '(menu-item "Display in Other Window" dired-display-file
    :help "Display file at cursor in a different window"))


;; `Single' > `Open' menu.
;;
(defvar diredp-single-open-menu (make-sparse-keymap "Rename")
  "`Open' submenu for Dired menu-bar `Single' menu.")
(define-key diredp-menu-bar-single-menu [multiple-open] (cons "Open" diredp-single-open-menu))

;; On Windows, bind more.
(eval-after-load "w32-browser"
  '(progn
    (define-key diredp-single-open-menu [dired-w32-browser]
      '(menu-item "Open Associated Windows App" dired-w32-browser
        :help "Open file using the Windows app associated with its file type"))
    (define-key diredp-single-open-menu [dired-w32explore]
      '(menu-item "Open in Windows Explorer" dired-w32explore
        :help "Open file in Windows Explorer"))))
(define-key diredp-single-open-menu [find-file-other-frame]
  '(menu-item "Open in Other Frame" diredp-find-file-other-frame
    :help "Edit file at cursor in a different frame"))
(define-key diredp-single-open-menu [find-file-other-window]
  '(menu-item "Open in Other Window" dired-find-file-other-window
    :help "Edit file at cursor in a different window"))
(define-key diredp-single-open-menu [find-file]
  '(menu-item "Open" dired-find-file :help "Edit file at cursor"))


;; `Single' > `Rename' menu.
;;
(defvar diredp-single-rename-menu (make-sparse-keymap "Rename")
  "`Rename' submenu for Dired menu-bar `Single' menu.")
(define-key diredp-menu-bar-single-menu [multiple-case] (cons "Rename" diredp-single-rename-menu))

(define-key diredp-single-rename-menu [single-rename-capitalize]
  '(menu-item "Capitalize" diredp-capitalize-this-file
    :help "Capitalize (initial caps) name of file at cursor"))
(define-key diredp-single-rename-menu [single-rename-downcase]
  '(menu-item "Downcase" diredp-downcase-this-file
    ;; When running on plain MS-DOS, there is only one letter-case for file names.
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename file at cursor to a lower-case name"))
(define-key diredp-single-rename-menu [single-rename-upcase]
  '(menu-item "Upcase" diredp-upcase-this-file
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename file at cursor to an upper-case name"))


;; `Single' > `Move / Copy / Link' menu.
;;
(defvar diredp-single-move-copy-link-menu (make-sparse-keymap "Move / Copy / Link")
  "`Move / Copy / Link' submenu for Dired menu-bar `Single' menu.")
(define-key diredp-menu-bar-single-menu [multiple-move-copy-link]
  (cons "Move / Copy / Link" diredp-single-move-copy-link-menu))

(define-key diredp-single-move-copy-link-menu [single-hardlink]
  '(menu-item "Hardlink to..." diredp-hardlink-this-file
    :help "Make hard links for current or marked files"))
(define-key diredp-single-move-copy-link-menu [single-symlink]
  '(menu-item "Symlink to (Absolute)..." diredp-symlink-this-file
              :help "Make absolute symbolic link for file at cursor"))
(define-key diredp-single-move-copy-link-menu [single-relsymlink]
  '(menu-item "Symlink to (Relative)..." diredp-relsymlink-this-file
              :help "Make relative symbolic link for file at cursor"))
(define-key diredp-single-move-copy-link-menu [single-copy]
  '(menu-item "Copy to..." diredp-copy-this-file :help "Copy file at cursor"))
(define-key diredp-single-move-copy-link-menu [single-rename]
  '(menu-item "Move to..." diredp-rename-this-file
    :help "Rename file at cursor, or move it to a different directory"))


;; `Single' > `Image' menu.
;;
(defvar diredp-single-image-menu (make-sparse-keymap "Image"))
(defalias 'diredp-single-image-menu diredp-single-image-menu)
(define-key diredp-menu-bar-single-menu [image]
  '(menu-item "Image" diredp-single-image-menu
    :enable (let ((img-file  (diredp-get-image-filename 'LOCALP 'NO-ERROR)))
              (and (fboundp 'image-dired-dired-display-image)  img-file))))

(define-key diredp-single-image-menu [diredp-image-dired-display-thumb]
  '(menu-item "Go To Thumbnail" diredp-image-dired-display-thumb
    :help "Pop to buffer showing the thumbnail of this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-create-thumb]
  '(menu-item "Create Thumbnail" diredp-image-dired-create-thumb
    :help "Create a thumbnail image for this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-edit-comment-and-tags]
  '(menu-item "Edit Comment and Tags..." diredp-image-dired-edit-comment-and-tags
    :help "Edit comment and tags for this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-delete-tag]
  '(menu-item "Delete Image Tag..." diredp-image-dired-delete-tag
    :help "Remove an `image-dired' tag from this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-tag-file]
  '(menu-item "Add Tags..." diredp-image-dired-tag-file
    :help "Add tags to this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-comment-file]
  '(menu-item "Add Comment..." diredp-image-dired-comment-file
    :help "Add a comment to this image file"))
(define-key diredp-single-image-menu [diredp-image-dired-copy-with-exif-name]
  '(menu-item "Copy with EXIF Name" diredp-image-dired-copy-with-exif-name
    :help "Copy this image file to main image dir using EXIF name"))
(define-key diredp-single-image-menu [image-dired-dired-display-external]
  '(menu-item "Display Externally" image-dired-dired-display-external
    :help "Display image using external viewer"))
(define-key diredp-single-image-menu [image-dired-dired-display-image]
  '(menu-item "Display to Fit Other Window" image-dired-dired-display-image
    :help "Display scaled image to fit a separate window"))
(define-key diredp-single-image-menu [diredp-image-show-this-file]
  '(menu-item "Display Full Size Or Smaller" diredp-image-show-this-file
    :help "Display image full size or at least prefix-arg lines high"))
(define-key diredp-single-image-menu [dired-find-file]
  '(menu-item "Display Full Size" dired-find-file
    :help "Display image full size"))


;; `Single' > `Encryption' menu.
;;
(when (fboundp 'epa-dired-do-encrypt)   ; Emacs 23+
  (defvar diredp-single-encryption-menu (make-sparse-keymap "Encryption"))
  (define-key diredp-menu-bar-single-menu [encryption]
    (cons "Encryption" diredp-single-encryption-menu))

  (define-key diredp-single-encryption-menu [diredp-decrypt-this-file]
    '(menu-item "Decrypt..." (lambda ()
                               (interactive)
                               (epa-decrypt-file (expand-file-name (dired-get-filename nil 'NO-ERROR))))
      :help "Decrypt this file"))
  (define-key diredp-single-encryption-menu [diredp-verify-this-file]
    '(menu-item "Verify..." (lambda ()
                              (interactive)
                              (epa-verify-file (expand-file-name (dired-get-filename nil 'NO-ERROR))))
      :help "Verify this file"))
  (define-key diredp-single-encryption-menu [diredp-sign-this-file]
    '(menu-item "Sign..." (lambda ()
                            (interactive)
                            (epa-sign-file (expand-file-name (dired-get-filename nil 'NO-ERROR))
                                           (epa-select-keys (epg-make-context)
                                                            "Select keys for signing.
If no one is selected, default secret key is used.  "
                                                            nil
                                                            t)))
      :help "Encrypt this file"))
  (define-key diredp-single-encryption-menu [diredp-encrypt-this-file]
    '(menu-item "Encrypt..." (lambda ()
                               (interactive)
                               (epa-encrypt-file (expand-file-name (dired-get-filename nil 'NO-ERROR))
                                                 (epa-select-keys
                                                  (epg-make-context)
                                                  "Select recipients for encryption.
If no one is selected, symmetric encryption will be performed.  "
                                                  nil t)))
      :help "Sign this file")))


;; `Single' > `Bookmark' menu.
;;
(when (require 'bookmark+ nil t)
  (defvar diredp-single-bookmarks-menu (make-sparse-keymap "Bookmark"))
  (define-key diredp-menu-bar-single-menu [bookmark]
    (cons "Bookmark" diredp-single-bookmarks-menu))

  (define-key diredp-single-bookmarks-menu [diredp-set-tag-value-this-file]
    '(menu-item "Set Tag Value..." diredp-set-tag-value-this-file
      :help "Set the value (not the name) of a given tag for this file"))
  (define-key diredp-single-bookmarks-menu [diredp-paste-replace-tags-this-file]
    '(menu-item "Paste Tags (Replace)" diredp-paste-replace-tags-this-file
      :help "Replace tags for this file with previously copied tags"))
  (define-key diredp-single-bookmarks-menu [diredp-paste-add-tags-this-file]
    '(menu-item "Paste Tags (Add)" diredp-paste-add-tags-this-file
      :help "Add previously copied tags to this file"))
  (define-key diredp-single-bookmarks-menu [diredp-copy-tags-this-file]
    '(menu-item "Copy Tags" diredp-copy-tags-this-file
      :help "Copy the tags from this file, so you can paste them to another"))
  (define-key diredp-single-bookmarks-menu [diredp-remove-all-tags-this-file]
    '(menu-item "Remove All Tags" diredp-remove-all-tags-this-file
      :help "Remove all tags from the file at cursor"))
  (define-key diredp-single-bookmarks-menu [diredp-untag-this-file]
    '(menu-item "Remove Tags..." diredp-untag-this-file
      :help "Remove some tags from the file at cursor (`C-u': remove all tags)"))
  (define-key diredp-single-bookmarks-menu [diredp-tag-this-file]
    '(menu-item "Add Tags..." diredp-tag-this-file :help "Add some tags to the file at cursor"))
  (define-key diredp-single-bookmarks-menu [diredp-bookmark-this-file]
    '(menu-item "Bookmark..." diredp-bookmark-this-file
      :help "Bookmark the file at cursor (create/set autofile)")))


;; `Multiple' menu.
;;
;; REPLACE ORIGINAL "Operate" menu in `dired.el'.
;;
(defvar diredp-menu-bar-multiple-menu (make-sparse-keymap "Multiple"))
(define-key dired-mode-map [menu-bar operate] (cons "Multiple" diredp-menu-bar-multiple-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-operate-menu 'diredp-menu-bar-multiple-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-operate-menu 'diredp-menu-bar-multiple-menu "2017-04-09")

(define-key diredp-menu-bar-multiple-menu [diredp-describe-marked-autofiles]
  '(menu-item "Describe Marked Autofiles" diredp-describe-marked-autofiles
    :help "Show the metadata for the marked files that are autofiles"
    :enable (featurep 'bookmark+)))
(define-key diredp-menu-bar-multiple-menu [separator-describe] '("--")) ; -----------------------

(unless (memq system-type '(windows-nt ms-dos))
  (define-key diredp-menu-bar-multiple-menu [chown]
    '(menu-item "Change Owner..." dired-do-chown
      :help "Change the owner of marked files")))
(unless (memq system-type '(windows-nt ms-dos))
  (define-key diredp-menu-bar-multiple-menu [chgrp]
    '(menu-item "Change Group..." dired-do-chgrp
      :help "Change the owner of marked files")))
(define-key diredp-menu-bar-multiple-menu [chmod]
  '(menu-item "Change Mode..." dired-do-chmod
    :help "Change mode (attributes) of marked files"))
(when (fboundp 'dired-do-touch)         ; Emacs 22+
  (define-key diredp-menu-bar-multiple-menu [touch]
    '(menu-item "Change Timestamp (`touch')..." dired-do-touch
      :help "Change the timestamp of the marked files, using `touch'")))
(define-key diredp-menu-bar-multiple-menu [separator-change] '("--")) ; -------------------------

(define-key diredp-menu-bar-multiple-menu [diredp-do-remove-from-recentf]
    '(menu-item "Remove Marked Files From Recent Visits" diredp-do-remove-from-recentf
      :help "Remove the files marked here from the list of recently visited files"
      :enable (featurep 'recentf)))
(define-key diredp-menu-bar-multiple-menu [diredp-do-add-to-recentf]
    '(menu-item "Add Marked Files To Recent Visits" diredp-do-add-to-recentf
      :help "Add the files marked here to the list of recently visited files"
      :enable (featurep 'recentf)))
(define-key diredp-menu-bar-multiple-menu [diredp-do-eval-in-marked]
  '(menu-item "Eval Sexp In..." diredp-do-eval-in-marked
              :help "Evaluate a Lisp sexp in each marked file"))
;;; (define-key diredp-menu-bar-multiple-menu [diredp-do-invoke-in-marked]
;;;   '(menu-item "Invoke Function In..." diredp-do-invoke-in-marked
;;;               :help "Invoke a Lisp function in each marked file"))
(define-key diredp-menu-bar-multiple-menu [diredp-do-apply-to-marked]
  '(menu-item "Apply Function To..." diredp-do-apply-to-marked
              :help "Apply a Lisp function to each marked file name"))
(define-key diredp-menu-bar-multiple-menu [diredp-do-command-in-marked]
    '(menu-item "Invoke Command/Macro In..." diredp-do-command-in-marked
      :help "Invoke an Emacs command or keyboard macro in each marked file"))
(define-key diredp-menu-bar-multiple-menu [print]
  '(menu-item "Print..." dired-do-print :help "Print marked files, supplying print command"))
(define-key diredp-menu-bar-multiple-menu [compress]
  '(menu-item "Compress/Uncompress" dired-do-compress :help "Compress/uncompress marked files"))
(when (fboundp 'dired-do-compress-to)
  (define-key diredp-menu-bar-multiple-menu [compress-to]
    '(menu-item "Compress to..." dired-do-compress-to
      :help "Compress marked files and dirs together, in the same archive")))
(define-key diredp-menu-bar-multiple-menu [command]
  '(menu-item "Shell Command..." dired-do-shell-command
    :help "Run a shell command on each marked file"))
(when (fboundp 'dired-do-async-shell-command) ; Emacs 23+
  (define-key diredp-menu-bar-multiple-menu [async-command]
    '(menu-item "Asynchronous Shell Command..." dired-do-async-shell-command
      :help "Run a shell command asynchronously on each marked file")))
(define-key diredp-menu-bar-multiple-menu [compile]
  '(menu-item "Byte Compile" dired-do-byte-compile :help "Byte-compile marked Emacs Lisp files"))
(define-key diredp-menu-bar-multiple-menu [load]
  '(menu-item "Load" dired-do-load :help "Load marked Emacs Lisp files"))

(unless (require 'bookmark+ nil t)
  (define-key diredp-menu-bar-multiple-menu [diredp-bookmark-this-file]
    '(menu-item "Bookmark..." diredp-bookmark-this-file :help "Bookmark the file at cursor")))
(when (fboundp 'mkhtml-dired-files)     ; In `mkhtml.el'.
  (define-key diredp-menu-bar-multiple-menu [mkhtml-dired-files]
    '(menu-item "Create HTML" mkhtml-dired-files
      :help "Create HTML files corresponding to marked files")))
(define-key diredp-menu-bar-multiple-menu [separator-misc] '("--")) ; ---------------------------

(define-key diredp-menu-bar-multiple-menu [diredp-copy-abs-filenames-as-kill]
  '(menu-item "Copy Marked Names as Absolute" diredp-copy-abs-filenames-as-kill
    :help "Copy absolute names of marked files to the kill ring"
    :keys "M-0 w"))
(define-key diredp-menu-bar-multiple-menu [kill-ring]
  '(menu-item "Copy Marked Names" dired-copy-filename-as-kill
    :help "Copy names of marked files to the kill ring, for pasting"))
(define-key diredp-menu-bar-multiple-menu [diredp-list-marked]
    '(menu-item "List Marked Files" diredp-list-marked
      :help "List the files marked here (C-u C-u: all, C-u C-u C-u: all + dirs)"))
(define-key diredp-menu-bar-multiple-menu [diredp-insert-subdirs]
  '(menu-item "Insert Subdirs" diredp-insert-subdirs
    :help "Insert the marked subdirectories - like using `i' at each marked dir"))
;; On Windows, bind more.
(eval-after-load "w32-browser"
  '(define-key diredp-menu-bar-multiple-menu [dired-multiple-w32-browser]
      '(menu-item "Open Associated Windows Apps" dired-multiple-w32-browser
        :help "Open files using the Windows apps associated with their file types")))
(when (fboundp 'dired-do-find-marked-files)
  (define-key diredp-menu-bar-multiple-menu [find-files]
    '(menu-item "Open" dired-do-find-marked-files ; In `dired-x.el'.
      :help "Open each marked file for editing")))


;; `Multiple' > `Apply (Map)' menu.
;;
(defvar diredp-apply-multiple-menu (make-sparse-keymap "Apply (Map)"))
(defalias 'diredp-apply-multiple-menu diredp-apply-multiple-menu)
(define-key diredp-menu-bar-multiple-menu [apply]
  (cons "Apply (Map)" diredp-apply-multiple-menu))

(define-key diredp-apply-multiple-menu [diredp-do-eval-in-marked]
  '(menu-item "Eval Sexp In..." diredp-do-eval-in-marked
              :help "Evaluate a Lisp sexp in each marked file or dir"))
(define-key diredp-apply-multiple-menu [diredp-do-command-in-marked]
  '(menu-item "Invoke Command/Macro In..." diredp-do-command-in-marked
              :help "Invoke Emacs command or keyboard macro in each marked file or dir"))
;;; (define-key diredp-apply-multiple-menu [diredp-do-invoke-in-marked]
;;;   '(menu-item "Invoke Function In..." diredp-do-invoke-in-marked
;;;               :help "Invoke a Lisp function in each marked file or dir"))
(define-key diredp-apply-multiple-menu [diredp-do-apply-to-marked]
  '(menu-item "Apply Function To..." diredp-do-apply-to-marked
              :help "Apply a Lisp function to each marked file or dir name"))


;; `Multiple' > `Dired' menu.
;;
(defvar diredp-multiple-dired-menu (make-sparse-keymap "Dired")
  "`Dired' submenu for Dired menu-bar `Multiple' menu.")
(define-key diredp-menu-bar-multiple-menu [multiple-dired]
  `(menu-item "Dired" ,diredp-multiple-dired-menu
    :enable (save-excursion (goto-char (point-min))
                            (and (re-search-forward (dired-marker-regexp) nil t)
                                 (re-search-forward (dired-marker-regexp) nil t)))
    :help "Open Dired on marked files and dirs only"))

(define-key diredp-multiple-dired-menu [diredp-marked-other-window]
  '(menu-item "Dired Marked in Other Window" diredp-marked-other-window
    :enable (save-excursion (goto-char (point-min))
                            (and (re-search-forward (dired-marker-regexp) nil t)
                                 (re-search-forward (dired-marker-regexp) nil t)))
    :help "Open Dired on marked files and dirs only, in other window"))
(define-key diredp-multiple-dired-menu [diredp-marked]
  '(menu-item "Dired Marked" diredp-marked
    :enable (save-excursion (goto-char (point-min))
                            (and (re-search-forward (dired-marker-regexp) nil t)
                                 (re-search-forward (dired-marker-regexp) nil t)))
    :help "Open Dired on marked files and dirs only"))


;; `Multiple' > `Omit' menu.
;;
(defvar diredp-multiple-omit-menu (make-sparse-keymap "Omit")
  "`Omit' submenu for Dired menu-bar `Multiple' menu.")
(define-key diredp-menu-bar-multiple-menu [multiple-omit] (cons "Omit" diredp-multiple-omit-menu))

(define-key diredp-multiple-omit-menu [omit-unmarked]
  '(menu-item "Omit Unmarked" diredp-omit-unmarked :help "Hide lines of unmarked files"))
(define-key diredp-multiple-omit-menu [omit-marked]
  '(menu-item "Omit Marked" diredp-omit-marked :help "Hide lines of marked files"))


;; `Multiple' > `Delete' menu.
;;
(defvar diredp-multiple-delete-menu (make-sparse-keymap "Delete")
  "`Delete' submenu for Dired menu-bar `Multiple' menu.")
(define-key diredp-menu-bar-multiple-menu [multiple-delete] (cons "Delete" diredp-multiple-delete-menu))

(define-key diredp-multiple-delete-menu [delete-flagged]
  '(menu-item "Delete Flagged" dired-do-flagged-delete
    :help "Delete all files flagged for deletion (D)"))
(define-key diredp-multiple-delete-menu [delete]
  '(menu-item "Delete Marked (not Flagged)" dired-do-delete
    :help "Delete current file or all marked files (not flagged files)"))


;; `Multiple' > `Rename' menu.
;;
(defvar diredp-multiple-rename-menu (make-sparse-keymap "Rename")
  "`Rename' submenu for Dired menu-bar `Multiple' menu.")
(define-key diredp-menu-bar-multiple-menu [multiple-case] (cons "Rename" diredp-multiple-rename-menu))

(define-key diredp-multiple-rename-menu [multiple-rename-rename]
  '(menu-item "Move to Dir... / Rename This..." dired-do-rename
    :help "Move marked (or next N) files, or rename current file"))

(define-key diredp-multiple-rename-menu [multiple-rename-capitalize]
  '(menu-item "Capitalize" diredp-capitalize
    :help "Capitalize (initial caps) the names of all marked files"))
(define-key diredp-multiple-rename-menu [multiple-rename-downcase]
  '(menu-item "Downcase" dired-downcase
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename marked files to lowercase names"))
(define-key diredp-multiple-rename-menu [multiple-rename-upcase]
  '(menu-item "Upcase" dired-upcase
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename marked files to uppercase names"))


;; `Multiple' > `Move / Copy / Link' menu.
;;
(defvar diredp-multiple-move-copy-link-menu (make-sparse-keymap "Move / Copy / Link")
  "`Move / Copy / Link' submenu for Dired menu-bar `Multiple' menu.")
(define-key diredp-menu-bar-multiple-menu [multiple-move-copy-link]
  (cons "Move / Copy / Link" diredp-multiple-move-copy-link-menu))

(define-key diredp-multiple-move-copy-link-menu [multiple-move-copy-link-hardlink]
  '(menu-item "Hardlink to..." dired-do-hardlink
    :help "Make hard links for current or marked files"))
(define-key diredp-multiple-move-copy-link-menu [multiple-move-copy-link-symlink]
  '(menu-item "Symlink to (Absolute)..." dired-do-symlink ; In `dired-aux.el'.
              :help "Make absolute symbolic links for current or marked files"))
(define-key diredp-multiple-move-copy-link-menu [multiple-move-copy-link-relsymlink]
  '(menu-item "Symlink to (Relative)..." dired-do-relsymlink ; In `dired-x.el'.
              :help "Make relative symbolic links for current or marked files"))
(define-key diredp-multiple-move-copy-link-menu [multiple-move-copy-link-copy]
  '(menu-item "Copy to..." dired-do-copy :help "Copy current file or all marked files"))
(define-key diredp-multiple-move-copy-link-menu [multiple-move-copy-link-rename]
  '(menu-item "Move to..." dired-do-rename :help "Rename current file or move marked files"))


;; `Multiple' > `Images' menu.
;;
(defvar diredp-multiple-images-menu (make-sparse-keymap "Images"))
(defalias 'diredp-multiple-images-menu diredp-multiple-images-menu)
(define-key diredp-menu-bar-multiple-menu [images]
  '(menu-item "Images" diredp-multiple-images-menu
    :enable (fboundp 'image-dired-display-thumbs)))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-images-menu 'diredp-multiple-images-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-images-menu 'diredp-multiple-images-menu "2017-04-09")

;; Remove the items from `Multiple' menu.
(define-key diredp-menu-bar-multiple-menu [image-dired-delete-tag] nil)
(define-key diredp-menu-bar-multiple-menu [image-dired-tag-files] nil)
(define-key diredp-menu-bar-multiple-menu [image-dired-dired-comment-files] nil)
(define-key diredp-menu-bar-multiple-menu [image-dired-display-thumbs] nil)

;; Add them to `Multiple' > `Images' menu.
(define-key diredp-multiple-images-menu [image-dired-delete-tag]
  '(menu-item "Delete Tag..." image-dired-delete-tag
    :help "Delete tag from marked image files"))
(define-key diredp-multiple-images-menu [image-dired-tag-files]
  '(menu-item "Add Tags..." image-dired-tag-files
    :help "Add tags to marked image files"))
(define-key diredp-multiple-images-menu [image-dired-dired-comment-files]
  '(menu-item "Add Comment..." image-dired-dired-comment-files
    :help "Add comment to marked image files"))
(define-key diredp-multiple-images-menu [image-dired-display-thumbs]
  '(menu-item "Display Thumbnails" image-dired-display-thumbs
    :help "Display thumbnails for marked image files"))
(define-key diredp-multiple-images-menu [diredp-do-display-images]
  '(menu-item "Display" diredp-do-display-images
    :help "Display the marked image files"))


;; `Multiple' > `Encryption' menu.
;;
(when (fboundp 'epa-dired-do-encrypt)   ; Emacs 23+
  (defvar diredp-multiple-encryption-menu (make-sparse-keymap "Encryption"))
  (define-key diredp-menu-bar-multiple-menu [encryption]
    (cons "Encryption" diredp-multiple-encryption-menu))

  ;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
  ;; works for newer Emacs too.
  (when (fboundp 'defvaralias)          ; Emacs 22+
    (defvaralias 'diredp-menu-bar-encryption-menu 'diredp-multiple-encryption-menu))
  (diredp-make-obsolete-variable 'diredp-menu-bar-encryption-menu 'diredp-multiple-encryption-menu "2017-04-09")

  (when (boundp 'diredp-menu-bar-encryption-menu)
    (defalias 'diredp-menu-bar-encryption-menu diredp-menu-bar-encryption-menu))
  (diredp-make-obsolete 'diredp-menu-bar-encryption-menu 'diredp-multiple-encryption-menu "2017-04-09")

  ;; Remove the items from `Multiple' menu.
  (define-key diredp-menu-bar-multiple-menu [epa-dired-do-decrypt] nil)
  (define-key diredp-menu-bar-multiple-menu [epa-dired-do-verify] nil)
  (define-key diredp-menu-bar-multiple-menu [epa-dired-do-sign] nil)
  (define-key diredp-menu-bar-multiple-menu [epa-dired-do-encrypt] nil)

  ;; Add them to `Multiple' > `Encryption' menu.
  (define-key diredp-multiple-encryption-menu [epa-dired-do-decrypt]
    '(menu-item "Decrypt..." epa-dired-do-decrypt :help "Decrypt the marked files"))
  (define-key diredp-multiple-encryption-menu [epa-dired-do-verify]
    '(menu-item "Verify..." epa-dired-do-verify :help "Verify the marked files"))
  (define-key diredp-multiple-encryption-menu [epa-dired-do-sign]
    '(menu-item "Sign..." epa-dired-do-sign :help "Sign the marked files"))
  (define-key diredp-multiple-encryption-menu [epa-dired-do-encrypt]
    '(menu-item "Encrypt..." epa-dired-do-encrypt :help "Encrypt the marked files")))


;; `Multiple' > `Search' menu.
;;
(defvar diredp-multiple-search-menu (make-sparse-keymap "Search"))
(define-key diredp-menu-bar-multiple-menu [search]
  (cons "Search" diredp-multiple-search-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-operate-search-menu 'diredp-multiple-search-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-operate-search-menu 'diredp-multiple-search-menu "2017-04-09")

(when (fboundp 'dired-do-isearch-regexp) ; Emacs 23+
  (define-key diredp-multiple-search-menu [isearch-regexp]
    '(menu-item "Isearch Regexp Files..." dired-do-isearch-regexp
      :help "Incrementally search marked files for regexp"))
  (define-key diredp-multiple-search-menu [isearch]
    '(menu-item "Isearch Files..." dired-do-isearch
      :help "Incrementally search marked files for string")))
(when (fboundp 'dired-do-find-regexp-and-replace)
  (define-key diredp-multiple-search-menu [find-query-replace]
    '(menu-item "Query Replace Using `find'..." dired-do-find-regexp-and-replace
      :help "Replace regexp in marked files using `find'")))
(define-key diredp-multiple-search-menu [query-replace]
  (if (< emacs-major-version 21)
      '(menu-item "Query Replace Using TAGS Table..." dired-do-query-replace)
    '(menu-item "Query Replace Using TAGS Table..." dired-do-query-replace-regexp
      :help "Replace regexp in marked files using tags in a TAGS table")))
(when (fboundp 'dired-do-find-regexp)
  (define-key diredp-multiple-search-menu [find-regexp]
    '(menu-item "Search Files Using `find'..." dired-do-find-regexp
      :help "Search marked files for regexp using `find'")))
(define-key diredp-multiple-search-menu [search]
  '(menu-item "Search Files Using TAGS Table..." dired-do-search
              :help "Search marked files for regexp using tags in a TAGS table"))
(define-key diredp-multiple-search-menu [grep]
  '(menu-item "Grep..." diredp-do-grep :help "Grep marked, next N, or all files shown"))


;; `Multiple' > `Bookmark' menu.
;;
(defvar diredp-multiple-bookmarks-menu (make-sparse-keymap "Bookmark"))
(define-key diredp-menu-bar-multiple-menu [bookmark]
  (cons "Bookmark" diredp-multiple-bookmarks-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-operate-bookmarks-menu 'diredp-multiple-bookmarks-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-operate-bookmarks-menu 'diredp-multiple-bookmarks-menu "2017-04-09")

(when (require 'bookmark+ nil t)
  (define-key diredp-multiple-bookmarks-menu [diredp-do-set-tag-value]
    '(menu-item "Set Tag Value..." diredp-do-set-tag-value
      :help "Set the value of a given tag for the marked or next N files"))
  (define-key diredp-multiple-bookmarks-menu [diredp-do-paste-replace-tags]
    '(menu-item "Paste Tags (Replace)" diredp-do-paste-replace-tags
      :help "Replace tags for the marked or next N files with copied tags"))
  (define-key diredp-multiple-bookmarks-menu [diredp-do-paste-add-tags]
    '(menu-item "Paste Tags (Add)" diredp-do-paste-add-tags
      :help "Add previously copied tags to the marked or next N files"))
  (define-key diredp-multiple-bookmarks-menu [diredp-do-remove-all-tags]
    '(menu-item "Remove All Tags" diredp-do-remove-all-tags
      :help "Remove all tags from the marked or next N files"))
  (define-key diredp-multiple-bookmarks-menu [diredp-do-untag]
    '(menu-item "Remove Tags..." diredp-do-untag
      :help "Remove some tags from the marked or next N files"))
  (define-key diredp-multiple-bookmarks-menu [diredp-do-tag]
    '(menu-item "Add Tags..." diredp-do-tag
      :help "Add some tags to the marked or next N files"))
  (define-key diredp-multiple-bookmarks-menu [separator-book-2] '("--"))) ; ------------

(define-key diredp-multiple-bookmarks-menu
    [diredp-do-bookmark-in-bookmark-file-recursive]
  '(menu-item "Bookmark in Bookmark File (Here and Below)..."
    diredp-do-bookmark-in-bookmark-file-recursive
    :help "Bookmark marked files (including in marked subdirs) in bookmark file and save it"))
(define-key diredp-multiple-bookmarks-menu
    [diredp-set-bookmark-file-bookmark-for-marked-recursive]
  '(menu-item "Create Bookmark-File Bookmark (Here and Below)..."
    diredp-set-bookmark-file-bookmark-for-marked-recursive
    :help "Create a bookmark-file bookmark for marked files, including in marked subdirs"))
(define-key diredp-multiple-bookmarks-menu [diredp-do-bookmark-dirs-recursive]
    '(menu-item "Bookmark Dirs (Here and Below)..." diredp-do-bookmark-dirs-recursive
      :help "Bookmark this Dired buffer and marked subdirectory Dired buffers, recursively."))
(define-key diredp-multiple-bookmarks-menu [diredp-do-bookmark-recursive]
  '(menu-item "Bookmark (Here and Below)..." diredp-do-bookmark-recursive
    :help "Bookmark the marked files, including those in marked subdirs"))
(define-key diredp-multiple-bookmarks-menu [separator-book-1] '("--")) ; ---------------

(define-key diredp-multiple-bookmarks-menu [diredp-do-bookmark-in-bookmark-file]
  '(menu-item "Bookmark in Bookmark File..." diredp-do-bookmark-in-bookmark-file
    :help "Bookmark the marked files in BOOKMARK-FILE and save BOOKMARK-FILE"))
(define-key diredp-multiple-bookmarks-menu [diredp-set-bookmark-file-bookmark-for-marked]
  '(menu-item "Create Bookmark-File Bookmark..." diredp-set-bookmark-file-bookmark-for-marked
    :help "Create a bookmark-file bookmark, and bookmark the marked files in it"))
(define-key diredp-multiple-bookmarks-menu [diredp-do-bookmark]
  '(menu-item "Bookmark..." diredp-do-bookmark :help "Bookmark the marked or next N files"))


;; `Multiple' > `Marked Here and Below' menu.
;;
(defvar diredp-multiple-recursive-menu (make-sparse-keymap "Marked Here and Below"))
(define-key diredp-menu-bar-multiple-menu [operate-recursive]
  (cons "Marked Here and Below" diredp-multiple-recursive-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-operate-recursive-menu 'diredp-multiple-recursive-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-operate-recursive-menu 'diredp-multiple-recursive-menu "2017-04-09")

(when (fboundp 'diredp-do-chown-recursive)
  (define-key diredp-multiple-recursive-menu [chown]
    '(menu-item "Change Owner..." diredp-do-chown-recursive
      :help "Change the owner of marked files, including those in marked subdirs")))
(when (fboundp 'diredp-do-chgrp-recursive)
  (define-key diredp-multiple-recursive-menu [chgrp]
    '(menu-item "Change Group..." diredp-do-chgrp-recursive
      :help "Change the owner of marked files, including those in marked subdirs")))
(define-key diredp-multiple-recursive-menu [chmod]
  '(menu-item "Change Mode..." diredp-do-chmod-recursive
    :help "Change mode (attributes) of marked files, including those in marked subdirs"))
(when (fboundp 'dired-do-touch)         ; Emacs 22+
  (define-key diredp-multiple-recursive-menu [touch]
    '(menu-item "Change Timestamp (`touch')..." diredp-do-touch-recursive
      :help "Change timestamp of marked files, including those in marked subdirs")))
(define-key diredp-multiple-recursive-menu [separator-change] '("--")) ; ----------------

(define-key diredp-multiple-recursive-menu [diredp-do-print-recursive]
    '(menu-item "Print..." diredp-do-print-recursive
      :help "Print the marked files, including those in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-do-shell-command-recursive]
    '(menu-item "Shell Command..." diredp-do-shell-command-recursive
      :help "Run shell command on the marked files, including those in marked subdirs"))
(when (fboundp 'dired-do-async-shell-command) ; Emacs 23+
  (define-key diredp-multiple-recursive-menu [diredp-do-async-shell-command-recursive]
    '(menu-item "Asynchronous Shell Command..." diredp-do-async-shell-command-recursive
      :help "Run shell command asynchronously on marked files, including in marked subdirs")))

(when (fboundp 'diredp-unmark-all-marks-recursive) ; Emacs 22+
  (define-key diredp-multiple-recursive-menu [separator-1] '("--")) ; ------------
  (define-key diredp-multiple-recursive-menu [diredp-change-marks-recursive]
    '(menu-item "Change Mark..." diredp-change-marks-recursive
      :help "Change all OLD marks to NEW marks, including those in marked subdirs"))
  (define-key diredp-multiple-recursive-menu [diredp-unmark-all-files-recursive]
    '(menu-item "Unmark Marked-With..." diredp-unmark-all-files-recursive
      :help "Remove a given mark everywhere, including in marked subdirs"))
  (define-key diredp-multiple-recursive-menu [diredp-unmark-all-marks-recursive]
    '(menu-item "Unmark All..." diredp-unmark-all-marks-recursive
      :help "Remove ALL marks everywhere, including in marked subdirs")))

(define-key diredp-multiple-recursive-menu [separator-misc] '("--")) ; ------------------

(define-key diredp-multiple-recursive-menu [diredp-do-delete-recursive]
    '(menu-item "Delete Marked (not Flagged)" diredp-do-delete-recursive
      :help "Delete marked (not flagged) files, including in marked subdirs"))
(define-key diredp-multiple-recursive-menu [separator-delete] '("--")) ; ----------------

(define-key diredp-multiple-recursive-menu [diredp-do-hardlink-recursive]
  '(menu-item "Hardlink to..." diredp-do-hardlink-recursive
    :help "Make hard links for marked files, including those in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-do-symlink-recursive]
  '(menu-item "Symlink to (Absolute)..." diredp-do-symlink-recursive
              :help "Make absolute symbolic links for marked files, including those in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-do-relsymlink-recursive]
  '(menu-item "Symlink to (Relative)..." diredp-do-relsymlink-recursive
              :help "Make relative symbolic links for marked files, including those in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-do-copy-recursive]
    '(menu-item "Copy to..." diredp-do-copy-recursive
      :help "Copy marked files, including in marked subdirs, to a given directory"))
(define-key diredp-multiple-recursive-menu [diredp-do-move-recursive]
    '(menu-item "Move to..." diredp-do-move-recursive
      :help "Move marked files, including in marked subdirs, to a given directory"))
(define-key diredp-multiple-recursive-menu [separator-copy-move] '("--")) ; -------------

(define-key diredp-multiple-recursive-menu [diredp-capitalize-recursive]
  '(menu-item "Capitalize" diredp-capitalize-recursive
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Capitalize the names of all marked files, including in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-downcase-recursive]
  '(menu-item "Downcase" diredp-downcase-recursive
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename marked files, including in marked subdirs, to lowercase names"))
(define-key diredp-multiple-recursive-menu [diredp-upcase-recursive]
  '(menu-item "Upcase" diredp-upcase-recursive
    :enable (or (not (fboundp 'msdos-long-file-names))  (msdos-long-file-names))
    :help "Rename marked files, including in marked subdirs, to uppercase names"))
(define-key diredp-multiple-recursive-menu [separator-lettercase] '("--")) ; ------------

(define-key diredp-multiple-recursive-menu [diredp-list-marked-recursive]
    '(menu-item "List Marked Files" diredp-list-marked-recursive
      :help "List the files marked here and in marked subdirs, recursively"))
(define-key diredp-multiple-recursive-menu [diredp-copy-filename-as-kill-recursive]
    '(menu-item "Copy File Names (to Paste)" diredp-copy-filename-as-kill-recursive
      :help "Copy names of files marked here and in marked subdirs, to `kill-ring'"))
(define-key diredp-multiple-recursive-menu [diredp-insert-subdirs-recursive]
  '(menu-item "Insert Subdirs" diredp-insert-subdirs-recursive
    :help "Insert the marked subdirectories, gathered recursively"))
(define-key diredp-multiple-recursive-menu [separator-dirs] '("--")) ; ------------------

(define-key diredp-multiple-recursive-menu [diredp-marked-recursive-other-window]
    '(menu-item "Dired (Marked) in Other Window" diredp-marked-recursive-other-window
      :help "Open Dired (in other window) on marked files, including those in marked subdirs"))
(define-key diredp-multiple-recursive-menu [diredp-marked-recursive]
    '(menu-item "Dired (Marked)" diredp-marked-recursive
      :help "Open Dired on marked files, including those in marked subdirs"))
;; On Windows, bind more.
(eval-after-load "w32-browser"
  '(define-key diredp-multiple-recursive-menu [diredp-multiple-w32-browser-recursive]
    '(menu-item "Open Associated Windows Apps" diredp-multiple-w32-browser-recursive
      :help "Run Windows apps for with marked files, including those in marked subdirs")))
(define-key diredp-multiple-recursive-menu [diredp-do-find-marked-files-recursive]
    '(menu-item "Open" diredp-do-find-marked-files-recursive
      :help "Find marked files simultaneously, including those in marked subdirs"))


;; `Multiple' > `Marked Here and Below' > `Apply (Map)' menu.
;;
(defvar diredp-apply-recursive-menu (make-sparse-keymap "Apply (Map)"))
(defalias 'diredp-apply-recursive-menu diredp-apply-recursive-menu)
(define-key diredp-multiple-recursive-menu [apply]
  (cons "Apply (Map)" diredp-apply-recursive-menu))

(define-key diredp-apply-recursive-menu [diredp-do-eval-in-marked-recursive]
  '(menu-item "Eval Sexp In..." diredp-do-eval-in-marked-recursive
              :help "Evaluate a Lisp sexp in marked, including in marked subdirs"))
(define-key diredp-apply-recursive-menu [diredp-do-command-in-marked-recursive]
  '(menu-item "Invoke Command/Macro In..." diredp-do-command-in-marked-recursive
              :help "Invoke command or keyboard macro in each marked file, including in marked subdirs"))
;;; (define-key diredp-apply-recursive-menu [diredp-do-invoke-in-marked-recursive]
;;;   '(menu-item "Invoke Function In..." diredp-do-invoke-in-marked-recursive
;;;               :help "Invoke a Lisp function in each marked file, including in marked subdirs"))
(define-key diredp-apply-recursive-menu [diredp-do-apply-to-marked-recursive]
  '(menu-item "Apply Function To..." diredp-do-apply-to-marked-recursive
              :help "Apply a Lisp function to marked file names, including in marked subdirs"))


;; `Multiple' > `Marked Here and Below' > `Images' menu.
;;
(defvar diredp-images-recursive-menu (make-sparse-keymap "Images"))
(defalias 'diredp-images-recursive-menu diredp-images-recursive-menu)

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-images-recursive-menu 'diredp-images-recursive-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-images-recursive-menu 'diredp-images-recursive-menu "2017-04-09")

(when (boundp 'diredp-menu-bar-images-recursive-menu)
  (defalias 'diredp-menu-bar-images-recursive-menu diredp-menu-bar-images-recursive-menu))
(diredp-make-obsolete 'diredp-menu-bar-images-recursive-menu 'diredp-images-recursive-menu "2017-04-09")

(define-key diredp-multiple-recursive-menu [images]
  '(menu-item "Images" diredp-images-recursive-menu
    :enable (fboundp 'image-dired-delete-tag)))
(define-key diredp-images-recursive-menu [diredp-image-dired-delete-tag-recursive]
  '(menu-item "Delete Image Tag..." diredp-image-dired-delete-tag-recursive
    :help "Remove an `image-dired' tag from marked files, including those in marked subdirs"))
(define-key diredp-images-recursive-menu [diredp-image-dired-tag-files-recursive]
  '(menu-item "Add Image Tags..." diredp-image-dired-tag-files-recursive
    :help "Add `image-dired' tags to marked files, including those in marked subdirs"))
(define-key diredp-images-recursive-menu [diredp-image-dired-comment-files-recursive]
  '(menu-item "Add Image Comment..." diredp-image-dired-comment-files-recursive
    :help "Add image comment to marked files, including those in marked subdirs"))
(define-key diredp-images-recursive-menu [diredp-image-dired-display-thumbs-recursive]
  '(menu-item "Display Image Thumbnails" diredp-image-dired-display-thumbs-recursive
    :help "Show thumbnails for marked image files, including those in marked subdirs"))


;; `Multiple' > `Marked Here and Below' > `Encryption' menu.
;;
(when (fboundp 'epa-dired-do-encrypt)   ; Emacs 23+
  (defvar diredp-menu-bar-encryption-recursive-menu (make-sparse-keymap "Encryption"))
  (define-key diredp-multiple-recursive-menu [encryption]
    (cons "Encryption" diredp-menu-bar-encryption-recursive-menu))
  (define-key diredp-menu-bar-encryption-recursive-menu [diredp-do-decrypt-recursive]
    '(menu-item "Decrypt..." diredp-do-decrypt-recursive
      :help "Decrypt marked files, including those in marked subdirs"))
  (define-key diredp-menu-bar-encryption-recursive-menu [diredp-do-verify-recursive]
    '(menu-item "Verify..." diredp-do-verify-recursive
      :help "Verify marked files, including those in marked subdirs"))
  (define-key diredp-menu-bar-encryption-recursive-menu [diredp-do-sign-recursive]
    '(menu-item "Sign..." diredp-do-sign-recursive
      :help "Sign marked files, including those in marked subdirs"))
  (define-key diredp-menu-bar-encryption-recursive-menu [diredp-do-encrypt-recursive]
    '(menu-item "Encrypt..." diredp-do-encrypt-recursive
      :help "Encrypt marked files, including those in marked subdirs")))


;; `Multiple' > `Marked Here and Below' > `Search' menu.
;;
(defvar diredp-menu-bar-search-recursive-menu (make-sparse-keymap "Search"))
(define-key diredp-multiple-recursive-menu [search]
  (cons "Search" diredp-menu-bar-search-recursive-menu))
(when (fboundp 'dired-do-isearch-regexp) ; Emacs 23+
  (define-key diredp-menu-bar-search-recursive-menu [diredp-do-isearch-regexp-recursive]
    '(menu-item "Isearch Regexp Files..." diredp-do-isearch-regexp-recursive
      :help "Incrementally regexp search marked files, including those in marked subdirs"))
  (define-key diredp-menu-bar-search-recursive-menu [diredp-do-isearch-recursive]
    '(menu-item "Isearch Files..." diredp-do-isearch-recursive
      :help "Incrementally search marked files, including those in marked subdirs")))
(define-key diredp-menu-bar-search-recursive-menu [diredp-do-query-replace-regexp-recursive]
  '(menu-item "Query Replace..." diredp-do-query-replace-regexp-recursive
    :help "Replace regexp in marked files, including those in marked subdirs"))
(define-key diredp-menu-bar-search-recursive-menu [diredp-do-search-recursive]
  '(menu-item "Search Files..." diredp-do-search-recursive
    :help "Regexp search marked files, including those in marked subdirs"))
(define-key diredp-menu-bar-search-recursive-menu [diredp-do-grep-recursive]
  '(menu-item "Grep..." diredp-do-grep-recursive
    :help "Run `grep' on the marked files, including those in marked subdirs"))


;; `Multiple' > `Marked Here and Below' > `Bookmark' menu.
;;
(defvar diredp-menu-bar-bookmarks-recursive-menu (make-sparse-keymap "Bookmark"))
(define-key diredp-multiple-recursive-menu [bookmarks]
  (cons "Bookmark" diredp-menu-bar-bookmarks-recursive-menu))
(define-key diredp-menu-bar-bookmarks-recursive-menu
    [diredp-do-bookmark-in-bookmark-file-recursive]
    '(menu-item "Bookmark in Bookmark File..." diredp-do-bookmark-in-bookmark-file-recursive
      :help "Bookmark marked files, including those in marked subdirs, in a bookmark file"))
(define-key diredp-menu-bar-bookmarks-recursive-menu
    [diredp-set-bookmark-file-bookmark-for-marked-recursive]
  '(menu-item "Create Bookmark-File Bookmark..."
    diredp-set-bookmark-file-bookmark-for-marked-recursive
    :help "Create a bookmark-file bookmark for marked files, including in marked subdirs"))
(define-key diredp-menu-bar-bookmarks-recursive-menu [diredp-do-bookmark-dirs-recursive]
    '(menu-item "Bookmark Dirs..." diredp-do-bookmark-dirs-recursive
      :help "Bookmark this Dired buffer and marked subdirectory Dired buffers, recursively."))
(define-key diredp-menu-bar-bookmarks-recursive-menu [diredp-do-bookmark-recursive]
    '(menu-item "Bookmark..." diredp-do-bookmark-recursive
      :help "Bookmark the marked files, including those in marked subdirs"))



;; `Regexp' menu.
;;
;; REPLACE ORIGINAL `Regexp' menu in `dired.el'.
;;
(defvar diredp-menu-bar-regexp-menu (make-sparse-keymap "Regexp"))
(define-key dired-mode-map [menu-bar regexp] (cons "Regexp" diredp-menu-bar-regexp-menu))

(define-key diredp-menu-bar-regexp-menu [hardlink]
  '(menu-item "Hardlink to..." dired-do-hardlink-regexp ; In `dired-aux.el'.
    :help "Make hard links for files matching regexp"))
(define-key diredp-menu-bar-regexp-menu [symlink]
  '(menu-item "Symlink to (Absolute)..." dired-do-symlink-regexp ; In `dired-aux.el'.
              :help "Make absolute symbolic links for files matching regexp"))
(define-key diredp-menu-bar-regexp-menu [relsymlink]
  '(menu-item "Symlink to (Relative)..." dired-do-relsymlink-regexp ; In `dired-x.el'.
              :help "Make relative symbolic links for files matching regexp"))
(define-key diredp-menu-bar-regexp-menu [copy]
  '(menu-item "Copy to..." dired-do-copy-regexp ; In `dired-aux.el'.
              :help "Copy marked files matching regexp"))
(define-key diredp-menu-bar-regexp-menu [rename]
  '(menu-item "Move to..." dired-do-rename-regexp ; In `dired-aux.el'.
              :help "Move marked files matching regexp"))
(define-key diredp-menu-bar-regexp-menu [unmark-regexp-default-dir]
  '(menu-item "Unmark (Default Dir)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "UNmark files (regexp): ") ?\040 nil))
              :help "Unmark files matching regexp with default directory"
              :keys "C-u C-u \\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [unmark-regexp-absolute]
  '(menu-item "Unmark (Absolute)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "UNmark files (regexp): ") ?\040 t))
              :help "Unmark files matching regexp against absolute file name"
              :keys "M-0 \\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [unmark-regexp-relative]
  '(menu-item "Unmark (Relative)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "UNmark files (regexp): ") ?\040 'no-dir))
              :help "Unmark files matching regexp against relative file name"
              :keys "C-u \\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [mark-regexp-default-dir]
  '(menu-item "Mark (Default Dir)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char nil))
              :help "Mark files matching regexp with default directory"
              :keys "M-9 \\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [mark-regexp-absolute]
  '(menu-item "Mark (Absolute)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char t))
              :help "Mark files matching regexp against absolute file name"
              :keys "M-- \\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [mark-regexp-relative]
  '(menu-item "Mark (Relative)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char 'no-dir))
              :help "Mark files matching regexp against relative file name"
              :keys "\\[dired-mark-files-regexp]"))
(define-key diredp-menu-bar-regexp-menu [mark-containing]
  '(menu-item "Mark Containing..." dired-mark-files-containing-regexp
              :help "Mark files whose contents matches regexp"))
(define-key diredp-menu-bar-regexp-menu [image-dired-mark-tagged-files]
  '(menu-item "Mark Image Files Tagged..." image-dired-mark-tagged-files
              :enable (fboundp 'image-dired-mark-tagged-files)
              :help "Mark image files whose image tags match regexp"))
(define-key diredp-menu-bar-regexp-menu [flag]
  '(menu-item "Flag..." dired-flag-files-regexp
              :help "Flag files matching regexp for deletion"))


;; `Regexp' > `Here and Below' menu.
;;
(defvar diredp-regexp-recursive-menu (make-sparse-keymap "Here and Below"))
(define-key diredp-menu-bar-regexp-menu [mark-recursive]
  (cons "Here and Below" diredp-regexp-recursive-menu))
(define-key diredp-regexp-recursive-menu [diredp-mark-files-regexp-recursive]
    '(menu-item "Mark Named (Absolute)..." diredp-mark-files-regexp-recursive
      :help "Mark all file names matching a regexp, including those in marked subdirs"))
(define-key diredp-regexp-recursive-menu [diredp-mark-files-containing-regexp-recursive]
    '(menu-item "Mark Containing..." diredp-mark-files-containing-regexp-recursive
      :help "Mark all files with content matching a regexp, including in marked subdirs"))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-regexp-recursive-menu 'diredp-regexp-recursive-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-regexp-recursive-menu 'diredp-regexp-recursive-menu "2017-04-09")

(when (boundp 'diredp-menu-bar-regexp-recursive-menu)
  (defalias 'diredp-menu-bar-regexp-recursive-menu diredp-menu-bar-regexp-recursive-menu))
(diredp-make-obsolete 'diredp-menu-bar-regexp-recursive-menu 'diredp-regexp-recursive-menu "2017-04-09")


;; "Marks" menu.
;;
;; REPLACE ORIGINAL `Marks' menu in `dired.el'.
;;
(defvar diredp-menu-bar-marks-menu (make-sparse-keymap "Marks"))
(define-key dired-mode-map [menu-bar mark] (cons "Marks" diredp-menu-bar-marks-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-mark-menu 'diredp-menu-bar-marks-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-mark-menu 'diredp-menu-bar-marks-menu "2017-04-09")

(define-key diredp-menu-bar-marks-menu [prev]
  '(menu-item "Previous Marked" dired-prev-marked-file :help "Move to previous marked file"))
(define-key diredp-menu-bar-marks-menu [next]
  '(menu-item "Next Marked" dired-next-marked-file :help "Move to next marked file"))
(define-key diredp-menu-bar-marks-menu [marks]
  '(menu-item "Change Mark..." dired-change-marks
    :help "Replace a given mark character with another"))
(define-key diredp-menu-bar-marks-menu [toggle-marks]
  (if (> emacs-major-version 21)
      '(menu-item "Toggle Marked/Unmarked" dired-toggle-marks
        :help "Mark unmarked files, unmark marked ones")
    '(menu-item "Toggle Marked/Unmarked" dired-toggle-marks
      :help "Mark unmarked files, unmark marked ones")))


;; `Marks' > `Tagged' menu.
;;
(when (require 'bookmark+ nil t)
  (defvar diredp-marks-tags-menu (make-sparse-keymap "Tagged (Autofiles)")
    "`Tags' submenu for Dired menu-bar `Marks' menu.")
  (define-key diredp-menu-bar-marks-menu [mark-tags] (cons "Tagged" diredp-marks-tags-menu))

  (define-key diredp-marks-tags-menu [diredp-unmark-files-tagged-none]
    '(menu-item "Unmark Not Tagged with Any..." diredp-unmark-files-tagged-none
      :help "Unmark files that are not tagged with *any* of the tags you enter"))
  (define-key diredp-marks-tags-menu [diredp-unmark-files-tagged-not-all]
    '(menu-item "Unmark Not Tagged with All..." diredp-unmark-files-tagged-not-all
      :help "Unmark files that are not tagged with *all* tags"))
  (define-key diredp-marks-tags-menu [diredp-unmark-files-tagged-some]
    '(menu-item "Unmark Tagged with Some..." diredp-unmark-files-tagged-some
      :help "Unmark files that are tagged with at least one of the tags you enter"))
  (define-key diredp-marks-tags-menu [diredp-unmark-files-tagged-all]
    '(menu-item "Unmark Tagged with All..." diredp-unmark-files-tagged-all
      :help "Unmark files that are tagged with *each* tag you enter"))
  (define-key diredp-marks-tags-menu [diredp-unmark-files-tagged-regexp]
    '(menu-item "Unmark Tagged Matching Regexp..." diredp-unmark-files-tagged-regexp
      :help "Unmark files that have at least one tag that matches a regexp"))
  (define-key diredp-marks-tags-menu [separator-marks-tags] '("--")) ; -------------------------

  (define-key diredp-marks-tags-menu [diredp-mark-files-tagged-none]
    '(menu-item "Mark Not Tagged with Any..." diredp-mark-files-tagged-none
      :help "Mark files that are not tagged with *any* of the tags you enter"))
  (define-key diredp-marks-tags-menu [diredp-mark-files-tagged-not-all]
    '(menu-item "Mark Not Tagged with All..." diredp-mark-files-tagged-not-all
      :help "Mark files that are not tagged with *all* tags"))
  (define-key diredp-marks-tags-menu [diredp-mark-files-tagged-some]
    '(menu-item "Mark Tagged with Some..." diredp-mark-files-tagged-some
      :help "Mark files that are tagged with at least one of the tags you enter"))
  (define-key diredp-marks-tags-menu [diredp-mark-files-tagged-all]
    '(menu-item "Mark Tagged with All..." diredp-mark-files-tagged-all
      :help "Mark files that are tagged with *each* tag you enter"))
  (define-key diredp-marks-tags-menu [diredp-mark-files-tagged-regexp]
    '(menu-item "Mark Tagged Matching Regexp..." diredp-mark-files-tagged-regexp
      :help "Mark files that have at least one tag that matches a regexp")))


;; `Marks' > `Omit' menu.
;;
(defvar diredp-marks-omit-menu (make-sparse-keymap "Omit")
  "`Omit' submenu for Dired menu-bar `Marks' menu.")
(define-key diredp-menu-bar-marks-menu [marks-omit] (cons "Omit" diredp-marks-omit-menu))

(define-key diredp-marks-omit-menu [marks-omit-unmarked]
  '(menu-item "Omit Unmarked" diredp-omit-unmarked :help "Hide lines of unmarked files"))
(define-key diredp-marks-omit-menu [marks-omit-marked]
  '(menu-item "Omit Marked" diredp-omit-marked :help "Hide lines of marked files"))


;; `Marks' > `Flag' menu.
;;
(defvar diredp-marks-flag-menu (make-sparse-keymap "Flag")
  "`Flag' submenu for Dired menu-bar `Marks' menu.")
(define-key diredp-menu-bar-marks-menu [mark-flag] (cons "Flag" diredp-marks-flag-menu))

(define-key diredp-marks-flag-menu [marks-flag-extension]
  '(menu-item "Flag Extension..." dired-flag-extension ; In `dired-x.el'
              :help "Flag all files that have a certain extension, for deletion"))
(define-key diredp-marks-flag-menu [marks-flag-garbage-files]
  '(menu-item "Flag Garbage Files" dired-flag-garbage-files
    :help "Flag unneeded files for deletion"))
(define-key diredp-marks-flag-menu [marks-flag-backup-files]
  '(menu-item "Flag Backup Files" dired-flag-backup-files
    :help "Flag all backup files for deletion"))
(define-key diredp-marks-flag-menu [marks-flag-auto-save-files]
  '(menu-item "Flag Auto-save Files" dired-flag-auto-save-files
    :help "Flag auto-save files for deletion"))
(define-key diredp-marks-flag-menu [marks-flag-region]
  '(menu-item "Flag Region" diredp-flag-region-files-for-deletion
    :visible (diredp-nonempty-region-p)
    :help "Flag all files in the region (selection) for deletion"))
(when (< emacs-major-version 21)
  (put 'diredp-flag-region-files-for-deletion 'menu-enable '(diredp-nonempty-region-p)))
(define-key diredp-marks-flag-menu [marks-flag-deletion]
  '(menu-item "Flag This" dired-flag-file-deletion
    :visible (not (diredp-nonempty-region-p))
    :help "Flag current line's file for deletion"))


;; `Marks' > `Unmark' menu.
;;
(defvar diredp-marks-unmark-menu (make-sparse-keymap "Unmark")
  "`Unmark' submenu for Dired menu-bar `Marks' menu.")
(define-key diredp-menu-bar-marks-menu [mark-mark] (cons "Unmark" diredp-marks-unmark-menu))

(define-key diredp-marks-unmark-menu [unmark-regexp-default-dir]
  '(menu-item "Unmark Name Matching Regexp (Default Dir)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "UNmark files (regexp): ") ?\040 nil))
              :help "Unmark files matching regexp with default directory"
              :keys "C-u C-u \\[dired-mark-files-regexp]"))
(define-key diredp-marks-unmark-menu [unmark-regexp-absolute]
  '(menu-item "Unmark Name Matching Regexp (Absolute)..."
              (lambda () (interactive)
                (dired-mark-files-regexp
                 (diredp-read-regexp "UNmark files (regexp): ")
                 ?\040
                 t))
              :help "Unmark files matching regexp against absolute file name"
              :keys "M-0 \\[dired-mark-files-regexp]"))
(define-key diredp-marks-unmark-menu [unmark-regexp-relative]
  '(menu-item "Unmark Name Matching Regexp (Relative)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "UNmark files (regexp): ") ?\040 'no-dir))
              :help "Unmark files matching regexp against relative file name"
              :keys "C-u \\[dired-mark-files-regexp]"))
(define-key diredp-marks-unmark-menu [unmark-autofiles]
  '(menu-item "Unmark Autofiles" diredp-unmark-autofiles
    :help "Unmark all autofiles (bookmarks with same name as file)"
    :enable (featurep 'bookmark+)))
(define-key diredp-marks-unmark-menu [unmark-all]
  '(menu-item "Unmark All" dired-unmark-all-marks :help "Remove all marks from all files"))
(define-key diredp-marks-unmark-menu [unmark-with]
  '(menu-item "Unmark Marked-With..." dired-unmark-all-files
    :help "Remove a specific mark (or all marks) from every file"))
(define-key diredp-marks-unmark-menu [unmark-region]
  '(menu-item "Unmark Region" diredp-unmark-region-files
    :visible (diredp-nonempty-region-p)
    :help "Unmark all files in the region (selection)"))
(when (< emacs-major-version 21)
  (put 'diredp-unmark-region-files 'menu-enable '(diredp-nonempty-region-p)))
(define-key diredp-marks-unmark-menu [unmark-this]
  '(menu-item "Unmark This" dired-unmark
    :visible (not (diredp-nonempty-region-p))
    :help "Unmark or unflag current line's file"))


;; `Marks' > `Mark' menu.
;;
(defvar diredp-marks-mark-menu (make-sparse-keymap "Mark")
  "`Mark' submenu for Dired menu-bar `Marks' menu.")
(define-key diredp-menu-bar-marks-menu [marks-mark] (cons "Mark" diredp-marks-mark-menu))

(define-key diredp-marks-mark-menu [marks-mark-regexp-default-dir]
  '(menu-item "Mark Name Matching Regexp (Default Dir)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char nil))
              :help "Mark files matching regexp with default directory"
              :keys "M-9 \\[dired-mark-files-regexp]"))
(define-key diredp-marks-mark-menu [marks-mark-regexp-absolute]
  '(menu-item "Mark Name Matching Regexp (Absolute)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char t))
              :help "Mark files matching regexp against absolute file name"
              :keys "M-- \\[dired-mark-files-regexp]"))
(define-key diredp-marks-mark-menu [marks-mark-regexp-relative]
  '(menu-item "Mark Name Matching Regexp (Relative)..."
              (lambda () (interactive)
                (dired-mark-files-regexp (diredp-read-regexp "Mark files (regexp): ") dired-marker-char 'no-dir))
              :help "Mark files matching regexp against relative file name"
              :keys "\\[dired-mark-files-regexp]"))
(define-key diredp-marks-mark-menu [marks-mark-containing]
  '(menu-item "Mark Content Matching Regexp..." dired-mark-files-containing-regexp
    :help "Mark files whose contents matches regexp"))
(define-key diredp-marks-mark-menu [marks-mark-sexp]
  '(menu-item "Mark If..." dired-mark-sexp ; In `dired-x.el'.
              :help "Mark files that satisfy specified condition"))
(define-key diredp-marks-mark-menu [marks-image-dired-mark-tagged-files]
  '(menu-item "Mark Image Files Tagged..." image-dired-mark-tagged-files
    :enable (fboundp 'image-dired-mark-tagged-files) ; In `image-dired.el'.
    :help "Mark image files whose image tags match regexp"))
(when (fboundp 'dired-mark-omitted)     ; In `dired-x.el', Emacs 22+.
  (define-key diredp-marks-mark-menu [marks-mark-omitted]
    '(menu-item "Mark Omitted..." dired-mark-omitted
      :help "Mark all omitted files and subdirectories")))
(define-key diredp-marks-mark-menu [marks-mark-extension]
  '(menu-item "Mark Extension..." diredp-mark/unmark-extension
    :help "Mark all files with specified extension"))
(define-key diredp-marks-mark-menu [marks-mark-autofiles]
  '(menu-item "Mark Autofiles" diredp-mark-autofiles
    :help "Mark all autofiles (bookmarks with same name as file)"
    :enable (featurep 'bookmark+)))
(define-key diredp-marks-mark-menu [marks-mark-symlinks]
  '(menu-item "Mark Symlinks" dired-mark-symlinks
    :visible (fboundp 'make-symbolic-link) :help "Mark all symbolic links"))
(define-key diredp-marks-mark-menu [marks-mark-directories]
  '(menu-item "Mark Directories" dired-mark-directories
    :help "Mark all directories except `.' and `..'"))
(define-key diredp-marks-mark-menu [marks-mark-directory]
  '(menu-item "Mark Old Backups" dired-clean-directory
    :help "Flag old numbered backups for deletion"))
(define-key diredp-marks-mark-menu [marks-mark-executables]
  '(menu-item "Mark Executables" dired-mark-executables :help "Mark all executable files"))
(define-key diredp-marks-mark-menu [diredp-mark-with-char]
  '(menu-item "Mark This with Char..." diredp-mark-with-char
              :visible (not (diredp-nonempty-region-p))
              :help "Mark this line with a character you type"))
(define-key diredp-marks-mark-menu [diredp-mark-region-files-with-char]
  '(menu-item "Mark Region with Char..." diredp-mark-region-files-with-char
              :visible (diredp-nonempty-region-p)
              :help "Mark lines in region with a character you type"))
(define-key diredp-marks-mark-menu [marks-mark-region]
  '(menu-item "Mark Region" diredp-mark-region-files
    :visible (diredp-nonempty-region-p)
    :help "Mark the lines in the region (selection)"))
(when (< emacs-major-version 21)
  (put 'diredp-mark-region-files 'menu-enable '(diredp-nonempty-region-p)))
(define-key diredp-marks-mark-menu [marks-mark-this]
  '(menu-item "Mark This" dired-mark
    :visible (not (diredp-nonempty-region-p))
    :help "Mark current line"))


;; `Marks' > `Here and Below' menu.
;;
(defvar diredp-marks-recursive-menu (make-sparse-keymap "Here and Below"))
(define-key diredp-menu-bar-marks-menu [mark-recursive]
  (cons "Here and Below" diredp-marks-recursive-menu))

(define-key diredp-marks-recursive-menu [diredp-flag-auto-save-files-recursive]
    '(menu-item "Flag Auto-Save Files..." diredp-flag-auto-save-files-recursive
      :help "Flag all auto-save files for deletion, including those in marked subdirs"))
(when (fboundp 'diredp-unmark-all-marks-recursive) ; Emacs 22+
  (define-key diredp-marks-recursive-menu [diredp-change-marks-recursive]
    '(menu-item "Change Mark..." diredp-change-marks-recursive
      :help "Change all OLD marks to NEW marks, including those in marked subdirs"))
  (define-key diredp-marks-recursive-menu [diredp-unmark-all-files-recursive]
    '(menu-item "Unmark Marked-With..." diredp-unmark-all-files-recursive
      :help "Remove a given mark everywhere, including in marked subdirs"))
  (define-key diredp-marks-recursive-menu [diredp-unmark-all-marks-recursive]
    '(menu-item "Unmark All..." diredp-unmark-all-marks-recursive
      :help "Remove ALL marks everywhere, including in marked subdirs"))
  (define-key diredp-marks-recursive-menu [separator-1] '("--"))) ; ------------
(define-key diredp-marks-recursive-menu [diredp-mark-sexp-recursive]
  '(menu-item "If..." diredp-mark-sexp-recursive
    :help "Mark files satisfying specified condition, including those in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-files-containing-regexp-recursive]
  '(menu-item "Containing Regexp..." diredp-mark-files-containing-regexp-recursive
    :help "Mark all files with content matching a regexp, including in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-files-regexp-recursive]
  '(menu-item "Named Regexp (Absolute)..." diredp-mark-files-regexp-recursive
    :help "Mark all file names matching a regexp, including those in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-extension-recursive]
  '(menu-item "Extension..." diredp-mark-extension-recursive
    :help "Mark all files with a given extension, including those in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-autofiles-recursive]
  '(menu-item "Autofiles" diredp-mark-autofiles-recursive
    :help "Mark all files with a given extension, including those in marked subdirs"
    :enable (featurep 'bookmark+)))
(define-key diredp-marks-recursive-menu [diredp-mark-symlinks-recursive]
  '(menu-item "Symbolic Links" diredp-mark-symlinks-recursive
    :help "Mark all symbolic links, including those in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-directories-recursive]
  '(menu-item "Directories" diredp-mark-directories-recursive
    :help "Mark all directories, including those in marked subdirs"))
(define-key diredp-marks-recursive-menu [diredp-mark-executables-recursive]
  '(menu-item "Executables" diredp-mark-executables-recursive
    :help "Mark all executable files, including those in marked subdirs"))


;; "Dir" menu.
;;
;; REPLACE ORIGINAL `Subdir' menu in `dired.el'.
;;
(defvar diredp-menu-bar-dir-menu (make-sparse-keymap "Dir"))
(define-key dired-mode-map [menu-bar subdir] (cons "Dir" diredp-menu-bar-dir-menu))

;; We don't use `define-obsolete-variable-alias' so that byte-compilation in older Emacs
;; works for newer Emacs too.
(when (fboundp 'defvaralias)            ; Emacs 22+
  (defvaralias 'diredp-menu-bar-subdir-menu 'diredp-dir-menu))
(diredp-make-obsolete-variable 'diredp-menu-bar-subdir-menu 'diredp-dir-menu "2017-04-09")

(when (boundp 'diredp-menu-bar-subdir-menu)
  (defalias 'diredp-menu-bar-subdir-menu diredp-menu-bar-subdir-menu))
(diredp-make-obsolete 'diredp-menu-bar-subdir-menu 'diredp-dir-menu "2017-04-09")


;; `Dir' > `Hide/Show' menu.
;;
(defvar diredp-hide/show-menu (make-sparse-keymap "Hide/Show")
  "`Hide/Show' submenu for Dired menu-bar `Dir' menu.")
(define-key diredp-menu-bar-dir-menu [hide-show] (cons "Hide/Show" diredp-hide/show-menu))

(when (fboundp 'dired-omit-mode)
  (define-key diredp-hide/show-menu [dired-omit-mode]
    '(menu-item "Hide/Show Uninteresting (Omit Mode)" dired-omit-mode
      :help "Toggle omission of uninteresting files (Omit mode)")))
(when (fboundp 'dired-hide-details-mode) ; Emacs 24.4+
  (define-key diredp-hide/show-menu [hide-details]
    '(menu-item "Hide/Show Details" dired-hide-details-mode
      :help "Hide or show less important fields of directory listing")))
(define-key diredp-hide/show-menu [hide-all]
  '(menu-item "Hide/Show All Subdirs" dired-hide-all
    :help "Hide all subdirectories, leave only header lines"))
(define-key diredp-hide/show-menu [hide-subdir]
  '(menu-item "Hide/Show Subdir" diredp-hide-subdir-nomove
    :help "Hide or unhide current directory listing"))


;; `Dir' > `Bookmark' menu.
;;
(defvar diredp-bookmark-menu (make-sparse-keymap "Bookmark")
  "`Bookmark' submenu for Dired menu-bar `Dir' menu.")
(define-key diredp-menu-bar-dir-menu [bookmark] (cons "Bookmark" diredp-bookmark-menu))

(define-key diredp-bookmark-menu [diredp-highlight-autofiles-mode]
  '(menu-item "Toggle Autofile Highlighting" diredp-highlight-autofiles-mode
    :help "Toggle whether to highlight autofile bookmarks"
    :visible (and (featurep 'bookmark+)  (featurep 'highlight))))
(define-key diredp-bookmark-menu [diredp-do-bookmark-dirs-recursive]
    '(menu-item "Bookmark Dirs Here and Below..." diredp-do-bookmark-dirs-recursive
      :help "Bookmark this Dired buffer and marked subdirectory Dired buffers, recursively."))
(define-key diredp-bookmark-menu [bookmark-dired]
  '(menu-item "Bookmark Dired Buffer..." bookmark-set :help "Bookmark this Dired buffer"))


;; `Dir' > `Navigate' menu.
;;
(defvar diredp-navigate-menu (make-sparse-keymap "Navigate")
  "`Navigate' submenu for Dired menu-bar `Dir' menu.")
(define-key diredp-menu-bar-dir-menu [navigate] (cons "Navigate" diredp-navigate-menu))

(define-key diredp-navigate-menu [insert]
  '(menu-item "Move To This Subdir" dired-maybe-insert-subdir
    :help "Move to subdirectory line or listing"))
(define-key diredp-navigate-menu [tree-down]
  '(menu-item "Tree Down" dired-tree-down :help "Go to first subdirectory header down the tree"))
(define-key diredp-navigate-menu [tree-up]
  '(menu-item "Tree Up" dired-tree-up :help "Go to first subdirectory header up the tree"))
(define-key diredp-navigate-menu [up]
  '(menu-item "Up Directory" diredp-up-directory :help "Dired the parent directory"))
(define-key diredp-navigate-menu [prev-subdir]
  '(menu-item "Prev Subdir" diredp-prev-subdir :help "Go to previous subdirectory header line"))
(define-key diredp-navigate-menu [next-subdir]
  '(menu-item "Next Subdir" diredp-next-subdir :help "Go to next subdirectory header line"))
(define-key diredp-navigate-menu [prev-dirline]
  '(menu-item "Prev Dirline" diredp-prev-dirline :help "Move to previous directory-file line"))
(define-key diredp-navigate-menu [next-dirline]
  '(menu-item "Next Dirline" diredp-next-dirline :help "Move to next directory-file line"))

(define-key diredp-menu-bar-dir-menu [separator-subdir] '("--")) ; --------------------------

(define-key diredp-menu-bar-dir-menu [image-dired-dired-toggle-marked-thumbs]
  '(menu-item "Toggle Image Thumbnails" image-dired-dired-toggle-marked-thumbs
    :enable (fboundp 'image-dired-dired-toggle-marked-thumbs)
    :help "Add or remove image thumbnails in front of marked file names"))
(when (fboundp 'dired-isearch-filenames) ; Emacs 23+
  (define-key diredp-menu-bar-dir-menu [isearch-filenames-regexp]
    '(menu-item "Isearch Regexp in File Names..." dired-isearch-filenames-regexp
      :help "Incrementally search for regexp in file names only"))
  (define-key diredp-menu-bar-dir-menu [isearch-filenames]
    '(menu-item "Isearch in File Names..." dired-isearch-filenames
      :help "Incrementally search for literal text in file names only.")))
(when (or (> emacs-major-version 21)  (fboundp 'wdired-change-to-wdired-mode))
  (define-key diredp-menu-bar-dir-menu [wdired-mode]
    '(menu-item "Edit File Names (WDired)" wdired-change-to-wdired-mode
      :help "Put a Dired buffer in a mode in which filenames are editable"
      :keys "C-x C-q" :filter (lambda (x) (and (derived-mode-p 'dired-mode)  x)))))
(define-key diredp-menu-bar-dir-menu [diredp-yank-files]
  '(menu-item "Paste Files from Copied Absolute Names" diredp-yank-files
    :help "Paste files here whose absolute names you copied"
    :enable (catch 'dir-menu--yank-files
              (let ((files  (car kill-ring-yank-pointer)))
                (and (stringp files)
                     (dolist (file  (split-string files))
                       (unless (file-name-absolute-p file) (throw 'dir-menu--yank-files nil)))))
              t)))
(when (fboundp 'dired-compare-directories) ; Emacs 22+
  (define-key diredp-menu-bar-dir-menu [compare-directories]
    '(menu-item "Compare Directories..." dired-compare-directories
      :help "Mark files with different attributes in two Dired buffers")))

(define-key diredp-menu-bar-dir-menu [separator-dired-misc] '("--")) ; --------------------

(define-key diredp-menu-bar-dir-menu [diredp-sort-arbitrary-command]
  '(menu-item "Sort Arbitrary File List..." diredp-sort-arbitrary-command
    :enable (consp dired-directory)
    :help "Sort Dired buffer of arbitrary files"))
(define-key diredp-menu-bar-dir-menu [diredp-dired-recent-dirs]
  '(menu-item "Dired Recent Directories..." diredp-dired-recent-dirs
    :visible (boundp 'recentf-list) :enable  (and (boundp 'recentf-list)  (consp recentf-list))
    :help "Open a Dired buffer for recently visited directories"))
(define-key diredp-menu-bar-dir-menu [diredp-dired-recent-files]
  '(menu-item "Dired Recent Files..." diredp-dired-recent-files
    :visible (boundp 'recentf-list) :enable  (and (boundp 'recentf-list)  (consp recentf-list))
    :help "Open a Dired buffer for recently visited files and directories"))
(define-key diredp-menu-bar-dir-menu [diredp-dired-inserted-subdirs]
  '(menu-item "Dired Each Inserted Subdir..." diredp-dired-inserted-subdirs
    :enable (cdr dired-subdir-alist)    ; First elt is current dir.  Must have at least one more.
    :help "Open Dired separately for each of the inserted subdirectories"))
(define-key diredp-menu-bar-dir-menu [diredp-add-to-this-dired-buffer]
  '(menu-item "Add Entries Here..." diredp-add-to-this-dired-buffer
    :help "Add individual file and directory names to the listing"
    :keys "C-x E"))
(define-key diredp-menu-bar-dir-menu [diredp-dired-union]
  '(menu-item "Dired Union..." diredp-dired-union
    :help "Open Dired for the union of some existing Dired buffers"))
(define-key diredp-menu-bar-dir-menu [diredp-fileset-other-window]
  '(menu-item "Dired Fileset..." diredp-fileset-other-window
    :enable (> emacs-major-version 21) :help "Open Dired on an Emacs fileset"))
(define-key diredp-menu-bar-dir-menu [diredp-dired-for-files]
  '(menu-item "Dired Files Located Anywhere" diredp-dired-for-files
    :help "Open Dired on specific files whose names you provide"))

(define-key diredp-menu-bar-dir-menu [separator-dired-on-set] '("--")) ; --------------------

(define-key diredp-menu-bar-dir-menu [diredp-marked-other-window]
  '(menu-item "Dired Marked Files in Other Window" diredp-marked-other-window
    :enable (save-excursion (goto-char (point-min))
                            (and (re-search-forward (dired-marker-regexp) nil t)
                                 (re-search-forward (dired-marker-regexp) nil t)))
    :help "Open Dired on marked files only, in other window"))
(define-key diredp-menu-bar-dir-menu [diredp-marked]
  '(menu-item "Dired Marked Files" diredp-marked
    :enable (save-excursion (goto-char (point-min))
                            (and (re-search-forward (dired-marker-regexp) nil t)
                                 (re-search-forward (dired-marker-regexp) nil t)))
    :help "Open Dired on marked files only"))
(define-key diredp-menu-bar-dir-menu [dired]
  '(menu-item "Dired (Filter via Wildcards)..." dired
    :help "Explore a directory (you can provide wildcards)"))
(define-key diredp-menu-bar-dir-menu [diredp-change-ls-switches]
  '(menu-item "Change `ls' switches..." diredp-change-ls-switches
    :help "Change the `ls' switches for this Dired buffer"))

(define-key diredp-menu-bar-dir-menu [separator-dired] '("--")) ; ---------------------

(define-key diredp-menu-bar-dir-menu [insert]
  '(menu-item "Insert/Move-To This Subdir" dired-maybe-insert-subdir
    :help "Move to subdirectory line or listing"))
(define-key diredp-menu-bar-dir-menu [dired-undo]
  '(menu-item "Undo" dired-undo :help "Undo changes: marks, killed lines, and subdir listings"))
(define-key diredp-menu-bar-dir-menu [revert]
  '(menu-item "Refresh (Sync \& Show All)" revert-buffer :help "Update directory contents"))
(define-key diredp-menu-bar-dir-menu [create-directory] ; Moved from "Immediate".
  '(menu-item "New Directory..." dired-create-directory :help "Create a directory"))


;;; Mouse-3 menu binding.
(define-key dired-mode-map [down-mouse-3] 'diredp-mouse-3-menu)
(define-key dired-mode-map [mouse-3]      'ignore)


;;; Non-menu Dired bindings.

;; Move `dired-omit-mode' to `C-x M-o', so prefix key `M-o' is free for face/font-lock stuff.
(define-key dired-mode-map "\C-x\M-o" (if (fboundp 'dired-omit-mode) 'dired-omit-mode 'dired-omit-toggle))
(when (memq (lookup-key dired-mode-map "\M-o") '(dired-omit-mode dired-omit-toggle))
  (define-key dired-mode-map "\M-o" nil))

;; These are global, not just Dired mode.  They are on prefix key `C-x D'.
(unless (lookup-key ctl-x-map "D")
  (define-key ctl-x-map   "D" nil)      ; For Emacs 20
  (define-key ctl-x-map   "DA" 'diredp-add-to-dired-buffer)                ; `C-x D A'
  (define-key ctl-x-map   "DF" 'diredp-dired-for-files)                    ; `C-x D F'
  (define-key ctl-x-map   "DR" 'diredp-dired-recent-files)                 ; `C-x D R'
  (define-key ctl-x-map   "Dr" 'diredp-dired-recent-dirs)                  ; `C-x D r'
  (define-key ctl-x-map   "DS" 'diredp-fileset)                            ; `C-x D S'
  (define-key ctl-x-map   "DU" 'diredp-dired-union))                       ; `C-x D U'

(unless (lookup-key ctl-x-4-map "D")
  (define-key ctl-x-4-map "D" nil)      ; For Emacs 20
  (define-key ctl-x-4-map "DA" 'diredp-add-to-dired-buffer-other-window)   ; `C-x 4 D A'
  (define-key ctl-x-4-map "DF" 'diredp-dired-for-files-other-window)       ; `C-x 4 D F'
  (define-key ctl-x-4-map "DR" 'diredp-dired-recent-files-other-window)    ; `C-x 4 D R'
  (define-key ctl-x-4-map "Dr" 'diredp-dired-recent-dirs-other-window)     ; `C-x 4 D r'
  (define-key ctl-x-4-map "DS" 'diredp-fileset-other-window)               ; `C-x 4 D S'
  (define-key ctl-x-4-map "DU" 'diredp-dired-union-other-window))          ; `C-x 4 D U'

;; Navigation
(substitute-key-definition 'dired-up-directory 'diredp-up-directory dired-mode-map)
(substitute-key-definition 'dired-next-line 'diredp-next-line dired-mode-map)
(substitute-key-definition 'dired-previous-line 'diredp-previous-line dired-mode-map)
(substitute-key-definition 'dired-next-dirline 'diredp-next-dirline dired-mode-map)
(substitute-key-definition 'dired-prev-dirline 'diredp-prev-dirline dired-mode-map)
(substitute-key-definition 'dired-next-subdir 'diredp-next-subdir dired-mode-map)
(substitute-key-definition 'dired-prev-subdir 'diredp-prev-subdir dired-mode-map)


(define-key dired-mode-map [S-down-mouse-1] 'ignore) ; (normally `mouse-set-font')
;; `diredp-mouse-mark-region-files' provides Windows-Explorer behavior
;; for selecting (marking) files.
(define-key dired-mode-map [S-mouse-1] 'diredp-mouse-mark-region-files)     ; `S-mouse-1'
(define-key dired-mode-map [mouse-2] 'dired-mouse-find-file-other-window)   ; `mouse-2'
;; But be aware that `dired-sort-menu.el' binds `S-mouse-2' to `dired-sort-menu-popup'.
(define-key dired-mode-map [S-down-mouse-2] 'dired-mouse-find-file)         ; `S-mouse-2'
(define-key dired-mode-map [S-mouse-2] 'ignore)
(define-key dired-mode-map [M-mouse-2] 'diredp-mouse-find-file-other-frame) ; `M-mouse-2'

;; On Windows, bind more.
(eval-after-load "w32-browser"
  '(progn
    (define-key dired-mode-map [(control return)] 'dired-w32explore)                ; `C-RET'
    (define-key dired-mode-map [(meta return)] 'dired-w32-browser)                  ; `M-RET'
    (define-key dired-mode-map [mouse-2] 'dired-mouse-w32-browser)                  ; `mouse-2'
    (define-key dired-mode-map (kbd "<C-M-return>") 'dired-multiple-w32-browser)))  ; `C-M-RET'

(when (fboundp 'diredp-w32-drives)
  (when (< emacs-major-version 21) (define-key dired-mode-map ":"    nil)) ; For Emacs 20
  (define-key dired-mode-map ":/"    'diredp-w32-drives))                            ; `:/'

;; Other keyboard keys
;;
(define-key dired-mode-map "@"           nil) ; For Emacs 20
(define-key dired-mode-map "@@"          'diredp-do-apply-to-marked)                ; `@ @'
;;; (define-key dired-mode-map (kbd "@ M-@") 'diredp-do-invoke-in-marked)               ; `@ M-@'
(define-key dired-mode-map (kbd "@ M-x") 'diredp-do-command-in-marked)        ; `@ M-x'
(define-key dired-mode-map (kbd "@ M-:") 'diredp-do-eval-in-marked)                 ; `@ M-:'
(define-key dired-mode-map "$"       'diredp-hide-subdir-nomove)                    ; `$'
(define-key dired-mode-map "\M-$"    'dired-hide-subdir)                            ; `M-$'
(define-key dired-mode-map "="       'diredp-ediff)                                 ; `='
;; This replaces the `dired-x.el' binding of `dired-mark-extension'.
(define-key dired-mode-map "*."      'diredp-mark/unmark-extension)                 ; `* .'
(define-key dired-mode-map "*B"      'diredp-mark-autofiles)                        ; `* B'
(define-key dired-mode-map [(control meta ?*)] 'diredp-marked-other-window)         ; `C-M-*'
(define-key dired-mode-map "\M-a"    'dired-do-search)                              ; `M-a'
(define-key dired-mode-map "\M-b"    'diredp-do-bookmark)                           ; `M-b'
(define-key dired-mode-map "\C-\M-b" 'diredp-set-bookmark-file-bookmark-for-marked) ; `C-M-b'
(when diredp-bind-problematic-terminal-keys
  (define-key dired-mode-map [(control meta shift ?b)]                              ; `C-M-B' (aka `C-M-S-b')
    'diredp-do-bookmark-in-bookmark-file))
(define-key dired-mode-map "e"       'diredp-visit-this-file)                       ; `e' (was `dired-find-file')
(define-key dired-mode-map [C-down]  'diredp-visit-next-file)                 ; `C-down' (was `forward-paragraph')
(define-key dired-mode-map [C-up]    'diredp-visit-previous-file)             ; `C-up' (was `backward-paragraph')
(define-key dired-mode-map "\C-\M-g" 'diredp-do-grep)                               ; `C-M-g'
(when (fboundp 'mkhtml-dired-files)     ; In `mkhtml.el'.
  (define-key dired-mode-map "\M-h"  'mkhtml-dired-files))                          ; `M-h'
(define-key dired-mode-map "\C-\M-i" 'diredp-dired-inserted-subdirs)                ; `C-M-i'
(define-key dired-mode-map "\M-q"    (if (< emacs-major-version 21)
                                         'dired-do-query-replace
                                       'dired-do-query-replace-regexp))             ; `M-q'
(when diredp-bind-problematic-terminal-keys
  (define-key dired-mode-map [(control meta shift ?r)]                              ; `C-M-R' (aka `C-M-S-r')
    'diredp-toggle-find-file-reuse-dir))
(define-key dired-mode-map "U"       'dired-unmark-all-marks)                       ; `U'
(substitute-key-definition 'describe-mode 'diredp-describe-mode                     ; `h', `C-h m'
                           dired-mode-map (current-global-map))
(substitute-key-definition 'dired-mark 'diredp-mark dired-mode-map)                 ; `m', `* m'

;; Tags - same keys as in `*Bookmark List*'.
;;
;; NOTE: If this changes then need to update `dired-sort-menu+.el' to reflect the changes.
;;
(define-key dired-mode-map "T"       nil) ; For Emacs 20
(define-key dired-mode-map "T+"      'diredp-tag-this-file)                ; `T +'
(define-key dired-mode-map "T-"      'diredp-untag-this-file)              ; `T -'
(define-key dired-mode-map "T0"      'diredp-remove-all-tags-this-file)    ; `T 0'
(define-key dired-mode-map "Tc"      'diredp-copy-tags-this-file)          ; `T c'
(define-key dired-mode-map "Tp"      'diredp-paste-add-tags-this-file)     ; `T p'
(define-key dired-mode-map "Tq"      'diredp-paste-replace-tags-this-file) ; `T q'
(define-key dired-mode-map "Tv"      'diredp-set-tag-value-this-file)      ; `T v'
(define-key dired-mode-map "T\M-w"   'diredp-copy-tags-this-file)          ; `T M-w'
(define-key dired-mode-map "T\C-y"   'diredp-paste-add-tags-this-file)     ; `T C-y'
(define-key dired-mode-map "T>+"     'diredp-do-tag)                       ; `T > +'
(define-key dired-mode-map "T>-"     'diredp-do-untag)                     ; `T > -'
(define-key dired-mode-map "T>0"     'diredp-do-remove-all-tags)           ; `T > 0'
(define-key dired-mode-map "T>p"     'diredp-do-paste-add-tags)            ; `T > p'
(define-key dired-mode-map "T>q"     'diredp-do-paste-replace-tags)        ; `T > q'
(define-key dired-mode-map "T>v"     'diredp-do-set-tag-value)             ; `T > v'
(define-key dired-mode-map "T>\C-y"  'diredp-do-paste-add-tags)            ; `T > C-y'
(define-key dired-mode-map "Tm%"     'diredp-mark-files-tagged-regexp)     ; `T m %'
(define-key dired-mode-map "Tm*"     'diredp-mark-files-tagged-all)        ; `T m *'
(define-key dired-mode-map "Tm+"     'diredp-mark-files-tagged-some)       ; `T m +'
(define-key dired-mode-map "Tm~*"    'diredp-mark-files-tagged-not-all)    ; `T m ~ *'
(define-key dired-mode-map "Tm~+"    'diredp-mark-files-tagged-none)       ; `T m ~ +'
(define-key dired-mode-map "Tu%"     'diredp-unmark-files-tagged-regexp)   ; `T u %'
(define-key dired-mode-map "Tu*"     'diredp-unmark-files-tagged-all)      ; `T u *'
(define-key dired-mode-map "Tu+"     'diredp-unmark-files-tagged-some)     ; `T u +'
(define-key dired-mode-map "Tu~*"    'diredp-unmark-files-tagged-not-all)  ; `T u ~ *'
(define-key dired-mode-map "Tu~+"    'diredp-unmark-files-tagged-none)     ; `T u ~ +'
;; $$$$$$ (define-key dired-mode-map [(control ?+)] 'diredp-do-tag)
;; $$$$$$ (define-key dired-mode-map [(control ?-)] 'diredp-do-untag)


;; Vanilla Emacs binds `c' to `dired-do-compress-to'.  Use `M-z' instead'.
;; (`dired-sort-menu.el' binds `c' to `dired-sort-menu-toggle-ignore-case'.)
;;
(when (fboundp 'dired-do-compress-to) ; Emacs 25+
  (define-key dired-mode-map (kbd "M-z") 'dired-do-compress-to))


;; Commands for operating on the current line's file.  When possible,
;; these are lower-case versions of the upper-case commands for operating on
;; the marked files.  (Most of the other corresponding lower-case letters are already
;; defined and cannot be used here.)

;; $$$$$$ (define-key dired-mode-map [(control meta ?+)] 'diredp-tag-this-file)
;; $$$$$$ (define-key dired-mode-map [(control meta ?-)] 'diredp-untag-this-file)
(define-key dired-mode-map "\r"      'dired-find-file)                      ; `RET'
(when (fboundp 'diredp-describe-file)
  (define-key dired-mode-map (kbd "C-h RET")        'diredp-describe-file)  ; `C-h RET'
  (define-key dired-mode-map (kbd "C-h C-<return>") 'diredp-describe-file)) ; `C-h C-RET'
(define-key dired-mode-map "%c"      'diredp-capitalize)                    ; `% c'
(define-key dired-mode-map "b"       'diredp-byte-compile-this-file)        ; `b'
(define-key dired-mode-map [(control shift ?b)] 'diredp-bookmark-this-file) ; `C-B'
(define-key dired-mode-map "\M-c"    'diredp-capitalize-this-file)          ; `M-c'
(when (and (fboundp 'diredp-chgrp-this-file)  diredp-bind-problematic-terminal-keys)
  (define-key dired-mode-map [(control meta shift ?g)] 'diredp-chgrp-this-file)) ; `C-M-G' (aka `C-M-S-g')
(define-key dired-mode-map "\M-i"    'diredp-insert-subdirs)                ; `M-i'
(define-key dired-mode-map "\M-l"    'diredp-downcase-this-file)            ; `M-l'
(define-key dired-mode-map "\C-\M-l" 'diredp-list-marked)                   ; `C-M-l'
(define-key dired-mode-map [(control meta shift ?l)] 'diredp-sort-arbitrary-command) ; `C-M-L' (aka `C-M-S-l')
(when diredp-bind-problematic-terminal-keys
  (define-key dired-mode-map [(meta shift ?m)] 'diredp-chmod-this-file))    ; `M-M' (aka `M-S-m')
(define-key dired-mode-map "\C-o"    'diredp-find-file-other-frame)         ; `C-o'
(when (and (fboundp 'diredp-chown-this-file)  diredp-bind-problematic-terminal-keys)
  (define-key dired-mode-map [(meta shift ?o)] 'diredp-chown-this-file))    ; `M-O' (aka `M-S-o')
(define-key dired-mode-map "\C-\M-o" 'dired-display-file)                   ; `C-M-o' (not `C-o')
(define-key dired-mode-map "\M-p"    'diredp-print-this-file)               ; `M-p'
(define-key dired-mode-map "r"       'diredp-rename-this-file)              ; `r'
(when (fboundp 'image-dired-dired-display-image)
  (define-key dired-mode-map "\C-tI"   'diredp-image-show-this-file))       ; `C-t I'
(when diredp-bind-problematic-terminal-keys
  (define-key dired-mode-map [(meta shift ?t)] 'diredp-touch-this-file)     ; `M-T' (aka `M-S-t')
  (define-key dired-mode-map [(control meta shift ?t)] 'dired-do-touch))    ; `C-M-T' (aka `C-M-S-t')
(define-key dired-mode-map "\M-u"    'diredp-upcase-this-file)              ; `M-u'
(define-key dired-mode-map "y"       'diredp-relsymlink-this-file)          ; `y'
(define-key dired-mode-map "\C-w"    'diredp-move-files-named-in-kill-ring) ; `C-w'
(define-key dired-mode-map "\C-y"    'diredp-yank-files)                    ; `C-y'
(define-key dired-mode-map "z"       'diredp-compress-this-file)            ; `z'
(when (fboundp 'dired-show-file-type)
  (define-key dired-mode-map "_"      'dired-show-file-type))               ; `_' (underscore)
(substitute-key-definition 'kill-line 'diredp-delete-this-file              ; `C-k', `delete', `deleteline'
                           dired-mode-map (current-global-map))


;; Commands that handle marked below, recursively.
;; Use `M-+' as a prefix key for all such commands.

(define-prefix-command 'diredp-recursive-map)
(define-key dired-mode-map "\M-+"  diredp-recursive-map) ; `M-+'

(when (fboundp 'char-displayable-p)     ; Emacs 22+
  (define-key diredp-recursive-map "\M-\C-?"   'diredp-unmark-all-files-recursive))     ; `M-DEL'
(define-key diredp-recursive-map "@@"          'diredp-do-apply-to-marked-recursive)    ; `@ @'
;;; (define-key diredp-recursive-map (kbd "@ M-@") 'diredp-do-invoke-in-marked-recursive)   ; `@ M-@'
(define-key diredp-recursive-map (kbd "@ M-x") 'diredp-do-command-in-marked-recursive) ; `@ M-x'
(define-key diredp-recursive-map (kbd "@ M-:") 'diredp-do-eval-in-marked-recursive)     ; `@ M-:'
(define-key diredp-recursive-map "#"           'diredp-flag-auto-save-files-recursive)  ; `#'
(define-key diredp-recursive-map "*@"          'diredp-mark-symlinks-recursive)         ; `* @'
(define-key diredp-recursive-map "**"          'diredp-mark-executables-recursive)      ; `* *'
(define-key diredp-recursive-map "*/"          'diredp-mark-directories-recursive)      ; `* /'
(define-key diredp-recursive-map "*."          'diredp-mark-extension-recursive)        ; `* .'
(define-key diredp-recursive-map "*("          'diredp-mark-sexp-recursive)             ; `* ('
(define-key diredp-recursive-map "*B"          'diredp-mark-autofiles-recursive)        ; `* B'
(when (fboundp 'char-displayable-p)     ; Emacs 22+
  (define-key diredp-recursive-map "*c"        'diredp-change-marks-recursive))         ; `* c'
(define-key diredp-recursive-map "*%"          'diredp-mark-files-regexp-recursive)     ; `* %'
(when (> emacs-major-version 22)
  (define-key diredp-recursive-map ":d"        'diredp-do-decrypt-recursive)            ; `: d'
  (define-key diredp-recursive-map ":e"        'diredp-do-encrypt-recursive)            ; `: e'
  (define-key diredp-recursive-map ":s"        'diredp-do-sign-recursive)               ; `: s'
  (define-key diredp-recursive-map ":v"        'diredp-do-verify-recursive))            ; `: v'
(define-key diredp-recursive-map "%c"          'diredp-capitalize-recursive)            ; `% c'
(define-key diredp-recursive-map "%g"          'diredp-mark-files-containing-regexp-recursive) ; `% g'
(define-key diredp-recursive-map "%l"          'diredp-downcase-recursive)              ; `% l'
(define-key diredp-recursive-map "%m"          'diredp-mark-files-regexp-recursive)     ; `% m'
(define-key diredp-recursive-map "%u"          'diredp-upcase-recursive)                ; `% u'
(when (fboundp 'dired-do-async-shell-command) ; Emacs 23+
  (define-key diredp-recursive-map "&"         'diredp-do-async-shell-command-recursive)) ; `&'
(define-key diredp-recursive-map "!"           'diredp-do-shell-command-recursive)      ; `!'
(define-key diredp-recursive-map (kbd "C-M-*") 'diredp-marked-recursive-other-window)   ; `C-M-*'
(define-key diredp-recursive-map "A"           'diredp-do-search-recursive)             ; `A'
(define-key diredp-recursive-map "\M-b"        'diredp-do-bookmark-recursive)           ; `M-b'
(when diredp-bind-problematic-terminal-keys
  (define-key diredp-recursive-map [(meta shift ?b)]                                    ; `M-B' (aka `M-S-b')
    'diredp-do-bookmark-dirs-recursive))
(define-key diredp-recursive-map (kbd "C-M-b")                                          ; `C-M-b'
  'diredp-set-bookmark-file-bookmark-for-marked-recursive)
(when diredp-bind-problematic-terminal-keys
  (define-key diredp-recursive-map [(control meta shift ?b)]                            ; `C-M-B' (aka `C-M-S-b')
    'diredp-do-bookmark-in-bookmark-file-recursive))
(define-key diredp-recursive-map "C"           'diredp-do-copy-recursive)               ; `C'
(define-key diredp-recursive-map "D"           'diredp-do-delete-recursive)             ; `D'
(define-key diredp-recursive-map "F"           'diredp-do-find-marked-files-recursive)  ; `F'
(when (fboundp 'diredp-do-chgrp-recursive)
  (define-key diredp-recursive-map "G"         'diredp-do-chgrp-recursive))             ; `G'
(define-key diredp-recursive-map "\C-\M-g"     'diredp-do-grep-recursive)               ; `C-M-g'
(define-key diredp-recursive-map "H"           'diredp-do-hardlink-recursive)           ; `H'
(define-key diredp-recursive-map "\M-i"        'diredp-insert-subdirs-recursive)        ; `M-i'
(define-key diredp-recursive-map "\C-\M-l"     'diredp-list-marked-recursive)           ; `C-M-l'
(define-key diredp-recursive-map "M"           'diredp-do-chmod-recursive)              ; `M'
(when (fboundp 'diredp-do-chown-recursive)
  (define-key diredp-recursive-map "O"         'diredp-do-chown-recursive))             ; `O'
(define-key diredp-recursive-map "P"           'diredp-do-print-recursive)              ; `P'
(define-key diredp-recursive-map "Q"         'diredp-do-query-replace-regexp-recursive) ; `Q'
(define-key diredp-recursive-map "R"           'diredp-do-move-recursive)               ; `R'
(define-key diredp-recursive-map "S"           'diredp-do-symlink-recursive)            ; `S'
(define-key diredp-recursive-map (kbd "M-s a C-s")                                      ; `M-s a C-s'
  'diredp-do-isearch-recursive)
(define-key diredp-recursive-map (kbd "M-s a C-M-s")                                    ; `M-s a C-M-s'
  'diredp-do-isearch-regexp-recursive)
(when diredp-bind-problematic-terminal-keys
  (define-key diredp-recursive-map [(control meta shift ?t)]
    'diredp-do-touch-recursive))                                                        ; `C-M-T' (aka `C-M-S-t')
(define-key diredp-recursive-map "\C-tc"   'diredp-image-dired-comment-files-recursive) ; `C-t c'
(define-key diredp-recursive-map "\C-td"  'diredp-image-dired-display-thumbs-recursive) ; `C-t d'
(define-key diredp-recursive-map "\C-tr"      'diredp-image-dired-delete-tag-recursive) ; `C-t r'
(define-key diredp-recursive-map "\C-tt"       'diredp-image-dired-tag-files-recursive) ; `C-t t'
(when (fboundp 'char-displayable-p)     ; Emacs 22+
  (define-key diredp-recursive-map "U"         'diredp-unmark-all-marks-recursive))     ; `U'
(define-key diredp-recursive-map "\M-("        'diredp-mark-sexp-recursive)             ; `M-('
(define-key diredp-recursive-map "\M-w"        'diredp-copy-filename-as-kill-recursive) ; `M-w'
(define-key diredp-recursive-map "Y"           'diredp-do-relsymlink-recursive)         ; `Y'

(eval-after-load "w32-browser"
  '(define-key diredp-recursive-map (kbd "<C-M-return>") 'diredp-multiple-w32-browser-recursive)) ; `C-M-RET'

;; Undefine some bindings that would try to modify a Dired buffer.  Their key sequences will
;; then appear to the user as available for local (Dired) definition.
(when (fboundp 'undefine-killer-commands) (undefine-killer-commands dired-mode-map))

;;;;;;;;;;;;

(setq diredp-loaded-p  t)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; dired+.el ends here
#+end_src

** dired-details+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220434714952000

#+name: 20210601220434714952000
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; dired-details+.el --- Enhancements to library `dired-details+.el'.
;;
;; Filename: dired-details+.el
;; Description: Enhancements to library `dired-details+.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2005-2018, Drew Adams, all rights reserved.
;; Created: Tue Dec 20 13:33:01 2005
;; Version: 0
;; Package-Requires: ((dired-details "0"))
;; Last-Updated: Mon Jan  1 10:52:44 2018 (-0800)
;;           By: dradams
;;     Update #: 238
;; URL: https://www.emacswiki.org/emacs/download/dired-details%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/DiredDetails
;; Keywords: dired, frames
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `autofit-frame', `dired', `dired-details', `fit-frame',
;;   `misc-fns', `strings', `thingatpt', `thingatpt+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;  This enhances the functionality of library `dired-details.el'.
;;
;;
;;    NOTE: If you use Emacs 24.4 or later, and if you use library
;;          `dired+.el', THEN YOU DO NOT NEED THIS library or library
;;          `dired-details.el'.
;;
;;          Instead, you can use `dired-hide-details-mode'.  Library
;;          `dired+.el' enhances `dired-hide-details-mode' to give it
;;          the same features as `dired-details+.el' provides.  In
;;          that case, use `(require 'dired+.el)', and use option
;;          `diredp-hide-details-propagate-flag' instead of option
;;          `dired-details-propagate-flag'.
;;
;;
;;  `dired-details+.el' enhances `dired-details.el' in these ways:
;;
;;  1. It shrink-wraps Dired's frame whenever you show or hide
;;     details.  For this enhancement, you will need library
;;     `autofit-frame.el'.
;;
;;  2. It updates the listing whenever you create new files or
;;     directories or rename them.
;;
;;  3. It adds user option `dired-details-propagate-flag' which, if
;;     non-nil, propagates the last state you chose to the next Dired
;;     buffer you open.
;;
;;  4. It binds both `)' and `(' to `dired-details-toggle'.
;;
;;  Perhaps #2 corresponds to this TO-DO item in `dired-details.el':
;;
;;    * add a hook for dired-add-file to hide new entries as necessary
;;
;;
;;  ***** NOTE: The following function defined in `dired-details.el'
;;              has been REDEFINED HERE:
;;
;;  `dired-details-activate' - If `dired-details-propagate-flag' is
;;                             non-nil, then use the last state.
;;
;;
;;  Put this in your initialization file (~/.emacs):
;;
;;   (require 'dired-details+)
;;
;;  I also recommend customizing `dired-details-hidden-string' to use
;;  the value "" instead of the default "[...]" - less wasted space.
;;
;;  Note: This library also calls `dired-details-install', activates
;;  show/hide and binds key `)'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2013/07/22 dadams
;;     Hard-require, not soft-require, dired-details.el.
;; 2013/07/19 dadams
;;     Mention in Commentary that you do not need dired-details(+).el for Emacs
;;       24.4 or later.
;; 2013/07/13 dadams
;;     If dired-hide-details-mode is defined, bind that to (, like vanilla Emacs.
;; 2011/01/04 dadams
;;     Added autoload cookies for defcustom.
;; 2009/06/07 dadams
;;     eval-after-load dired-details, and require dired.  Thx to Suvayu Ali.
;;     dired-details-propagate-flag: Added :group's.  Thx to Thierry Volpiatto.
;; 2008/03/28 dadams
;;     Do everything while widened.
;; 2008/03/08 dadams
;;     dired-details-activate: Save restriction.
;; 2008/03/04 dadams
;;     dired-details-activate:
;;       Widen, then delete overlays initially, to trim new lines from, e.g. `C'.
;;     Removed advised functions: dired-create(-files|directory),
;; 2007/09/01 dadams
;;     Advised dired-do-chmod.
;; 2006/02/02 dadams
;;     Bind both ) and ( to dired-details-toggle.
;; 2006/01/02 dadams
;;     Advised dired-byte-compile and dired-compress.
;; 2006/01/01 dadams
;;     Advised dired-create-directory.
;; 2005/12/30 dadams
;;     Advised dired-create-files.
;;     dired-details-(show|hide): Only fit frame if it's showing Dired.
;; 2005/12/26 dadams
;;     Updated groups.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to the
;; Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; ;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

;;; Do this `defcustom' first, before we load `dired-details', so we
;;; don't pick up the `defcustom' there.  The default value here is
;;; the empty string, so the overlay doesn't give a false impression
;;; of the current column number.  This is important for frame fitting
;;; (see library `fit-frame.el', required by `autofit-frame.el').
;;;###autoload
(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details :group 'dired :type 'string)

(require 'dired-details) ;; dired-details-hide, dired-details-initially-hide,
                         ;; dired-details-install, dired-details-show,
                         ;; dired-details-state
(require 'autofit-frame nil t) ;; (no error if not found): fit-frame-if-one-window

;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Quiet the byte-compiler.
(defvar dired-details-state)
(defvar dired-details-initially-hide)

;;;;;;;;;;;;;;;;


;;;###autoload
(defcustom dired-details-propagate-flag t
  "*Non-nil means next Dired buffer should be displayed the same.
The last `dired-details-state' value set is used by the next Dired
buffer created."
  :group 'dired-details :group 'dired :type 'boolean)

(defvar dired-details-last-state nil
  "Last `dired-details-state' value.
This is changed each time any Dired buffer's state changes.")



;;; REPLACE ORIGINAL in `dired-details.el'.
;;; Temporarily widen.
;;; Delete overlays to trim new lines from, e.g. `C'.
;;; Use last hide/show state, if `dired-details-propagate-flag'.
;;;
(defun dired-details-activate ()
  "Set up dired-details in the current dired buffer.
Called by `dired-after-readin-hook' on initial display and when a
subdirectory is inserted (with `i').  The state is chosen as follows:
If the state is already established here, leave it alone.
If `dired-details-propagate-flag' is non-nil, then use the last state.
Otherwise, use the default state, as determined by
  `dired-details-initially-hide'."
  (save-excursion
    (save-restriction
      (widen)
      (dired-details-delete-overlays)
      (cond (dired-details-state        ; State chosen in this buffer; respect it.
             (when (eq 'hidden dired-details-state) (dired-details-hide)))
            ((and dired-details-propagate-flag ; Inherit state from previous.
                  dired-details-last-state)
             (when (eq 'hidden dired-details-last-state) (dired-details-hide)))
            (t
             ;;otherwise, use the default state
             (when dired-details-initially-hide (dired-details-hide)))))))

;; The test (get-buffer-window (current-buffer)) is to make sure that
;; Dired is already displayed.  If not, the selected frame is not what
;; we want to fit.
(eval-after-load "dired-details"
  '(progn
    (require 'dired)
    (dired-details-install)
    ;; Override bindings in `dired-details-install'.
    (define-key dired-mode-map "(" (if (fboundp 'dired-hide-details-mode)
                                       'dired-hide-details-mode ; Restore vanilla
                                     'dired-details-toggle))
    (define-key dired-mode-map ")" 'dired-details-toggle)
    (defadvice dired-details-show (after fit-dired-frame activate)
      "Save `dired-details-last-state'.  Fit Dired frame if `one-window-p'."
      (setq dired-details-last-state dired-details-state)
      (when (and (get-buffer-window (current-buffer))
                 (fboundp 'fit-frame-if-one-window))
        (fit-frame-if-one-window)))

    (defadvice dired-details-hide (after fit-dired-frame activate)
      "Save `dired-details-last-state'.  Fit Dired frame if `one-window-p'."
      (setq dired-details-last-state dired-details-state)
      (when (and (get-buffer-window (current-buffer))
                 (fboundp 'fit-frame-if-one-window))
        (fit-frame-if-one-window)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'dired-details+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; dired-details+.el ends here
#+end_src

** doremi-frm.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220444734995300

#+name: 20210601220444734995300
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; doremi-frm.el --- Incrementally adjust face attributes and frame parameters.
;;
;; Filename: doremi-frm.el
;; Description: Incrementally adjust face attributes and frame parameters.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2004-2021, Drew Adams, all rights reserved.
;; Created: Sat Sep 11 10:40:32 2004
;; Version: 0
;; Package-Requires: ((doremi "0") (faces+ "0") (frame-fns "0") (hexrgb "0"))
;; Last-Updated: Tue Mar 30 10:43:56 2021 (-0700)
;;           By: dradams
;;     Update #: 3078
;; URL: https://www.emacswiki.org/emacs/download/doremi-frm.el
;; Doc URL: https://www.emacswiki.org/emacs/DoReMi
;; Keywords: frames, extensions, convenience, keys, repeat, cycle
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `backquote', `bytecomp', `cconv', `cl-lib',
;;   `col-highlight', `crosshairs', `custom', `doremi', `faces',
;;   `faces+', `frame-cmds', `frame-fns', `hexrgb', `hl-line',
;;   `hl-line+', `macroexp', `misc-cmds', `misc-fns', `mwheel',
;;   `palette', `ring', `strings', `thingatpt', `thingatpt+',
;;   `timer', `vline', `widget'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Do Re Mi commands to incrementally adjust face attributes and
;;    frame parameters using arrow keys or mouse wheel.
;;
;;  When you invoke the Do Re Mi iterative commands defined here, you
;;  can press and hold an up/down arrow key, or rotate the mouse
;;  wheel, to change face attributes or frame parameters.  For more
;;  information, see file `doremi.el', in particular the doc-string
;;  for function `doremi'.
;;
;;  NOTE: Functions and variables in this library have the prefix
;;        `doremi-'.  In order to more easily distinguish commands
;;        that iterate in Do Re Mi fashion from other functions in the
;;        library, the iterative commands are suffixed with `+'.
;;
;;  Note about saving changes made with the commands defined here:
;;
;;    Some of the commands defined here change face parameters.  User
;;    option `doremi-customization-status' controls whether, and if so
;;    how, Customize is to be informed about these changes.  In any
;;    case, the commands do not save any changes they make.  If you
;;    want to save the changes then you will need to tell Customize to
;;    do that.
;;
;;    The default value of option `doremi-customization-status' is
;;    `customized', which means to tell Customize that the changes
;;    were made by Customize itself, that is, just as if you had set
;;    the new values using the Customize UI.  In this case, you can
;;    use command `customize-unsaved' (aka `customize-customized') to
;;    open Customize for all of the changed faces.  You can then save
;;    any of them individualy (using its `State' menu, item `Save for
;;    Future Sessions') or click the button (`Apply and Save') to save
;;    all of them at once.
;;
;;    If the value of option `doremi-customization-status' is
;;    `outside' then changes made by the commands here are considered
;;    by Customize to have been made outside Customize, that is, as
;;    so-called "rogue" changes.  This is how Customize considers
;;    changes made by command `set-face-foreground', for example.  In
;;    this case, if you want to save the changes then you can use
;;    command `customize-rogue' to open Customize for them.
;;
;;    If the value of option `doremi-customization-status' is anything
;;    else then Customize is not informed of the changes made by
;;    commands defined here.  You see the changes in the current Emacs
;;    session, but Customize does not recognize them.  In this case
;;    there is no way to know what the changes were, and hence no way
;;    to save them except by noting the current color values (e.g.,
;;    using `C-u C-x =') and then explicitly setting them in a way
;;    that Customize will recognize, such as using the Customize UI or
;;    a command such as `set-face-foreground'.
;;
;;    Frame parameter changes, such as background color, are different
;;    from face changes (though the background color of face `default'
;;    is used as the default value for frame parameter
;;    `background-color').  When you change the background or
;;    foreground color of a given frame, this change is not associated
;;    with any particular persistent setting in the same way that a
;;    face change is associated with a face, whose customization can
;;    be saved.  That is, there is no single variable for saving
;;    changes to parameters of the current frame.
;;
;;    Instead, the frame settings that are persistent are the alist
;;    options that determine the default characteristics of certain
;;    *kinds* of frame, not individual frames.  These include:
;;    `default-frame-alist', `initial-frame-alist',
;;    `special-display-frame-alist', and `minibuffer-frame-alist' (if
;;    you use a standalone minibuffer frame).  The complete list of
;;    such frame alist variables is available using function
;;    `frame-alist-var-names', defined in library `frame-cmds.el'.
;;
;;    After you use Do Re Mi commands that change a frame background
;;    or foreground color, if you want to save that new appearance in
;;    one of the frame alist variables then you need to obtain the
;;    current color and use it to customize the alist variable.
;;
;;    Example: Suppose you change the background color of a frame, and
;;    you want to make it the default background color for new frames
;;    in the future.  You will need to update the value of variable
;;    `default-frame-alist', so that it uses the `background-color'
;;    parameter setting of the changed frame.
;;
;;    You can easily copy one or all parameter values from any given
;;    frame to any frame alist variable (such as
;;    `default-frame-alist'), by using the commands
;;    `set-frame-alist-parameter-from-frame' and
;;    `set-all-frame-alist-parameters-from-frame'.  Those commands are
;;    defined in library `frame-cmds.el'.  Alternatively, you can use
;;    `M-: (frame-parameters)' to show all of the current parameter
;;    values for the selected frame, and then customize the alist
;;    variable to use any of them you like.
;;
;;  Note on available color names:
;;
;;    Color names supported by your Emacs release and platform are
;;    those returned by function `x-color-names'.  This often includes
;;    names that are essentially the same as duplicates, e.g.,
;;    "LightBlue" and "light blue".  By default, Do Re Mi
;;    canonicalizes these names by lowercasing them and removing
;;    whitespace.  Then it removes the duplicates.  This behavior is
;;    governed by option `hexrgb-canonicalize-defined-colors-flag'.
;;    Customize that option to nil if you need the original names.
;;
;;
;;  User options defined here:
;;
;;    `doremi-customization-status', `doremi-frame-config-ring-size',
;;    `doremi-move-frame-wrap-within-display-flag',
;;    `doremi-push-frame-config-for-cmds-flag',
;;    `doremi-RGB-increment-factor', `doremi-wrap-color-flag'.
;;
;;
;;  Commands defined here:
;;
;;    `doremi-all-faces-bg+', `doremi-all-faces-fg+',
;;    `doremi-all-frames-bg+', `doremi-all-frames-fg+', `doremi-bg+',
;;    `doremi-bg-blue+', `doremi-bg-brightness+',
;;    `doremi-bg-color-name+', `doremi-bg-cyan+', `doremi-bg-green+',
;;    `doremi-bg-hue+', `doremi-bg-hue-stepping-saturation+',
;;    `doremi-bg-magenta+', `doremi-bg-purity+', `doremi-bg-red+',
;;    `doremi-bg-saturation+', `doremi-bg-value+',
;;    `doremi-bg-yellow+', `doremi-buffer-font-size+',
;;    `doremi-face-bg+', `doremi-face-bg-color-name+',
;;    `doremi-face-bg-hue-stepping-saturation+', `doremi-face-fg+',
;;    `doremi-face-fg-color-name+',
;;    `doremi-face-fg-hue-stepping-saturation+', `doremi-fg+',
;;    `doremi-fg-blue+', `doremi-fg-brightness+',
;;    `doremi-fg-color-name+', `doremi-fg-cyan+', `doremi-fg-green+',
;;    `doremi-fg-hue+', `doremi-fg-hue-stepping-saturation+',
;;    `doremi-fg-magenta+', `doremi-fg-purity+', `doremi-fg-red+',
;;    `doremi-fg-saturation+', `doremi-fg-value+',
;;    `doremi-fg-yellow+', `doremi-font+', `doremi-font-size+',
;;    `doremi-frame-configs+', `doremi-frame-font-size+',
;;    `doremi-frame-height+', `doremi-frame-horizontally+',
;;    `doremi-frame-vertically+', `doremi-frame-width+',
;;    `doremi-increment-background-color',
;;    `doremi-increment-color-component',
;;    `doremi-increment-face-bg-color',
;;    `doremi-increment-face-fg-color',
;;    `doremi-increment-foreground-color',
;;    `doremi-set-background-color', `doremi-set-foreground-color',
;;    `doremi-toggle-wrap-color', `doremi-undo-last-face-change',
;;    `doremi-undo-last-frame-color-change',
;;    `toggle-doremi-wrap-color'.
;;
;;
;;  Non-interactive functions defined here:
;;
;;    `doremi-adjust-increment-for-color-component',
;;    `doremi-all-faces-bg/fg-1', `doremi-all-frames-bg/fg-1',
;;    `doremi-bg-1', `doremi-bg/fg-color-name-1', `doremi-delete-if',
;;    `doremi-face-bg/fg-1', `doremi-face-bg/fg-color-name-1',
;;    `doremi-face-color-component',
;;    `doremi-face-hue-stepping-saturation', `doremi-face-set',
;;    `doremi-fg-1', `doremi-frame-color-component',
;;    `doremi-frame-config-wo-parameters',
;;    `doremi-frame-hue-stepping-saturation',
;;    `doremi-frame-new-position',
;;    `doremi-increment-background-color-1', `doremi-increment-color',
;;    `doremi-increment-face-color',
;;    `doremi-increment-face-color-read-args', `doremi-face-default',
;;    `doremi-increment-blue', `doremi-increment-foreground-color-1',
;;    `doremi-increment-frame-color', `doremi-increment-green',
;;    `doremi-increment-red', `doremi-push-current-frame-config',
;;    `doremi-push-frame-config-for-command', `doremi-read-component',
;;    `doremi-read-increment-arg', `doremi-set-frame-color',
;;    `doremi-update-face-customization-status',
;;    `doremi-wrap-or-limit-color-component'.
;;
;;
;;  Internal variables defined here:
;;
;;    `doremi-current-increment', `doremi-frame-config-ring',
;;    `doremi-last-face-value', `doremi-last-frame-color'.
;;
;;
;;  See also these related Do Re Mi libraries:
;;
;;    `doremi-mac.el' - Macro to define Do Re Mi commands and
;;                      automatically add them to a Do Re Mi menu.
;;    `doremi-cmd.el' - Do Re Mi commands not dealing with frames.
;;
;;  See also these files for other frame commands:
;;
;;     `autofit-frame.el' - Automatically fit each frame to its
;;                          selected window.  Uses `fit-frame.el'.
;;
;;     `fit-frame.el'     - 1) Fit a frame to its selected window.
;;                          2) Incrementally resize a frame.
;;
;;     `frame-cmds.el'    - Various frame and window commands.
;;
;;     `thumb-frm.el'     - Shrink frames to a thumbnail size and
;;                          restore them again.
;;
;;     `zoom-frm.el'      - Zoom a frame, so that its font becomes
;;                          larger or smaller.
;;
;;
;;  Put this in your init file (`~/.emacs'): (require 'doremi-frm)
;;
;;  Suggested key bindings:
;;
;;   (defalias 'doremi-prefix (make-sparse-keymap))
;;   (defvar doremi-map (symbol-function 'doremi-prefix)
;;     "Keymap for Do Re Mi commands.")
;;   (define-key global-map "\C-xt" 'doremi-prefix)
;;   (define-key doremi-map "a" 'doremi-all-faces-fg+)    ; "All"
;;   (define-key doremi-map "c" 'doremi-bg+)              ; "Color"
;;   (define-key doremi-map "f" 'doremi-face-fg+)         ; Face"
;;   (define-key doremi-map "h" 'doremi-frame-height+)
;;   (define-key doremi-map "t" 'doremi-font+)            ; "Typeface"
;;   (define-key doremi-map "u" 'doremi-frame-configs+)   ; "Undo"
;;   (define-key doremi-map "x" 'doremi-frame-horizontally+)
;;   (define-key doremi-map "y" 'doremi-frame-vertically+)
;;   (define-key doremi-map "z" 'doremi-font-size+))      ; "Zoom"
;;
;;  Customize the menu.  Uncomment this to try it out.
;;
;;   (defvar menu-bar-doremi-menu (make-sparse-keymap "Do Re Mi"))
;;   (define-key global-map [menu-bar doremi]
;;     (cons "Do Re Mi" menu-bar-doremi-menu))
;;   (define-key menu-bar-doremi-menu [doremi-frame-configs+]
;;     '(menu-item "Frame Configurations"  doremi-frame-configs+
;;       :help "Cycle among frame configurations recorded: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-font+]
;;     '(menu-item "Font"  doremi-font+
;;       :help "Successively cycle among fonts, choosing by name: `up'/`down'"))
;;   (when (fboundp 'text-scale-increase)    ; Emacs 23+.
;;     (define-key menu-bar-doremi-menu [doremi-buffer-font-size+]
;;       '(menu-item "Buffer Text Size (Zoom)" doremi-buffer-font-size+
;;         :help "Change text size for buffer incrementally: `up'/`down'")))
;;   (define-key menu-bar-doremi-menu [doremi-frame-font-size+]
;;     '(menu-item "Frame Font Size (Zoom)" doremi-frame-font-size+
;;       :help "Change font size for frame incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-all-frames-fg+]
;;     '(menu-item "All Frame Foregrounds..." doremi-all-frames-fg+
;;       :help "Change foreground of all frames incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-all-frames-bg+]
;;     '(menu-item "All Frame Backgrounds..." doremi-all-frames-bg+
;;       :help "Change background of all frames incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-undo-last-frame-color-change]
;;     '(menu-item "Undo Frame Color Change" doremi-undo-last-frame-color-change
;;       :enable doremi-last-frame-color
;;       :help "Undo the last frame color change by `doremi-fg+' or `doremi-bg+'"))
;;   (define-key menu-bar-doremi-menu [doremi-fg-color-name+]
;;     '(menu-item "Frame Foreground Name..." doremi-fg-color-name+
;;       :help "Change frame foreground color incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-fg+]
;;     '(menu-item "Frame Foreground..." doremi-fg+
;;       :help "Change frame foreground color incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-bg-color-name+]
;;     '(menu-item "Frame Background Name..." doremi-bg-color-name+
;;       :help "Change frame background color incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-bg+]
;;     '(menu-item "Frame Background..." doremi-bg+
;;       :help "Change frame background color incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-all-faces-fg+]
;;     '(menu-item "All Faces - Foreground..." doremi-all-faces-fg+
;;       :help "Change foreground color of all faces incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-all-faces-bg+]
;;     '(menu-item "All Faces - Background..." doremi-all-faces-bg+
;;       :help "Change background color of all faces incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-undo-last-face-change]
;;     '(menu-item "Undo Face Color Change" doremi-undo-last-face-change
;;       :enable (facep 'doremi-last-face) ; Actually, it's always non-nil.
;;       :help "Undo the last face color change by Do Re Mi"))
;;   (define-key menu-bar-doremi-menu [doremi-face-fg-color-name+]
;;     '(menu-item "Face Foreground Name..." doremi-face-fg-color-name+
;;       :help "Change foreground color name of a face incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-face-fg+]
;;     '(menu-item "Face Foreground..." doremi-face-fg+
;;       :help "Change foreground color of a face incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-face-bg-color-name+]
;;     '(menu-item "Face Background Name..." doremi-face-bg-color-name+
;;       :help "Change background color name of a face incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-face-bg+]
;;     '(menu-item "Face Background..." doremi-face-bg+
;;       :help "Change background color of a face incrementally: `up'/`down'"))
;;   (define-key menu-bar-doremi-menu [doremi-frame-vertically+]
;;     '(menu-item "Move Frame" doremi-frame-vertically+
;;       :help "Move frame incrementally: `up'/`down'/`left'/`right'"))
;;   (define-key menu-bar-doremi-menu [doremi-frame-height+]
;;     '(menu-item "Frame Size" doremi-frame-height+
;;       :help "Resize frame incrementally: `up'/`down'/`left'/`right'"))
;;
;;
;;  TO DO?
;;
;;    1. Factor out more common stuff between foreground and background.
;;    2. Make it easy to turn on and off doremi-push-frame-config stuff.
;;    3. Integrate more with Customize.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2020/11/05 dadams
;;     Wrap soft-require of palette.el with condition-case to ignore error if error hard-requiring vline.el.
;; 2015/07/26 dadams
;;     Added: doremi-customization-status, doremi-update-face-customization-status.
;;     doremi-increment-color, doremi-face-(bg|fg)-hue-stepping-saturation+,
;;       doremi-face-(bg|fg)+:
;;         Use doremi-update-face-customization-status.
;;     doremi-face-bg/fg-1:
;;       Removed put of properties customized-face and face-modified onto FACE.
;; 2015/07/08 dadams
;;     doremi-increment-color:
;;       Raise error if x-color-values returns nil (probably from "unspecified-[bf]g").
;;     Everywhere: Use %S, not %s in error messages for unknown values.
;; 2013/06/06 dadams
;;     Do not require ring+.el unless prior to Emacs 23.
;; 2012/03/02 dadams
;;     Added doremi-delete-if: to avoid runtime load of cl.el.
;;     doremi-frame-config-wo-parameters: Use doremi-delete-if.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non def* sexps and non-interactive functions.
;;     Added missing autoload cookies for defgroup, defcustom, defalias, commands.
;; 2010/10/19 dadams
;;     doremi-frame-color-component, doremi-bg/fg-color-name-1, doremi-set-frame-color:
;;       Replace frame-update-face-colors with frame-set-background-mode for > Emacs 20.
;; 2009/11/14 dadams
;;     Added: doremi(-face)-(bg|fg)-hue-stepping-saturation+,
;;            doremi-(face|frame)-hue-stepping-saturation.  (No keys bound.)  Thx to Ahei.
;; 2009/11/10 dadams
;;     Added: doremi(-face)-bg/fg-color-name-1.  Thx to Ahei.
;;     doremi(-face)-(bg|fg)-color-name+: Use doremi(-face)-bg/fg-color-name-1.  Add args.
;; 2009/11/07 dadams
;;     Added: doremi-adjust-increment-for-color-component, doremi-face-bg/fg-1,
;;            doremi-face-color-component, doremi-increment-face-color
;;            doremi-face-default, doremi-increment-(blue|green|red),
;;            doremi-all-(frames|faces)-bg/fg-1,
;;     doremi-all-frames-(bg|fg)+: Use *-all-frames-bg/fg-1, *-read-component.
;;                                 Set increment to 1 if nil.  Use only visible frames.
;;     doremi-face-(bg|fg)+:
;;       Added interactive-p arg.  Use *-face-bg/fg-1.  Set *-last-face-value only when
;;       interactive.  Wrap in condition-case for C-g.  Handle R, H, and list of
;;       increments, via *-face-bg/fg-1 and *-face-color-component.
;;     doremi-all-faces-(bg|fg)+: Use *-all-faces-bg/fg-1 (handles R, H, increment list).
;;     doremi-all-(frames|faces)-bg/fg-1 (new), doremi-(frame|face)-color-component:
;;       Use *-adjust-increment-for-color-component.
;;     doremi-increment-color: Use doremi-increment-(blue|green|red).
;; 2009/11/05 dadams
;;     Renamed all Do Re Mi iterative commands by appending +.
;; 2009/11/04 dadams
;;     Added: doremi-(bg|fg)-1, doremi-current-increment, doremi-frame-color-component,
;;            doremi-increment-(back|fore)ground-color-1,
;;            doremi-increment-frame-color, doremi-read-component, doremi-set-frame-color.
;;     doremi-read-increment-arg: Redefined - allow list of numbers, added LENGTH arg.
;;     doremi-increment-color: Allow a list value for increment.
;;     Use doremi-read-increment-arg everywhere, with args 3 and 1.
;;     doremi-(bg|fg), doremi-increment-(back|fore)ground-color:
;;       Added interactive-p arg.  Use doremi-read-component.
;;       Set *-last-frame-color only when interactive.
;;       Use *-1 helper fn.  Wrap in condition-case for C-g.
;;     doremi-(bg|fg): Handle R, H, and a list of increments, via *-(bg|fg)-1 and
;;                     *-frame-color-component.
;;     doremi-set-(back|fore)ground-color: Use doremi-set-frame-color.
;; 2009/11/03 dadams
;;     Renamed: doremi-number-arg to doremi-read-increment-arg.
;; 2009/11/02 dadams
;;     Added: doremi-face-(bg|fg)-color-name, doremi-fg-color-name.  Thx to Ahei.
;;     doremi-face-(bg|fg): Added unwind-protect, to delete sample buffer & window.
;;                          Inhibit frame fitting.
;;     doremi-(bg|fg)-color-name, doremi-increment-color-component:
;;       Use the function hexrgb-defined-colors(-alist), not the constant.
;;     doremi-face-set: Don't define it for Emacs 20.
;; 2009/08/05 dadams
;;     doremi-RGB-increment-factor: Changed default value to 1.
;;     doremi-increment-*ground-color: Back up doremi-last-frame-color if interactive.
;; 2009/08/04 dadams
;;     Added: doremi-RGB-increment-factor.
;;     doremi(-all-(frames|faces)|-face)-(bg|fg):
;;       Use doremi-RGB-increment-factor, not 256.
;;     doremi-all-faces-(bg|fg): Scale by doremi-RGB-increment-factor (forgot to scale).
;;     Thx to Stefan Guath.
;; 2009/06/26 dadams
;;     doremi-frame-width, doremi-frame-horizontally:
;;       Use new key-list options, doremi-...-keys (not -key).
;; 2008/01/03 dadams
;;     doremi(-face)-(bg|fg), doremi-all-frames-(bg|fg):
;;       Scale increment arg by 256 for RGB.
;;     doremi-increment-color(-component): Do not scale INCREMENT arg by 256 for RGB.
;;     doremi-increment-color: Limit INCREMENT from -100 to 100 for HSV only.
;; 2007/12/31 dadams
;;     doremi-last-face-value: Use copy-face instead of internal-find-face.
;; 2007/12/30 dadams
;;     doremi-all-(faces|frames)-(bg|fg): Bound doremi-wrap-color-flag to nil.
;; 2007/11/01 dadams
;;     doremi-frame-(horizontally|vertically): Don't use doremi-number-arg.
;;     Lowercased all :groups.
;; 2007/10/26 dadams
;;     doremi-last-frame-color: Initial value is nil now.
;;     doremi-undo-last-frame-color-change: Added error message if no last frame color.
;; 2007/10/21 dadams
;;     Renamed: doremi-wrap-or-limit to doremi-wrap-or-limit-color-component.
;;              Redefined it using doremi-limit and doremi-wrap.
;; 2007/10/08 dadams
;;     Use lowercase for defgroup group.
;; 2007/09/30 dadams
;;     doremi-face-set: (setq attrs (cdr attrs)) -> (setq attrs (cddr attrs)).
;; 2006/06/23 dadams
;;     picked-(back|fore)ground -> eyedrop-picked-(back|fore)ground
;;     Require eyedropper.el or palette.el, depending on the Emacs version.
;;     doremi(-face)-(bg|fg):
;;       Added pickup-p arg. Use picked color if pickup-p arg or C-u (not <0).
;;     doremi-(bg|fg)-*: Call doremi-(bg|fg) with pickup-p arg.
;;     Bug fix, doremi(-face)-(bg|fg):
;;       Only pick up picked bg or fg on first call (interactive).
;;       Tolerate no load of pick-up code.
;; 2006/06/06 dadams
;;     Use hexrgb-defined-colors(-alist) instead of x-defined-colors.
;; 2006/05/30 dadams
;;     doremi-increment-color-component: Use hexrgb-color-name-to-hex.
;;     Removed: doremi-color-name-to-RGB.
;; 2006/01/07 dadams
;;      Added :link.
;; 2005/12/26: dadams
;;     Updated group and parent groups.
;; 2005/12/13 dadams
;;     doremi-increment-face-(b|f)g-color:
;;       Bug fix: Only update doremi-last-face(-value) when interactive.
;; 2005/08/09 dadams
;;     Added: doremi-wrap-color-flag, doremi-wrap-or-limit, doremi-toggle-wrap-color,
;;            toggle-doremi-wrap-color.
;;     doremi-increment-color: Take doremi-wrap-color-flag into account.
;;                             Use doremi-wrap-or-limit.
;; 2005/08/02 dadams
;;     Added: doremi-all-faces-(b|f)g, doremi-all-frames-(b|f)g,
;;            doremi-set-(back|fore)ground-color.
;;     doremi-(b|f)g, doremi-increment-(back|fore)ground-color,
;;       doremi-undo-last-frame-color-change, doremi-increment-color: Added frame arg.
;;     doremi-increment-color: Updated doc string.  Lower bound of increment is -100.
;;     doremi-increment-face-(b|f)g-color: Use nil frame arg to doremi-increment-color.
;;                                         Save face arg as last face.
;;     doremi-increment-(back|fore)ground-color: Use doremi-number-arg.
;;     doremi-(b|f)g, doremi-increment-(back|fore)ground-color:
;;       Use doremi-set-(back|fore)ground-color instead of set-(back|fore)ground-color.
;;     doremi-color-name-to-RGB: Use facemenu-read-color, instead of completing-read.
;;     doremi-last-face-value, doremi-last-frame-color: Better default values.
;;     doremi-undo-last-face-change: Error if no last face.
;;     Only require strings.el if read-number is not fboundp.
;; 2005/07/31 dadams
;;     Added: doremi-color-name-to-RGB, doremi-number-arg.
;;     doremi-frame-(horizontally|vertically), doremi-(bg|fg),
;;       doremi-increment-face-color-read-args, doremi-increment-color-component:
;;         Use doremi-number-arg.
;;     doremi-increment-color-component: Made into a command.
;;     doremi-face-(fg|bg): Use doremi-increment-face-color-read-args.
;; 2005/07/29 dadams
;;     Added: doremi-increment-color-component.
;; 2005/07/25 dadams
;;     Added: :prefix to defgroup.
;; 2005/07/17 dadams
;;     doremi-increment-color: Limit increment to 100 max.
;;     Mention in doc strings that increment max is 100.
;; 2005/07/02 dadams
;;     Added: doremi-fg*, doremi-increment-foreground-color,
;;            doremi-undo-last-frame-color-change, doremi-last-frame-color.
;; 2005/07/01 dadams
;;     doremi-face-[fb]g: Added treatment of negative prefix arg (use picked color).
;;     doremi-face-[fb]g-1: Use increment arg, already normalized by caller.
;;     doremi-undo-last-face-change: Use doremi-last-face directly.
;; 2005/06/30 dadams
;;     doremi-face-[fb]g:
;;       Also display sample of face before changes.
;;       Save face before changes, for doremi-undo-last-face-change.
;;       Error if face arg doesn't name a face.
;;     Added: doremi-last-face-value, doremi-undo-last-face-change.
;;     Removed: doremi-face-(fore|back)ground (to faces+.el as face-(fore|back)ground-20+.
;;     Hard require faces+.el.
;; 2005/06/28 dadams
;;     doremi-face-[fb]g: Pop up a sample.
;;     Added: doremi-face-[fb]g-1.
;; 2005/06/26 dadams
;;     doremi-increment-color: Fixed bug when face was a symbol, not a variable - use
;;       apply instead of eval funcall.
;; 2005/06/24 dadams
;;     doremi-face-[bf]g:
;;       1) No longer convert face to internal-get-face form.
;;       2) Use face, instead of face-name.
;;       3) No longer use doremi-face-set.  Use set-face-attribute or modify-face.
;;     doremi-increment-face-[bf]g-color: ensure face via facep, not internal-get-face.
;;     doremi-face-set: No longer use face-spec-set.  This should be OK for Emacs 22,
;;       but it is not used, for now.
;; 2005/05/29 dadams
;;     Renamed: doremi-frame-move-wrap-within-display ->
;;                doremi-move-frame-wrap-within-display-flag.
;; 2005/01/25 dadams
;;     doremi-face-bg, doremi-face-fg (bug fix):
;;       1) Use internal-get-face, not facemenu-get-face.
;;       2) Use face-name for face arg to doremi-face-set.
;;     doremi-increment-face-fg-color (and -bg-) (bug fix): Use internal-get-face.
;;     doremi-frame-move-wrap-within-display: defvar -> defcustom.
;; 2005/01/18 dadams
;;     Added Note on saving changes.
;; 2005/01/16 dadams
;;     1. Added: doremi-face-set, doremi-face-foreground, doremi-face-background.
;;     2. doremi-face-fg, doremi-face-bg, doremi-increment-face-fg-color,
;;        doremi-increment-face-bg-color: Use doremi-face-set and doremi-face-foreground
;;                                        or doremi-face-background.
;; 2005/01/15 dadams
;;     doremi-increment-color and functions that call it: default is hue.
;;     Added: doremi-bg-cyan, doremi-bg-magenta, doremi-bg-yellow.
;; 2005/01/09 dadams
;;     Renamed: doremi-bg-rgb to doremi-bg, doremi-increment-face-bg-hex to
;;       doremi-increment-face-bg-color, doremi-increment-face-fg-hex to
;;       doremi-increment-face-fg-color, doremi-face-bg-rgb to doremi-face-bg,
;;       doremi-face-fg-rgb to doremi-face-fg, doremi-increment-background-hex to
;;       doremi-increment-background-color.
;;     Treat HSV now too: doremi-bg, doremi-increment-background-color, doremi-face-fg,
;;       doremi-increment-face-fg-color, doremi-face-bg,
;;       doremi-increment-face-bg-color, doremi-bg-value.
;;     Added: doremi-bg-hue, doremi-bg-saturation, doremi-bg-value (HSV version),
;;       doremi-bg-brightness, doremi-bg-purity, doremi-push-frame-config-for-cmds-flag,
;;       doremi-increment-color, doremi-increment-face-color-read-args.
;;     doremi-increment-background-color, doremi-increment-face-bg-color,
;;       doremi-increment-face-fg-color: Factored out common parts to create
;;       doremi-increment-color and doremi-increment-face-color-read-args.
;;     Fixed to use characters, not symbols: doremi-bg-red, doremi-bg-green,
;;       doremi-bg-blue, doremi-bg-hue, doremi-bg-saturation, doremi-bg-value,
;;       doremi-bg-brightness, doremi-bg-purity.
;;     Do not do doremi-push-frame-config-for-command by default
;;       (doremi-push-frame-config-for-cmds-flag is nil).
;; 2005/01/08 dadams
;;     Moved doremi-grow-font to frame-cmds.el, and renamed it to enlarge-font.
;; 2005/01/07 dadams
;;     doremi-grow-font: Treat error when new size is too small.
;; 2005/01/01 dadams
;;     defvar -> defcustom.  Added (defgroup doremi-frm).
;; 2004/12/28 dadams
;;     doremi-bg-rgb:
;;       You can now chain from changing one parameter to another.
;;       Color parameter (r,g,b,v) is now character type, not symbol type.
;;       Changed arg order.
;;     doremi-increment-background-hex:
;;       COMPONENT is a character, not symbol.
;;       Changed arg order.
;;     Added: doremi-face-bg-rgb, doremi-face-fg-rgb, doremi-increment-face-bg-hex,
;;            doremi-increment-face-fg-hex.
;; 2004/11/28 dadams
;;     Rewrote doremi-frame-horizontally and doremi-frame-vertically to:
;;       1) move frame off the display
;;       2) wrap frame around display
;;     Added: doremi-frame-new-position, doremi-frame-move-wrap-within-display.
;;     Require frame-fns.el[c].  Hard require ring+.el[c].
;; 2004/10/17 dadams
;;     doremi-grow-font: Fixed for Emacs 21: set point size and width to "*"
;; 2004/10/11 dadams
;;     doremi-frame-(horizontally|vertically):
;;       1. If start off screen, move frame back on screen (no error).
;;       2. Use modify-frame-parameters, not set-frame-position, bc unchanging
;;          value could be a cons.
;;       3. Chain each off of the other, so can use all four arrows.
;; 2004/09/26 dadams
;;     Renamed do-re-mi* to doremi*.
;;     Prefixed everything here with doremi-.
;;     Removed "adjust", "cycle", and "move" from names.
;; 2004/09/23 dadams
;;     doremi-grow-font: Removed font-info stuff (unused).
;;     doremi-frame-width, doremi-frame-horizontally:
;;            Changed key sequences to events.
;; 2004/09/21 dadams
;;     doremi-push-frame-config-for-command: Message only if interactive-p.
;; 2004/09/20 dadams
;;     Added: doremi-bg-blue, doremi-bg-brightness,
;;            doremi-bg-green, doremi-bg-red,
;;            doremi-bg-rgb, doremi-increment-background-hex.
;;     Renamed doremi-adjust-bg-color to doremi-bg-color-name.
;;     Changed suggested binding C-xtc to doremi-bg-rgb.
;;     Apply doremi-push-frame-config-for-command to new commands.
;; 2004/09/19 dadams
;;     Corrected interactive spec for doremi-font-size
;; 2004/09/17 dadams
;;     Added non-nil allow-new-p to doremi-adjust-bg-color
;; 2004/09/11 dadams
;;     Created this from stuff in doremi.el and frame-cmds.el
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'doremi) ;; doremi, doremi-limit, doremi-wrap
(require 'hexrgb) ;; hexrgb-color-name-to-hex, hexrgb-color-values-to-hex,
                  ;; hexrgb-defined-colors, hexrgb-defined-colors-alist,
                  ;; hexrgb-increment-blue, hexrgb-increment-green, hexrgb-increment-red,
                  ;; hexrgb-hsv-to-rgb, hexrgb-rgb-to-hsv
(require 'ring) ;; ring-insert, ring-member, ring-next (Emacs 23)
(unless (fboundp 'ring-member)          ; < Emacs 23
  (require 'ring+)) ;; ring-insert, ring-member, ring-next
(require 'frame-fns) ;; frame-geom-spec-cons, frame-geom-value-cons, get-a-frame
(require 'faces+) ;; face-background-20+, face-foreground-20+, Emacs 20: read-face-name

;; eyedrop-picked-background, eyedrop-picked-foreground
(if (fboundp 'defvaralias) ;; Emacs 22
    (condition-case nil (require 'palette nil t) (error nil)) ; Requires `vline.el'.
  (require 'eyedropper nil t))
(require 'frame-cmds nil t) ;; (no error if not found):
                            ;; frame-configuration-to-register, enlarge-font
                            ;; jump-to-frame-config-register
(unless (fboundp 'read-number)
  (require 'strings nil t)) ;; (no error if not found): read-number (std in Emacs 22)

(eval-when-compile (require 'cl-lib)) ;; case (plus, for Emacs 20: pop)

;; Quiet the byte-compiler
(defvar text-scale-mode)                ; In `face-remap.el' (Emacs 23+)
(defvar text-scale-mode-amount)         ; In `face-remap.el' (Emacs 23+)

;;;;;;;;;;;;;;;;;;;;;;;;

;;; User Options (Variables)

;;;###autoload
(defgroup doremi-frame-commands nil
  "Commands to incrementally adjust face attributes and frame parameters."
  :prefix "doremi-" :group 'doremi :group 'frames :group 'faces
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
doremi-frm.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download"
          "https://www.emacswiki.org/emacs/download/doremi-frm.el")
  :link '(url-link :tag "Description"
          "https://www.emacswiki.org/emacs/Doremi")
  :link '(emacs-commentary-link :tag "Commentary" "doremi-frm")
  )

;;;###autoload
(defcustom doremi-customization-status 'customized
  "How Customize is to treat Do Re Mi face changes.
Value determines whether Customize is aware of the changes and, if so,
how it views them.  If the value is `customized' or `outside' then you
can check what has changed by using command `customize-unsaved' or
`customize-rogue', respectively.  If the value is anything else then
there is no way to know what has changed, because you have effectively
told Customize that nothing has changed.  The default value is
`customize', which means that you can use `customize-unsaved' to show
all changes and optionally save some or all of them.

Value             What Customize Thinks            Command to Check
---------------   ------------------------------   ----------------
`customized'      Changes made using Customize     `customize-unsaved'
`outside'         Changes made outside Customize   `customize-rogue'
anything else     No changes made                  (no command)"
  :type '(choice
          (const :tag "Changes were made by Customize (set, not saved)" 'customized)
          (const :tag "Changes were made outside Customize"             'outside)
          (const :tag "No changes were made"                            'ignore))
  :group 'Doremi-Frame-Commands)

;;;###autoload
(defcustom doremi-frame-config-ring-size 20
  "*Maximum number of stored frame configurations."
  :type 'integer :group 'Doremi-Frame-Commands)

;;;###autoload
(defcustom doremi-move-frame-wrap-within-display-flag t
  "*Non-nil means wrap frame movements within the display.
Commands `doremi-frame-horizontally+' and `doremi-frame-vertically+'
then move the frame back onto the display when it moves off of it.
If nil, you can move the frame as far off the display as you like."
  :type 'boolean :group 'doremi-frame-commands)

;;;###autoload
(defcustom doremi-push-frame-config-for-cmds-flag nil
  "*Non-nil means commands that change frame config save it first.
This is done by advising all commands that change frame configuration
when library `doremi-frm.el' is loaded."
  :type 'boolean :group 'Doremi-Frame-Commands)

;;;###autoload
(defcustom doremi-RGB-increment-factor 1
  "*Factor to scale up RGB incrementing for some Do Re Mi functions.
Because RGB incrementing is by nature finer scale than HSV
incrementing, some Do Re Mi commands automatically scale up the
incrementing by this factor, so you need not iterate (cycle) so many
times to see an appreciable change.  When this is the case, it is
noted for the individual function.

The scale factor to use depends on how many hex digits there are in
your color representations.  A scale factor of 16 (and an input
increment of 1) means that, for each RGB component, it is the second
component digit from the right, not the rightmost, that is incremented
with each key press.  A factor of 256 means that the third digit from
the right cycles.  The default value is 1: no scaling.

If the digit that would be cycled is greater than the length of your
color components, then no incrementation occurs.  For example, if the
colors you use have the format #RRGGBB, so that each component has two
hex digits, then a factor of 256 is not appropriate, since it leaves
the component value unchanged (wraparound).  In that case, change the
value.

In general, 256 is good for colors represented as #RRRRGGGGBBBB, 16 is
good for #RRRGGGBBB, and 1 (no scaling) is appropriate for #RRGGBB.

What counts is the color representation you use, not what Emacs can
actually display for your screen.  On most platforms, Emacs can really
only display 8-bit color components, so #RRGGBB is the best it can do.
But you might well have defined your colors using the format
#RRRRGGGGBBBB.  That's OK, and it lets you see information reflecting
a more precise correspondance between RGB codes and color names, but
that extra precision is in fact ignored by Emacs and your display.

Personally, I use the longer format, ##RRRRGGGGBBBB, because I like to
see more info about the colors I use, even though my display cannot
really distinguish that many.  I also use libraries `hexrgb.el' and
`palette.el', and I convert color information between various formats
\(RGB, HSV, color names).  So I prefer to use the finer-grained
format, even though I can't see all the differences it provides.
Thus, I customize this option to 256.

The commands that use this option to scale up incrementing do so for
convenience.  You can always use other commands that perform no such
scaling.  For example, `doremi-bg+' scales RGB, but you can use
`doremi-increment-background-color' instead, for finer tuning."
  :type 'integer :group 'doremi-frame-commands)

;;;###autoload
(defcustom doremi-wrap-color-flag t
  "*Non-nil means wrap color changes around past the max and min.
For example, if non-nil, a current color value has FFFF as the red
component, and the red component is incremented by 1, then the result
has a red component of 0000.  If nil, the same example yields FFFF,
because the red component is already at its maximum."
  :type 'boolean :group 'doremi-frame-commands)

;;; Internal Variables

(defvar doremi-frame-config-ring (make-ring doremi-frame-config-ring-size)
  "Frame configuration ring.")

;; An Emacs 22 bug doesn't let us add t as a third arg here for `copy-face'.
(defvar doremi-last-face-value (cons 'doremi-last-face
                                     (copy-face 'default 'doremi-last-face))
  "Previous value of the last face changed by Do Re Mi.
That is, changed by `doremi-face-*' or `doremi-undo-last-face-change',
but not by `doremi-all-faces-*'.

A cons with the face name as `car' and the face value as `cdr'.  The
face named `doremi-last-face' is a copy of the face before the change.

Command `doremi-undo-last-face-change' swaps the `cdr' with the
current value of the face named by the `car', so it toggles between
the last two values of the face.")

(defvar doremi-last-frame-color nil
  "Previous value of last frame color changed by Do Re Mi.
That is, changed by `doremi-fg+' or `doremi-bg+' (or
`doremi-undo-last-frame-color-change' or
`doremi-increment-*ground-color' when used interactively), but not by
`doremi-all-frames-fg+' or `doremi-all-frames-bg+'.

A cons with `foreground-color' or `background-color' as `car' and the
color as `cdr'.

Command `doremi-undo-last-frame-color-change' swaps this with the
current color, so it toggles between the last two values.")

(defvar doremi-current-increment 0
  "Increment input by user for current Do Re Mi command.")

;;; Miscellaneous Do Re Mi Frame Commands

;; This command uses an incremental growth function, `enlarge-font',
;; which is defined in `frame-cmds.el'.
;;;###autoload
(defalias 'doremi-font-size+ 'doremi-frame-font-size+)
;;;###autoload
(defun doremi-frame-font-size+ (&optional increment frame)
  "Change font size for FRAME by INCREMENT.
Interactively, INCREMENT is given by the prefix argument.
Optional FRAME parameter defaults to current frame."
  (interactive "p")
  (doremi (lambda (inc) (enlarge-font inc frame)
            (cdr (assq 'font (frame-parameters frame))))
          (cdr (assq 'font (frame-parameters frame)))
          increment
          t))

;; This command uses an incremental growth function, `text-scale-increase',
;; which is defined in `face-remap.el' or (enhanced) in `face-remap+.el'.
(when (fboundp 'text-scale-increase)    ; Emacs 23+.
  (defun doremi-buffer-font-size+ (&optional increment)
    "Change font size for current buffer by INCREMENT steps.
Interactively, INCREMENT is given by the prefix argument."
    (interactive "p")
    (unless (require 'face-remap nil t)
      (error "This command requires library `face-remap.el'"))
    (doremi (lambda (inc)
              (let ((text-scale-mode-step  1.1)) (text-scale-increase inc))
              (if text-scale-mode text-scale-mode-amount 0))
            (if text-scale-mode text-scale-mode-amount 0)
            increment
            t)))

;; You can replace the enumeration list (x-list-fonts "*") with a list
;; of fonts you have.  A short list is easier to work with, but you
;; can use long lists like these too:
;;   (x-list-fonts "*")
;;   (append w32-fixed-font-alist (list (generate-fontset-menu)))
;;
;; For example, you can use a short list like this:
;;
;; ("-*-Garamond-normal-i-*-*-*-*-96-96-p-*-iso8859-2"
;;  "-*-*-normal-r-*-*-15-112-96-96-c-*-fontset-iso8859_1_15"
;;  "-*-Arial-bold-i-*-*-*-*-96-96-p-*-iso8859-1"
;;  "-*-Century Gothic-bold-i-*-*-*-*-96-96-p-*-iso8859-5"
;;  "-*-Microsoft Sans Serif-normal-r-*-*-*-*-96-96-p-*-iso8859-4")
;;
;;;###autoload
(defun doremi-font+ ()
  "Successively cycle among fonts, choosing by name.
Operates on the current frame. Cycled font list is (x-list-fonts \"*\")."
  (interactive)
  (doremi (lambda (newval) (set-frame-font newval) newval)
          (frame-parameter (selected-frame) 'font)
          nil                           ; ignored
          nil                           ; ignored
          (x-list-fonts "*")
          'extend))


;; This command uses an absolute setting function.  It rebinds `doremi-up-keys'
;; and `doremi-down-keys' so they are more intuitive for width.
;;;###autoload
(defun doremi-frame-width+ (&optional increment frame)
  "Change width of current frame incrementally.
Width of frame FRAME is increased in increments of amount INCREMENT."
  (interactive "p")
  (let ((doremi-up-keys          '(left)) ; More intuitive keys for width.
        (doremi-boost-up-keys    '(M-left))
        (doremi-down-keys        '(right))
        (doremi-boost-down-keys  '(M-right)))
    (doremi (lambda (new-val) (set-frame-width frame new-val) new-val)
            (frame-width frame)
            (- increment)))             ; Reverse, so arrows correspond.
  (when (member (car unread-command-events)
                (append doremi-up-keys   doremi-boost-up-keys
                        doremi-down-keys doremi-boost-down-keys))
    (doremi-frame-height+ increment frame)))

;; This command uses an absolute setting function.
;;;###autoload
(defun doremi-frame-height+ (&optional increment frame)
  "Change height of current frame incrementally.
Height of frame FRAME is increased in increments of amount INCREMENT."
  (interactive "p")
  (doremi (lambda (new-val) (set-frame-height frame new-val) new-val)
          (frame-height frame)
          (- increment))                ; Reverse, so arrows correspond.
  (when (member (car unread-command-events) '(left right M-left M-right))
    (doremi-frame-width+ increment frame)))

;; ;; This does the same thing as `doremi-frame-height+'.
;; ;; Example command that uses an incrementing function, `enlarge-frame',
;; ;; defined in `frame-cmds.el'.
;; ;;;###autoload
;; (defun doremi-frame-height-bis+ (&optional increment frame)
;;   "Change frame height incrementally."
;;   (interactive "p")
;;   (doremi (lambda (inc) (enlarge-frame inc frame) (frame-height frame))
;;             (frame-height frame)
;;             (- increment)               ; Reverse, so arrows correspond.
;;             t))

;; Move frame left/right incrementally.
;; This command uses an incremental growth function.
;; Rebinds `doremi-up-keys' and `doremi-down-keys': more intuitive for horizontal.
;; Uses default increment value of 10.
;;;###autoload
(defun doremi-frame-horizontally+ (&optional increment frame)
  "Move frame left/right incrementally.
Prefix arg is the INCREMENT to move (default value interactively: 10).
FRAME defaults to the selected frame.

Variable `doremi-move-frame-wrap-within-display-flag' controls whether
or not you can move the frame completely off the display. The default
behavior (value `t') is to wrap frame movement around the display."
  (interactive
   (list (if current-prefix-arg (prefix-numeric-value current-prefix-arg) 10)))
  (setq increment  (or increment 10)    ; 1 is too small
        frame      (or frame (selected-frame)))
  (let ((doremi-up-keys          '(left)) ; More intuitive keys for width.
        (doremi-boost-up-keys    '(M-left))
        (doremi-down-keys        '(right))
        (doremi-boost-down-keys  '(M-right)))
    (doremi (lambda (incr)
              (modify-frame-parameters
               frame
               (list (list 'left '+ (doremi-frame-new-position frame 'left incr))))
              (frame-geom-spec-cons (assq 'left (frame-parameters frame)) frame))
            (frame-geom-spec-cons (assq 'left (frame-parameters frame)) frame)
            (- increment)               ; Reverse, so arrows correspond.
            t))
  (when (member (car unread-command-events)
                (append doremi-up-keys   doremi-boost-up-keys
                        doremi-down-keys doremi-boost-down-keys))
    (doremi-frame-vertically+ increment frame)))

;; Move frame up/down incrementally.
;; This command uses an incremental growth function.
;; Uses default increment value of 10.
;;;###autoload
(defun doremi-frame-vertically+ (&optional increment frame)
  "Move frame up/down incrementally.
Prefix arg is the INCREMENT to move (default value interactively: 10).
FRAME defaults to the selected frame.

Variable `doremi-move-frame-wrap-within-display-flag' controls whether or
not you can move the frame completely off the display. The default
behavior (value `t') is to wrap frame movement around the display."
  (interactive
   (list (if current-prefix-arg (prefix-numeric-value current-prefix-arg) 10)))
  (setq increment  (or increment 10)    ; 1 is too small
        frame      (or frame (selected-frame)))
  (doremi (lambda (incr)
            (modify-frame-parameters
             frame
             (list (list 'top '+ (doremi-frame-new-position frame 'top incr))))
            (frame-geom-spec-cons (assq 'top (frame-parameters frame)) frame))
          (frame-geom-spec-cons (assq 'top (frame-parameters frame)) frame)
          (- increment)                 ; Reverse, so arrows correspond.
          t)
  (when (member (car unread-command-events) '(left right M-left M-right))
    (doremi-frame-horizontally+ increment frame)))

(defun doremi-frame-new-position (frame type incr)
  "Return the new TYPE position of FRAME, incremented by INCR.
TYPE is `left' or `top'.
INCR is the increment to use when changing the position."
  (let ((new-pos
         (+ incr (cadr (frame-geom-value-cons
                        type (cdr (assq type (frame-parameters frame)))))))
        (display-dimension
         (if (eq 'left type) (x-display-pixel-width) (x-display-pixel-height)))
        (frame-dimension
         (if (eq 'left type) (frame-pixel-width frame) (frame-pixel-height frame))))
    (if (not doremi-move-frame-wrap-within-display-flag)
        new-pos
      (when (< new-pos (- frame-dimension)) (setq new-pos  display-dimension))
      (when (> new-pos display-dimension) (setq new-pos  (- frame-dimension)))
      new-pos)))

(defun doremi-push-current-frame-config ()
  "Push the current frame configuration to `doremi-frame-config-ring'
after removing frame parameters `buffer-list' and `minibuffer'."
  (let ((curr-conf  (doremi-frame-config-wo-parameters (current-frame-configuration)
                                                       '(buffer-list minibuffer))))
    (unless (ring-member doremi-frame-config-ring curr-conf)
      (ring-insert doremi-frame-config-ring curr-conf))))

(defun doremi-frame-config-wo-parameters (frame-config params-to-remove)
  "A copy of FRAME-CONFIG, but without frame parameters PARAMS-TO-REMOVE."
  (cons 'frame-configuration
        (mapcar (lambda (fr+parms)
                  (let ((parms  (copy-sequence (nth 1 fr+parms))))
                    (list (car fr+parms) ; frame
                          (doremi-delete-if (lambda (parm)
                                              (memq (car parm) params-to-remove))
                                            parms)
                          (nth 2 fr+parms)))) ; window config
                (cdr frame-config))))   ; frames alist

;; Define this to avoid requiring `cl.el' at runtime.
(defun doremi-delete-if (predicate list)
  "Remove all occurrences of ITEM in LIST that satisfy PREDICATE.
This is a destructive function: It reuses the storage of LIST whenever
possible."
  (while (and list  (funcall predicate (car list)))
    (setq list  (cdr list)))
  (let ((cl-p  list))
    (while (cdr cl-p)
      (if (funcall predicate (cadr cl-p))
          (setcdr cl-p (cddr cl-p))
        (setq cl-p  (cdr cl-p)))))
  list)

;; NOTE: Frame parameters `buffer-list' and `minibuffer' are ignored
;;       when determining if two frame configurations are equal here.
(defun doremi-push-frame-config-for-command (command)
  "Advise COMMAND to save frame configuration.
You can restore previous frame configurations with \\[doremi-frame-configs+]."
  (when (featurep 'ring+)
    (eval
     `(defadvice ,command (around doremi-push-frame-config-for-command activate)
       "Saves frame configuration. You can restore previous frame configuration \
with \\[doremi-frame-configs+]."
       (doremi-push-current-frame-config)
       (when (fboundp 'frame-configuration-to-register) ; Defined in `frame-cmds.el'
         (frame-configuration-to-register frame-config-register))
       ad-do-it                         ; COMMAND code is executed here.
       (when (interactive-p)
         (message
          (substitute-command-keys
           (if (fboundp 'jump-to-frame-config-register) ; Defined in `frame-cmds.el'
               (format "Use `\\[jump-to-frame-config-register]' (`C-x r j %c') or \
`\\[doremi-frame-configs+]' to restore frames as before (undo)." frame-config-register)
             "Use `\\[doremi-frame-configs+]' to restore frames as before (undo)."))))))))

;; Undo (rotate) frame configuration changes made by the
;; frame-changing commands defined here (see mapcar, at end of file).
;;
;; Note:
;;;###autoload
(defun doremi-frame-configs+ ()
  "Cycle among frame configurations recorded in `doremi-frame-config-ring'."
  (interactive)
  (when (featurep 'ring+)
    (doremi (lambda (newval)            ; Cycle among previous frame configs.
              (set-frame-configuration (ring-next doremi-frame-config-ring newval))
              newval)
            (doremi-frame-config-wo-parameters (current-frame-configuration)
                                               '(buffer-list minibuffer))
            nil
            nil
            doremi-frame-config-ring
            t)))

;;; Background Frame Color Commands

;; (This is for both background and foreground changes.)
;;;###autoload
(defun doremi-undo-last-frame-color-change (&optional frame)
  "Restore last frame color changed by `doremi-fg+' or `doremi-bg+'.
This acts as a toggle between the last two values.
Optional arg FRAME defaults to the selected frame.
  The last frame-color change must have been to FRAME, or the result
  will likely not be what you expect.
Note: This does not undo changes made by `doremi-all-frames-fg+' or
`doremi-all-frames-bg+'"
  (interactive)
  (unless doremi-last-frame-color (error "No undo - no last frame color."))
  (let ((temp  (assq (car doremi-last-frame-color) (frame-parameters frame))))
    (modify-frame-parameters (or frame (selected-frame)) `(,doremi-last-frame-color))
    (setq doremi-last-frame-color  temp)))

;; Do not use this non-interactively - use `doremi-bg-fg-color-name-1'.
;;;###autoload
(defun doremi-bg-color-name+ (&optional frame interactive-p)
  "Successively cycle among background colors, choosing by name.
Operates on FRAME, which is the current frame when interactive."
  (interactive (list (selected-frame) t))
  (let ((curr-bg   (assq 'background-color (frame-parameters frame))))
    (when interactive-p (setq doremi-last-frame-color  curr-bg))
    (condition-case nil
        (doremi-bg/fg-color-name-1 'background-color frame (car curr-bg))
      (quit (modify-frame-parameters frame (list curr-bg))))))

;;;###autoload
(defun doremi-bg-red+ (&optional increment)
  "Change frame background red value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?r increment))

;;;###autoload
(defun doremi-bg-green+ (&optional increment)
  "Change frame background green value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?g increment nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-bg-blue+ (&optional increment)
  "Change frame background blue value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?b increment nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-bg-cyan+ (&optional increment)
  "Change frame background cyan value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?r (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-bg-magenta+ (&optional increment)
  "Change frame background green value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?g (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-bg-yellow+ (&optional increment)
  "Change frame background blue value incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?b (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-bg-hue+ (&optional increment)
  "Change frame background hue incrementally.  See `doremi-bg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-bg+ ?h increment nil (consp current-prefix-arg)))

;;;###autoload
(defalias 'doremi-bg-purity+ 'doremi-bg-saturation+)
;;;###autoload
(defun doremi-bg-saturation+ (&optional increment)
  "Change frame background color saturation incrementally.
Prefix arg is the INCREMENT to change.  See `doremi-bg+'."
  (interactive "p")
  (doremi-bg+ ?s increment nil (consp current-prefix-arg)))

;;;###autoload
(defalias 'doremi-bg-brightness+ 'doremi-bg-value+)
;;;###autoload
(defun doremi-bg-value+ (&optional increment)
  "Change frame background brightness (HSV \"value\") incrementally.
Prefix arg is the INCREMENT to change.  See `doremi-bg+'."
  (interactive "p")
  (doremi-bg+ ?v increment nil (consp current-prefix-arg)))


;; Do NOT use this non-interactively - use `doremi-bg-1'.
;;;###autoload
(defun doremi-bg+ (component &optional increment frame pickup-p interactive-p)
  "Change FRAME's background color incrementally.
Optional arg FRAME defaults to the selected frame.

You are prompted for the color COMPONENT to increment/decrement (a
character):
  `r' - red
  `g' - green
  `b' - blue
  `h' - hue (basic color)
  `s' - saturation (purity)
  `v' - value (brightness)

  `R' - red, green, and blue, at the same time
  `H' - hue, saturation, and value, at the same time

`R' and `H' increment all components of the respective color spaces,
according to the value of INCREMENT.

You can at any time change, to increment/decrement a different color
component (r, g, b, h, s, v, R, or H).  For example, you can type `r'
and use the arrow keys or mouse wheel to change the red component,
then type `b' and use the arrows or wheel to change the blue
component, and so on, all in the same call to `doremi-bg+'.

Tip: To increment or decrement the cyan, magenta, or yellow component,
     just decrement or increment the red, green, or blue component,
     respectively.  CMY is just the opposite direction from RGB.

INCREMENT is the increment to change.  The value can be a number or a
list of 3 numbers.  The default value is 1.  You can use a prefix
argument to specify a number value.  Otherwise, you are prompted to
input the value.

If the value is a list of 3 numbers, they are used to increment the
individual components red, green, and blue, respectively, as well as
hue, saturation, and value, respectively.  If you change the
component(s) to increment, then the original input INCREMENT is
reapplied.

For example, if INCREMENT is (0.2 -0.5 1.1) and the initial COMPONENT
value is `R', then red is incremented by 0.2, green by -0.5, and blue
by 1.1.  If you then hit `h', hue is incremented by 0.2.  If you then
hit `b', blue is incremented by 1.1.

For RGB, INCREMENT is actually multiplied by
`doremi-RGB-increment-factor', for convenience.  If you need finer
control than that provides, use command
`doremi-increment-background-color' to refine the color.  If it seems
that no incrementing occurs, then reduce
`doremi-RGB-increment-factor'.

The initial color value is converted to a hexadecimal RGB (red, green,
blue) string that starts with \"#\".  The initial value is the current
background color of the selected frame.

If `eyedrop-picked-background' is non-nil and you use plain `C-u'
instead of a numeric prefix argument (or, non-interactively, PICKUP-P
is non-nil), then the frame background is first set to the value of
`eyedrop-picked-background'.  This happens only if library
`eyedropper.el' or `palette.el' is loaded.  This lets you pick up a
background color from somewhere, using `eyedrop-pick-background-at-*',
and then use that as the initial value for `doremi-bg+'.

Colors can be expressed in Emacs as color names or hex RGB strings.
Depending on your operating system, the RGB components for a given
Emacs color can have different numbers of hex digits.  For example, on
one system RGB component values might vary from 000 to FFF; on another
system they might vary from 0000 to FFFF.  Incrementing or
decrementing a given color's RGB spec makes it roll over when the
limit (say 000 or FFF) is reached.

As for all Do Re Mi incrementation commands, use
`doremi-boost-up-keys' and `doremi-boost-down-keys' for faster
incrementation.  The change is `doremi-boost-scale-factor' times
faster than for `doremi-up-keys' and `doremi-down-keys'."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1) nil nil t))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'background-color (frame-parameters frame))))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-background) eyedrop-picked-background)
    (doremi-set-background-color eyedrop-picked-background frame))
  (let ((curr-bg   (assq 'background-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-bg-1 component increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-bg))))))

;; Do not use this non-interactively - use `doremi-frame-hue-stepping-saturation'.
;;;###autoload
(defun doremi-bg-hue-stepping-saturation+ (&optional increment frame pickup-p
                                           interactive-p)
  "Increment frame background hue, stepping saturation down after each cycle.
Repeatedly increment hue until it reaches its maximum.  Then increment
saturation once.  Then repeatedly increment hue again - and so on.

You can think of this as moving along a row of the hue x saturation
color plane, then down to the next row and across, and so on.

See `doremi-bg+' for more info (e.g. other args)."
  (interactive (list (doremi-read-increment-arg 3 1) nil nil t))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'background-color (frame-parameters frame))))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-background) eyedrop-picked-background)
    (doremi-set-background-color eyedrop-picked-background frame))
  (unless increment (setq increment  1))
  (let ((curr-bg   (assq 'background-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-frame-hue-stepping-saturation 'background-color increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-bg))))))

;;;###autoload
(defun doremi-all-frames-bg+ (component increment)
  "Change background color of all visible frames incrementally.
You are prompted for the color COMPONENT to increment.
Prefix arg is the INCREMENT to change; the default value is 1.

See command `doremi-bg+'.  This command behaves similarly, but it
changes the background color of all frames, not just one frame.

NOTE: You cannot use `C-g' to cancel and revert changes you make using
this command, and you cannot use `doremi-undo-last-frame-color-change'
to undo changes.  (There is no single initial color to revert to,
since multiple frames are affected.)

For RGB, INCREMENT is multiplied by `doremi-RGB-increment-factor', for
convenience.  If you need finer control than that provides, use
command `doremi-increment-background-color' to refine the color.  If
it seems that no incrementing occurs, then reduce
`doremi-RGB-increment-factor'.

Option `doremi-wrap-color-flag' is bound to nil during this command,
which means that an individual color change stops when the limit is
reached."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)))
  (unless increment (setq increment  1))
  (doremi-all-frames-bg/fg-1 'background-color component increment))

;; Do not use this non-interactively - use `doremi-increment-background-color-1'.
;;;###autoload
(defun doremi-increment-background-color (component increment
                                          &optional frame interactive-p)
  "Change frame background color by INCREMENT of color COMPONENT.
You are prompted for the color COMPONENT to increment/decrement.
COMPONENT and INCREMENT are as for `doremi-increment-color'.
Optional arg FRAME defaults to the selected frame.  See `doremi-bg+'."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)
                     nil 'interactive-p))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'background-color (frame-parameters frame))))
  (let ((curr-bg  (assq 'background-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-increment-background-color-1 component increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-bg))))))

;; A function like this should be available in Emacs.
;;;###autoload
(defun doremi-set-background-color (color-name &optional frame interactive-p)
  "Set the background color of the FRAME to COLOR-NAME.
When called interactively, prompt for the name of the color to use.
To get the frame's current background color, use `frame-parameters'.
This is the same as `set-background-color', except that this accepts a
FRAME parameter."
  (interactive (list (facemenu-read-color) nil 'interactive-p))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'background-color (frame-parameters frame))))
  (doremi-set-frame-color 'background-color color-name frame))

;;; Foreground Frame Color Commands

;; Do not use this non-interactively - use `doremi-bg-fg-color-name-1'.
;;;###autoload
(defun doremi-fg-color-name+ (&optional frame interactive-p)
  "Successively cycle among foreground colors, choosing by name.
Operates on FRAME, which is the current frame when interactive."
  (interactive (list (selected-frame) t))
  (let ((curr-fg   (assq 'foreground-color (frame-parameters frame))))
    (when interactive-p (setq doremi-last-frame-color  curr-fg))
    (condition-case nil
        (doremi-bg/fg-color-name-1 'foreground-color frame (car curr-fg))
      (quit (modify-frame-parameters frame (list curr-fg))))))

;;;###autoload
(defun doremi-fg-red+ (&optional increment)
  "Change frame foreground red value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?r increment nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-green+ (&optional increment)
  "Change frame foreground green value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?g increment nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-blue+ (&optional increment)
  "Change frame foreground blue value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?b increment nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-cyan+ (&optional increment)
  "Change frame foreground cyan value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?r (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-magenta+ (&optional increment)
  "Change frame foreground green value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?g (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-yellow+ (&optional increment)
  "Change frame foreground blue value incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?b (- increment) nil (consp current-prefix-arg)))

;;;###autoload
(defun doremi-fg-hue+ (&optional increment)
  "Change frame foreground hue incrementally.  See `doremi-fg+'.
Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?h increment nil (consp current-prefix-arg)))

;;;###autoload
(defalias 'doremi-fg-purity+ 'doremi-fg-saturation+)
;;;###autoload
(defun doremi-fg-saturation+ (&optional increment)
  "Change frame foreground color saturation incrementally.
See `doremi-fg+'.  Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?s increment nil (consp current-prefix-arg)))

;;;###autoload
(defalias 'doremi-fg-brightness+ 'doremi-fg-value+)
;;;###autoload
(defun doremi-fg-value+ (&optional increment)
  "Change frame foreground brightness (HSV \"value\") incrementally.
See `doremi-fg+'.  Prefix arg is the INCREMENT to change."
  (interactive "p")
  (doremi-fg+ ?v increment nil (consp current-prefix-arg)))


;; Do NOT use this non-interactively - use `doremi-frame-hue-stepping-saturation'.
;;;###autoload
(defun doremi-fg-hue-stepping-saturation+ (&optional increment frame pickup-p
                                           interactive-p)
  "Increment frame foreground hue, stepping saturation down after each cycle.
See `doremi-bg-hue-stepping-saturation+'.
`doremi-fg-hue-stepping-saturation+' is the same, with \"foreground\"
substituted for \"background\"."
  (interactive (list (doremi-read-increment-arg 3 1) nil nil t))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'foreground-color (frame-parameters frame))))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-foreground) eyedrop-picked-foreground)
    (doremi-set-foreground-color eyedrop-picked-foreground frame))
  (unless increment (setq increment  1))
  (let ((curr-fg   (assq 'foreground-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-frame-hue-stepping-saturation 'foreground-color increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-fg))))))

;;;###autoload
(defun doremi-fg+ (component &optional increment frame pickup-p interactive-p)
  "Change FRAME's foreground color incrementally.
See `doremi-bg+'; `doremi-fg+' is the same, with \"foreground\"
substituted for \"background\"."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1) nil nil t))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'foreground-color (frame-parameters frame))))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-foreground) eyedrop-picked-foreground)
    (doremi-set-foreground-color eyedrop-picked-foreground frame))
  (let ((curr-fg   (assq 'foreground-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-fg-1 component increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-fg))))))

;;;###autoload
(defun doremi-all-frames-fg+ (component increment)
  "Change foreground color of all visible frames incrementally.
You are prompted for the color COMPONENT to increment.
Prefix arg is the INCREMENT to change; the default value is 1.

See command `doremi-fg+'.  This command behaves similarly, but it
changes the foreground color of all frames, not just one frame.

NOTE: You cannot use `C-g' to cancel and revert changes you make using
this command, and you cannot use `doremi-undo-last-frame-color-change'
to undo changes.  (There is no single initial color to revert to,
since multiple frames are affected.)

For RGB, INCREMENT is multiplied by `doremi-RGB-increment-factor', for
convenience.  If you need finer control than this, use command
`doremi-increment-foreground-color' to refine the color.  If it seems
that no incrementing occurs, then reduce
`doremi-RGB-increment-factor'.

Option `doremi-wrap-color-flag' is bound to nil during this command,
which means that an individual color change stops when the limit is
reached."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)))
  (unless increment (setq increment  1))
  (doremi-all-frames-bg/fg-1 'foreground-color component increment))

;; Do not use this non-interactively - use `doremi-increment-foreground-color-1'.
;;;###autoload
(defun doremi-increment-foreground-color (component increment
                                          &optional frame interactive-p)
  "Change foreground color of FRAME by INCREMENT of color COMPONENT.
You are prompted for the color COMPONENT to increment/decrement.
COMPONENT and INCREMENT are as for `doremi-increment-color'.
Optional arg FRAME defaults to the selected frame.  See `doremi-bg+'."
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)
                     nil 'interactive-p))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'foreground-color (frame-parameters frame))))
  (let ((curr-fg  (assq 'foreground-color (frame-parameters frame)))
        (curr-frm  frame))
    (condition-case nil
        (doremi-increment-foreground-color-1 component increment frame)
      (quit (modify-frame-parameters curr-frm (list curr-fg))))))

;; A function like this should be available in Emacs.
;;;###autoload
(defun doremi-set-foreground-color (color-name &optional frame interactive-p)
  "Set the foreground color of the FRAME to COLOR-NAME.
When called interactively, prompt for the name of the color to use.
To get the frame's current foreground color, use `frame-parameters'.
This is the same as `set-foreground-color', except that this accepts a
FRAME parameter."
  (interactive (list (facemenu-read-color) nil 'interactive-p))
  (when interactive-p
    (setq doremi-last-frame-color  (assq 'foreground-color (frame-parameters frame))))
  (doremi-set-frame-color 'foreground-color color-name frame))

;;; Face and Color Commands

;;;###autoload
(defalias 'toggle-doremi-wrap-color 'doremi-toggle-wrap-color)
;;;###autoload
(defun doremi-toggle-wrap-color ()
  "Toggle value of `doremi-wrap-color-flag'."
  (interactive)
  (setq doremi-wrap-color-flag  (not doremi-wrap-color-flag)))

;; (This is for both background and foreground changes.)
;;;###autoload
(defun doremi-undo-last-face-change ()
  "Return last face changed by `doremi-face-*' to its previous value.
This acts as a toggle between the last two values of the face.
Note: This does not undo changes made by `doremi-all-faces-fg+' or
`doremi-all-faces-bg+'."
  (interactive)
  (unless (facep 'doremi-last-face) (error "No undo - no last face."))
  (let ((face  (car doremi-last-face-value)))
    (copy-face face 'doremi-temp-face)  ; Save current value face.
    (copy-face 'doremi-last-face face)  ; Restore previous value.
    (setq doremi-last-face-value        ; Be able to get back the changed value.
          (cons face (copy-face 'doremi-temp-face 'doremi-last-face)))))

;;;###autoload
(defun doremi-face-bg+ (face component &optional increment pickup-p interactive-p)
  "Change background color of FACE incrementally.
The color is changed on all frames.
You are prompted for the FACE, the color COMPONENT to increment.
Unless you use a prefix argument, you are prompted for the INCREMENT.

See command `doremi-bg+'.  This command behaves the same, except that
it is the background color of FACE that is changed, not the frame
background color.

For RGB, INCREMENT is actually multiplied by
`doremi-RGB-increment-factor', for convenience.  If you need finer
control than this, use command `doremi-increment-face-bg-color' to
refine the color.  If it seems that no incrementing occurs, then
reduce `doremi-RGB-increment-factor'.

If `eyedrop-picked-background' is non-nil and you use plain `C-u'
instead of a numeric prefix argument (or, non-interactively, PICKUP-P
is non-nil), then the face background is first set to the value of
`eyedrop-picked-background'.  This happens only if library
`eyedropper.el' or `palette.el' is loaded.  This lets you pick up a
background color from somewhere, using `eyedrop-pick-background-at-*',
and then use that as the initial value for `doremi-face-bg+'."
  (interactive `(,@(doremi-increment-face-color-read-args) nil 'interactive-p))
  (unless (facep face)
    (error "Command `doremi-face-bg+': FACE arg is not a face name: %S" face))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-background) eyedrop-picked-background)
    (set-face-background face eyedrop-picked-background))
  ;; Tell Customize how to view the change.
  (doremi-update-face-customization-status face)
  (let ((curr-bg  (face-background-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-bg/fg-1 'background-color face component increment)
      (quit (set-face-background face curr-bg)))))

;; Do not use this non-interactively - use `doremi-face-hue-stepping-saturation'.
;;;###autoload
(defun doremi-face-bg-hue-stepping-saturation+ (face &optional increment pickup-p
                                                interactive-p)
  "Increment FACE background hue, stepping saturation down after each cycle.

See command `doremi-bg-hue-stepping-saturation+'.  This command
behaves the same, except that it is the background color of FACE that
is changed, not the frame background color.
See `doremi-face-bg+' for more info (e.g. other args)."
  (interactive (list (if (< emacs-major-version 21)
                         (read-face-name "Face to change: ")
                       (read-face-name "Face to change"))
                     (doremi-read-increment-arg 3 1)
                     nil
                     t))
  (unless (facep face)
    (error "Command `doremi-face-bg-hue-stepping-saturation+': \
FACE arg is not a face name: %S" face))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-background) eyedrop-picked-background)
    (set-face-background face eyedrop-picked-background))
  ;; Tell Customize how to view the change.
  (doremi-update-face-customization-status face)
  (let ((curr-bg  (face-background-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-hue-stepping-saturation 'background-color face increment)
      (quit (set-face-background face curr-bg)))))

;; Do not use this non-interactively - use `doremi-bg-fg-color-name-1'.
;;;###autoload
(defun doremi-face-bg-color-name+ (face &optional interactive-p)
  "Successively cycle among background colors for FACE, choosing by name.
The color is changed on all frames.
You are prompted for the FACE.

See command `doremi-bg-color-name+'.  This command behaves the same,
except that it is the background color of FACE that is changed, not
the frame background color."
  (interactive (list (read-face-name "Face to change: ") t))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (let ((curr-bg  (face-background-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-bg/fg-color-name-1 'background-color face)
      (quit (set-face-background face curr-bg)))))

;;;###autoload
(defun doremi-all-faces-bg+ (component increment)
  "Change background color of all faces incrementally, for all frames.
See command `doremi-face-bg+'.  This command behaves similarly, but it
is the background color of all faces that is changed, not one face.

For RGB, INCREMENT is actually multiplied by
`doremi-RGB-increment-factor'.  If you need finer control than this,
use command `doremi-increment-face-bg-color' to refine the color.  If
it seems that no incrementing occurs, then reduce
`doremi-RGB-increment-factor'.

Option `doremi-wrap-color-flag' is bound to nil during this command.

NOTE: You cannot use `C-g' to cancel and revert changes you make using
this command, and you cannot use `doremi-undo-last-face-change' to
undo changes.  (There is no single initial color to revert to, since
multiple faces are affected.)"
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)))
  (unless increment (setq increment  1))
  (doremi-all-faces-bg/fg-1 'background-color component increment))

;;;###autoload
(defun doremi-increment-face-bg-color (face component increment)
  "Change background color of FACE by INCREMENT of COMPONENT.
The color is changed on all frames.
You are prompted for the FACE and the color COMPONENT to increment.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (interactive (doremi-increment-face-color-read-args))
  (unless (facep face)
    (error "Command `doremi-increment-face-bg-color': FACE arg is not a face: %S" face))
  (when (interactive-p)
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (doremi-increment-color component increment
                          (or (face-background-20+ face nil 'default)
                              (cdr (assq 'background-color (frame-parameters))))
                          'set-face-background nil face)
  (face-background-20+ face nil 'default)) ; Return new value.

;;;###autoload
(defun doremi-face-fg+ (face component &optional increment pickup-p interactive-p)
  "Change foreground color of FACE incrementally.
See `doremi-face-bg+'; `doremi-face-fg+' is the same, with
\"foreground\" substituted for \"background\"."
  (interactive `(,@(doremi-increment-face-color-read-args) nil 'interactive-p))
  (unless (facep face)
    (error "Command `doremi-face-fg+': FACE arg is not a face name: %S" face))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-foreground) eyedrop-picked-foreground)
    (set-face-foreground face eyedrop-picked-foreground))
  ;; Tell Customize how to view the change.
  (doremi-update-face-customization-status face)
  (let ((curr-fg  (face-foreground-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-bg/fg-1 'foreground-color face component increment)
      (quit (set-face-foreground face curr-fg)))))

;; Do not use this non-interactively - use `doremi-face-hue-stepping-saturation'.
;;;###autoload
(defun doremi-face-fg-hue-stepping-saturation+ (face &optional increment pickup-p
                                                interactive-p)
  "Increment FACE foreground hue, stepping saturation down after each cycle.
See `doremi-face-bg+' for info about the other args."
  (interactive (list (if (< emacs-major-version 21)
                         (read-face-name "Face to change: ")
                       (read-face-name "Face to change"))
                     (doremi-read-increment-arg 3 1)
                     nil
                     t))
  (unless (facep face)
    (error "Command `doremi-face-fg-hue-stepping-saturation+': \
FACE arg is not a face name: %S" face))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (when (and (or pickup-p (and interactive-p (or (consp current-prefix-arg))))
             (boundp 'eyedrop-picked-foreground) eyedrop-picked-foreground)
    (set-face-foreground face eyedrop-picked-foreground))
  ;; Tell Customize how to view the change.
  (doremi-update-face-customization-status face)
  (let ((curr-fg  (face-foreground-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-hue-stepping-saturation 'foreground-color face increment)
      (quit (set-face-foreground face curr-fg)))))

;; Do not use this non-interactively - use `doremi-bg-fg-color-name-1'.
;;;###autoload
(defun doremi-face-fg-color-name+ (face &optional interactive-p)
  "Successively cycle among foreground colors for FACE, choosing by name.
The color is changed on all frames.
You are prompted for the FACE.

See command `doremi-fg-color-name+'.  This command behaves the same,
except that it is the foreground color of FACE that is changed, not
the frame foreground color."
  (interactive (list (read-face-name "Face to change: ") t))
  (when interactive-p
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (let ((curr-fg  (face-foreground-20+ face nil 'default)))
    (condition-case nil
        (doremi-face-bg/fg-color-name-1 'foreground-color face)
      (quit (set-face-foreground face curr-fg)))))

;;;###autoload
(defun doremi-all-faces-fg+ (component increment)
  "Change foreground color of all faces incrementally, for all frames.
See command `doremi-face-fg+'.  This command behaves similarly, but it
is the foreground color of all faces that is changed, not one face.

For RGB, INCREMENT is actually multiplied by
`doremi-RGB-increment-factor'.  If you need finer control than this,
use command `doremi-increment-face-fg-color' to refine the color.  If
it seems that no incrementing occurs, then reduce
`doremi-RGB-increment-factor'.

Option `doremi-wrap-color-flag' is bound to nil during this command.

NOTE: You cannot use `C-g' to cancel and revert changes you make using
this command, and you cannot use `doremi-undo-last-face-change' to
undo changes.  (There is no single initial color to revert to, since
multiple faces are affected.)"
  (interactive (list (doremi-read-component) (doremi-read-increment-arg 3 1)))
  (unless increment (setq increment  1))
  (doremi-all-faces-bg/fg-1 'foreground-color component increment))

;;;###autoload
(defun doremi-increment-face-fg-color (face component increment)
  "Change foreground color of FACE by INCREMENT of COMPONENT.
The color is changed on all frames.
You are prompted for the FACE and the color COMPONENT to increment.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (interactive (doremi-increment-face-color-read-args))
  (unless (facep face)
    (error "Command `doremi-increment-face-fg-color': FACE arg is not a face: %S" face))
  (when (interactive-p)
    (copy-face face 'doremi-last-face)
    (setq doremi-last-face-value  (cons face 'doremi-last-face)))
  (doremi-increment-color component increment
                          (or (face-foreground-20+ face nil 'default)
                              (cdr (assq 'foreground-color (frame-parameters))))
                          'set-face-foreground nil face)
  (face-foreground-20+ face nil 'default)) ; Return new value.

;;;###autoload
(defun doremi-increment-color-component (component color increment)
  "Increase COMPONENT (RGB or HSV) of COLOR by INCREMENT.
Returns a hexadecimal RGB code (a string) for the new color, of the
form #RRRRGGGGBBBB (RRRR: red, GGGG: green, BBBB: blue).

COMPONENT is the color component to increment (a character):
  `r' - red
  `g' - green
  `b' - blue
  `h' - hue (basic color)
  `s' - saturation (purity)
  `v' - value (brightness)
  The default is `h' (hue).
COLOR is a string representing a color.  It can be a color name or a
  hexadecimal RGB string of the form #RRRRGGGGBBBB.
INCREMENT is the increment to increase the value component of COLOR."
  (interactive
   (list (read-char-exclusive           ; Not `doremi-read-component', since no `R', `H'.
          "Adjust red, green, blue, hue, saturation, or value? [rgbhsv]: ")
         ;; Cannot use `facemenu-read-color' here, because we allow "#...".
         (completing-read "Color (name or #rrrrggggbbbb): " (hexrgb-defined-colors-alist))
         (doremi-read-increment-arg 3 1)))
  (setq color  (hexrgb-color-name-to-hex color))
  (let ((hlen  (/ (1- (length color)) 3)) ; length of one hex color, R, G, or B
        result)
    (setq result
          (case component
            (?r (hexrgb-increment-red color hlen increment))
            (?g (hexrgb-increment-green color hlen increment))
            (?b (hexrgb-increment-blue color hlen increment))
            (otherwise
             ;; Convert RGB to HSV.  Convert range 0-65535 to range 0.0-1.0.
             (let* ((rgb         (x-color-values color))
                    (red         (/ (float (nth 0 rgb)) 65535.0))
                    (green       (/ (float (nth 1 rgb)) 65535.0))
                    (blue        (/ (float (nth 2 rgb)) 65535.0))
                    (hsv         (hexrgb-rgb-to-hsv red green blue))
                    (hue         (nth 0 hsv))
                    (saturation  (nth 1 hsv))
                    (value       (nth 2 hsv)))
               (case component
                 (?h (setq hue  (+ hue (/ increment 100.0)))
                     (when (> hue 1.0) (setq hue  (1- hue))))
                 (?v (setq value  (+ value (/ increment 100.0)))
                     (when (> value 1.0) (setq value  (1- value))))
                 (?s (setq saturation  (+ saturation (/ increment 100.0)))
                     (when (> saturation 1.0) (setq saturation  (1- saturation))))
                 ;; Default input COMPONENT is hue.
                 (otherwise (setq hue  (+ hue (/ increment 100.0)))
                            (when (> hue 1.0) (setq hue  (1- hue)))))
               (hexrgb-color-values-to-hex
                (mapcar (lambda (x) (floor (* x 65535.0)))
                        (hexrgb-hsv-to-rgb hue saturation value)))))))
    (when (interactive-p) (message result))
    result))

;;; Helper Functions for Face and Frame Color Commands

(defun doremi-read-component ()
  "Read a color-component character, one of [rgbhsvRH]."
  (read-char-exclusive
         "Adjust red, green, blue, hue, saturation, value, \
all RGB, or HSV? [rgbhsvRH]: "))

(defun doremi-read-increment-arg (&optional length default)
  "Read a Do Re Mi increment argument.
With a prefix argument, use its numerical value.
Otherwise prompt for user input, which must be a number or a list of
numbers.
LENGTH is the number of list elements to allow.  If nil, no limit.
DEFAULT is used if input is empty."
  (when (numberp default) (setq default  (number-to-string default)))
  (setq doremi-current-increment
        (or (and current-prefix-arg (prefix-numeric-value current-prefix-arg))
            (let ((input  (read-from-minibuffer
                           (format "Increment (# or Lisp list of %s%s#s): "
                                   (or length "") (if length " " ""))
                           nil nil 'read nil default))
                  (ok-p   t))
              (while (not (or (numberp input)
                              (and (consp input)
                                   (or (not length)
                                       (and (eq length (length input))
                                            (dotimes (ii (1- length) ok-p)
                                              (setq ok-p (numberp (elt input ii)))))))))
                (message "Not a number or a list of %s%snumbers - try again"
                         (or length "") (if length " " ""))
                (sit-for 1)
                (setq input  (read-from-minibuffer
                              (format "Increment (# or Lisp list of %s%s#s): "
                                      (or length "") (if length " " ""))
                              nil nil 'read nil default)))
              input))))

(defun doremi-increment-face-color-read-args ()
  "Read arguments for functions `doremi*-face-*'.
That is, for functions `doremi-face-bg+', `doremi-face-fg+',
`doremi-increment-face-bg-color', and
`doremi-increment-face-fg-color'.
The arguments read are the face to change, the color component to
increment, and, if no prefix argument, the increment (amount).
If a prefix arg was used, then its numerical value is used as the
increment."
  (list (if (< emacs-major-version 21)
            (read-face-name "Face to change: ")
          (read-face-name "Face to change"))
        (doremi-read-component) (doremi-read-increment-arg 3 1)))

(defun doremi-all-frames-bg/fg-1 (frame-parameter component increment)
  "Iteratively INCREMENT color FRAME-PARAMETER on all frames for COMPONENT.
This is a Do Re Mi cl-loop: increment in response to user actions.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (setq increment  (doremi-adjust-increment-for-color-component component increment))
  (let ((doremi-wrap-color-flag  nil))
    ;; DO RE MI, according to the INCREMENT type: number or list.
    (if (atom increment)
        (doremi (lambda (inc)
                  (dolist (fr  (visible-frame-list))
                    (doremi-increment-frame-color frame-parameter component inc fr))
                  "- N/A -")            ; Irrelevant
                "- N/A -"               ; Irrelevant
                increment
                t)
      (doremi (lambda (inc)
                (dolist (fr  (visible-frame-list))
                  (let ((comp  component))
                    (setq comp  (if (eq comp ?R) ?r ?h))
                    (doremi-increment-frame-color frame-parameter comp (car inc) fr)
                    (setq comp  (if (eq comp ?r) ?g ?s))
                    (doremi-increment-frame-color frame-parameter comp (cadr inc) fr)
                    (setq comp  (if (eq comp ?g) ?b ?v))
                    (doremi-increment-frame-color frame-parameter comp (caddr inc) fr)))
                "- N/A -")              ; Irrelevant
              "- N/A -"                 ; Irrelevant
              increment
              t))
    ;; Recurse with the NEXT-COMPONENT.  Revert increment to `doremi-current-increment'.
    (let ((next-component  (pop unread-command-events)))
      (when (member next-component '(?r ?g ?b ?h ?s ?v ?R ?H))
        (doremi-all-frames-bg/fg-1 frame-parameter next-component
                                   doremi-current-increment)))))

(defun doremi-bg-1 (component &optional increment frame)
  "Non-interactive version of `doremi-bg+'."
  (unless increment (setq increment  1))
  (doremi-frame-color-component 'background-color component increment frame))

(defun doremi-fg-1 (component &optional increment frame)
  "Non-interactive version of `doremi-fg+'."
  (unless increment (setq increment  1))
  (doremi-frame-color-component 'foreground-color component increment frame))

(defun doremi-frame-color-component (frame-parameter component increment &optional frame)
  "Iteratively INCREMENT color FRAME-PARAMETER of FRAME for COMPONENT.
This is a Do Re Mi cl-loop: increment in response to user actions.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (setq increment  (doremi-adjust-increment-for-color-component component increment))
  ;; DO RE MI, according to the INCREMENT type: number or list.
  (if (atom increment)
      (doremi (lambda (inc)
                (doremi-increment-frame-color frame-parameter component inc frame)
                (cdr (assq frame-parameter (frame-parameters frame))))
              (cdr (assq frame-parameter (frame-parameters frame)))
              increment
              t)
    (doremi (lambda (inc)
              (let ((comp  component))
                (setq comp  (if (eq comp ?R) ?r ?h))
                (doremi-increment-frame-color frame-parameter comp (car inc) frame)
                (setq comp  (if (eq comp ?r) ?g ?s))
                (doremi-increment-frame-color frame-parameter comp (cadr inc) frame)
                (setq comp  (if (eq comp ?g) ?b ?v))
                (doremi-increment-frame-color frame-parameter comp (caddr inc) frame)
                (cdr (assq frame-parameter (frame-parameters frame)))))
            (cdr (assq frame-parameter (frame-parameters frame)))
            increment
            t))
  ;; Recurse with the NEXT-COMPONENT.  Revert increment to `doremi-current-increment'.
  (let ((next-component  (pop unread-command-events)))
    (if (> emacs-major-version 20)      ; Update the way faces display
        (frame-set-background-mode frame)
      (frame-update-face-colors frame))
    (when (member next-component '(?r ?g ?b ?h ?s ?v ?R ?H))
      (doremi-frame-color-component frame-parameter next-component
                                    doremi-current-increment frame))))

(defun doremi-adjust-increment-for-color-component (component increment)
  "Return INCREMENT, but adjusted for color COMPONENT.
For [rgbhsv], return a number.  For RH, return a list of 3 numbers.
For [Rrgb], scale the number(s) by `doremi-RGB-increment-factor'."
  (let ((new  increment))
    (if (atom new)
        (when (memq component '(?R ?H)) (setq new  (list new new new)))
      (case component
        ((?r ?h) (setq new  (car new)))
        ((?g ?s) (setq new  (cadr new)))
        ((?b ?v) (setq new  (caddr new)))))
    (when (memq component '(?r ?g ?b)) (setq new  (* new doremi-RGB-increment-factor)))
    (when (eq component ?R)
      (setq new  (mapcar (lambda (in) (* in doremi-RGB-increment-factor)) new)))
    new))

(defun doremi-increment-background-color-1 (component increment &optional frame)
  "Non-interactive version of `doremi-increment-background-color'."
  (doremi-increment-frame-color 'background-color component increment frame))

(defun doremi-increment-foreground-color-1 (component increment &optional frame)
  "Non-interactive version of `doremi-increment-foreground-color'."
  (doremi-increment-frame-color 'foreground-color component increment frame))

(defun doremi-increment-frame-color (frame-parameter component increment &optional frame)
  "Change color FRAME-PARAMETER by INCREMENT of color COMPONENT.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'.
Optional arg FRAME defaults to the selected frame.  See `doremi-bg+'."
  (doremi-increment-color component increment
                          (cdr (assq frame-parameter (frame-parameters frame)))
                          (if (eq frame-parameter 'background-color)
                              'doremi-set-background-color
                            'doremi-set-foreground-color)
                          (or frame (selected-frame)))
;; $$$$$  (if (> emacs-major-version 20)      ; Update the way faces display
;; $$$$$      (frame-set-background-mode frame)
;; $$$$$    (frame-update-face-colors frame))
  (cdr (assq frame-parameter (frame-parameters frame)))) ; Return new value.

(defun doremi-frame-hue-stepping-saturation (frame-parameter increment &optional frame)
  "Increment frame hue for FRAME-PARAMETER, stepping saturation per cycle.
See `doremi-bg+' for info about the other args."
  (doremi (lambda (inc)
            (let ((hue  (hexrgb-hue (or (cdr (assq frame-parameter
                                                   (frame-parameters frame)))
                                        (if (eq frame-parameter 'background-color)
                                            "White"
                                          "Black")))))
              (when (or (> hue 0.99) (< hue 0.01))
                (cond ((> hue 0.9999) (setq hue  0.0))
                      ((< hue 0.0001) (setq hue  1.0)))
                (doremi-increment-frame-color frame-parameter ?s (- inc) frame)
                (doremi-increment-frame-color frame-parameter ?h inc frame)))
            (doremi-increment-frame-color frame-parameter ?h inc frame)
            (cdr (assq frame-parameter (frame-parameters frame))))
          (cdr (assq frame-parameter (frame-parameters frame)))
          increment
          t))

(defun doremi-bg/fg-color-name-1 (frame-parameter frame init-color)
  "Helper function for `doremi-bg-color-name+' and `doremi-fg-color-name+'."
  (let ((set-fn  (if (eq frame-parameter 'background-color)
                     #'set-background-color
                   #'set-foreground-color)))
    (doremi (lambda (newval) (funcall set-fn newval) newval)
            init-color
            nil                         ; ignored
            nil                         ; ignored
            (hexrgb-defined-colors)     ; Enumeration list
            t)
    (if (> emacs-major-version 20)      ; Update the way faces display
        (frame-set-background-mode frame)
      (frame-update-face-colors frame))))

(defun doremi-increment-face-color (frame-parameter face component increment)
  "Change color FRAME-PARAMETER of FACE by INCREMENT of color COMPONENT.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'.
The color is changed on all frames."
  (doremi-increment-color component increment
                          (doremi-face-default frame-parameter face)
                          (if (eq frame-parameter 'foreground-color)
                              #'set-face-foreground
                            #'set-face-background)
                          nil
                          face)
  (doremi-face-default frame-parameter face)) ; Return new value.

(defun doremi-face-default (frame-parameter face)
  "Return a default FACE value for FRAME-PARAMETER.
The FACE's current FRAME-PARAMETER value or, if none, the frame's."
  (or (if (eq frame-parameter 'foreground-color)
          (face-foreground-20+ face nil 'default)
        (face-background-20+ face nil 'default))
      (cdr (assq frame-parameter (frame-parameters)))))

(defun doremi-face-hue-stepping-saturation (frame-parameter face increment)
  "Increment FACE hue for FRAME-PARAMETER, stepping saturation per cycle.
See `doremi-bg+' for info about the other args."
  (doremi (lambda (inc)
            (let ((hue  (hexrgb-hue (or (doremi-face-default frame-parameter face)
                                        (if (eq frame-parameter 'background-color)
                                            "White"
                                          "Black")))))
              (when (or (> hue (- 1.0 (/ inc 100.0))) (< hue (/ inc 100.0)))
                (cond ((> hue (- 1.0 (/ inc 1000.0))) (setq hue  0.0))
                      ((< hue (/ inc 1000.0)) (setq hue  1.0)))
                (doremi-increment-face-color frame-parameter face ?s (- inc))))
            (doremi-increment-face-color frame-parameter face ?h inc)
            (doremi-face-default frame-parameter face))
          (doremi-face-default frame-parameter face)
          increment
          t))

(defun doremi-all-faces-bg/fg-1 (frame-parameter component increment)
  "Iteratively INCREMENT color FRAME-PARAMETER of all faces for COMPONENT.
This is a Do Re Mi cl-loop: increment in response to user actions.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (setq increment  (doremi-adjust-increment-for-color-component component increment))
  (let ((doremi-wrap-color-flag  nil)
        (fn                      (if (eq frame-parameter 'background-color)
                                     'doremi-increment-face-bg-color
                                   'doremi-increment-face-fg-color)))
    (if (atom increment)
        (doremi (lambda (inc)
                  (dolist (face  (face-list)) (funcall fn face component inc))
                  "- N/A -")            ; Irrelevant
                "- N/A -"               ; Irrelevant
                increment
                t)
      (doremi (lambda (inc)
                (dolist (face  (face-list))
                  (let ((comp  component))
                    (setq comp  (if (eq comp ?R) ?r ?h))
                    (funcall fn face comp (car inc))
                    (setq comp  (if (eq comp ?r) ?g ?s))
                    (funcall fn face comp (cadr inc))
                    (setq comp  (if (eq comp ?g) ?b ?v))
                    (funcall fn face comp (caddr inc))))
                "- N/A -")              ; Irrelevant
              "- N/A -"                 ; Irrelevant
              increment
              t))
    ;; Recurse with the NEXT-COMPONENT.  Revert increment to `doremi-current-increment'.
    (let ((next-component  (pop unread-command-events)))
      (when (member next-component '(?r ?g ?b ?h ?s ?v ?R ?H))
        (doremi-all-faces-bg/fg-1 frame-parameter next-component
                                  doremi-current-increment)))))

(defun doremi-face-bg/fg-1 (frame-parameter face component &optional increment)
  "Iteratively INCREMENT color FRAME-PARAMETER of FACE for COMPONENT.
This is a Do Re Mi cl-loop: increment in response to user actions.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'."
  (unless increment (setq increment  1))
  (unwind-protect
       (progn
         (let* ((special-display-regexps         nil)
                (after-make-frame-functions      nil)
                (fit-frame-inhibit-fitting-flag  t)
                (sample-text
                 (format "\n    Sample text in face `%s'\n" face))
                (pop-up-frame-alist
                 (append '((name . "*Face Sample*") (height . 5) (auto-raise . t)
                           (minibuffer) (tool-bar-lines . 0) (menu-bar-lines . 0)
                           (vertical-scroll-bars))
                         `((width ,@ (+ 4 (length sample-text))))
                         (frame-parameters))))
           (with-temp-buffer
             (get-buffer-create "*Face Sample*")
             (pop-to-buffer "*Face Sample*")
             (insert sample-text)
             (goto-char 2)
             (put-text-property 6 (progn (goto-char (point-min)) (forward-line 2) (point))
                                'face face)
             (save-excursion (insert (format "    Previous value of `%s'" face)))
             (put-text-property (point) (save-excursion (forward-line 1) (point))
                                'face 'doremi-last-face)
             (goto-char (point-min))
             (setq buffer-read-only  t)
             (doremi-face-color-component frame-parameter face component increment)
             (if (one-window-p t) (delete-frame) (delete-window))))
         (when (get-buffer "*Face Sample*") (kill-buffer "*Face Sample*"))
         (if (eq frame-parameter 'foreground-color)
             (let ((new-fg  (face-foreground-20+ face nil 'default)))
               (set-face-foreground face new-fg))
           (let ((new-bg  (face-background-20+ face nil 'default)))
             (set-face-background face new-bg)))
         (message (substitute-command-keys
                   "Use `\\[doremi-undo-last-face-change]' to return to previous face \
value. Use `\\[customize-face]' to revisit changes.")))
    (when (get-buffer "*Face Sample*") (kill-buffer "*Face Sample*"))
    (let ((fr  (get-a-frame "*Face Sample*"))) (when fr (delete-frame fr)))))

(defun doremi-face-color-component (frame-parameter face component increment)
  "Iteratively INCREMENT color FRAME-PARAMETER of FACE for COMPONENT.
The color is changed on all frames.
This is a Do Re Mi cl-loop: increment in response to user actions.
FRAME-PARAMETER can be `background-color' or `foreground-color'.
COMPONENT and INCREMENT are as for `doremi-increment-color'.
INCREMENT is scaled here, for RGB, by `doremi-RGB-increment-factor'."
  (setq increment  (doremi-adjust-increment-for-color-component component increment))
  ;; DO RE MI, according to the INCREMENT type: number or list.
  (if (atom increment)
      (doremi (lambda (inc)
                (doremi-increment-face-color frame-parameter face component inc)
                (doremi-face-default frame-parameter face))
              (doremi-face-default frame-parameter face)
              increment
              t)
    (doremi (lambda (inc)
              (let ((comp  component))
                (setq comp  (if (eq comp ?R) ?r ?h))
                (doremi-increment-face-color frame-parameter face comp (car inc))
                (setq comp  (if (eq comp ?r) ?g ?s))
                (doremi-increment-face-color frame-parameter face comp (cadr inc))
                (setq comp  (if (eq comp ?g) ?b ?v))
                (doremi-increment-face-color frame-parameter face comp (caddr inc)))
              (doremi-face-default frame-parameter face))
            (doremi-face-default frame-parameter face)
            increment
            t))
  ;; Recurse with the NEXT-COMPONENT.  Revert increment to `doremi-current-increment'.
  (let ((next-component  (pop unread-command-events)))
    (when (member next-component '(?r ?g ?b ?h ?s ?v ?R ?H))
      (doremi-face-color-component frame-parameter face next-component
                                   doremi-current-increment))))

;; See also `hexrgb-increment-(hue|saturation|value)', for similar logic.
(defun doremi-increment-color (component increment color set-fn
                               &optional frame &rest args)
  "Increment COLOR by INCREMENT of COMPONENT and use for FRAME.
COMPONENT is as for `doremi-bg+' (which see).
For HSV components, INCREMENT is limited here to range -100 to 100.
COLOR is the color to change.
SET-FN is the function used to set the new FRAME parameter value.
  It can set the background or foreground color.
  It must accept FRAME as its final argument.
Optional arg FRAME is passed to SET-FN as its last argument.  It does
  ,*not* default to the selected frame, because for some SET-FNs, such
  as `set-face-foreground', nil means all frames.
ARGS are additional arguments for SET-FN, which appear before the
  color in the calling sequence.  For example, if SET-FN is
  `set-face-foreground', ARGS can be a list containing the face whose
  foreground is to be set."
  (unless (string-match "#" color)      ; Convert color name to #hhh...
    (setq color  (hexrgb-color-values-to-hex (or (x-color-values color)
                                                 (error "No such color: %S" color)))))
  (setq increment  (case component
                     ((?R ?H) (if (consp increment)
                                  increment
                                (list increment increment increment)))
                     ((?r ?h) (if (consp increment) (car increment) increment))
                     ((?g ?s) (if (consp increment) (cadr increment) increment))
                     ((?b ?v) (if (consp increment) (caddr increment) increment))))
  (let ((hlen  (/ (1- (length color)) 3))) ; length of one hex color, R, G, or B
    (case component
      (?R (doremi-increment-red   hlen increment color set-fn frame args)
          (doremi-increment-green hlen increment color set-fn frame args)
          (doremi-increment-blue  hlen increment color set-fn frame args))
      (?r (doremi-increment-red   hlen increment color set-fn frame args))
      (?g (doremi-increment-green hlen increment color set-fn frame args))
      (?b (doremi-increment-blue  hlen increment color set-fn frame args))
      (otherwise                        ; HSV
       (setq increment  (if (atom increment)
                            (max (min increment 100) -100)
                          (list (max (min (car increment)   100) -100)
                                (max (min (cadr increment)  100) -100)
                                (max (min (caddr increment) 100) -100))))

       ;; Convert RGB to HSV.  Convert range 0-65535 to range 0.0-1.0.
       (let* ((rgb         (x-color-values color))
              (red         (/ (float (nth 0 rgb)) 65535.0))
              (green       (/ (float (nth 1 rgb)) 65535.0))
              (blue        (/ (float (nth 2 rgb)) 65535.0))
              (hsv         (hexrgb-rgb-to-hsv red green blue))
              (hue         (nth 0 hsv))
              (saturation  (nth 1 hsv))
              (value       (nth 2 hsv)))
         (case component
           (?H (setq hue
                     (doremi-wrap-or-limit-color-component
                      (+ hue (/ (if (atom increment) increment (car increment)) 100.0)))

                     saturation
                     (doremi-wrap-or-limit-color-component
                      (+ saturation (/ (if (atom increment) increment (cadr increment))
                                       100.0)))

                     value
                     (doremi-wrap-or-limit-color-component
                      (+ value (/ (if (atom increment) increment (caddr increment))
                                  100.0)))))
           (?h (setq hue  (doremi-wrap-or-limit-color-component ; Default is HUE.
                           (+ hue (/ (if (atom increment) increment (car increment))
                                     100.0)))))
           (?s (setq saturation  (doremi-wrap-or-limit-color-component
                                  (+ saturation (/ (if (atom increment)
                                                       increment
                                                     (cadr increment))
                                                   100.0)))))
           (?v (setq value  (doremi-wrap-or-limit-color-component
                             (+ value (/ (if (atom increment) increment (caddr increment))
                                         100.0)))))
           (t  (setq hue  (doremi-wrap-or-limit-color-component ; Default is HUE.
                           (+ hue (/ (if (atom increment) increment (car increment))
                                     100.0))))))
         (apply set-fn (append args
                               (list (hexrgb-color-values-to-hex
                                      (mapcar (lambda (x) (floor (* x 65535.0)))
                                              (hexrgb-hsv-to-rgb hue saturation value))))
                               (list frame)))

         ;; Tell Customize how to view the change.
         (when (memq set-fn '(set-face-foreground set-face-background))
           (doremi-update-face-customization-status (car args))))))))

(defun doremi-increment-red (hlen increment color set-fn frame args)
  "Increment the red component of COLOR using SET-FN, for FRAME.
HLEN is the number of hex digits for the component.
See `doremi-increment-color' for the other args."
  (apply set-fn (append args (list (hexrgb-increment-red
                                    color hlen
                                    (if (atom increment) increment (car increment))
                                    doremi-wrap-color-flag))
                        (list frame))))

(defun doremi-increment-green (hlen increment color set-fn frame args)
  "Increment the green component of COLOR using SET-FN, for FRAME.
HLEN is the number of hex digits for the component.
See `doremi-increment-color' for the other args."
  (apply set-fn (append args (list (hexrgb-increment-green
                                    color hlen
                                    (if (atom increment) increment (cadr increment))
                                    doremi-wrap-color-flag))
                        (list frame))))

(defun doremi-increment-blue (hlen increment color set-fn frame args)
  "Increment the blue component of COLOR using SET-FN, for FRAME.
HLEN is the number of hex digits for the component.
See `doremi-increment-color' for the other args."
  (apply set-fn (append args (list (hexrgb-increment-blue
                                    color hlen
                                    (if (atom increment) increment (caddr increment))
                                    doremi-wrap-color-flag))
                        (list frame))))

(defun doremi-wrap-or-limit-color-component (value)
  "Limit color component VALUE between 0.0 and 1.0.
Wrap around if `doremi-wrap-color-flag'."
  (if doremi-wrap-color-flag
      (doremi-wrap value  0.0  1.0)
    (doremi-limit value  0.0  1.0)))

(defun doremi-face-bg/fg-color-name-1 (frame-parameter face)
  "Helper for `doremi-face-bg-color-name+', `doremi-face-fg-color-name+'."
  (unless (facep face)
    (error "Command `doremi-face-bg-color-name+': FACE arg is not a face name: %S" face))
  (let ((set-fn     (if (eq frame-parameter 'background-color)
                        #'set-face-background
                      #'set-face-foreground))
        (access-fn  (if (eq frame-parameter 'background-color)
                        #'face-background-20+
                      #'face-foreground-20+))
        (attribute  (if (eq frame-parameter 'background-color) :background :foreground)))
    (unwind-protect
         (progn
           (let* ((special-display-regexps         nil)
                  (after-make-frame-functions      nil)
                  (fit-frame-inhibit-fitting-flag  t)
                  (sample-text
                   (format "\n    Sample text in face `%s'\n" face))
                  (pop-up-frame-alist
                   (append '((name . "*Face Sample*") (height . 5) (auto-raise . t)
                             (minibuffer) (tool-bar-lines . 0) (menu-bar-lines . 0)
                             (vertical-scroll-bars))
                           `((width ,@ (+ 4 (length sample-text))))
                           (frame-parameters))))
             (copy-face face 'doremi-last-face)
             (setq doremi-last-face-value  (cons face 'doremi-last-face))
             (with-temp-buffer
               (get-buffer-create "*Face Sample*")
               (pop-to-buffer "*Face Sample*")
               (insert sample-text)
               (goto-char 2)
               (put-text-property
                6 (progn (goto-char (point-min)) (forward-line 2) (point)) 'face face)
               (save-excursion (insert (format "    Previous value of `%s'" face)))
               (put-text-property (point) (save-excursion (forward-line 1) (point))
                                  'face 'doremi-last-face)
               (goto-char (point-min))
               (setq buffer-read-only  t)
               (doremi (lambda (newval) (funcall set-fn face newval) newval)
                       (or (funcall access-fn face nil 'default)
                           (cdr (assq frame-parameter (frame-parameters))))
                       nil              ; ignored
                       nil              ; ignored
                       (hexrgb-defined-colors) ; Enumeration list
                       t)
               (if (one-window-p t) (delete-frame) (delete-window))))
           (let ((new-color  (funcall access-fn face nil 'default)))
             (if (fboundp 'set-face-attribute)
                 (set-face-attribute face nil attribute new-color)
               (modify-face face nil new-color nil nil nil nil))
             (put face 'customized-face
                  (list (list 't (list attribute new-color)))))
           (put face 'face-modified nil)
           (message (substitute-command-keys
                     "Use `\\[doremi-undo-last-face-change]' to return to previous face \
value. Use `\\[customize-face]' to revisit changes.")))
      (when (get-buffer "*Face Sample*") (kill-buffer "*Face Sample*"))
      (let ((fr  (get-a-frame "*Face Sample*"))) (when fr (delete-frame fr))))))

;; A function like this should be available as part of the Customize
;; code, but there is none.
;; This is OK for Emacs 22, but won't work for Emacs 20, because of `set-face-attribute'.
;; We don't bother to use this now.
(when (fboundp 'set-face-attribute)
  (defun doremi-face-set (face spec)
    "Tell Customize that FACE has been set to value SPEC.
SPEC is as for `defface'."
    (let ((attrs  (face-spec-choose spec)))
      (while attrs
        (let ((attribute  (car attrs))
              (value      (cadr attrs)))
          (when attribute
            (set-face-attribute face nil attribute value)))
        (setq attrs  (cddr attrs))))
    (put face 'customized-face spec)
    (message (substitute-command-keys
              "Use `\\[customize-face]' to revisit changes."))))

(defun doremi-set-frame-color (frame-parameter color-name &optional frame)
  "Set the color FRAME-PARAMETER of FRAME to COLOR-NAME.
FRAME-PARAMETER can be `background-color' or `foreground-color'."
  (modify-frame-parameters (or frame (selected-frame))
                           (list (cons frame-parameter color-name)))
  (if (> emacs-major-version 20)        ; Update the way faces display
      (frame-set-background-mode (or frame (selected-frame)))
    (frame-update-face-colors (or frame (selected-frame)))))

(defun doremi-update-face-customization-status (face)
  "Tell Customize how to view updates to FACE by Do Re Mi.
The behavior is controlled by option `doremi-customization-status'.
FACE is a face symbol."
  (case doremi-customization-status
    (customized
     (put face 'customized-face (list (list 't (face-attr-construct face))))
     (put face 'face-modified nil))
    (outside
     (put face 'customized-face nil)
     (put face 'face-modified t))
    (ignore)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Apply `doremi-push-frame-config-for-command' to all commands that change
;; frame configuration.  Only do this if `doremi.el' is loaded, so
;; can use `doremi-frame-configs+'.
(when (and doremi-push-frame-config-for-cmds-flag (featurep 'doremi))
  (mapcar 'doremi-push-frame-config-for-command
          '(doremi-bg+ doremi-bg-blue+ doremi-bg-brightness+ doremi-bg-color-name+
            doremi-bg-cyan+ doremi-bg-green+ doremi-bg-hue+ doremi-bg-magenta+
            doremi-bg-red+ doremi-bg-saturation+ doremi-bg-value+ doremi-bg-yellow+
            doremi-buffer-font-size+ doremi-face-bg+ doremi-face-bg-color-name+
            doremi-face-fg+ doremi-face-fg-color-name+ doremi-fg+ doremi-fg-blue+
            doremi-fg-brightness+ doremi-fg-color-name+ doremi-fg-cyan+
            doremi-fg-green+ doremi-fg-hue+ doremi-fg-magenta+ doremi-fg-red+
            doremi-fg-saturation+ doremi-fg-value+ doremi-fg-yellow+ doremi-font+
            doremi-frame-font-size+ doremi-frame-height+ doremi-frame-width+
            doremi-increment-background-color doremi-increment-face-bg-color
            doremi-increment-face-fg-color enlarge-font
            doremi-frame-horizontally+ doremi-frame-vertically+
            doremi-undo-last-face-change doremi-undo-last-frame-color-change)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'doremi-frm)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; doremi-frm.el ends here
#+end_src

** facemenu+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220449908089400

#+name: 20210601220449908089400
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; facemenu+.el --- Extensions to `facemenu.el'.
;;
;; Filename: facemenu+.el
;; Description: Extensions to `facemenu.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2005-2019, Drew Adams, all rights reserved.
;; Created: Sat Jun 25 14:42:07 2005
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Thu Nov  5 15:26:44 2020 (-0800)
;;           By: dradams
;;     Update #: 1966
;; URL: https://www.emacswiki.org/emacs/download/facemenu%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/CustomizingFaces
;; Doc URL: https://www.emacswiki.org/emacs/HighlightLibrary
;; Keywords: faces, extensions, convenience, menus, local
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid', `backquote', `button', `bytecomp', `cconv', `cl',
;;   `cl-lib', `col-highlight', `crosshairs', `custom', `doremi',
;;   `doremi-frm', `easymenu', `facemenu', `faces', `faces+',
;;   `font-lock-menus', `frame-cmds', `frame-fns', `gv', `help-fns',
;;   `help-fns+', `help-mode', `hexrgb', `hl-line', `hl-line+',
;;   `info', `macroexp', `misc-cmds', `misc-fns', `mwheel', `naked',
;;   `palette', `radix-tree', `ring', `strings', `thingatpt',
;;   `thingatpt+', `timer', `vline', `wid-edit', `wid-edit+',
;;   `widget', `zones'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `facemenu.el'.
;;
;;  This library enhances the "Text Properties" menu.  It adds menu
;;  items to the menu, and provides two different versions of the
;;  menu: one for the menu-bar Edit menu (`facemenu-menu') and one for
;;  the mouse popup menu (`facemenu-mouse-menu').  In standard library
;;  `facemenu.el', these two menus are the same.
;;
;;  Items are added to each of these menus to examine, copy, and
;;  change foreground and background colors in various ways.
;;
;;  In the `C-mouse-2' popup version of the menu
;;  (`facemenu-mouse-menu'), menu items use the character under the
;;  mouse pointer, instead of the character after the text cursor
;;  (point).  For example, in the mouse menu, "Describe Properties"
;;  describes the text properties under the mouse pointer.  This makes
;;  the mouse menu generally more convenient than the menubar menu -
;;  just point and click.
;;
;;  Menu items "Do Re Mi - *" make use of commands `doremi-face-fg+'
;;  `doremi-face-bg+', and `doremi-undo-last-face-change', which are
;;  defined in library `doremi-frm.el'.  They let you change the face
;;  color incrementally, using the arrow keys or the mouse wheel, and
;;  undo such changes.
;;
;;  Menu items "Palette - *" make use of library `palette.el' (which
;;  is available only for Emacs 22 and later).  They let you use a
;;  color palette to change the color.  You can restore the face color
;;  before as it was before palette editing, by using command
;;  `facemenup-face-bg-restore' or `facemenup-face-fg-restore'.
;;
;;  If option `facemenup-palette-update-while-editing-flag' is nil,
;;  then quitting the palette using `q' cancels any color change you
;;  made there, and exiting the palette using `x' effects the color
;;  change.  If the option is non-nil (the default), then each time
;;  you change the palette color the face color changes as well.  This
;;  lets you see the effect immediately, without exiting the palette,
;;  but you cannot then use `q' in the palette to cancel the edit.
;;  But you can still restore the color as it was before the edit.
;;
;;  Both Do Re Mi and the color palette let you change colors by
;;  changing color components, whether RGB (red, green, blue) or HSV
;;  (hue, saturation, value).
;;
;;  In addition, standard commands `facemenu-set-face' (`M-o o') and
;;  `list-faces-display' have been enhanced to let you pick a face to
;;  apply from the *Faces* display.  The face sample text is an action
;;  button that does this.  The face name is a link to the face
;;  description, which also has a link to customize the face.  If the
;;  region is active when you call either of these functions, then
;;  clicking a face's sample text applies the face to the region;
;;  otherwise, it applies the face to newly entered text.  To use this
;;  feature with `facemenu-set-face', use a numeric prefix argument,
;;  such as `C-8'.
;;
;;  The reason for this enhancement to `facemenu-set-face' and
;;  `list-faces-display' is to let you see what face you are choosing:
;;  its appearance, not just its name.  If you use Icicles, then you
;;  do not need this enhancement, because face names are displayed in
;;  *Completions* with their own faces.
;;
;;  Similarly, standard command `list-colors-display' has been
;;  enhanced to open the color palette on a color when you click it.
;;  (Using the palette to edit the color does not change the original
;;  color's definition.)  The palette is useful in this context mainly
;;  to show you the color in context.  In addition, the tooltip is
;;  improved, showing more precise HSV values and decimal RGB.
;;
;;  Standard commands `facemenu-set-face' (`M-o o') and
;;  `facemenu-add-face' have also been enhanced here, so that they
;;  prevent the highlighting that you add from being erased by font
;;  lock.  To take advantage of this, you must use Emacs version 22 or
;;  later, and you must also load library `font-lock+.el'.  I strongly
;;  recommend that you do that.  Otherwise, you cannot use facemenu
;;  commands in a font-locked buffer.
;;
;;  If you load library `highlight.el' before you load `facemenu+.el',
;;  then the commands in that library are also added to the Text
;;  Properties menu, as a Highlight submenu.
;;
;;  If you also use library `zones.el' then narrowing and other
;;  commands record buffer zones (including narrowings) in
;;  buffer-local variable `zz-izones' (by default).  You can use
;;  command `facemenup-add-face-to-regions' to add a face to these
;;  zones, and you can use command
;;  `facemenup-add-face-to-regions-in-buffers' to add a face to all
;;  zones recorded for a given set of buffers.
;;
;;  Commands defined here:
;;
;;    `facemenu-mouse-menu', `facemenup-add-face-to-regions',
;;    `facemenup-add-face-to-regions-in-buffers',
;;    `facemenup-change-bg-of-face-at-mouse+',
;;    `facemenup-change-bg-of-face-at-point+',
;;    `facemenup-change-fg-of-face-at-mouse+',
;;    `facemenup-change-fg-of-face-at-point+',
;;    `facemenup-customize-face-at-mouse',
;;    `facemenup-customize-face-at-point',
;;    `facemenup-describe-text-properties-at-mouse',
;;    `facemenup-face-bg-restore', `facemenup-face-fg-restore',
;;    `facemenup-palette-face-bg-at-mouse',
;;    `facemenup-palette-face-bg-at-point',
;;    `facemenup-palette-face-fg-at-mouse',
;;    `facemenup-palette-face-fg-at-point',
;;    `facemenup-paste-to-face-bg-at-mouse',
;;    `facemenup-paste-to-face-bg-at-point',
;;    `facemenup-paste-to-face-fg-at-mouse',
;;    `facemenup-paste-to-face-fg-at-point',
;;    `facemenu-rgb-format-for-display',
;;    `facemenup-set-face-attribute',
;;    `facemenup-set-face-attribute-at-mouse',
;;    `facemenup-set-face-attribute-at-point',
;;    `facemenup-set-face-bg-RGB-at-mouse',
;;    `facemenup-set-face-bg-RGB-at-point',
;;    `facemenup-set-face-bg-RGB-hex-at-mouse',
;;    `facemenup-set-face-bg-RGB-hex-at-point',
;;    `facemenup-set-face-fg-RGB-at-mouse',
;;    `facemenup-set-face-fg-RGB-at-point',
;;    `facemenup-set-face-fg-RGB-hex-at-mouse',
;;    `facemenup-set-face-fg-RGB-hex-at-point',
;;    `palette-for-background-at-point',
;;    `palette-for-foreground-at-point'.
;;
;;  User options defined here:
;;
;;    `facemenup-palette-update-while-editing-flag'.
;;
;;  Non-interactive functions defined here:
;;
;;    `facemenup-copy-tree' (Emacs 20-21), `facemenup-face-bg',
;;    `facemenup-face-fg', `facemenup-nonempty-region-p',
;;    `facemenup-set-face-attribute-at--1',
;;    `facemenup-set-face-from-list'.
;;
;;  Internal variables defined here:
;;
;;    `facemenu-mouse-menu', `facemenup-err-mouse',
;;    `facemenup-err-point', `facemenup-highlight-menu',
;;    `facemenup-last-face-bg', `facemenup-last-face-changed',
;;    `facemenup-last-face-fg'.
;;
;;  Button types defined here:
;;
;;    `help-facemenu-edit-color', `help-facemenu-set-face'.
;;
;;  Macros defined here:
;;
;;    `facemenu+-with-help-window'.
;;
;;
;;  ***** NOTE: The following functions defined in `facemenu.el'
;;              have been REDEFINED HERE:
;;
;;    `facemenu-add-face' (Emacs 22+),
;;    `facemenu-post-self-insert-function' (Emacs 24+),
;;    `facemenu-read-color', `facemenu-set-face' (Emacs 22+),
;;    `list-colors-print' (Emacs 22+).
;;
;;
;;  ***** NOTE: The following function defined in `faces.el'
;;              has been REDEFINED HERE (Emacs 22+):
;;
;;    `list-faces-display'.
;;
;;  Add this to your init file (~/.emacs):
;;
;;    (require 'facemenu+)
;;
;;
;;  Suggestions, if you use Emacs 22 or later:
;;
;;  1. Load library `font-lock+.el' also, to prevent font lock from
;;     erasing the highlighting you add using `facemenu+.el'.
;;
;;  2. (This is unrelated to `facemenu+.el'.)  Customize option
;;     `facemenu-listed-faces' to t, so that any faces you use are
;;     automatically added to the face menu.  That way, to use one
;;     again, you need not choose `Other...' in the menu each time.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2020/11/05 dadams
;;     list-colors-print (Emacs 23):
;;       Don't create button help-facemenu-edit-color if palette.el not loaded.
;; 2019/04/10 dadams
;;     Do not require zones.el for < Emacs 22.
;; 2018/12/28 dadams
;;     facemenup-add-face-to-regions: Pass explicit list of zones to zz-izone-limits.
;; 2015/08/16 dadams
;;     Renamed wide-n.el stuff to zones.el stuff.
;; 2015/08/14 dadams
;;     facemenup-add-face-to-regions: Call wide-n-limits with ONLY-THIS-BUFFER arg.
;; 2015/08/12 dadams
;;     facemenup-add-face-to-regions: Updated for wide-n.el format change.
;; 2015/07/11 dadams
;;     Added: facemenup-add-face-to-regions, facemenup-add-face-to-regions-in-buffers.
;; 2014/08/30 dadams
;;     Added facemenu-post-self-insert-function (fixes Emacs 24+ via font-lock-ignore).
;;     facemenu-add-face: Do not show message if font-lock+.el loaded (no font-lock override).
;; 2014/08/17 dadams
;;     Applied renaming: icicle-read-color-wysiwyg -> icicle-read-color-WYSIWYG.
;; 2014/05/17 dadams
;;     Added: facemenu+-with-help-window.
;;     list-faces-display: with-output-to-temp-buffer -> facemenu+-with-help-window.
;;                         save-excursion + set-buffer -> with-current-buffer.
;; 2014/02/17 dadams
;;     facemenup-set-face-attribute-at-point: Fixed prompt for reading attribute.
;; 2014/02/06 dadams
;;     Do not add Display Font's to menu twice (for font-lock-menus.el and font-menus.el).
;; 2014/01/17 dadams
;;     list-faces-display: Use dolist instead of while.
;; 2014/01/05 dadams
;;     Add to Syntax Highlighting (Font Lock) menu: icicle-next-font-lock-keywords-repeat,
;;                                                  icicle-font-lock-keyword.
;;     Soft-require font-lock-menus.el.
;; 2013/07/24 dadams
;;     Added: facemenup-nonempty-region-p.
;;     Paste Text Properties to Region menu: use hlt-copied-props and facemenup-nonempty-region-p.
;;     Use facemenup-nonempty-region-p instead of just mark-active, everywhere.
;; 2012/11/13 dadams
;;     Handle font-lock-menus.el (like font-menus.el), which replaces font-menus-da.el.
;; 2012/08/26 dadams
;;     Added submenu Syntax Highlighting (Font Lock), from font-menus(-da).el.
;; 2012/06/20 dadams
;;     facemenu-add-face: Updated to Emacs 24 definition.
;; 2011/11/26 dadams
;;     facemenu-read-color: Applied renaming of icicle-read-color to icicle-read-color-wysiwyg.
;;                          Use new arg order for hexrgb-read-color.
;; 2011/07/24 dadams
;;     facemenu-remove-(face-props|all): Add them to Edit > Region menu, if available.
;;                                       Disable them if no active region (Emacs bug #9162).
;;
;; 2011/07/23 dadams
;;     facemenup-highlight-menu: Added hlt-copy-props, hlt-yank-props.
;; 2011/06/27 dadams
;;     Just soft-require palette.el - if not available then hard-require eyedropper.el.
;; 2011/06/26 dadams
;;     list-faces-display:
;;       If available, use help-commands-to-key-buttons, not substitute-command-keys.
;;       Added \\<help-mode-map> to help string (see Emacs bug #8939).
;;       Removed print-help-return-message (updated per newer vanilla Emacs).
;;     Soft-require help-fns+.el (Emacs 23+), for help-commands-to-key-buttons.
;; 2011/02/15 dadams
;;     Added: facemenup-copy-tree (Emacs 20-21).  Use in facemenu-mouse-menu.
;;                                                Removed require of cl.el for copy-tree.
;;     list-colors-print: Updated for Emacs 24.  Enhanced tooltip.
;; 2011/01/22 dadams
;;     list-faces-display: Removed colon from read-regexp prompt (it supplies one).
;; 2011/01/04 dadams
;;     Added autoload cookies for defcustom, defconst, commands.  Removed from non-interactive fn.
;; 2009/11/16 dadams
;;     Added: facemenup-palette-update-while-editing-flag.  Thx to Ahei.
;;     facemenup-palette-face-(bg|fg)-at-(mouse|point):
;;       Respect facemenup-palette-update-while-editing-flag.
;;       Use facemenup-face-(bg|fg), not face-(background|foreground) - bug fix.
;; 2009/11/15 dadams
;;     facemenup-paste-to-face-(bg|fg)-at-point:
;;       Test eyedrop-last-picked-color, not eyedrop-picked-background, for error.
;; 2009/11/07 dadams
;;     Renamed: *-change-(bg|fg)-*-at-(point|mouse) to *-change-(bg|fg)-*-at-(point|mouse)+.
;;     Applied doremi cmd renamings (added +).
;; 2009/08/04 dadams
;;     Added: facemenu-rgb-format-for-display.
;;     list-faces-display: Use read-regexp in interactive spec for Emacs 23.
;;     list-colors-print: Use facemenu-rgb-format-for-display, not hardcoded #RRGGBB.
;; 2009/06/25 dadams
;;     facemenu-read-color: nil REQUIRE-MATCH for completing-read.
;; 2008/04/05 dadams
;;     Use easy-menu-add-item instead of easy-menu-do-add-item (no longer exists in Emacs 23).
;; 2008/01/17 dadams
;;     Removed soft require of icicles.el.
;; 2007/12/27 dadams
;;     Added Help menu item.
;;     Move Display Fonts from end of list to after Display Colors.
;; 2007/11/27 dadams
;;     list-faces-display: If available, use icicle-read-string-completing.
;; 2007/09/04 dadams
;;     Added: redefinition of facemenu-read-color.
;; 2007/06/05 dadams
;;     Added Highlight submenu.  Added: facemenup-highlight-menu.
;; 2007/05/18 dadams
;;     Require cl.el only at compile time (for Emacs < 21).
;; 2007/03/25 dadams
;;     Added: facemenu-add-face.
;; 2007/03/20 dadams
;;     facemenu-set-face: Redefined to let numeric prefix arg use face list.
;;     Mention in header that you need not use the M-o o enhancement if you have Icicles.
;; 2006/08/06 dadams
;;     Added redefinition of list-colors-print.
;;     Added: help-facemenu-edit-color.
;; 2006/08/05 dadams
;;     Added: facemenup-set-face-from-list, help-facemenu-set-face (button) (Emacs 22 only).
;;     Added redefinitions of: facemenu-set-face, list-faces-display (Emacs 22 only).
;;     Require help-mode.el (Emacs 22 only).
;;     Changed text of Eyedropper menu items when palette is available.
;; 2006/06/25 dadams
;;     Moved here from faces+.el: set-face-(back|fore)ground-RGB-*.  No longer require faces+.el.
;;       Renamed with prefix facemenup- and changed background/foreground to bg/fg.
;;     Renamed: set-attribute-of-face* to facemenup-set-face-attribute*,
;;              change-(back|fore)ground-of-face-at* to facemenup-change-(bg|fg)-at*,
;;              customize-face-at* to facemenup-customize-face-at*.
;;     Added: facemenup-face-(bg|fg)(-restore), facemenup-last-face-*, *-paste-to-face*.
;;     facemenup-palette-face-(bg|fg)-at-*, facemenup-set-face-(bg|fg)*: Save last bg|fg.
;;     facemenup-set-face-(bg|fg)*: Use eyedrop-face-at-point.
;;     Changed require of doremi-frm.el to soft require.
;; 2006/06/24 dadams
;;     Added: facemenup-palette-face-(bg|fg)-at-*.  Added to menus.
;;     change-*-of-face-at-*, set-attribute-of-face-at-*, customize-face-at-*:
;;       Use eyedrop-face-at-point.
;;     Updated Commentary.
;; 2006/06/23 dadams
;;     Require eyedropper.el or palette.el, depending on the Emacs version.
;;     pick-(fore|back)ground-at-* -> eyedrop-pick-(fore|back)ground-at-*
;;     change-(fore|back)ground-of-face-at-*:
;;       Use plain C-u, not <0, to pick up picked color.
;;       Call doremi-face-(bg|fg) with pickup-p arg.
;;       Bug fix: Added missing interactive prefix arg.
;;     Renamed: *-at-mouse-pointer to *-at-mouse.
;; 2005/07/02 dadams
;;     Renamed: "Change Face Attribute" to "Set Face Attribute" and
;;              `change-attribute-*' to `set-attribute-*').
;;     Added: "Set Face *".
;;     set-attribute-of-face-at--1: read-from-minibuffer -> read-minibuffer.
;;     set-attribute-of-face: Use set-attribute-of-face-at--1 and intern face.
;;     Reordered menus: grouped foreground and background stuff.
;; 2005/07/01 dadams
;;     change-(fore|back)ground-of-face-at-*: Added increment arg - pass it along.
;;     Added: menu items Pick Up Foreground, Pick Up Background.
;; 2005/06/28 dadams
;;     Added: customize-face-at-point, customize-face-at-mouse-pointer.
;;     Renamed: Change Face (Foreground|Background) -> same + "Incrementally".
;;     change-*-of-face-at-*: Moved *Face Sample* stuff to doremi-frm.el.
;;     Added require of easymenu.el.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'facemenu)
(require 'doremi-frm nil t) ;; (no error if not found)
                            ;; doremi-face-fg+, doremi-face-bg+, doremi-undo-last-face-change
(require 'hexrgb nil t) ;; (no error if not found, but hard-required anyway for Emacs 22+,
                        ;; by `palette.el' and `eyedropper.el'.
                        ;; hexrgb-read-color, hexrgb-hex-to-int, hexrgb-hex-to-(rgb|hsv)

;; eyedrop-pick-*-at-*, eyedrop-face-at-point:
(if (fboundp 'defvaralias) ;; Emacs 22+
    (or (require 'palette nil t)  (require 'eyedropper))
  (require 'eyedropper))

(when (> emacs-major-version 21)
  (require 'zones nil t)) ;; (no error if not found
                          ;; zz-izone-limits, zz-izone-limits-in-bufs

;; (require 'icicles nil t) ;; (no error if not found):
                            ;; icicle-read-color-WYSIWYG, icicle-read-string-completing

(require 'easymenu) ;; easy-menu-add-item, easy-menu-create-menu,
(when (> emacs-major-version 21) (require 'help-mode)) ;; help-xref (button type)

;; No error if these are not found - soft-requires:
(when (< emacs-major-version 21) (require 'faces+ nil t)) ;; read-face-name
(when (> emacs-major-version 22) (require 'help-fns+ nil t)) ;; help-commands-to-key-buttons
(require 'font-lock-menus nil t) ; Submenu for font-lock levels.

;; Quiet the byte-compiler.
(defvar facemenu-self-insert-data) ;; In `facemenu.el'
(defvar palette-action)            ;; In `palette.el'.
(defvar zz-izones-var)             ;; In `zones.el'.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Same as `icicle-with-help-window'.
(defmacro facemenu+-with-help-window (buffer &rest body)
  "`with-help-window', if available; else `with-output-to-temp-buffer'."
  (if (fboundp 'with-help-window)
      `(with-help-window ,buffer ,@body)
    `(with-output-to-temp-buffer ,buffer ,@body)))

(put 'facemenu+-with-help-window 'common-lisp-indent-function '(4 &body))


(defun facemenup-nonempty-region-p ()
  "Return non-nil if region is active and non-empty."
  (and transient-mark-mode  mark-active  (> (region-end) (region-beginning))))

;;;###autoload
(defcustom facemenup-palette-update-while-editing-flag t
  "*Non-nil means update the face whose color you're editing in the palette.
The face is updated automatically each time you change the palette's
current color, which is typically when you hit `RET' or click
`mouse-2'.  If nil, then the face is updated only when you exit the
palette using `x'."
  :type 'boolean :group 'facemenu)

(defconst facemenup-err-mouse "No defined face under mouse pointer. Face to change"
  "Error message for no defined face under mouse pointer.")

(defconst facemenup-err-point "No defined face at cursor (point). Face to change"
  "Error message for no defined face under mouse pointer.")

(defvar facemenup-last-face-changed nil "Last face changed using the face menu.")

(defvar facemenup-last-face-bg nil
  "Background of last face changed using face menu, before the change.")

(defvar facemenup-last-face-fg nil
  "Foreground of last face changed using face menu, before the change.")

(when (featurep 'font-lock-menus)
  (define-key-after facemenu-menu [flm-list-fonts] '("Display Fonts" . flm-list-fonts) 'dc))

;; `font-lock-menus.el' puts `Display Fonts' last in menu.  Move it after `Display Colors'.
;; It provides both feature `font-lock-menus' and feature `font-menus'.  `font-menus.el' is an
;; older version of `font-lock-menus.el', and it calls command `display-fonts'.
(when (featurep 'font-menus)
  (if (featurep 'font-lock-menus)
      (define-key-after facemenu-menu [flm-list-fonts] '("Display Fonts" . flm-list-fonts) 'dc)
    (define-key-after facemenu-menu [display-fonts] '("Display Fonts" . display-fonts) 'dc)))

(when (or (featurep 'font-lock-menus)  (featurep 'font-menus)) ; Submenu for font-lock levels.
  (easy-menu-add-item facemenu-menu () (easy-menu-create-menu ; (menu-name menu-items)
                                        "Syntax Highlighting (Font Lock)"
                                        '(["In All Buffers" global-font-lock-mode
                                           :style toggle :selected global-font-lock-mode
                                           :active t]
                                          ["In Current Buffer" font-lock-mode
                                           :style toggle :selected font-lock-mode :active t]
                                          "--"
                                          ["More In Current Buffer" font-lock-fontify-more
                                           (nth 2 (if (boundp 'flm-font-lock-fontify-level)
                                                      flm-font-lock-fontify-level
                                                    font-lock-fontify-level))]
                                          ["Less In Current Buffer" font-lock-fontify-less
                                           (nth 1 (if (boundp 'flm-font-lock-fontify-level)
                                                      flm-font-lock-fontify-level
                                                    font-lock-fontify-level))]
                                          "--"
                                          ["Cycle Keywords (Icicles)"
                                           icicle-next-font-lock-keywords-repeat
                                           :active
                                           (and (boundp 'icicle-mode)  icicle-mode
                                            (fboundp 'icicle-next-font-lock-keywords-repeat))]
                                          ["+ Choose Keywords (Icicles)" icicle-font-lock-keyword
                                           :active (and (boundp 'icicle-mode)  icicle-mode
                                                    (fboundp 'icicle-font-lock-keyword))]))
                      "Syntax Highlighting (Font Lock)"))

;;;###autoload
(defconst facemenup-highlight-menu
    (easy-menu-create-menu
     "Highlight"
     (append
      '(["Highlight Region/Buffer" hlt-highlight-region t]
        ["Highlight Regexp in Region/Buffer..." hlt-highlight-regexp-region t]
        ["Highlight Regexp to End" hlt-highlight-regexp-to-end t]
        ["Unhighlight Region/Buffer" hlt-unhighlight-region t]
        ["Unhighlight Region/Buffer for Face" hlt-unhighlight-region-for-face t]
        "--"
        ["Copy Text Properties" hlt-copy-props t]
        ["Paste Text Properties to Region" hlt-yank-props
         (and (facemenup-nonempty-region-p)  (not buffer-read-only)  hlt-copied-props)]
        "--"
        ["Highlighter Pen" hlt-highlighter-mouse t]
        ["Eraser" hlt-eraser-mouse t])
      (and (fboundp 'hlt-show-only)
           '("--"
             ["Hide Only Faces..." hlt-hide-only t]
             ["Show Only Faces..." hlt-show-only t]
             ["Show Faces..." hlt-show t]
             ["Hide Faces..." hlt-hide t]
             "--"))
      '(["Choose Highlighting Face" hlt-choose-default-face t]
        ["Replace Highlighting Face in Region/Buffer" hlt-replace-highlight-face t]
        ["Toggle Using Overlays for Highlighting" hlt-toggle-use-overlays-flag t])
      (and (fboundp 'hlt-toggle-act-on-any-face-flag)
           '(["Toggle Highlighting Arbritrary Faces" hlt-toggle-act-on-any-face-flag t]))
      (and (fboundp 'hlt-next-highlight)
           '("--"
             ["Go To Next Highlight" hlt-next-highlight t]
             ["Go To Previous Highlight" hlt-previous-highlight t]))))
  "Highlight submenu of Text Properties menu.")

(unless (fboundp 'copy-tree)            ; Emacs 20-21
  (defun facemenup-copy-tree (tree &optional vecp)
    "Make a copy of TREE.
If TREE is a cons cell, this recursively copies both its car and its cdr.
Contrast to `copy-sequence', which copies only along the cdrs.  With second
argument VECP, this copies vectors as well as conses."
    (if (consp tree)
        (let (result)
          (while (consp tree)
            (let ((newcar  (car tree)))
              (when (or (consp (car tree))  (and vecp  (vectorp (car tree))))
                (setq newcar  (facemenup-copy-tree (car tree) vecp)))
              (push newcar result))
            (setq tree  (cdr tree)))
          (nconc (nreverse result) tree))
      (if (and vecp  (vectorp tree))
          (let ((ii  (length (setq tree  (copy-sequence tree)))))
            (while (>= (setq ii  (1- ii)) 0)
              (aset tree ii (facemenup-copy-tree (aref tree ii) vecp)))
            tree)
        tree))))

;; Use a different menu for the mouse popup menu from the Edit > Text Properties menu.
(defvar facemenu-mouse-menu (if (fboundp 'copy-tree)
                                (copy-tree facemenu-menu)
                              (facemenup-copy-tree facemenu-menu))
  "Facemenu top-level popup mouse menu keymap.")
(defalias 'facemenu-mouse-menu facemenu-mouse-menu)
(define-key global-map [C-down-mouse-2] 'facemenu-mouse-menu)

;; Replace "Describe Properties" (Emacs 22) or "List Properties" (Emacs 20) menu item in
;; mouse menu.  Use `facemenup-describe-text-properties-at-mouse' instead of
;; `describe-text-properties' (Emacs 22) or `list-text-properties-at' (Emacs 20).
(define-key facemenu-mouse-menu [dp]
  (cons (purecopy "Describe Properties") 'facemenup-describe-text-properties-at-mouse))

;; For Emacs 20, rename "List Properties" to "Describe Properties" in menu-bar menu.
(unless (fboundp 'describe-text-properties)
  (define-key facemenu-menu [dp] '(menu-item "Describe Properties" list-text-properties-at)))

;; `facemenu-remove-all' and `facemenu-remove-face-props'.
;; Add them to `Edit' > `Region' submenu, if it exists.
(when (boundp 'menu-bar-edit-region-menu) ; Defined in `menu-bar+.el'.
  (define-key menu-bar-edit-region-menu [ra]
    '(menu-item "Remove Text Properties" facemenu-remove-all))
  (define-key facemenu-menu [rm]
    '(menu-item "Remove Face Properties" facemenu-remove-face-props)))
;; Disable them if no active region.  Mention `from Region' in name.  This is for Emacs bug #9162.
(define-key facemenu-menu [ra]
  '(menu-item "Remove Text Properties from Region" facemenu-remove-all
    :enable (facemenup-nonempty-region-p)))
(define-key facemenu-menu [rm]
  '(menu-item "Remove Face Properties from Region" facemenu-remove-face-props
    :enable (facemenup-nonempty-region-p)))
(define-key facemenu-mouse-menu [ra]
  '(menu-item "Remove Text Properties from Region" facemenu-remove-all
    :enable (facemenup-nonempty-region-p)))
(define-key facemenu-mouse-menu [rm]
  '(menu-item "Remove Face Properties from Region" facemenu-remove-face-props
    :enable (facemenup-nonempty-region-p)))

;; Add a separator before "Describe Properties": it and the items that
;; follow it do not apply to the region like the items before them do.
(easy-menu-add-item facemenu-mouse-menu () ["---" nil] 'dp)
(easy-menu-add-item facemenu-menu () ["---" nil] 'dp)

;; Add new menu items to mouse menu.
(when (fboundp 'hlt-highlight)
  (easy-menu-add-item facemenu-mouse-menu () facemenup-highlight-menu "Special Properties"))

(when (fboundp 'palette)                ; Defined in `palette.el'.
  (easy-menu-add-item facemenu-mouse-menu () "--")
  (easy-menu-add-item facemenu-mouse-menu () ["Color Palette" palette t])
  (easy-menu-add-item facemenu-mouse-menu () ["Palette - Edit Face Foreground"
                                              facemenup-palette-face-fg-at-mouse t])
  (easy-menu-add-item facemenu-mouse-menu () ["Palette - Edit Face Background"
                                              facemenup-palette-face-bg-at-mouse t]))
(easy-menu-add-item facemenu-mouse-menu () "--")
(cond ((fboundp 'palette)
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Copy Foreground (C-u: Palette)"
                            eyedrop-pick-foreground-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Copy Background (C-u: Palette)"
                            eyedrop-pick-background-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Paste to Face Foreground"
                            facemenup-paste-to-face-fg-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Paste to Face Background"
                            facemenup-paste-to-face-bg-at-mouse t]))
      (t
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Copy Foreground (C-u: Palette)"
                            eyedrop-pick-foreground-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Copy Background (C-u: Palette)"
                            eyedrop-pick-background-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Paste to Face Foreground"
                            facemenup-paste-to-face-fg-at-mouse t])
       (easy-menu-add-item facemenu-mouse-menu ()
                           ["Eyedropper - Paste to Face Background"
                            facemenup-paste-to-face-bg-at-mouse t])))
(when (fboundp 'doremi-face-fg+)        ; Defined in `doremi-frm.el'.
  (easy-menu-add-item facemenu-mouse-menu () "--")
  (easy-menu-add-item facemenu-mouse-menu () ["Do Re Mi - Edit Face Foreground"
                                              facemenup-change-fg-of-face-at-mouse+ t])
  (easy-menu-add-item facemenu-mouse-menu () ["Do Re Mi - Edit Face Background"
                                              facemenup-change-bg-of-face-at-mouse+ t])
  (easy-menu-add-item facemenu-mouse-menu () ["Do Re Mi - Undo Last Edit"
                                              doremi-undo-last-face-change t]))
(easy-menu-add-item facemenu-mouse-menu () "--")
(easy-menu-add-item facemenu-mouse-menu () ["Set Face Foreground RGB"
                                            facemenup-set-face-fg-RGB-at-mouse t])
(easy-menu-add-item facemenu-mouse-menu () ["Set Face Background RGB"
                                            facemenup-set-face-bg-RGB-at-mouse t])
(easy-menu-add-item facemenu-mouse-menu () ["Set Face Foreground RGB (Hex)"
                                            facemenup-set-face-fg-RGB-hex-at-mouse t])
(easy-menu-add-item facemenu-mouse-menu () ["Set Face Background RGB (Hex)"
                                            facemenup-set-face-bg-RGB-hex-at-mouse t])
(easy-menu-add-item facemenu-mouse-menu () ["Restore Last Foreground (Except Do Re Mi)"
                                            facemenup-face-fg-restore t])
(easy-menu-add-item facemenu-mouse-menu () ["Restore Last Background (Except Do Re Mi)"
                                            facemenup-face-bg-restore t])
(easy-menu-add-item facemenu-mouse-menu () "--")
(when (fboundp 'set-face-attribute)     ; Emacs 22
  (easy-menu-add-item facemenu-mouse-menu () ["Set Face Attribute"
                                              facemenup-set-face-attribute-at-mouse t]))
(easy-menu-add-item facemenu-mouse-menu ()
                    ["Customize Face" facemenup-customize-face-at-mouse t])

;;;###autoload
(defun facemenup-help (event)
  "Open the Emacs manual to help about formatted text."
  (interactive "e") (info "(emacs)Editing Format Info"))

(easy-menu-add-item facemenu-mouse-menu () "--")
(easy-menu-add-item facemenu-mouse-menu () ["Help" facemenup-help t])


;; Add new menu items to menu-bar menu, preceded by a separator.
(when (fboundp 'hlt-highlight)
  (easy-menu-add-item facemenu-menu () facemenup-highlight-menu "Special Properties"))

(when (fboundp 'palette)                ; Defined in `palette.el'.
  (easy-menu-add-item facemenu-menu () "--")
  (easy-menu-add-item facemenu-menu () ["Color Palette" palette t])
  (easy-menu-add-item facemenu-menu () ["Palette - Edit Face Foreground"
                                        facemenup-palette-face-fg-at-point t])
  (easy-menu-add-item facemenu-menu () ["Palette - Edit Face Background"
                                        facemenup-palette-face-bg-at-point t]))
(when (fboundp 'doremi-face-fg+)        ; Defined in `doremi-frm.el'.
  (easy-menu-add-item facemenu-menu () "--")
  (easy-menu-add-item facemenu-menu () ["Do Re Mi - Edit Face Foreground"
                                        facemenup-change-fg-of-face-at-point+ t])
  (easy-menu-add-item facemenu-menu () ["Do Re Mi - Edit Face Background"
                                        facemenup-change-bg-of-face-at-point+ t])
  (easy-menu-add-item facemenu-menu () ["Do Re Mi - Undo Last Edit"
                                        doremi-undo-last-face-change t]))
(easy-menu-add-item facemenu-menu () "--")
(easy-menu-add-item facemenu-menu () ["Eyedropper Copy Foreground Color"
                                      eyedrop-pick-foreground-at-point t])
(easy-menu-add-item facemenu-menu () ["Eyedropper Copy Background Color"
                                      eyedrop-pick-background-at-point t])
(easy-menu-add-item facemenu-menu () ["Eyedropper Paste to Face Foreground"
                                      facemenup-paste-to-face-fg-at-point t])
(easy-menu-add-item facemenu-menu () ["Eyedropper Paste to Face Background"
                                      facemenup-paste-to-face-bg-at-point t])
(easy-menu-add-item facemenu-menu () ["Set Face Foreground RGB"
                                      facemenup-set-face-fg-RGB-at-point t])
(easy-menu-add-item facemenu-menu () ["Set Face Background RGB"
                                      facemenup-set-face-bg-RGB-at-point t])
(easy-menu-add-item facemenu-menu () ["Set Face Foreground RGB (Hex)"
                                      facemenup-set-face-fg-RGB-hex-at-point t])
(easy-menu-add-item facemenu-menu () ["Set Face Background RGB (Hex)"
                                      facemenup-set-face-bg-RGB-hex-at-point t])
(easy-menu-add-item facemenu-menu () ["Restore Last Foreground (Except Do Re Mi)"
                                      facemenup-face-fg-restore t])
(easy-menu-add-item facemenu-menu () ["Restore Last Background (Except Do Re Mi)"
                                      facemenup-face-bg-restore t])
(easy-menu-add-item facemenu-menu () "--")
(when (fboundp 'set-face-attribute)     ; Emacs 22
  (easy-menu-add-item facemenu-menu () ["Set Face Attribute"
                                        facemenup-set-face-attribute-at-point t]))
(easy-menu-add-item facemenu-menu ()
                    ["Customize Face" facemenup-customize-face-at-point t])

(easy-menu-add-item facemenu-menu () "--")
(easy-menu-add-item facemenu-menu () ["Help" facemenup-help t])

;; Update the menu-bar menu.
(facemenu-update)

;;; ----------------------------------

;;;###autoload
(defun facemenup-describe-text-properties-at-mouse (event)
  "Describe text properties of character under the mouse pointer."
  (interactive "e")
  ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
  (while (input-pending-p) (discard-input))
  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                  (goto-char (posn-point (event-end event)))
                  (if (fboundp 'describe-text-properties)
                      (describe-text-properties (point)) ; Emacs 22
                    (list-text-properties-at (point))))) ; Emacs 20

;; Note: The informative messages in these commands do not appear in
;; the minibuffer if `tooltip-mode' is disabled (-1). Emacs Bug
;; reported 2006-06-25.

;;;###autoload
(defun facemenup-face-bg-restore ()
  "Restore background of last face changed by face menu to last color.
This is not an undo: It always restores the previous color as
the background of the last face changed.
This does not work for face changes made by Do Re Mi."
  (interactive)
  (unless (stringp facemenup-last-face-bg) (error "No previous face background"))
  (unless (facep facemenup-last-face-changed) (error "No face change to restore"))
  (set-face-background facemenup-last-face-changed facemenup-last-face-bg)
  (when (interactive-p)
    (message "Background of `%s' restored to `%s'"
             facemenup-last-face-changed facemenup-last-face-bg)))

;;;###autoload
(defun facemenup-face-fg-restore ()
  "Restore foreground of last face changed by face menu to last color.
This is not an undo: It always restores the previous color as
the foreground of the last face changed.
This does not work for face changes made by Do Re Mi."
  (interactive)
  (unless (stringp facemenup-last-face-fg) (error "No previous face foreground"))
  (unless (facep facemenup-last-face-changed) (error "No face change to restore"))
  (set-face-foreground facemenup-last-face-changed facemenup-last-face-fg)
  (when (interactive-p)
    (message "Foreground of `%s' restored to `%s'"
             facemenup-last-face-changed facemenup-last-face-fg)))

(when (fboundp 'palette)
  (defun facemenup-palette-face-bg-at-mouse (event)
    "Use palette to edit background of face under the mouse pointer.
To change this face: edit the color in the palette, then exit the
palette using \\<palette-mode-map>`\\[palette-exit]'.

To quit the palette without effecting any change on the face, use `\\[palette-quit]'.
To restore the face color after you have changed it, use
`\\[facemenup-face-bg-restore]'.

If option `facemenup-palette-update-while-editing-flag' is non-nil,
then the face is automatically updated each time you change the
palette's current color, which is typically when you hit `RET' or
click `mouse-2'.  In this case, quitting the palette with `\\[palette-quit]' will not
undo any face changes you made.  Use `\\[facemenup-face-bg-restore]' to restore."
    (interactive "e")
    (let ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                                 (goto-char (posn-point (event-end event)))
                                 (eyedrop-face-at-point))))
      (unless face (setq face  (read-face-name facemenup-err-mouse)))
      (add-hook 'palette-exit-hook `(lambda () (set-face-background ',face palette-current-color)))
      (let ((bg  (facemenup-face-bg face)))
        (setq facemenup-last-face-bg       bg
              facemenup-last-face-changed  face)
        (when facemenup-palette-update-while-editing-flag
          (setq palette-action  `(lambda () (set-face-background ',face palette-current-color))))
        (palette bg)))))

(when (fboundp 'palette)
  (defun facemenup-palette-face-fg-at-mouse (event)
    "Use palette to edit foreground of face under the mouse pointer.
To change this face: edit the color in the palette, then exit the
palette using `\\[palette-exit]'.

To quit the palette without effecting any change on the face, use `\\[palette-quit]'.
To restore the face color after you have changed it, use
`\\[facemenup-face-fg-restore]'.

If option `facemenup-palette-update-while-editing-flag' is non-nil,
then the face is automatically updated each time you change the
palette's current color, which is typically when you hit `RET' or
click `mouse-2'.  In this case, quitting the palette with `\\[palette-quit]' will not
undo any face changes you made.  Use `\\[facemenup-face-fg-restore]' to restore."
    (interactive "e")
    (let ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                                 (goto-char (posn-point (event-end event)))
                                 (eyedrop-face-at-point))))
      (unless face (setq face  (read-face-name facemenup-err-mouse)))
      (add-hook 'palette-exit-hook `(lambda () (set-face-foreground ',face palette-current-color)))
      (let ((fg  (facemenup-face-fg face)))
        (setq facemenup-last-face-fg       fg
              facemenup-last-face-changed  face)
        (when facemenup-palette-update-while-editing-flag
          (setq palette-action  `(lambda () (set-face-foreground ',face palette-current-color))))
        (condition-case nil
            (palette fg)
          (quit (set-face-foreground face fg)))))))

(when (fboundp 'palette)
  (defun facemenup-palette-face-bg-at-point ()
    "Use palette to edit background of face at the cursor (point).
To change this face: edit the color in the palette, then exit the
palette using `\\[palette-exit]'.

To quit the palette without effecting any change on the face, use `\\[palette-quit]'.
To restore the face color after you have changed it, use
`\\[facemenup-face-bg-restore]'.

If option `facemenup-palette-update-while-editing-flag' is non-nil,
then the face is automatically updated each time you change the
palette's current color, which is typically when you hit `RET' or
click `mouse-2'.  In this case, quitting the palette with `\\[palette-quit]' will not
undo any face changes you made.  Use `\\[facemenup-face-bg-restore]' to restore."
    (interactive)
    (let ((face  (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (add-hook 'palette-exit-hook
                `(lambda () (set-face-background ',face palette-current-color)))
      (let ((bg  (facemenup-face-bg face)))
        (setq facemenup-last-face-bg       bg
              facemenup-last-face-changed  face)
        (when facemenup-palette-update-while-editing-flag
          (setq palette-action  `(lambda () (set-face-background ',face palette-current-color))))
        (condition-case nil
            (palette bg)
          (quit (set-face-background face bg)))))))

(when (fboundp 'palette)
  (defun facemenup-palette-face-fg-at-point ()
    "Use palette to edit foreground of face at the cursor (point).
To change this face: edit the color in the palette, then exit the
palette using `\\[palette-exit]'.

To quit the palette without effecting any change on the face, use `\\[palette-quit]'.
To restore the face color after you have changed it, use
`\\[facemenup-face-fg-restore]'.

If option `facemenup-palette-update-while-editing-flag' is non-nil,
then the face is automatically updated each time you change the
palette's current color, which is typically when you hit `RET' or
click `mouse-2'.  In this case, quitting the palette with `\\[palette-quit]' will not
undo any face changes you made.  Use `\\[facemenup-face-fg-restore]' to restore."
    (interactive)
    (let ((face  (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (add-hook 'palette-exit-hook
                `(lambda () (set-face-foreground ',face palette-current-color)))
      (let ((fg  (facemenup-face-fg face)))
        (setq facemenup-last-face-fg       fg
              facemenup-last-face-changed  face)
        (when facemenup-palette-update-while-editing-flag
          (setq palette-action  `(lambda () (set-face-foreground ',face palette-current-color))))
        (condition-case nil
            (palette fg)
          (quit (set-face-foreground face fg)))))))

(when (fboundp 'doremi-face-bg+)
  (defun facemenup-change-bg-of-face-at-mouse+ (event increment)
    "Use Do Re Mi to edit background of face under the mouse pointer.
This uses command `doremi-face-bg+'; see that for more usage info.
Prefix argument is the INCREMENT of change.

If `eyedrop-picked-background' is non-nil and you use plain `C-u'
instead of a numeric prefix argument, then the face background is
first set to the value of `eyedrop-picked-background'.  This happens
only if library `eyedropper.el' or `palette.el' is loaded.  This lets
you pick up a background color from somewhere, using \"Pick Up
Background Color\" (`eyedrop-pick-background-at-mouse'), and then use
that as the initial value for
`facemenup-change-bg-of-face-at-mouse+'."
    (interactive "e\np")
    (let ((echo-keystrokes  0)
          (face             (save-excursion
                              (set-buffer (window-buffer (posn-window (event-end event))))
                              (goto-char (posn-point (event-end event)))
                              (eyedrop-face-at-point))))
      (unless face (setq face  (read-face-name facemenup-err-mouse)))
      ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
      (while (input-pending-p) (discard-input))
      (doremi-face-bg+ face
                       (read-char-exclusive (format "Change background of `%s'. \
Adjust red, green, blue, hue, saturation, or value? [rgbhsv]: " face))
                       increment (consp current-prefix-arg)))))

(when (fboundp 'doremi-face-fg+)
  (defun facemenup-change-fg-of-face-at-mouse+ (event increment)
    "Use Do Re Mi to edit foreground of face under the mouse pointer.
This uses command `doremi-face-fg+'; see that for more usage info.
Prefix argument is the INCREMENT of change.

If `eyedrop-picked-foreground' is non-nil and you use plain `C-u'
instead of a numeric prefix argument, then the face foreground is
first set to the value of `eyedrop-picked-foreground'.  This
happens only if library `eyedropper.el' or `palette.el' is
loaded.  This lets you pick up a foreground color from somewhere,
using \"Pick Up Foreground Color\"
\(`eyedrop-pick-foreground-at-mouse'), and then use that as the
initial value for `facemenup-change-fg-of-face-at-mouse+'."
    (interactive "e\np")
    (let ((echo-keystrokes  0)
          (face             (save-excursion
                              (set-buffer (window-buffer (posn-window (event-end event))))
                              (goto-char (posn-point (event-end event)))
                              (eyedrop-face-at-point))))
      (unless face (setq face  (read-face-name facemenup-err-mouse)))
      ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
      (while (input-pending-p) (discard-input))
      (doremi-face-fg+ face
                       (read-char-exclusive (format "Change foreground of `%s'. \
Adjust red, green, blue, hue, saturation, or value? [rgbhsv]: " face))
                       increment (consp current-prefix-arg)))))

(when (fboundp 'doremi-face-bg+)
  (defun facemenup-change-bg-of-face-at-point+ (increment)
    "Use Do Re Mi to edit background of face at the cursor (point).
This uses command `doremi-face-bg+'; see that for more usage info.
Prefix argument is the INCREMENT of change.

If `eyedrop-picked-background' is non-nil and you use plain `C-u'
instead of a numeric prefix argument, then the face background is
first set to the value of `eyedrop-picked-background'.  This
happens only if library `eyedropper.el' or `palette.el' is
loaded.  This lets you pick up a background color from somewhere,
using \"Pick Up Background Color\"
\(`eyedrop-pick-background-at-point'), and then use that as the
initial value for `facemenup-change-bg-of-face-at-point+'."
    (interactive "p")
    (let ((echo-keystrokes  0)
          (face             (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (doremi-face-bg+ face (read-char-exclusive (format "Change background of `%s'. \
Adjust red, green, blue, hue, saturation, or value? [rgbhsv]: " face))
                       increment (consp current-prefix-arg)))))

(when (fboundp 'doremi-face-fg+)
  (defun facemenup-change-fg-of-face-at-point+ (increment)
    "Use Do Re Mi to edit foreground of face at the cursor (point).
This uses command `doremi-face-fg+'; see that for more usage info.
Prefix argument is the INCREMENT of change.

If `eyedrop-picked-foreground' is non-nil and you use plain `C-u'
instead of a numeric prefix argument, then the face foreground is
first set to the value of `eyedrop-picked-foreground'.  This
happens only if library `eyedropper.el' or `palette.el' is
loaded.  This lets you pick up a foreground color from somewhere,
using \"Pick Up Foreground Color\"
\(`eyedrop-pick-foreground-at-point'), and then use that as the
initial value for `facemenup-change-fg-of-face-at-point+'."
    (interactive "p")
    (let ((echo-keystrokes  0)
          (face             (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (doremi-face-fg+ face (read-char-exclusive (format "Change foreground of `%s'. \
Adjust red, green, blue, hue, saturation, or value? [rgbhsv]: " face))
                       increment (consp current-prefix-arg)))))

;;;###autoload
(defun facemenup-set-face-bg-RGB-at-mouse (event)
  "Set RGB of background of face at character under the mouse pointer.
RGB is specified in decimal."
  (interactive "e")
  (let ((echo-keystrokes  0)
        (face             (save-excursion
                            (set-buffer (window-buffer (posn-window (event-end event))))
                            (goto-char (posn-point (event-end event)))
                            (eyedrop-face-at-point)))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
    (while (input-pending-p) (discard-input))
    (while (or (not (wholenump red))  (>= red 256))
      (setq red  (read-minibuffer "Red value (decimal): ")))
    (while (or (not (wholenump green))  (>= green 256))
      (setq green  (read-minibuffer "Green value (decimal): ")))
    (while (or (not (wholenump blue))  (>= blue 256))
      (setq blue  (read-minibuffer "Blue value (decimal): ")))
    (setq red    (format "%02x" red)
          green  (format "%02x" green)
          blue   (format "%02x" blue))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face (format "#%s%s%s" red green blue))))

;;;###autoload
(defun facemenup-set-face-fg-RGB-at-mouse (event)
  "Set RGB of foreground of face at character under the mouse pointer.
RGB is specified in decimal."
  (interactive "e")
  (let ((echo-keystrokes  0)
        (face             (save-excursion
                            (set-buffer (window-buffer (posn-window (event-end event))))
                            (goto-char (posn-point (event-end event)))
                            (eyedrop-face-at-point)))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
    (while (input-pending-p) (discard-input))
    (while (or (not (wholenump red))  (>= red 256))
      (setq red  (read-minibuffer "Red value (decimal): ")))
    (while (or (not (wholenump green))  (>= green 256))
      (setq green  (read-minibuffer "Green value (decimal): ")))
    (while (or (not (wholenump blue))  (>= blue 256))
      (setq blue  (read-minibuffer "Blue value (decimal): ")))
    (setq red    (format "%02x" red)
          green  (format "%02x" green)
          blue   (format "%02x" blue))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face (format "#%s%s%s" red green blue))))

;;;###autoload
(defun facemenup-set-face-bg-RGB-at-point ()
  "Set RGB of background of face at character following cursor (point).
RGB is specified in decimal, from 0 to 255."
  (interactive)
  (let ((face  (eyedrop-face-at-point))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (while (or (not (wholenump red))  (>= red 256))
      (setq red  (read-minibuffer "Red value (decimal, 0-255): ")))
    (while (or (not (wholenump green))  (>= green 256))
      (setq green  (read-minibuffer "Green value (decimal, 0-255): ")))
    (while (or (not (wholenump blue))  (>= blue 256))
      (setq blue  (read-minibuffer "Blue value (decimal, 0-255): ")))
    (setq red    (format "%02x" red)
          green  (format "%02x" green)
          blue   (format "%02x" blue))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face (format "#%s%s%s" red green blue))))

;;;###autoload
(defun facemenup-set-face-fg-RGB-at-point ()
  "Set RGB of foreground of face at character following cursor (point).
RGB is specified in decimal, from 0 to 255."
  (interactive)
  (let ((face  (eyedrop-face-at-point))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (while (or (not (wholenump red))  (>= red 256))
      (setq red  (read-minibuffer "Red value (decimal, 0-255): ")))
    (while (or (not (wholenump green))  (>= green 256))
      (setq green  (read-minibuffer "Green value (decimal, 0-255): ")))
    (while (or (not (wholenump blue))  (>= blue 256))
      (setq blue  (read-minibuffer "Blue value (decimal, 0-255): ")))
    (setq red    (format "%02x" red)
          green  (format "%02x" green)
          blue   (format "%02x" blue))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face (format "#%s%s%s" red green blue))))

;;;###autoload
(defun facemenup-set-face-bg-RGB-hex-at-mouse (event)
  "Set RGB of background of face at character under the mouse pointer.
RGB is specified in hexadecimal, from 0 to FFFF."
  (interactive "e")
  (let ((echo-keystrokes  0)
        (face             (save-excursion
                            (set-buffer (window-buffer (posn-window (event-end event))))
                            (goto-char (posn-point (event-end event)))
                            (eyedrop-face-at-point)))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
    (while (input-pending-p) (discard-input))
    (while (null (condition-case nil
                     (prog1
                         (setq red  (hexrgb-hex-to-int
                                     (read-from-minibuffer "Red value (hex, 0-FFFF): ")))
                       (when (or (< red 0)  (> red 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq green  (hexrgb-hex-to-int
                                       (read-from-minibuffer "Green value (hex, 0-FFFF): ")))
                       (when (or (< green 0)  (> green 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq blue  (hexrgb-hex-to-int
                                      (read-from-minibuffer "Blue value (hex, 0-FFFF): ")))
                       (when (or (< blue 0)  (> blue 65535)) (error)))
                   (error nil))))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face (format "#%04x%04x%04x" red green blue))))

;;;###autoload
(defun facemenup-set-face-fg-RGB-hex-at-mouse (event)
  "Set RGB of foreground of face at character under the mouse pointer.
RGB is specified in hexadecimal, from 0 to FFFF."
  (interactive "e")
  (let ((echo-keystrokes  0)
        (face             (save-excursion
                            (set-buffer (window-buffer (posn-window (event-end event))))
                            (goto-char (posn-point (event-end event)))
                            (eyedrop-face-at-point)))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
    (while (input-pending-p) (discard-input))
    (while (null (condition-case nil
                     (prog1
                         (setq red  (hexrgb-hex-to-int
                                     (read-from-minibuffer "Red value (hex, 0-FFFF): ")))
                       (when (or (< red 0)  (> red 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq green  (hexrgb-hex-to-int
                                       (read-from-minibuffer "Green value (hex, 0-FFFF): ")))
                       (when (or (< green 0)  (> green 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq blue  (hexrgb-hex-to-int
                                      (read-from-minibuffer "Blue value (hex, 0-FFFF): ")))
                       (when (or (< blue 0)  (> blue 65535)) (error)))
                   (error nil))))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face (format "#%04x%04x%04x" red green blue))))

;;;###autoload
(defun facemenup-set-face-bg-RGB-hex-at-point ()
  "Set RGB of background of face at character following cursor (point).
RGB is specified in hexadecimal, from 0 to FFFF."
  (interactive)
  (let ((face  (eyedrop-face-at-point))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (while (null (condition-case nil
                     (prog1
                         (setq red  (hexrgb-hex-to-int
                                     (read-from-minibuffer "Red value (hex, 0-FFFF): ")))
                       (when (or (< red 0)  (> red 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq green  (hexrgb-hex-to-int
                                       (read-from-minibuffer "Green value (hex, 0-FFFF): ")))
                       (when (or (< green 0)  (> green 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq blue  (hexrgb-hex-to-int
                                      (read-from-minibuffer "Blue value (hex, 0-FFFF): ")))
                       (when (or (< blue 0)  (> blue 65535)) (error)))
                   (error nil))))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face (format "#%04x%04x%04x" red green blue))))

;;;###autoload
(defun facemenup-set-face-fg-RGB-hex-at-point ()
  "Set RGB of foreground of face at character following cursor (point).
RGB is specified in hexadecimal, from 0 to FFFF."
  (interactive)
  (let ((face  (eyedrop-face-at-point))
        red green blue)
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (while (null (condition-case nil
                     (prog1
                         (setq red  (hexrgb-hex-to-int
                                     (read-from-minibuffer "Red value (hex, 0-FFFF): ")))
                       (when (or (< red 0)  (> red 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq green  (hexrgb-hex-to-int
                                       (read-from-minibuffer "Green value (hex, 0-FFFF): ")))
                       (when (or (< green 0)  (> green 65535)) (error)))
                   (error nil))))
    (while (null (condition-case nil
                     (prog1
                         (setq blue  (hexrgb-hex-to-int
                                      (read-from-minibuffer "Blue value (hex, 0-FFFF): ")))
                       (when (or (< blue 0)  (> blue 65535)) (error)))
                   (error nil))))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face (format "#%04x%04x%04x" red green blue))))

;;;###autoload
(defun facemenup-paste-to-face-bg-at-mouse (event)
  "Paste last color copied to background of face under mouse.
The last color copied is in `eyedrop-last-picked-color'."
  (interactive "e")
  (unless eyedrop-last-picked-color (error "Cannot paste. No color copied"))
  (let ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                               (goto-char (posn-point (event-end event)))
                               (eyedrop-face-at-point))))
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face eyedrop-last-picked-color)))

;;;###autoload
(defun facemenup-paste-to-face-fg-at-mouse (event)
  "Paste last color copied to foreground of face under mouse.
The last color copied is in `eyedrop-last-picked-color'."
  (interactive "e")
  (unless eyedrop-last-picked-color (error "Cannot paste. No color copied"))
  (let ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                               (goto-char (posn-point (event-end event)))
                               (eyedrop-face-at-point))))
    (unless face (setq face  (read-face-name facemenup-err-mouse)))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face eyedrop-last-picked-color)))

;;;###autoload
(defun facemenup-paste-to-face-bg-at-point ()
  "Paste last color copied to background of face at cursor (point).
The last color copied is in `eyedrop-last-picked-color'."
  (interactive)
  (unless eyedrop-last-picked-color (error "Cannot paste. No color copied"))
  (let ((face  (eyedrop-face-at-point)))
    (unless face (read-face-name facemenup-err-point))
    (let ((bg  (facemenup-face-bg face)))
      (setq facemenup-last-face-bg       bg
            facemenup-last-face-changed  face))
    (set-face-background face eyedrop-last-picked-color)))

;;;###autoload
(defun facemenup-paste-to-face-fg-at-point ()
  "Paste last color copied to foreground of face at cursor (point).
The last color copied is in `eyedrop-last-picked-color'."
  (interactive)
  (unless eyedrop-last-picked-color (error "Cannot paste. No color copied"))
  (let ((face  (eyedrop-face-at-point)))
    (unless face (read-face-name facemenup-err-point))
    (let ((fg  (facemenup-face-fg face)))
      (setq facemenup-last-face-fg       fg
            facemenup-last-face-changed  face))
    (set-face-foreground face eyedrop-last-picked-color)))

(when (fboundp 'set-face-attribute)     ; Emacs 22
  (defun facemenup-set-face-attribute-at-mouse (event)
    "Set attribute of face used at character under the mouse pointer.
You are prompted for the face attribute to change and its new value."
    (interactive "e")
    (let* ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                                  (goto-char (posn-point (event-end event)))
                                  (eyedrop-face-at-point))))
      (unless face (setq face  (read-face-name facemenup-err-mouse)))
      ;; Emacs bug on Windows: Get extra, pending <C-drag-mouse-2> event, so discard it.
      (while (input-pending-p) (discard-input))
      (facemenup-set-face-attribute-at--1 face)))

  (defun facemenup-set-face-attribute-at-point ()
    "Set attribute of face used at character following cursor (point).
You are prompted for the face attribute to change and its new value."
    (interactive)
    (let ((face  (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (facemenup-set-face-attribute-at--1 face)))

  ;; Helper function
  (defun facemenup-set-face-attribute-at--1 (face)
    (let* ((attr   (intern (completing-read "Face attribute to change: "
                                            [:family :width :height :weight :slant :foreground
                                                     :background :inverse-video :stipple
                                                     :underline :overline :strike-through
                                                     :inherit :box :font :bold :italic]
                                            nil t nil nil ":foreground")))
           (value  (read-minibuffer (format "New value for attribute `%s': " attr))))
      (set-face-attribute face nil attr value)
      (put face 'customized-face (list (list 't (list attr value))))
      (message (substitute-command-keys
                "Use `\\[customize-face]' to revisit changes."))))

  (defun facemenup-set-face-attribute ()
    "Set attribute of face.
You are prompted for the face, attribute to change, and its new value."
    (interactive)
    (let ((face  (intern (symbol-name (read-face-name "Modify face: ")))))
      (facemenup-set-face-attribute-at--1 face))))

;;;###autoload
(defun facemenup-customize-face-at-mouse (event)
  "Customize the face used at character under the mouse pointer."
  (interactive "e")
  (let ((face  (save-excursion (set-buffer (window-buffer (posn-window (event-end event))))
                               (goto-char (posn-point (event-end event)))
                               (eyedrop-face-at-point))))
    (unless face (read-face-name facemenup-err-mouse))
    (customize-face face)))

;;;###autoload
(defun facemenup-customize-face-at-point ()
  "Customize the face used at character following cursor (point)."
    (interactive)
    (let ((face  (eyedrop-face-at-point)))
      (unless face (read-face-name facemenup-err-point))
      (customize-face face)))

(defun facemenup-face-bg (face)
  "`face-background', but get frame background if face has none.
For Emacs 22+, this is `face-background' inheriting from `default'."
  (condition-case nil
      (face-background face nil 'default) ; Emacs 22
    (error (or (face-background face)  (cdr (assq 'background-color (frame-parameters)))))))

(defun facemenup-face-fg (face)
  "`face-foreground', but get frame foreground if face has none.
For Emacs 22+, this is `face-foreground' inheriting from `default'."
  (condition-case nil
      (face-foreground face nil 'default) ; Emacs 22+.  Raises error for previous versions.
    (error (or (face-foreground face)  (cdr (assq 'foreground-color (frame-parameters)))))))


(when (fboundp 'zz-izone-limits)

  (defun facemenup-add-face-to-regions (face &optional regions msgp)
    "Use `facemenu-add-face' to add FACE to each region in REGIONS.
Optional arg REGIONS is a list of (START END) region limits.  If nil,
the regions are taken from the izones in the variable that is the
value of `zz-izones-var'.  You need library `zones.el' for this
command."
    (interactive
     (progn (barf-if-buffer-read-only)
            (list (read-from-minibuffer "Face: " nil (if (boundp 'pp-read-expression-map)
                                                         pp-read-expression-map
                                                       read-expression-map)
                                        'READ 'read-expression-history)
                  (zz-izone-limits (symbol-value zz-izones-var) nil 'ONLY-THIS-BUFFER)
                  'MSGP)))
    (let (buf start end)
      (dolist (start+end  regions)
        (setq start  (car start+end)
              end    (cadr start+end)
              buf    (if (and (markerp start)  (markerp end)
                              (eq (marker-buffer start)  (marker-buffer end)))
                         (marker-buffer start)
                       (current-buffer)))
        (with-current-buffer buf
          (facemenu-add-face face start end)
          (unless (or (not msgp)  (featurep 'font-lock+)  (facemenu-enable-faces-p))
            (message "Font-lock will override faces you set in buffer `%s'" (buffer-name)))))))

  (defun facemenup-add-face-to-regions-in-buffers (face buffers &optional regions msgp)
    "Use `facemenup-add-face-to-regions' in each buffer of list BUFFERS.
A prefix arg means use all visible or iconified buffers.
Otherwise, you are prompted for the BUFFERS to use, one at a time.
Use `C-g' to end prompting.  If you specify no BUFFERS then the
current buffer is used.

The regions are taken from the izones in the value, in each buffer, of
the variable that is the value of `zz-izones-var'.

You need library `zones.el' for this command."
    (interactive
     (let* ((fac   (read-from-minibuffer "Face: " nil (if (boundp 'pp-read-expression-map)
                                                          pp-read-expression-map
                                                        read-expression-map)
                                         'READ 'read-expression-history))
            (bufs  (if current-prefix-arg
                       (zz-remove-if-not (lambda (bf) (get-buffer-window bf 0)) (buffer-list))
                     (zz-read-bufs)))
            (regs  (zz-izone-limits-in-bufs bufs)))
       (list fac bufs regs 'MSGP)))
    (facemenup-add-face-to-regions face regions msgp)))




;; REPLACES ORIGINAL in `facemenu.el':
;;
;; Use `icicle-read-color-WYSIWYG' if defined.  If not, use `hexrgb-read-color' if defined.
;;
(defun facemenu-read-color (&optional prompt)
  "Read a color using the minibuffer."
  (setq prompt  (or prompt  "Color: "))
  (let* ((completion-ignore-case  t)
         (col                     (cond ((and (boundp 'icicle-mode)  icicle-mode)
                                         (icicle-read-color-WYSIWYG 0 prompt))
                                        ((fboundp 'hexrgb-read-color)
                                         (hexrgb-read-color prompt nil t))
                                        (t
                                         (completing-read
                                          prompt
                                          (or facemenu-color-alist
                                              (if (fboundp 'defined-colors) ; Emacs 22+
                                                  (defined-colors)
                                                (and window-system
                                                     (mapcar 'list (x-defined-colors))))))))))
    (if (equal "" col) nil col)))       ; Return nil for "".


(when (>= emacs-major-version 22)

  ;; REPLACES ORIGINAL in `facemenu.el':
  ;;
  ;; Interactively, numeric prefix arg means show face list for user to choose face by
  ;; clicking a face sample.
  ;;
  (defun facemenu-set-face (face &optional start end)
    "Apply FACE to the region or the next character typed.
With no prefix argument or a numeric prefix argument, if the region is
 active and non-empty, then apply FACE to the region.
Otherwise, apply FACE to the next character inserted.

FACE is determined as follows:
 With no prefix argument or a plain prefix argument (`C-u'), read the
   name of FACE, using completion.
 With a numeric prefix argument:
   Display the face list.  If the user clicks a face sample, then use
   that FACE.

 Call `facemenu-add-new-face', then `facemenu-add-face'.
 Add FACE to the menu of faces, if allowed by `facemenu-listed-faces'."
    (interactive
     (list (progn (barf-if-buffer-read-only)
                  (if (and current-prefix-arg  (atom current-prefix-arg))
                      (let ((deactivate-mark  nil)) (list-faces-display))
                    (read-face-name "Use face")))
           (and (facemenup-nonempty-region-p)  (atom current-prefix-arg)  (region-beginning))
           (and (facemenup-nonempty-region-p)  (atom current-prefix-arg)  (region-end))))
    (unless (and (interactive-p)  current-prefix-arg  (atom current-prefix-arg))
      (facemenu-add-new-face face)
      (facemenu-add-face face start end)))


  ;; REPLACES ORIGINAL in `faces.el'.
  ;;
  ;; When you click the face's sample text, the face is applied to the previous buffer.
  ;;
  (defun list-faces-display (&optional regexp)
    "List all faces, using the same sample text in each.
The sample text is a string that comes from the variable
`list-faces-sample-text'.

You can click a face name to see a description of the face and
possibly customize it.

You can click a face's sample text to apply that face to the
last-accessed buffer.  If the region in that buffer is active and
non-empty, then the face is applied to it.  Otherwise, the face
is applied to any new text that is entered.

With a prefix argument, you are prompted for a regexp, and only
faces with matching names are displayed."
    (interactive (list (and current-prefix-arg
                            (if (fboundp 'icicle-read-string-completing)
                                (icicle-read-string-completing
                                 "List faces matching regexp: " nil
                                 (lambda (c) (string-match "regexp" (symbol-name c))))
                              (if (fboundp 'read-regexp) ; Emacs 23.
                                  (read-regexp "List faces matching regexp")
                                (read-string "List faces matching regexp: "))))))
    (let ((all-faces        (zerop (length regexp)))
          (frame            (selected-frame))
          (max-length       0)
          (deactivate-mark  nil)
          faces line-format disp-frame window face-name)
      ;; We filter and take the max length in one pass
      (setq faces  (delq nil (mapcar (lambda (f)
                                       (let ((ss  (symbol-name f)))
                                         (when (or all-faces  (string-match regexp ss))
                                           (setq max-length  (max (length ss) max-length))
                                           f)))
                                     (sort (face-list) #'string-lessp))))
      (unless faces (error "No faces matching \"%s\"" regexp))
      (setq max-length   (1+ max-length)
            line-format  (format "%%-%ds" max-length))
      (facemenu+-with-help-window "*Faces*"
        (with-current-buffer standard-output
          (setq truncate-lines  t)
          (insert (funcall
                   (if (fboundp 'help-commands-to-key-buttons) ; In `help-fns.el'.
                       #'help-commands-to-key-buttons
                     #'substitute-command-keys)
                   (concat "Use \\<help-mode-map>"
                           (and (display-mouse-p)  "\\[help-follow-mouse] or ")
                           "\\[help-follow]:\n"
                           " * on a face's sample text to set the region to that face, or\n"
                           " * on a face name to see a description of the face and possibly"
                           " customize it.\n\n"
                           "Face                                      Sample\n\n")))
          (setq help-xref-stack  ())
          (dolist (face  faces)
            (setq face-name  (symbol-name face))
            (insert (format line-format face-name))
            ;; Hyperlink to a help buffer for the face.
            (save-excursion (save-match-data
                              (search-backward face-name)
                              (setq help-xref-stack-item  `(list-faces-display ,regexp))
                              (help-xref-button 0 'help-face face)))
            (let ((beg       (point))
                  (line-beg  (line-beginning-position)))
              (insert list-faces-sample-text)
              ;; Button to apply the face to the active region.
              (save-excursion (save-match-data
                                (search-backward list-faces-sample-text)
                                (help-xref-button 0 'help-facemenu-set-face
                                                  (list face (other-buffer (current-buffer) t)))))
              (insert "\n")
              (put-text-property beg (1- (point)) 'face face)
              ;; Make all face commands default to the proper face
              ;; anywhere in the line.
              (put-text-property line-beg (1- (point)) 'read-face-name face)
              ;; If the sample text has multiple lines, line up all of them.
              (goto-char beg)
              (forward-line 1)
              (while (not (eobp))
                (insert-char ?  max-length) ; ?\s won't byte-compile in Emacs 20.
                (forward-line 1))))
          (goto-char (point-min))))
      ;; If the *Faces* buffer appears in a different frame,
      ;; copy all the face definitions from FRAME,
      ;; so that the display will reflect the frame that was selected.
      (setq window      (get-buffer-window (get-buffer "*Faces*") t)
            disp-frame  (if window (window-frame window) (car (frame-list))))
      (or (eq frame disp-frame)
          (dolist (face (face-list))  (copy-face face face frame disp-frame)))))


  (define-button-type 'help-facemenu-set-face
      :supertype 'help-xref
      'help-function 'facemenup-set-face-from-list
      'help-echo (purecopy "mouse-2, RET: Set region to face"))

  (defun facemenup-set-face-from-list (face+buffer)
    "Like `facemenu-set-face', but acts in another buffer.
Argument FACE+BUFFER is a list (FACE BUFFER), where FACE is the
face to apply and BUFFER is the target buffer.
Also, close the *Faces* display."
    (let ((face    (car face+buffer))
          (buffer  (cadr face+buffer)))
      (save-excursion (set-buffer buffer)
                      (facemenu-add-new-face face)
                      (facemenu-add-face face
                                         (and (facemenup-nonempty-region-p)  (region-beginning))
                                         (and (facemenup-nonempty-region-p)  (region-end)))
                      (setq mark-active  nil)))
    (let ((win  (get-buffer-window "*Faces*"))) (when win (delete-window win))))


  ;; REPLACES ORIGINAL in `facemenu.el':
  ;;
  ;; 1. Add hyperlink to open palette on the color.
  ;; 2. Use RGB format that reflects the display's degree of color support.
  ;; 3. Tooltip on RGB hex code shows decimal RGB and HSV values.
  ;;
  (if (> emacs-major-version 23)
      ;; Emacs 24+
      (defun list-colors-print (list &optional callback)
        (let ((callback-fn  (and callback  `(lambda (button)
                                             (funcall ,callback (button-get button 'color-name)))))
              (rgb-format   (facemenu-rgb-format-for-display))
              rgb-width)
          (setq rgb-width  (1+ (length (format rgb-format 1 1 1))))
          (dolist (color list)
            (if (consp color)
                (when (cdr color)
                  (setq color  (sort color (lambda (a b) (string< (downcase a) (downcase b))))))
              (setq color  (list color)))
            (let* ((opoint        (point))
                   (color-values  (color-values (car color)))
                   (light-p       (>= (apply 'max color-values)
                                      (* (car (color-values "white")) .5)))
                   (max-len       (max (- (window-width) 33) 20)))
              (insert (car color))
              (indent-to 22)
              (put-text-property opoint (point) 'face (list ':background (car color)))
              (put-text-property (prog1 (point)
                                   (insert " ")
                                   (if (cdr color)
                                       ;; Insert as many color names as possible, fitting max-len.
                                       (let ((names   (list (car color)))
                                             (others  (cdr color))
                                             (len     (length (car color)))
                                             newlen)
                                         (while (and others
                                                     (< (setq newlen
                                                              (+ len 2 (length (car others))))
                                                        max-len))
                                           (setq len  newlen)
                                           (push (pop others) names))
                                         (insert (mapconcat 'identity (nreverse names) ", ")))
                                     (insert (car color))))
                                 (point) 'face (list ':foreground (car color)))
              (indent-to (max (- (window-width) rgb-width) 44))
              (insert (propertize
                       (apply 'format rgb-format (mapcar (lambda (c) (lsh c -8))
                                                         (color-values (car color))))
                       'mouse-face 'highlight
                       ;; This overrides the general tooltip that says
                       ;; `mouse-2, RET: Open palette on color'.
                       'help-echo
                       (format "RGB: (%s); HSV: (%s)"
                               (mapconcat (lambda (dd) (format "%1.6f" dd))
                                          (hexrgb-hex-to-rgb (car color)) ", ")
                               (mapconcat (lambda (dd) (format "%1.6f" dd))
                                          (hexrgb-hex-to-hsv (car color)) ", "))))
              ;; Original tooltip: less precise HSV and no RGB.
              ;; (let ((hsv  (apply 'color-rgb-to-hsv (color-values (car color)))))
              ;;   (format "Hue: %d, Saturation: %d, Value: %d"
              ;;           (nth 0 hsv) (nth 1 hsv) (nth 2 hsv))))))

              ;; Hyperlink to open palette on the color.
              (save-excursion (save-match-data
                                (forward-line 0)
                                (re-search-forward ".*")
                                (setq help-xref-stack-item  `(list-colors-display ,list))
                                (help-xref-button 0 'help-facemenu-edit-color
                                                  (if (consp color) (car color) color))))
              (when callback
                (make-text-button opoint (point)
                                  'follow-link t
                                  'mouse-face  (list :background (car color)
                                                     :foreground (if light-p "black" "white"))
                                  'color-name  (car color)
                                  'action      callback-fn)))
            (insert "\n")))
        (when (fboundp 'fit-frame-if-one-window) (fit-frame-if-one-window))
        (goto-char (point-min)))
    ;; Emacs 23
    (defun list-colors-print (list)
      (let ((rgb-format  (facemenu-rgb-format-for-display))
            rgb-width)
        (setq rgb-width  (1+ (length (format rgb-format 1 1 1))))
        (dolist (color list)
          (if (consp color)
              (when (cdr color)
                (setq color  (sort color (lambda (a b) (string< (downcase a) (downcase b))))))
            (setq color  (list color)))
          (put-text-property (prog1 (point) (insert (car color)) (indent-to 22))
                             (point) 'face (list ':background (car color)))
          (put-text-property (prog1 (point)
                               (insert " " (if (cdr color)
                                               (mapconcat 'identity (cdr color) ", ")
                                             (car color))))
                             (point) 'face (list ':foreground (car color)))
          (indent-to (max (- (window-width) rgb-width) 44))
          (insert (apply 'format rgb-format (mapcar (lambda (c) (lsh c -8))
                                                    (color-values (car color)))))
          ;; Hyperlink to open palette on the color.
          (when (fboundp 'palette)
            (save-excursion
              (save-match-data
                (forward-line 0)
                (re-search-forward ".*")
                (setq help-xref-stack-item  `(list-colors-display ,list))
                (help-xref-button 0 'help-facemenu-edit-color (if (consp color) (car color) color)))))
          (insert "\n")))
      (goto-char (point-min))))

  (defun facemenu-rgb-format-for-display ()
    (let ((ncolors  (display-color-cells (selected-frame)))
          (exp      0))
      (while (> (lsh ncolors (- exp)) 1)
        (setq exp  (1+ exp)))
      (setq exp  (/ exp 12))
      (format "#%%0%dx%%0%dx%%0%dx" exp exp exp)))

  (when (fboundp 'palette)
    (define-button-type 'help-facemenu-edit-color
      :supertype 'help-xref
      'help-function 'palette
      'help-echo (purecopy "mouse-2, RET: Open palette on color")))



  ;; REPLACES ORIGINAL in `facemenu.el':
  ;;
  ;; Put text property `font-lock-ignore' on the highlighted text.
  ;;
  (if (> emacs-major-version 23)
      ;; Emacs 24
      (defun facemenu-add-face (face &optional start end)
        "Add FACE to text between START and END.
If START is nil or START to END is empty, add FACE to next typed character
instead.  For each section of that region that has a different face property,
FACE will be consed onto it, and other faces that are completely hidden by
that will be removed from the list.
If `facemenu-add-face-function' and maybe `facemenu-end-add-face' are non-nil,
they are used to set the face information.

As a special case, if FACE is `default', then the region is left with NO face
text property.  Otherwise, selecting the default face would not have any
effect.  See `facemenu-remove-face-function'."
        (interactive "*xFace: \nr")
        (cond
          ((and (eq face 'default)
                (not (eq facemenu-remove-face-function t)))
           (if facemenu-remove-face-function
               (funcall facemenu-remove-face-function start end)
             (if (and start  (< start end))
                 (remove-text-properties start end '(face default))
               (facemenu-set-self-insert-face 'default))))
          (facemenu-add-face-function
           (save-excursion
             (when end (goto-char end))
             (save-excursion (when start (goto-char start))
                             (insert-before-markers (funcall facemenu-add-face-function face end)))
             (when facemenu-end-add-face
               (insert (if (stringp facemenu-end-add-face)
                           facemenu-end-add-face
                         (funcall facemenu-end-add-face face))))))
          ((and start  (< start end))
           (let ((part-start  start)
                 part-end)
             (while (not (= part-start end))
               (setq part-end  (next-single-property-change part-start 'face nil end))
               (let ((prev  (get-text-property part-start 'face)))
                 (put-text-property part-start part-end 'face
                                    (if (null prev)
                                        face
                                      (facemenu-active-faces
                                       (cons face (if (listp prev) prev (list prev)))
                                       ;; Specify selected frame because nil means to use the
                                       ;; new-frame default settings, and those are usually nil.
                                       (selected-frame))))
                 (put-text-property part-start part-end 'font-lock-ignore t))
               (setq part-start  part-end))))
          (t
           (facemenu-set-self-insert-face
            (if (eq last-command (cdr facemenu-self-insert-data))
                (cons face (if (listp (car facemenu-self-insert-data))
                               (car facemenu-self-insert-data)
                             (list (car facemenu-self-insert-data))))
              face))))
        (unless (or (featurep 'font-lock+)  (facemenu-enable-faces-p))
          (message "Font-lock mode will override any faces you set in this buffer")))

    ;; Emacs 22, 23
    (defun facemenu-add-face (face &optional start end)
      "Add FACE to text between START and END.
If START is nil or START to END is empty, add FACE to next typed character
instead.  For each section of that region that has a different face property,
FACE will be consed onto it, and other faces that are completely hidden by
that will be removed from the list.
If `facemenu-add-face-function' and maybe `facemenu-end-add-face' are non-nil,
they are used to set the face information.

As a special case, if FACE is `default', then the region is left with NO face
text property.  Otherwise, selecting the default face would not have any
effect.  See `facemenu-remove-face-function'."
      (interactive "*xFace: \nr")
      (if (and (eq face 'default)
               (not (eq facemenu-remove-face-function t)))
          (if facemenu-remove-face-function
              (funcall facemenu-remove-face-function start end)
            (if (and start  (< start end))
                (remove-text-properties start end '(face default))
              (setq self-insert-face          'default
                    self-insert-face-command  this-command)))
        (if facemenu-add-face-function
            (save-excursion
              (when end (goto-char end))
              (save-excursion
                (when start (goto-char start))
                (insert-before-markers (funcall facemenu-add-face-function face end)))
              (when facemenu-end-add-face
                (insert (if (stringp facemenu-end-add-face)
                            facemenu-end-add-face
                          (funcall facemenu-end-add-face face)))))
          (if (and start  (< start end))
              (let ((part-start  start)
                    part-end)
                (while (not (= part-start end))
                  (setq part-end  (next-single-property-change part-start 'face nil end))
                  (let ((prev  (get-text-property part-start 'face)))
                    (put-text-property part-start part-end 'face
                                       (if (null prev)
                                           face
                                         (facemenu-active-faces
                                          (cons face (if (listp prev) prev (list prev)))
                                          ;; Specify selected frame because nil means to use the
                                          ;; new-frame default settings, and those are usually nil.
                                          (selected-frame))))
                    (put-text-property part-start part-end 'font-lock-ignore t))
                  (setq part-start  part-end)))
            (setq self-insert-face  (if (eq last-command self-insert-face-command)
                                        (cons face (if (listp self-insert-face)
                                                       self-insert-face
                                                     (list self-insert-face)))
                                      face)
                  self-insert-face-command this-command))))
      (unless (or (featurep 'font-lock+)  (facemenu-enable-faces-p))
        (message "Font-lock mode will override any faces you set in this buffer")))))


  ;; REPLACES ORIGINAL in `facemenu.el':
  ;;
  ;; Put text property `font-lock-ignore' on the highlighted text.
  ;;
(when (fboundp 'facemenu-post-self-insert-function) ; Emacs 24+
  (defun facemenu-post-self-insert-function ()
    (when (and (car facemenu-self-insert-data)
               (eq last-command (cdr facemenu-self-insert-data)))
      (put-text-property (1- (point)) (point) 'face (car facemenu-self-insert-data))
      (put-text-property (1- (point)) (point) 'font-lock-ignore t)
      (setq facemenu-self-insert-data nil))
    (remove-hook 'post-self-insert-hook 'facemenu-post-self-insert-function)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide 'facemenu+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; facemenu+.el ends here
#+end_src

** fit-frame.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220455404939700

#+name: 20210601220455404939700
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; fit-frame.el --- Resize a frame.  In particular, fit a frame to its buffers.
;;
;; Filename: fit-frame.el
;; Description: Resize a frame.  In particular, fit a frame to its buffers.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 2000-2018, Drew Adams, all rights reserved.
;; Created: Thu Dec  7 09:32:12 2000
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Sun Apr  1 20:10:02 2018 (-0700)
;;           By: dradams
;;     Update #: 1392
;; URL: https://www.emacswiki.org/emacs/download/fit-frame.el
;; Doc URL: https://www.emacswiki.org/emacs/Shrink-Wrapping_Frames
;; Doc URL: https://www.emacswiki.org/emacs/OneOnOneEmacs
;; Keywords: internal, extensions, convenience, local
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Resize a frame.  In particular, fit a frame to its buffers.
;;
;;  Commands and user options (variables) are provided here to resize
;;  (shrink-wrap) a frame to fit its displayed buffers, its selected
;;  buffer, or the `fill-column' width.
;;
;;  The command to fit a frame is `fit-frame'.  The main user options
;;  for this command are `fit-frame-inhibit-fitting-flag' and
;;  `fit-frame-max-*[-percent]'.  You can use a prefix argument to
;;  control the behavior of command `fit-frame'.
;;
;;  To take full advantage of the functionality provided here, load
;;  the companion library `autofit-frame.el', to modify primitives
;;  `display-buffer' and `switch-to-buffer' so they automatically fit
;;  all frames that have a single window.  Library `autofit-frame.el'
;;  loads library `fit-frame.el'.
;;
;;  Put this in your initialization file (`~/.emacs'):
;;
;;    (require 'fit-frame)
;;    (add-hook 'after-make-frame-functions 'fit-frame)
;;
;;  The second line here causes newly created frames to be fitted to
;;  their buffer.  Even if you load library `autofit-frame.el', you
;;  will still need to do this, because `display-buffer' and
;;  `switch-to-buffer' are not called when a new frame is created.
;;
;;  Command `fit-frame' does *not* take the following into account,
;;  when determining the proper frame size:
;;
;;   - font sizes, other than the default frame font
;;   - characters that have special widths
;;
;;  NOTE: If you also use library `frame-cmds.el', and you are on MS
;;  Windows, then load that library after `fit-frame.el'.  This is
;;  because the commands `maximize-frame' and `restore-frame' defined
;;  there are more general and non-Windows-specific.
;;
;;  Suggested key bindings:
;;
;;   (global-set-key [(control ?x) (control ?_)] 'fit-frame)
;;   (global-set-key [vertical-line down-mouse-1]
;;                   'fit-frame-or-mouse-drag-vertical-line)
;;
;;  Customize the menu-bar.  Uncomment this to try it out.
;;
;;   (defvar menu-bar-frames-menu (make-sparse-keymap "Frames"))
;;   (define-key global-map [menu-bar frames]
;;     (cons "Frames" menu-bar-frames-menu)))
;;   (define-key menu-bar-frames-menu [fit-frame]
;;     '("Fit This Frame" . fit-frame))
;;
;;
;;  Commands defined here:
;;
;;    `fit-frame', `fit-frame-or-mouse-drag-vertical-line',
;;    `fit-frame-maximize-frame', `fit-frame-minimize-frame',
;;    `fit-frame-restore-frame', `fit-frame-to-image',
;;    `maximize-frame', `minimize-frame', `restore-frame',
;;
;;  User options (variables) defined here:
;;
;;    `fit-frame-crop-end-blank-flag', `fit-frame-empty-height',
;;    `fit-frame-empty-special-display-height',
;;    `fit-frame-empty-special-display-width',
;;    `fit-frame-empty-width', `fit-frame-fill-column-margin',
;;    `fit-frame-inhibit-fitting-flag', `fit-frame-max-height',
;;    `fit-frame-max-height-percent', `fit-frame-max-width',
;;    `fit-frame-max-width-percent', `fit-frame-min-height',
;;    `fit-frame-min-width', `fit-frame-skip-header-lines-alist'.
;;
;;  Non-interactive functions defined here:
;;
;;    `fit-frame-fringe-width', `fit-frame-max-frame-size',
;;    `fit-frame-max-height', `fit-frame-max-width',
;;    `fit-frame-max-window-size', `fit-frame-same-column-windows',
;;    `fit-frame-same-row-windows', `fit-frame-thumbnail-factor'.
;;
;;
;;  See also these files for other frame commands:
;;
;;     `autofit-frame.el' - See above.
;;
;;     `frame-cmds.el' - Various frame and window commands, including
;;                       commands to incrementally resize frames and
;;                       better, non-Windows-specific commands to
;;                       maximize and restore frames.
;;
;;     `doremi-frm.el' - Incrementally adjust frame properties
;;                       using arrow keys and/or mouse wheel.
;;
;;  This file was formerly called `shrink-fit.el', then
;;  `resize-frame.el', and command `fit-frame' was formerly called
;;  `shrink-frame-to-fit', then `resize-frame'.
;;
;;  TO DO:
;;
;;  Emacs needs a command similar to `fit-frame' for windows, that is,
;;  a command that will fit the existing windows of a frame to their
;;  buffers, as well as possible.  That could be then be used in
;;  combination with `fit-frame'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2018/04/01 dadams
;;     fit-frame-max-height-percent: Change default value to 80 for Emacs 26+.
;; 2016/10/02 dadams
;;     Added: fit-frame-to-non-image.
;;     fit-frame:
;;       Added optional arg INTERACTIVEP.
;;       If image and not interactive, ignore errors in call to fit-frame-to-image.
;;       Factored out non-image case as fit-frame-to-non-image - just call it if no image.
;;     fit-frame-to-image: If not interactive then call message, not error.
;;                         Return non-nil if not no-op.
;; 2013/06/30 dadams
;;     fit-frame: Respect fit-frame-inhibit-fitting-flag for image-fitting also.
;; 2013/06/10 dadams
;;     fit-frame, fit-frame-to-image: No-op if Emacs not running in a graphic display.
;;     fit-frame: Ensure one-window-p before calling fit-frame-to-image.
;; 2013/03/12 dadams
;;     Do not defalias if a function with the alias name already exists.
;; 2012/11/01 dadams
;;     fit-frame-skip-header-lines-alist: Use 3 for Dired (1 for wildcards line).
;; 2011/03/04 dadams
;;     fit-frame-to-image: Fixed for Emacs 23, which doesn't yet have image-display-size.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non def* sexps.
;; 2010/12/24 dadams
;;     Added: fit-frame-to-image.
;;     fit-frame: Call fit-frame-to-image if frame is in an image mode.
;; 2010/08/27 dadams
;;     Added: fit-frame-fringe-width.
;;     fit-frame-max-frame-size: Increase width by fit-frame-fringe-width.
;; 2009/05/17 dadams
;;     Updated to reflect thumb-frm.el name changes.
;; 2009/05/15 dadams
;;     Added: fit-frame-crop-end-blank-flag.
;;     fit-frame-min-width: Initalize to window-min-width, not to 20.
;;     fit-frame: Include menu-bar-lines, and assume menu-bar wraps once.
;;     fit-frame-max-window-size:
;;       Don't increase if at eob (can't move forward).
;;       Respect fit-frame-crop-end-blank-flag.
;;       Add 1 for mode-line.
;;       Header line count was 1 too many.
;; 2009/04/26 dadams
;;     fit-frame-max-window-size: Bind inhibit-field-text-motion, for end-of-line.
;; 2008/03/11 dadams
;;     fit-frame-same-(row|column)-windows: cadddr etc. -> non Common-Lisp versions.
;; 2007/12/30 dadams
;;     fit-frame: Forgot to set extra-lines for Emacs 20.
;; 2007/12/29 dadams
;;     fit-frame:
;;       Put init of empty-buf-p and specbuf-p back inside window excursion.
;;       Compute computed-max-frame-size before call set-frame-size.
;;     fit-frame-same-(row|column)-windows: Replace FRAME arg with WINS.
;; 2007/12/28 dadams
;;     fit-frame-same-(row|column)-windows: Use dolist instead of walk-windows.
;;     fit-frame: Compute empty-buf-p and specbuf-p in let binding.
;;     Misc. doc string and comment rephrasing.
;; 2007/12/18 dadams
;;     fit-frame-max-(width|height): Applied patch from David Reitter for Apple (Mac).
;; 2007/11/27 dadams
;;     fit-frame: Use read-number, if available.
;; 2007/11/21 dadams
;;     fit-frame: extra-lines:
;;       Don't add 1 for standalone minibuffer.
;;       Removed extra 2-line tweak factor for Emacs 21+.
;; 2007/11/01 dadams
;;     RMS request: Simplified fit-frame doc string.
;; 2007/07/22 dadams
;;     RMS requests:
;;       Lowercased group name.
;;       Renamed to use prefix fit-frame-: (maximize|minimize|restore)-frame,
;;         create-empty(-special-display)-frame-(height|width),
;;         fill-column-frame-margin, frame-max-(height|width)(-percent),
;;         frame-min-(height|width), inhibit-fit-frame-flag,  max-(frame|window)-size,
;;         same-(column|row)-windows, thumbnail-factor.
;;     Added aliases: maximize-frame, minimize-frame, restore-frame.
;; 2007/07/21 dadams
;;     fit-frame: Added optional all-windows-p arg.
;;     Added: max-frame-size, max-window-size, same-column-windows, same-row-windows.
;;     Removed: show-frame, get-a-frame, get-frame-name, (set-)minibuffer-empty-p.
;;     Removed require of frame-cmds.el.
;;     Renamed: create-frame-(min|max)-(width|height)(-percent) to
;;              frame-(min|max)-(width|height)(-percent).
;; 2007/03/11 dadams
;;     fit-frame: Deal with header lines that wrap more than once.
;;     fit-frame-skip-header-lines-alist: 2 lines for Dired.
;; 2006/03/13 dadams
;;     fit-frame: Treat nil tool-bar-lines as zero.  (Thx to Sebastian Luque.)
;; 2006/01/07 dadams
;;     Added :link for sending bug report.
;; 2006/01/06 dadams
;;     Added :link.  Capitalized group name.
;;     Added ;;;###autoload.
;; 2005/12/30 dadams
;;     Added: thumbnail-factor.
;;     create-frame-max-height: Use thumbnail-factor.
;; 2005/11/15 dadams
;;     create-frame-max-* functions: Added optional frame arg.
;;     Minor bug fix: Call create-frame-max-* with frame arg, so use correct char size.
;; 2005/07/31 dadams
;;     Removed require of strings.el.
;; 2005/07/04 dadams
;;     fit-frame: Bug fix: Added (set-buffer (window-buffer))
;; 2005/05/30 dadams
;;     Added: fit-frame-skip-header-lines-alist.
;;     fit-frame:
;;       Use fit-frame-skip-header-lines-alist to ignore width of header lines.
;; 2005/05/29 dadams
;;     Moved enlarge-frame* and shrink-frame* to frame-cmds.el.
;; 2005/05/25 dadams
;;     string-to-int -> string-to-number everywhere.
;; 2005/03/18 dadams
;;     Added: maximize-frame, restore-frame, minimize-frame.
;; 2004/12/18 dadams
;;     Updated Commentary to clarify use of after-make-frame-functions.
;; 2004/10/13 dadams
;;     Use special-display-p instead of special-display-buffer-p.
;; 2004/10/09 dadams
;;     Per request by RMS:
;;       Removed fit-1-window-frames-on (moved to compile-.el).
;;       Removed ;;;#autoload's.
;;       Renamed resize-* to fit-*.
;;       Changed defvar to defcustom.
;; 2004/10/02 dadams
;;     Per request by RMS:
;;       Renamed grow-frame-height and grow-frame-width to enlarge-frame
;;         and enlarge-frame-horizontally, respectively.
;;       Added shrink-frame and shrink-frame-horizontally.
;; 2004/08/26 dadams
;;     Added enlarge-frame and enlarge-frame-horizontally
;; 2004/06/01 dadams
;;     1. Removed making-frame-msg and making-frame-done-msg.
;;     2. Renamed shrink-* to resize-*. Renamed file.
;;     3. Renamed and reversed enable-* to inhibit-*.
;; 2004/05/07 dadams
;;     Updated to work with Emacs 21 and to work standalone.
;; 2004/04/06 dadams
;;     Removed nframe. make-frame is defined without it in Emacs 20.7.
;; 2001/01/05 dadams
;;     Protected show-frame via fboundp.
;; 2000/12/08 dadams
;;     Clarified doc strings: create-empty-frame-*, create-empty-special-*.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (when (< emacs-major-version 21) (require 'cl-lib))) ;; dolist

;; Quiet the byte compiler.
(defvar image-minor-mode)

;;;;;;;;;;;;;;;;;;;;;;;

;;; User options ---------------------------------------------------

;;;###autoload
(defgroup fit-frame nil
  "Resize a frame to fit its buffers."
  :group 'frames :group 'convenience
  :link `(url-link :tag "Send Bug Report"
          ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
fit-frame.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download"
          "https://www.emacswiki.org/emacs/download/fit-frame.el")
  :link '(url-link :tag "Description"
          "https://www.emacswiki.org/emacs/Shrink-Wrapping_Frames")
  :link '(emacs-commentary-link :tag "Commentary" "fit-frame"))

;;;###autoload
(defcustom fit-frame-inhibit-fitting-flag nil
  "*Non-nil means command `fit-frame' does nothing.
You can bind this to non-`nil' to temporarily inhibit frame fitting:
    (let ((fit-frame-inhibit-fitting-flag  t))...)"
  :type 'boolean :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-crop-end-blank-flag nil
  "*Non-nil means `fit-frame' doesn't count blank lines at end of buffer.
If nil, then fitting leaves room for such blank lines."
  :type 'boolean :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-min-width window-min-width
  "*Minimum width, in characters, that `fit-frame' gives to a frame.
The actual minimum is at least the greater of this and `window-min-width'."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-max-width nil
  "*Maximum width, in characters, that `fit-frame' gives to a frame.
If nil, then the function `fit-frame-max-width' is used instead."
  :type '(choice (const :tag "Use `fit-frame-max-width-percent' instead" nil)
                 integer)
  :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-max-width-percent 94
  "*Maximum percent of display width that `fit-frame' gives to a frame'.
See function `fit-frame-max-width'.
Not used unless `fit-frame-max-width' is nil."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-min-height window-min-height
  "*Minimum height, in lines, that `fit-frame' gives to a frame.
The actual minimum is at least the greater of this and `window-min-height'."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-max-height nil
  "*Maximum height, in lines, that `fit-frame' gives to a frame.
If nil, then the function `fit-frame-max-height' is used instead."
  :type '(choice (const :tag "Use `fit-frame-max-height-percent' instead" nil)
                 integer)
  :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-max-height-percent (if (> emacs-major-version 25) 80 82)
  "*Maximum percent of display height that `fit-frame' gives to a frame.
See function `fit-frame-max-height'.
Not used unless `fit-frame-max-height' is nil."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-empty-width (or (cdr (assq 'width default-frame-alist))  80)
  "*Width, in characters, that `fit-frame' gives to an empty frame."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-empty-height (or (cdr (assq 'height default-frame-alist))  35)
  "*Height, in lines, that `fit-frame' gives to an empty frame."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-empty-special-display-width 80
  "*Width, in chars, that `fit-frame' gives to an empty special-display frame.
If this is nil, it is ignored."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-empty-special-display-height 9
  "*Height, in lines, that `fit-frame' gives to an empty special-display frame.
If this is nil, it is ignored."
  :type 'integer :group 'fit-frame)

;;;###autoload
(defcustom fit-frame-fill-column-margin 7
  "*Difference between `fill-column' and frame width after fitting a frame.
Used when `fit-frame' fits a frame, if the prefix arg is negative.
Depending on the average word length of the language used in the
selected window, you might want different values for this.  This
variable is buffer-local."
  :type 'integer :group 'fit-frame)

(make-variable-buffer-local 'fit-frame-fill-column-margin)

;;;###autoload
(defcustom fit-frame-skip-header-lines-alist
  '((Info-mode . 1) (dired-mode . 3) (compilation-mode . 2))
  "*Alist of major-modes and header lines to ignore.
When `fit-frame' calculates the width of the current buffer, it can
first skip some lines at the buffer beginning, ignoring their
widths.  For example, Info, Dired, and compilation buffers sometimes
have a long header line at the top.  You can use this alist to tell
`fit-frame' to ignore the width of these header lines.

Each item in the alist is of form (MODE . LINES).
 MODE is a major-mode name.
 LINES is the number of lines to skip at the beginning of the buffer."
  :type '(repeat (cons :format "%v" (symbol :tag "Major Mode")
                       (integer :tag "Header Lines to Ignore")))
  :group 'fit-frame)

;;; Commands ---------------------------------------------------

;;;###autoload
(defun fit-frame (&optional frame width height all-windows-p interactivep)
  "Resize FRAME to fit its buffer(s).
Does nothing if `fit-frame-inhibit-fitting-flag' is non-nil.

FRAME defaults to the current (i.e. selected) frame.

If non-nil, WIDTH and HEIGHT specify the frame width and height.  To
define them interactively, use a non-negative prefix arg (e.g. `C-9').

To set the width to `fill-column' + `fit-frame-fill-column-margin',
use a negative prefix arg (e.g. `M--').

To fit the frame to all of its displayed buffers, use no prefix arg.
To fit it to just the current buffer, use a plain prefix arg (`C-u').

Fitting a non-empty buffer means resizing the frame to the smallest
size such that the following are both true:

 ,* The width is at least `fit-frame-min-width' and `window-min-width'.
   The width is at most `fit-frame-max-width(-percent)' and the
   longest line length.

   (However, extra width is allowed for fringe, if shown.)

 ,* The height is at least `fit-frame-min-height' and
   `window-min-height'.  The height is at most
   `fit-frame-max-height(-percent)' and the number of lines.

You can thus use those user variables to control the maximum and
minimum frame sizes.  The `*-percent' options let you specify the
maximum as a percentage of your display size.

See also options `fit-frame-skip-header-lines-alist' and
`fit-frame-crop-end-blank-flag'.

The following user options control how an empty frame is fit.
An empty frame is a one-window frame displaying an empty buffer.

 ,* `fit-frame-empty-width', `fit-frame-empty-height' (normal buffer)
 ,* `fit-frame-empty-special-display-width',
   `fit-frame-empty-special-display-height' (special-display buffer)

Note: `fit-frame' does not take into account wrapping of a menu-bar
line.  There is no easy way to calculate the number of display lines
from such wrapping."
  (interactive
   (let ((option  (prefix-numeric-value current-prefix-arg)))
     (list nil
           ;; Plain `C-u' means WIDTH, HEIGHT, and ALL-WINDOWS-P are all nil.
           ;; Non-negative prefix arg means prompt user for WIDTH and HEIGHT.
           ;; Negative prefix arg means use
           ;;   `fill-column' + `fit-frame-fill-column-margin'
           ;;   for WIDTH, and use current frame height for HEIGHT.
           (and current-prefix-arg  (atom current-prefix-arg)
                (if (fboundp 'display-graphic-p) (display-graphic-p) window-system)
                (if (natnump option)
                    (floor (if (fboundp 'read-number)
                               (read-number "New width: ")
                             (string-to-number (read-string "New width: "))))
                  (+ fill-column fit-frame-fill-column-margin)))
           (and current-prefix-arg  (atom current-prefix-arg)
                (if (fboundp 'display-graphic-p) (display-graphic-p) window-system)
                (if (natnump option)
                    (floor (if (fboundp 'read-number)
                               (read-number "New height: ")
                             (string-to-number (read-string "New height: "))))
                  (frame-height)))
           (atom current-prefix-arg)
           t)))
  (and (if (fboundp 'display-graphic-p) (display-graphic-p) window-system) ; No-op if not.
       (if (and (fboundp 'image-mode-fit-frame) ; Emacs 23+
                (if (or (null frame)  (eq frame (selected-frame)))
                    (or (eq major-mode 'image-mode)  image-minor-mode)
                  (save-window-excursion
                    (select-frame frame)
                    (one-window-p)      ; `fit-frame-to-image' requires it.
                    (or (eq major-mode 'image-mode)  image-minor-mode))))
           (unless fit-frame-inhibit-fitting-flag
             (if interactivep
                 (fit-frame-to-image t frame)
               (or (condition-case nil (fit-frame-to-image nil frame))
                   (fit-frame-to-image t frame))))
         (fit-frame-to-non-image frame width height all-windows-p))))

(defun fit-frame-to-non-image (&optional frame width height all-windows-p)
  "Fit FRAME (default: selected frame) to buffer contents.
FRAME has more than one window or the window is not showing an image."
  (setq frame  (or frame  (selected-frame)))
  (unless fit-frame-inhibit-fitting-flag
    (let ((extra-lines  0)
          computed-max-frame-size empty-buf-p specbuf-p)
      (save-window-excursion
        (select-frame frame)
        (setq empty-buf-p  (and (= (point-min) (point-max))
                                (one-window-p (selected-window)))
              specbuf-p    (and empty-buf-p
                                (special-display-p (buffer-name (window-buffer))))))
      ;; `extra-lines' for minimum frame height.  Starting with Emacs 21+,
      ;; `set-frame-size' includes the tool-bar and the minibuffer.  For Emacs
      ;; without a toolkit, the one-line menu-bar is also included - add 1 line
      ;; for that.  Add 1 line for the minibuffer, unless it is standalone.
      ;; Perhaps we should also take into account a possible horizontal scroll
      ;; bar, but we don't do that.
      (let* ((fparams     (frame-parameters frame))
             (menu-lines  (or (cdr (assq 'menu-bar-lines fparams))  0)))
        (when (> emacs-major-version 20)
          (setq extra-lines  (or (cdr (assq 'tool-bar-lines fparams))  0))
          (when (and (not (eq system-type 'windows-nt))  (not (featurep 'x-toolkit)))
            (setq extra-lines  (1+ extra-lines))))
        ;; We can't really know whether menu-bar gets wrapped.  Assume it wraps once.
        (when (> menu-lines 0)
          (setq extra-lines  (+ extra-lines (1+ menu-lines))))
        (when (and (cdr (assq 'minibuffer fparams)) ; Frame has a minibuffer, but
                   (save-window-excursion (select-frame frame) ; it's not standalone.
                                          (not (one-window-p nil 'selected-frame))))
          (setq extra-lines  (1+ extra-lines))))
      (unless (or empty-buf-p  (and width  height))
        (setq computed-max-frame-size  (fit-frame-max-frame-size frame all-windows-p)))
      (set-frame-size
       ;; Frame
       frame
       ;; Columns
       (or width
           (and empty-buf-p  (if specbuf-p
                                 fit-frame-empty-special-display-width
                               fit-frame-empty-width))
           (max fit-frame-min-width window-min-width
                (min (or fit-frame-max-width  (fit-frame-max-width frame))
                     (1+ (car computed-max-frame-size)))))
       ;; Rows
       (or height
           (and empty-buf-p  (if specbuf-p
                                 fit-frame-empty-special-display-height
                               fit-frame-empty-height))
           (max fit-frame-min-height window-min-height
                (min (or fit-frame-max-height  (fit-frame-max-height frame))
                     (+ (cdr computed-max-frame-size) extra-lines))))))))

;; Similar to `image-mode-fit-frame'.
;;
;; 1. Adds the optional arg FRAME.
;; 2. Does not toggle between original size and fit size unless interactive.
;;    When called from code it always fits.
;;
;;;###autoload
(defun fit-frame-to-image (interactivep &optional frame)
  "Fit FRAME to the current image.
If FRAME is not the selected frame, fit it to its first image.
Interactively, if frame has already been fit to the image, then
 restore the size from before it was fit.
This function assumes that FRAME has only one window."
  ;; Vanilla Emacs FIXME: This does not take into account decorations
  ;; like mode-line, minibuffer, header-line, ...
  (interactive "p")
  (unless (fboundp 'image-mode-fit-frame)
    (funcall (if interactivep #'error #'message)
             "This command requires the image support of Emacs 23 or later"))
  (and (if (fboundp 'display-graphic-p) (display-graphic-p) window-system) ; No-op if not.
       (let* ((saved    (frame-parameter frame 'image-mode-saved-size))
              (display  (if (or (null frame)  (equal frame (selected-frame)))
                            (image-get-display-property)
                          (save-selected-window (select-frame frame)
                                                (image-get-display-property))))
              (size     (if (fboundp 'image-display-size) ; Emacs 24+.
                            (image-display-size display nil frame)
                          (image-size display nil frame))))
         (setq frame  (or frame  (selected-frame)))
         (if (and interactivep  saved
                  (eq (caar saved) (frame-width frame))
                  (eq (cdar saved) (frame-height frame)))
             (progn                     ; Restore previous size, before it was fit.
               (set-frame-parameter frame 'image-mode-saved-size nil)
               (setq size  (cdr saved)))
           ;; Round up size, and save current size so we can toggle back to it.
           (setcar size (ceiling (car size)))
           (setcdr size (ceiling (cdr size)))
           (set-frame-parameter
            frame 'image-mode-saved-size
            (cons size (cons (frame-width frame) (frame-height frame)))))
         (set-frame-size frame (car size) (cdr size))
         t)))                           ; Return non-nil if not no-op.

;;;###autoload
(defun fit-frame-or-mouse-drag-vertical-line (start-event)
  "If only window in frame, `fit-frame'; else `mouse-drag-vertical-line'."
  (interactive "e")
  (if (one-window-p t) (fit-frame) (mouse-drag-vertical-line start-event)))

;; Note that in Windows you can also just double-click the title bar
;; of a frame to alternately maximize and restore it.
(when (eq window-system 'w32)
  (unless (fboundp 'restore-frame) (defalias 'restore-frame 'fit-frame-restore-frame))
  (defun fit-frame-restore-frame (&optional frame)
    "Restore FRAME to previous size (default: current frame)."
    (interactive)
    (w32-send-sys-command 61728 frame)))

(when (eq window-system 'w32)
  (unless (fboundp 'maximize-frame) (defalias 'maximize-frame 'fit-frame-maximize-frame))
  (defun fit-frame-maximize-frame (&optional frame)
    "Maximize FRAME (default: current frame)."
    (interactive)
    (w32-send-sys-command 61488 frame)))

(when (eq window-system 'w32)
  (unless (fboundp 'minimize-frame) (defalias 'minimize-frame 'fit-frame-minimize-frame))
  (defalias 'fit-frame-minimize-frame
      (if (fboundp 'thumfr-really-iconify-frame)
          'thumfr-really-iconify-frame
        'iconify-frame)))

;;; Non-Interactive Functions -------------------------------------------

(defun fit-frame-max-width (&optional frame)
  "Returns the maximum width, in chars, for a new frame that was fit.
If option `fit-frame-max-width' is non-nil, then this is not used.

The value is relative to your display size and FRAME's character
size, and depends on the value of `fit-frame-max-width-percent':

  (/ (* fit-frame-max-width-percent (x-display-pixel-width))
     (* 100 (frame-char-width FRAME)))"
  (setq frame  (or frame  (selected-frame)))
  (/ (* fit-frame-max-width-percent
        (if (fboundp 'winmgr-display-available-pixel-bounds) ; For MacIntosh.
         (nth 2 (winmgr-display-available-pixel-bounds))
         (x-display-pixel-width)))
     (* 100 (frame-char-width frame))))

(defun fit-frame-max-height (&optional frame)
  "Returns the maximum height, in lines, for a new frame that was fit.
If option `fit-frame-max-height' is non-nil, then this is not used.

The value is relative to your display size and FRAME's character
size, and depends on the value of `fit-frame-max-height-percent':

  (/ (* fit-frame-max-height-percent (x-display-pixel-height))
     (* 100 (frame-char-height FRAME)))"
  (setq frame  (or frame  (selected-frame)))
  (/ (* fit-frame-max-height-percent
        (if (fboundp 'winmgr-display-available-pixel-bounds) ; For MacIntosh.
         (nth 3 (winmgr-display-available-pixel-bounds))
         (x-display-pixel-height)))
     (* 100 (frame-char-height frame)
        ;; When fitting a thumbnail frame, we don't want the height to use the
        ;; whole display height.  So, we apply a fudge factor:
        ;; `fit-frame-thumbnail-factor'.  We could also use it in
        ;; `fit-frame-max-width', in addition to `fit-frame-max-height',
        ;; but we don't need to.
        (fit-frame-thumbnail-factor frame))))

(defun fit-frame-max-frame-size (frame all-windows-p)
  "Return maximum size of frame FRAME as a cons: (MAX-WIDTH . MAX-HEIGHT).
If ALL-WINDOWS-P is non-nil, then consider all buffers shown in FRAME.
Otherwise, consider only the selected buffer."
  (save-window-excursion
    (select-frame frame)
    (if (not all-windows-p)
        (let ((win-cons  (fit-frame-max-window-size (selected-window))))
          (cons (+ (car win-cons) (fit-frame-fringe-width frame))
                (cdr win-cons)))
      (let* ((wins         ())
             (marked-wins  ())           ; Windows whose size was already considered.
             (max-width    0)
             (max-height   0))
        (walk-windows (lambda (w) (push w wins)) 'no-mini 'this-frame)
        (setq wins  (sort wins (lambda (w1 w2) ; Top to bottom, left to right.
                                 (let ((edges1  (window-edges w1))
                                       (edges2  (window-edges w2)))
                                   (or (< (cadr edges1) (cadr edges2)) ; top
                                       (and (= (cadr edges1) (cadr edges2))
                                            (<= (car edges1) (car edges2)))))))) ; left
        ;; Iterate over all windows in frame.
        ;; For each, check all windows in the same row, and all in the same column.
        ;; When checking those in the same row:
        ;;   1. Increase MAX-HEIGHT to the max buffer height of the row windows.
        ;;   2. Increase MAX-WIDTH to the sum of the buffer widths of the row windows.
        ;; When checking those in the same column:
        ;;   1. Increase MAX-WIDTH to the max buffer width of the column windows.
        ;;   2. Increase MAX-HEIGHT to the sum of the buffer heights of the col windows.
        ;; After examining a window in the frame, exclude it from further examination
        ;;  by adding it to MARKED-WINS.
        (dolist (win wins)
          (unless (memq win marked-wins)
            (let* ((win-edges  (window-edges win))
                   (win-top    (cadr win-edges))
                   (win-left   (car win-edges)))
              ;; Add widths of buffers in the same row.  Max the heights of the buffers.
              (dolist (row-win (fit-frame-same-row-windows wins win marked-wins))
                ;; Add ROW-WIN to exclusion list for subsequent iterations.
                (setq marked-wins  (cons row-win marked-wins))
                (let* ((win-size        (fit-frame-max-window-size row-win))
                       (max-win-width   (car win-size))
                       (max-win-height  (cdr win-size)))
                  (unless (> (cadr (window-edges row-win)) win-top) ; Use only first.
                    (setq max-width  (+ max-width max-win-width)))
                  (setq max-height  (max max-height max-win-height))))
              ;; Add heights of buffers in the same column.  Max the buffer widths.
              (dolist (col-win (fit-frame-same-column-windows wins win marked-wins))
                ;; Add COL-WIN to exclusion list for subsequent iterations.
                (setq marked-wins  (cons col-win marked-wins))
                (let* ((win-size        (fit-frame-max-window-size col-win))
                       (max-win-width   (car win-size))
                       (max-win-height  (cdr win-size)))
                  (unless (> (car (window-edges col-win)) win-left) ; Use only first.
                    (setq max-height  (+ max-height max-win-height)))
                  (setq max-width  (max max-width max-win-width)))))))
        (cons (+ max-width (fit-frame-fringe-width frame)) max-height)))))

(defun fit-frame-fringe-width (&optional frame)
  "Width to allow for fringes on FRAME."
  ;; Ignore differences between frame parameter values and round-up actual widths.
  (let ((fringe        (+ (abs (or (frame-parameter frame 'left-fringe)   0))
                          (abs (or (frame-parameter frame 'right-fringe)  0))))
        (char-width    (frame-char-width frame))
        (fringe-width  0))
    (when (and (boundp 'fringe-mode)  fringe  (not (zerop fringe)))
      ;; Round the integer division using: 1 + (x-1)/y
      (setq fringe-width  (+ fringe-width 1 (/ (1- fringe) char-width))))
    fringe-width))

(defun fit-frame-same-row-windows (wins window exclude)
  "Returns the windows in WINS that are in the same row as window WINDOW.
This the list of windows in WINS whose top edge is above the bottom
 edge of WINDOW.
Windows that are in list EXCLUDE are excluded from the result."
  (let ((ref-bottom  (cadr (cddr (window-edges window))))
        (row-wins    ()))
    (dolist (win wins)
      (when (and (not (memq win exclude))  (< (cadr (window-edges win)) ref-bottom))
        (push win row-wins)))
    row-wins))

(defun fit-frame-same-column-windows (wins window exclude)
  "Returns the windows in WINS that are in the same column as window WINDOW.
This the list of windows in WINS whose left edge is to the left of the
 right edge of WINDOW.
Windows that are in list EXCLUDE are excluded from the result."
  (let ((ref-right  (car (cddr (window-edges window))))
        (col-wins   ()))
    (dolist (win wins)
      (when (and (not (memq win exclude))  (< (car (window-edges win)) ref-right))
        (push win col-wins)))
    col-wins))

(defun fit-frame-max-window-size (window)
  "Maximum size that would be needed to display the buffer in WINDOW.
Returned as a cons: (MAX-WIDTH . MAX-HEIGHT), where:
 MAX-WIDTH is the maximum width, in default characters.
 MAX-HEIGHT is the maximum height, in lines."
  (select-window window)
  (let ((hdr-lines                  (cdr (assq major-mode
                                               fit-frame-skip-header-lines-alist)))
        (hdr-widths                 ())
        (max-win-width              0)
        (max-win-height             1)
        (inhibit-field-text-motion  t)) ; So `end-of-line' will do what it says.
    (save-excursion
      (set-buffer (window-buffer))
      (goto-char (point-min))
      ;; Do not count header lines for width calculation.
      ;; FIXME. This does not work well if header lines have intangible text etc.
      ;; E.g. Does not work for Emacs 20-22 in Dired with wildcard showing only 1 file.
      (while (and hdr-lines  (> hdr-lines 0))
        (end-of-line)
        (setq hdr-widths  (cons (current-column) hdr-widths)
              hdr-lines   (1- hdr-lines))
        (when (zerop (forward-line 1))  ; Don't increase if can't move forward.
          (setq max-win-height  (1+ max-win-height))))
      ;; Calculate maximum line width and number of lines.
      (while (not (eobp))
        (end-of-line)
        (setq max-win-width  (max (current-column) max-win-width))
        (when (zerop (forward-line 1))  ; Don't increase if can't move forward.
          (setq max-win-height  (1+ max-win-height))))
      ;; No need to count lines at buffer end.
      (when fit-frame-crop-end-blank-flag
        (save-match-data
          (beginning-of-line)
          (while (and (looking-at "^\\s-*$")  (not (bobp)))
            (setq max-win-height  (1- max-win-height))
            (forward-line -1)))
        (setq max-win-height  (max 0 max-win-height))))
    ;; Add mode-line.
    (when (cdr (assq 'modeline (frame-parameters (window-frame window))))
      (setq max-win-height  (1+ max-win-height)))
    ;; Add height for any wrap-around header lines.
    (while hdr-widths
      (when (> (car hdr-widths) max-win-width)
        (if (zerop max-win-width)
            (setq max-win-height  (1+ max-win-height))
          (let ((nb-wraps   (1- (/ (car hdr-widths) max-win-width)))
                (remainder  (% (car hdr-widths) max-win-width)))
            (unless (zerop remainder) (setq nb-wraps  (1+ nb-wraps)))
            (setq max-win-height  (+ max-win-height nb-wraps)))))
      (setq hdr-widths  (cdr hdr-widths)))
    (cons max-win-width max-win-height)))

(defun fit-frame-thumbnail-factor (frame)
  "Shrink factor for thumbnail frames.  See `thumb-frm.el'.
FRAME is the frame to apply factor to."
  (let ((char-height  (frame-char-height frame)))
    (if (and (fboundp 'thumfr-thumbnail-frame-p) ; Defined in `thumb-frm.el'
             (thumfr-thumbnail-frame-p frame))
        ;; Need integer result for `set-frame-size'.  1+ because of integer round-off.
        (1+ (/ (+ char-height thumfr-font-difference) char-height))
      1)))

;;;;;;;;;;

(provide 'fit-frame)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; fit-frame.el ends here
#+end_src

** frame-fns.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220500125486500

#+name: 20210601220500125486500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; frame-fns.el --- Non-interactive frame and window functions.
;;
;; Filename: frame-fns.el
;; Description: Non-interactive frame and window functions.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
;; Created: Tue Mar  5 16:15:50 1996
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 11:45:14 2018 (-0800)
;;           By: dradams
;;     Update #: 236
;; URL: https://www.emacswiki.org/emacs/download/frame-fns.el
;; Doc URL: https://emacswiki.org/emacs/FrameModes
;; Keywords: internal, extensions, local, frames
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `avoid'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Non-interactive frame and window functions.
;;
;;  Main new functions defined here:
;;
;;    `1-window-frames-on', `distance', `flash-ding',
;;    `frame-geom-spec-cons', `frame-geom-value-cons',
;;    `frame-geom-spec-numeric', `frame-geom-value-numeric',
;;    `frames-on', `get-a-frame', `get-frame-name',
;;    `multi-window-frames-on', `read-frame', `window-coords'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2017/10/22 dadams
;;     frames-on: Removed (unused) second arg.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non-interactive functions.
;; 2010/01/12 dadams
;;     1-window-frames-on, multi-window-frames-on:
;;       save-excursion + set-buffer -> with-current-buffer.
;; 2008/04/05 dadams
;;     get-a-frame: Define without using member-if.
;; 2005/10/31 dadams
;;     read-frame: Swapped default and init values in call to completing-read.
;; 2004/11/26 dadams
;;     Added frame-geom-spec-numeric and frame-geom-value-numeric.
;; 2004/03/19 dadams
;;     read-frame: 1) if default is a frame, use its name,
;;                 2) use frame-name-history, not minibuffer-history,
;;                    and use make-frame-names-alist, not frame-alist,
;;                    in completing-read
;; 1996/02/14 dadams
;;     Added: window-coords, distance.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(eval-when-compile (when (< emacs-major-version 21) (require 'cl-lib)))
 ;; dolist, push
(require 'avoid nil t) ;; mouse-avoidance-point-position

;;;;;;;;;;;;;;;;;;;;;;;

(defun window-coords (&optional position)
  "Return window coordinates of buffer POSITION (default: point).
If POSITION is nil, (point) is used."
  (unless (fboundp 'mouse-avoidance-point-position) (require 'avoid))
  (cdr (mouse-avoidance-point-position)))

(defun distance (pt1 pt2)
  "Distance as the crow flies between PT1 and PT2.
PT1 and PT2 are each a cons of the form (X . Y)."
  (let ((xdiff  (abs (- (car pt1) (car pt2))))
        (ydiff  (abs (- (cdr pt1) (cdr pt2)))))
    (sqrt (+ (* xdiff xdiff) (* ydiff ydiff)))))

(defun frame-geom-value-numeric (type value &optional frame)
  "Return equivalent geometry value for FRAME in numeric terms.
A geometry value equivalent to VALUE for FRAME is returned,
where the value is numeric, not a consp.
TYPE is the car of the original geometry spec (TYPE . VALUE).
   It is `top' or `left', depending on which edge VALUE is related to.
VALUE is the cdr of a frame geometry spec: (left/top . VALUE).
If VALUE is a consp, then it is converted to a numeric value, perhaps
   relative to the opposite frame edge from that in the original spec.
FRAME defaults to the selected frame.

Examples (measures in pixels) -
 Assuming display height/width=1024, frame height/width=600:
 300 inside display edge:                   300  =>  300
                                        (+  300) =>  300
 300 inside opposite display edge:      (-  300) => -300
                                           -300  => -300
 300 beyond display edge
  (= 724 inside opposite display edge): (+ -300) => -724
 300 beyond display edge
  (= 724 inside opposite display edge): (- -300) =>  724

In the last two examples, the returned value is relative to the
opposite frame edge from the edge indicated in the input spec."
  (if (consp value)
      (if (natnump (cadr value))
          ;; e.g. (+ 300) or (- 300) => 300 or -300
          (funcall (car value) (cadr value))
        ;; e.g. (+ -300) or (- -300)
        (let ((oppval  (- (if (eq 'left type)
                              (x-display-pixel-width)
                            (x-display-pixel-height))
                          (cadr value)
                          (if (eq 'left type)
                              (frame-pixel-width frame)
                            (frame-pixel-height frame)))))
          (if (eq '+ (car value))
              (- oppval)                ; e.g. (+ -300) => -724
            oppval)))                   ; e.g. (- -300) =>  724
    ;; e.g. 300 or -300
    value))

(defun frame-geom-spec-numeric (spec &optional frame)
  "Return equivalent geometry specification for FRAME in numeric terms.
A geometry specification equivalent to SPEC for FRAME is returned,
where the value is numeric, not a consp.
SPEC is a frame geometry spec: (left . VALUE) or (top . VALUE).
If VALUE is a consp, then it is converted to a numeric value, perhaps
   relative to the opposite frame edge from that in the original SPEC.
FRAME defaults to the selected frame.

Examples (measures in pixels) -
 Assuming display height=1024, frame height=600:
 top 300 below display top:               (top .  300) => (top .  300)
                                          (top +  300) => (top .  300)
 bottom 300 above display bottom:         (top -  300) => (top . -300)
                                          (top . -300) => (top . -300)
 top 300 above display top
  (= bottom 724 above display bottom):    (top + -300) => (top . -724)
 bottom 300 below display bottom
  (= top 724 below display top):          (top - -300) => (top .  724)

In the last two examples, the returned value is relative to the
opposite frame edge from the edge indicated in the input SPEC."
  (cons (car spec) (frame-geom-value-numeric (car spec) (cdr spec))))

(defun frame-geom-value-cons (type value &optional frame)
  "Return equivalent geometry value for FRAME as a cons with car `+'.
A geometry value equivalent to VALUE for FRAME is returned,
where the value is a cons with car `+', not numeric.
TYPE is the car of the original geometry spec (TYPE . VALUE).
   It is `top' or `left', depending on which edge VALUE is related to.
VALUE is the cdr of a frame geometry spec: (left/top . VALUE).
If VALUE is a number, then it is converted to a cons value, perhaps
   relative to the opposite frame edge from that in the original spec.
FRAME defaults to the selected frame.

Examples (measures in pixels) -
 Assuming display height/width=1024, frame height/width=600:
 300 inside display edge:                   300  => (+  300)
                                        (+  300) => (+  300)
 300 inside opposite display edge:      (-  300) => (+  124)
                                           -300  => (+  124)
 300 beyond display edge
  (= 724 inside opposite display edge): (+ -300) => (+ -300)
 300 beyond display edge
  (= 724 inside opposite display edge): (- -300) => (+  724)

In the 3rd, 4th, and 6th examples, the returned value is relative to
the opposite frame edge from the edge indicated in the input spec."
  (cond ((and (consp value)  (eq '+ (car value))) ; e.g. (+ 300), (+ -300)
         value)
        ((natnump value) (list '+ value)) ; e.g. 300 => (+ 300)
        (t                              ; e.g. -300, (- 300), (- -300)
         (list '+ (- (if (eq 'left type) ; => (+ 124), (+ 124), (+ 724)
                         (x-display-pixel-width)
                       (x-display-pixel-height))
                     (if (integerp value) (- value) (cadr value))
                     (if (eq 'left type)
                         (frame-pixel-width frame)
                       (frame-pixel-height frame)))))))

(defun frame-geom-spec-cons (spec &optional frame)
  "Return equivalent geometry spec for FRAME as a cons with car `+'.
A geometry specification equivalent to SPEC for FRAME is returned,
where the value is a cons with car `+', not numeric.
SPEC is a frame geometry spec: (left . VALUE) or (top . VALUE).
If VALUE is a number, then it is converted to a cons value, perhaps
   relative to the opposite frame edge from that in the original spec.
FRAME defaults to the selected frame.

Examples (measures in pixels) -
 Assuming display height=1024, frame height=600:
 top 300 below display top:               (top .  300) => (top +  300)
                                          (top +  300) => (top +  300)
 bottom 300 above display bottom:         (top -  300) => (top +  124)
                                          (top . -300) => (top +  124)
 top 300 above display top
  (= bottom 724 above display bottom):    (top + -300) => (top + -300)
 bottom 300 below display bottom
  (= top 724 below display top):          (top - -300) => (top +  724)

In the 3rd, 4th, and 6th examples, the returned value is relative to
the opposite frame edge from the edge indicated in the input spec."
  (cons (car spec) (frame-geom-value-cons (car spec) (cdr spec))))

(defun get-frame-name (&optional frame)
  "Return the string that names FRAME (a frame).  Default is selected frame."
  (unless frame (setq frame  (selected-frame)))
  (if (framep frame)
      (cdr (assq 'name (frame-parameters frame)))
    (error "Function `get-frame-name': Argument not a frame: `%s'" frame)))

(defun get-a-frame (frame)
  "Return a frame, if any, named FRAME (a frame or a string).
If none, return nil.
If FRAME is a frame, it is returned."
  (cond ((framep frame) frame)
        ((stringp frame)
         (catch 'get-a-frame-found
           (dolist (fr (frame-list))
             (when (string= frame (get-frame-name fr))
               (throw 'get-a-frame-found fr)))
           nil))
        (t (error
            "Function `get-frame-name': Arg neither a string nor a frame: `%s'"
            frame))))

(defun read-frame (prompt &optional default existing)
  "Read the name of a frame, and return it as a string.
Prompts with 1st arg, PROMPT (a string).

The default frame is named by the optional 2nd arg, DEFAULT, if a
string or a frame, or by the `selected-frame', if nil.

Non-nil optional 3rd arg, EXISTING, means to allow only names of
existing frames."
  (setq default  (if (framep default)
                     (get-frame-name default)
                   (or default  (get-frame-name))))
  (unless (stringp default)
    (error "Function `read-frame': DEFAULT arg is neither a frame nor a string"))
  (completing-read prompt (make-frame-names-alist)
                   ;; To limit to live frames:
                   ;; (function (lambda (fn+f)(frame-live-p (cdr fn+f))))
                   ;; `frame-name-history' is defined in `frame.el'.
                   nil existing nil '(frame-name-history . 2) default))

(defun frames-on (buffer)
  "List of all live frames showing BUFFER (a buffer or its name)."
  (filtered-frame-list (lambda (fr) (get-buffer-window buffer fr))))

(defun 1-window-frames-on (buffer)
  "List of all visible 1-window frames showing BUFFER."
  (setq buffer  (get-buffer buffer))
  (when buffer                          ; Do nothing if BUFFER is not a buffer.
    (let ((frs  ()))
      (with-current-buffer buffer
        (when (buffer-live-p buffer)    ; Do nothing if dead buffer.
          (dolist (fr  (frames-on buffer))
            (save-window-excursion (select-frame fr)
                                   (when (one-window-p t fr) (push fr frs))))))
      frs)))

(defun multi-window-frames-on (buffer)
  "List of all visible multi-window frames showing BUFFER."
  (setq buffer  (get-buffer buffer))
  (when buffer                          ; Do nothing if BUFFER is not a buffer.
    (let ((frs  ()))
      (with-current-buffer buffer
        (when (buffer-live-p buffer)    ; Do nothing if dead buffer.
          (dolist (fr  (frames-on buffer))
            (save-window-excursion (select-frame fr)
                                   (unless (one-window-p t fr)
                                     (push fr frs))))))
      frs)))

(defun flash-ding (&optional do-not-terminate frame)
  "Ring bell (`ding'), after flashing FRAME (default: current), if relevant.
Terminates any keyboard macro executing, unless arg DO-NOT-TERMINATE non-nil."
  (save-window-excursion
    (when frame (select-frame frame))
    (let ((visible-bell  t)) (ding 'DO-NOT-TERMINATE))) ; Flash.
  (let ((visible-bell  nil)) (ding 'DO-NOT-TERMINATE))) ; Bell.

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'frame-fns)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; frame-fns.el ends here
#+end_src

** frame+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220504090444700

#+name: 20210601220504090444700
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; frame+.el --- Extensions to `frame.el'.
;;
;; Filename: frame+.el
;; Description: Extensions to `frame.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
;; Created: Fri Apr 12 16:42:12 1996
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Mon Jan  1 11:42:28 2018 (-0800)
;;           By: dradams
;;     Update #: 268
;; URL: https://www.emacswiki.org/emacs/download/frame%2b.el
;; Doc URL: https://emacswiki.org/emacs/OneOnOneEmacs
;; Keywords: frames
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `fit-frame', `frame'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `frame.el'.
;;
;;
;;  ***** NOTE: The following function defined in `frame.el' has been
;;              REDEFINED HERE:
;;
;;  `special-display-popup-frame' - Call `fit-frame'.
;;
;;  NOTE: Starting with Emacs 24, `special-display-popup-frame' was
;;        moved to `window.el' from `frame.el'.  I have therefore
;;        moved my enhancement of it from `frame+.el' to my library
;;        `window+.el'.  This means that `frame+.el' is now OBSOLETE.
;;        I leave it posted in case someone with an older release does
;;        not want the additional enhancements that are included in
;;        `window+.el'.
;;
;;  This file should be loaded after loading the standard GNU file
;;  `frame.el'.  So, in your `~/.emacs' file, do this:
;;  (eval-after-load "frame" '(require 'frame+))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2012/08/25 dadams
;;     special-display-popup-frame:
;;       Put back missing (set-window-buffer window buffer) - removed accidentally.
;;       Call fit-frame with the buffer's WINDOW selected.  Inhibit before then.
;; 2012/08/11 dadams
;;     special-display-popup-frame:
;;       Do not redefine if window+.el was loaded.
;;       Updated to be the same as definition in window+.el:
;;         For latest Emacs 24.
;;         Adapt redefinition for all Emacs versions.
;;         Do not raise or fit frame if (car ARGS) is FUNCTION.  Make it do the work.
;; 2011/06/29 dadams
;;     Restricted special-display-popup-frame definition here to Emacs < 24.
;; 2011/01/04 dadams
;;     Removed autoload cookie from non-interactive function.
;; 2005/05/31 dadams
;;     special-display-popup-frame: Put with-current-buffer around fit-frame.
;; 2005/05/29 dadams
;;     Moved to frame-cmds.el: enlarge-frame*, shrink-frame*.
;; 2004/10/11 dadams
;;     Moved here from fit-frame.el: enlarge-frame*, shrink-frame*.
;; 2004/10/01 dadams
;;     special-display-popup-frame: Updated for Emacs 21 also.
;; 2000/09/27 dadams
;;     special-display-popup-frame:
;;       1. Does fit-frame.
;;       2. Doesn't make-frame-visible (done by raise-frame).
;; 1999/03/17 dadams
;;     Updated to corrspond with version Emacs 34.1.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'frame)

(require 'fit-frame nil t) ;; (no error if not found): fit-frame

;;;;;;;;;;;;;;;;;;;



;; REPLACE ORIGINAL in `frame.el':
;;
;; This is the same definition as in `window+.el'.  Starting with Emacs 24,
;; `special-display-popup-frame' is defined in `window.el', not `frame.el'.
;;
;; 1. (Emacs 20 only) Calls `make-frame' while BUFFER is current, so that
;;    any frame hooks (e.g. `after-make-frame-functions') will use BUFFER,
;;    not the previously current buffer.
;;
;; 2. Call `fit-frame', with BUFFER's window selected.  Inhibit fitting before then.
;;
(unless (featurep 'window+)             ; Same definition is in `window+.el'.
  (defun special-display-popup-frame (buffer &optional args)
    "Pop up a frame displaying BUFFER.  Return its window.
If BUFFER is already displayed in a visible or iconified frame then
raise that frame.  Otherwise, display BUFFER in a new frame.

Optional argument ARGS is a list specifying additional information.

If ARGS is an alist, use it as a list of frame parameters.  If these
parameters contain (same-window . t) then display BUFFER in the
selected window.  If they contain (same-frame . t) then display BUFFER
in a window of the selected frame.

If ARGS is a list whose car is a symbol then use (car ARGS) as a
function to do the work: display the buffer and raise its frame.  Pass
it BUFFER as first argument, and (cdr ARGS) as the rest of the
arguments."
    (if (and args  (symbolp (car args)))
;;;   Should we let/make the FUNCTION that is (car ARGS) do everything, or should we
;;;   ensure that the frame is fit and raised?  For now, make FUNCTION do everything.
;;;   (let* ((window  (apply (car args) buffer (cdr args)))
;;;          (frame   (window-frame window)))
;;;     (when (fboundp 'fit-frame) (fit-frame (window-frame window)))
;;;     (raise-frame frame)
;;;     window)                         ; Return the window.
        (apply (car args) buffer (cdr args))
      (let ((window  (get-buffer-window buffer 0)))
        (or
         ;; If we have a window already, make it visible.
         (and window  (let ((frame  (window-frame window)))
                        (make-frame-visible frame)
                        (raise-frame frame)
                        (when (fboundp 'display-buffer-record-window) ; Emacs 24+
                          (display-buffer-record-window 'reuse window buffer))
                        (when (fboundp 'fit-frame) (fit-frame frame))
                        window))                ; Return the window.
         ;; Reuse the selected window if the caller requested it.
         (and (cdr (assq 'same-window args))
              (condition-case nil       ; Try Emacs 24 `switch-to-buffer' first.
                  (progn (switch-to-buffer buffer nil t) (selected-window))
                (error                  ; Try again, with old `switch-to-buffer'.
                 (condition-case nil
                     (progn (switch-to-buffer buffer) (selected-window))
                   (error nil)))))
         ;; Stay on the same frame if requested.
         (and (or (cdr (assq 'same-frame args))  (cdr (assq 'same-window args)))
              (let ((pop-up-windows                t)
                    (pop-up-frames                 nil)
                    (special-display-buffer-names  ())
                    (special-display-regexps       ()))
                (display-buffer buffer)))
         ;; If no window yet, make one in a new frame.
         ;; `make-frame' creates the frame before the buffer is shown in it, so do not
         ;; call `fit-frame' until we can select the buffer's window.
         (let* ((make-frame-functions  (delq 'fit-frame after-make-frame-functions))
                (frame                 (with-current-buffer buffer
                                         (make-frame
                                          (append args special-display-frame-alist))))
                (window                (frame-selected-window frame)))
           (set-window-buffer window buffer)
           (set-window-dedicated-p window t)
           (when (fboundp 'display-buffer-record-window) ; Emacs 24+
             (display-buffer-record-window 'frame window buffer))
           ;; Now call `fit-frame', with WINDOW selected.
           (save-selected-window (select-window window) (fit-frame))
           window))))))                 ; Return the window.

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'frame+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; frame+.el ends here
#+end_src

** info+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220517776845400

#+name: 20210601220517776845400
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; info+.el --- Extensions to `info.el'.     -*- coding:utf-8 -*-
;;
;; Filename: info+.el
;; Description: Extensions to `info.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2021, Drew Adams, all rights reserved.
;; Created: Tue Sep 12 16:30:11 1995
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Sun Mar  7 19:32:41 2021 (-0800)
;;           By: dradams
;;     Update #: 7096
;; URL: https://www.emacswiki.org/emacs/download/info%2b.el
;; Doc URL: https://www.emacswiki.org/emacs/InfoPlus
;; Keywords: help, docs, internal
;; Compatibility: GNU Emacs: 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `apropos', `apropos+', `avoid', `backquote', `bookmark',
;;   `bookmark+', `bookmark+-1', `bookmark+-bmu', `bookmark+-key',
;;   `bookmark+-lit', `button', `bytecomp', `cconv', `cl', `cl-lib',
;;   `cmds-menu', `col-highlight', `crosshairs', `fit-frame',
;;   `font-lock', `font-lock+', `frame-fns', `gv', `help+',
;;   `help-fns', `help-fns+', `help-macro', `help-macro+',
;;   `help-mode', `hl-line', `hl-line+', `info', `info+', `kmacro',
;;   `macroexp', `menu-bar', `menu-bar+', `misc-cmds', `misc-fns',
;;   `naked', `pp', `pp+', `radix-tree', `replace', `second-sel',
;;   `strings', `syntax', `text-mode', `thingatpt', `thingatpt+',
;;   `vline', `w32browser-dlgopen', `wid-edit', `wid-edit+'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `info.el'.
;;
;;  More description below.
;;
;;  If you use Emacs 20, 21, or 22 then use library `info+20.el'
;;  instead of `info+.el'.

;;(@> "Index")
;;
;;  Index
;;  -----
;;
;;  If you have library `linkd.el', load `linkd.el' and turn on
;;  `linkd-mode' now.  It lets you easily navigate around the sections
;;  of this doc.  Linkd mode will highlight this Index, as well as the
;;  cross-references and section headings throughout this file.  You
;;  can get `linkd.el' here:
;;  https://www.emacswiki.org/emacs/download/linkd.el.
;;
;;  (@> "Things Defined Here")
;;  (@> "Documentation")
;;  (@> "Macros")
;;  (@> "Faces (Customizable)")
;;  (@> "User Options (Customizable)")
;;  (@> "Internal Variables")
;;  (@> "New Commands")
;;  (@> "Replacements for Existing Functions")
;;  (@> "Non-Interactive Functions")

;;(@* "Things Defined Here")
;;
;;  Things Defined Here
;;  -------------------
;;
;;  Commands defined here:
;;
;;    `Info-breadcrumbs-in-mode-line-mode',
;;    `Info-change-visited-status' (Emacs 24+),
;;    `Info-cycle-fontify-quotations', `Info-describe-bookmark' (Emacs
;;    24.2+), `Info-define-custom-delimiting',
;;    `Info-follow-nearest-node-new-window', `Info-glossary',
;;    `Info-goto-node-web', `Info-history-clear',
;;    `Info-make-node-unvisited', `info-manual',
;;    `info-manual+node-buffer-name-mode', `Info-merge-subnodes',
;;    `Info-mouse-follow-nearest-node-new-window',
;;    `Info-outline-demote', `Info-outline-promote',
;;    `Info-persist-history-mode' (Emacs 24.4+), `info-rename-buffer',
;;    `Info-save-current-node', `Info-search-case-sensitively-next',
;;    `Info-set-breadcrumbs-depth',
;;    `Info-set-face-for-bookmarked-xref' (Emacs 24.2+),
;;    `Info-toggle-breadcrumbs-in-header', `Info-toggle-fontify-all',
;;    `Info-toggle-fontify-angle-bracketed',
;;    `Info-toggle-fontify-bookmarked-xrefs' (Emacs 24.2+),
;;    `Info-toggle-fontify-custom-delimited',
;;    `Info-toggle-fontify-emphasis',
;;    `Info-toggle-fontify-glossary-words',
;;    `Info-toggle-fontify-isolated-quote',
;;    `Info-toggle-fontify-reference-items',
;;    `Info-toggle-fontify-visited-nodes',
;;    `Info-toggle-node-access-invokes-bookmark' (Emacs 24.4+),
;;    `Info-toc-outline', `Info-toc-outline-refontify-region',
;;    `Info-url-for-node', `Info-variable-pitch-text-mode',
;;    `Info-virtual-book'.
;;
;;  Faces defined here:
;;
;;    `info-command-ref-item', `info-constant-ref-item',
;;    `info-custom-delimited', `info-double-quoted-name',
;;    `info-emphasis', `info-file', `info-fixed-pitch',
;;    `info-function-ref-item', `info-glossary-word',
;;    `info-indented-text', `info-isolated-backquote',
;;    `info-isolated-quote', `info-macro-ref-item', `info-menu',
;;    `info-node', `info-quoted-name', `info-reference-item',
;;    `info-special-form-ref-item', `info-string',
;;    `info-syntax-class-item', `info-user-option-ref-item',
;;    `info-variable-ref-item', `info-xref-bookmarked' (Emacs 24.2+).
;;
;;  Options (user variables) defined here:
;;
;;    `Info-bookmarked-node-xref-faces' (Emacs 24.2+),
;;    `Info-bookmark-use-only-node-not-file-flag',
;;    `Info-breadcrumbs-in-header-flag', `info-buffer-name-function',
;;    `Info-display-node-header-fn', `Info-emphasis-regexp',
;;    `Info-fit-frame-flag', `Info-fontify-angle-bracketed-flag',
;;    `Info-fontify-bookmarked-xrefs-flag' (Emacs 24.2+),
;;    `Info-fontify-custom-delimited', `Info-fontify-emphasis-flag',
;;    `Info-fontify-glossary-words',
;;    `Info-fontify-indented-text-chars',
;;    `Info-fontify-isolated-quote-flag', `Info-fontify-quotations',
;;    `Info-fontify-reference-items-flag',
;;    `Info-glossary-fallbacks-alist',
;;    `Info-node-access-invokes-bookmark-flag' (Emacs 24.4+),
;;    `Info-saved-history-file' (Emacs 24.4+), `Info-saved-nodes',
;;    `Info-subtree-separator', `Info-toc-outline-no-redundancy-flag'.
;;
;;  Macros defined here:
;;
;;    `info-user-error'.
;;
;;  Non-interactive functions defined here:
;;
;;    `Info--member-string-nocase', `Info--pop-to-buffer-same-window',
;;    `info--user-search-failed', `Info-bookmark-for-node',
;;    `Info-bookmark-name-at-point', `Info-bookmark-named-at-point',
;;    `Info-bookmark-name-for-node',
;;    `info-buffer-name-function-default',
;;    `Info-case-insensitive-string=',
;;    `Info-case-insensitive-string-hash', `info-custom-delim-1',
;;    `info-custom-delim-2', `Info-display-node-default-header',
;;    `info-fallback-manual-for-glossary',
;;    `Info-fontify-custom-delimited', `Info-fontify-glossary-words',
;;    `Info-fontify-indented-text', `Info-fontify-quotations',
;;    `Info-fontify-reference-items',
;;    `Info-get-glossary-hash-table-create',
;;    `Info-goto-glossary-definition', `Info-no-glossary-manuals',
;;    `Info-insert-breadcrumbs-in-mode-line', `Info-isearch-search-p',
;;    `Info-node-name-at-point', `Info-read-bookmarked-node-name',
;;    `Info-remap-default-face-to-variable-pitch',
;;    `Info-restore-history-list' (Emacs 24.4+),
;;    `Info-save-history-list' (Emacs 24.4+), `Info-search-beg',
;;    `Info-search-end', `Info-toc-outline-find-node',
;;    `Info-toc-outline-refontify-links'.
;;
;;  Internal variables defined here:
;;
;;    `Info-breadcrumbs-depth-internal',
;;    `info-custom-delimited-same-line-regexp',
;;    `info-fontify-emphasis', `info-glossary-link-map',
;;    `info-good-fixed-pitch-font-families',
;;    `info-isolated-backquote-regexp', `info-isolated-quote-regexp',
;;    `Info-link-faces', `Info-merged-map', `Info-mode-syntax-table',
;;    `info-quotation-regexp', `info-quotation-same-line-regexp',
;;    `info-quoted+<>-regexp', `info-quoted+<>-same-line-regexp',
;;    `info-remap-default-face-cookie', `Info-toc-outline-map'.
;;
;;
;;  ***** NOTE: The following standard faces defined in `info.el'
;;              have been REDEFINED HERE:
;;
;;  `info-title-1', `info-title-2', `info-title-3', `info-title-4'.
;;
;;
;;  ***** NOTE: The following standard functions defined in `info.el'
;;              have been REDEFINED or ADVISED HERE:
;;
;;  `info-apropos' - Apropos, not literal string, match by default.
;;                   Use other window if not already in Info.
;;  `Info-apropos-matches' - Added optional arg REGEXP-P.
;;  `Info-backward-node' - Prefix arg clones buffer.
;;  `Info-bookmark-jump' -
;;     Respect option `Info-bookmark-use-only-node-not-file-flag'.
;;  `Info-directory' - Prefix arg clones buffer.
;;  `info-display-manual' - Use completion to input manual name.
;;  `Info-find-emacs-command-nodes' - Added arg MSGP and message.
;;  `Info-find-file' - Handle virtual books.
;;  `Info-find-node', `Info-find-node-2' -
;;     Call `fit-frame' if `Info-fit-frame-flag'.
;;     Added optional arg NOMSG.
;;  `Info-fontify-node' -
;;     1. Show breadcrumbs in header line and/or mode line.
;;     2. File name in face `info-file'.
;;     3. Node names in face `info-node'.
;;     4. Menu items in face `info-menu'.
;;     5. Only 5th and 9th menu items have their `*' colored.
;;     6. Notes in face `info-xref'.
;;     7. If `Info-fontify-emphasis-flag', then fontify _..._.
;;     8. If `Info-fontify-quotations', then fontify ‘...’ or
;;        `...' in face `info-quoted-name', “...” in face
;;        `info-double-quoted-name',  and "..." in face `info-string'.
;;     9. If `Info-fontify-quotations' and
;;        `Info-fontify-angle-bracketed-flag' then fontify <...> in
;;        face `info-quoted-name'.
;;    10. If `Info-fontify-quotations' and
;;        `Info-fontify-isolated-quote-flag' then fontify ' in face
;;        `info-isolated-quote', and fontify ` in face
;;        `info-isolated-backquote'.
;;  `Info-forward-node' - Prefix arg clones buffer.
;;  `Info-goto-emacs-command-node' -
;;     1. Uses `completing-read' in interactive spec, with,
;;        as default, `symbol-nearest-point'.
;;     2. Added optional arg MSGP.
;;     3. Message if single node found.
;;     4. Returns `num-matches' if found; nil if not.
;;  `Info-goto-emacs-key-command-node' -
;;     1. Added optional arg MSGP.
;;     2. If key's command not found, then `Info-search's for key
;;        sequence in text and displays message about repeating.
;;  `Info-goto-node' - Respect option
;;     `Info-node-access-invokes-bookmark-flag' (Emacs 24.4+).
;;  `Info-history' - A prefix arg clears the history.
;;  `Info-history-back' - Prefix arg clones buffer.
;;  `Info-history-forward' - Prefix arg clones buffer.
;;  `Info-insert-dir' -
;;     Added optional arg NOMSG to inhibit showing progress msgs.
;;  `Info-isearch-search' - Respect restriction to active region.
;;  `Info-isearch-wrap' - Respect restriction to active region.
;;  `Info-mode' - Doc string shows all bindings.
;;  `Info-next' - Prefix arg clones buffer.
;;  `Info-prev' - Prefix arg clones buffer.
;;  `Info-read-node-name'   - Added optional arg DEFAULT.
;;  `Info-search' - 1. Fits frame.
;;                  2. Highlights found regexp if `search-highlight'.
;;  `Info--search-cl-loop' - Use `Info-search-beg' and `Info-search-end'.
;;  `Info-set-mode-line' - Handles breadcrumbs in the mode line.
;;  `Info-mouse-follow-nearest-node' - With prefix arg, show node in
;;                                     a new Info buffer.
;;  `Info-up' - Prefix arg clones buffer.
;;
;;
;;  ***** NOTE: The following standard function
;;              has been REDEFINED HERE:
;;
;;  `outline-invisible-p' - Fixes Emacs bug #28080.

;;(@* "Documentation")
;;
;;  Documentation
;;  -------------
;;
;;  Library `info+.el' extends the standard Emacs library `info.el' in
;;  many ways.  It provides these features:
;;
;;  * Association of additional information (metadata) with Info
;;    nodes.  You do this by bookmarking the nodes.  Library Bookmark+
;;    gives you the following features in combination with `info+.el'.
;;    In many ways an Info node and its default bookmark can be
;;    thought of as the same animal.
;;
;;    - Rich node metadata.  In particular, you can tag nodes with any
;;      number of arbitrary tags, to classify them in different and
;;      overlapping ways.  You can also annotate them (in Org mode, by
;;      default).
;;
;;    - You can use `C-h C-b' to show the metadata for a (bookmarked)
;;      node.  This is all of the associated bookmark information,
;;      including the annotation and tags for that node and the number
;;      of times you have visited it.  If invoked with point on a
;;      link, the targeted node is described; otherwise, you are
;;      prompted for the node name.
;;
;;    - Links for bookmarked nodes can have a different face, to let
;;      you know that those nodes have associated metadata.  Option
;;      `Info-fontify-bookmarked-xrefs-flag' controls whether this is
;;      done.
;;
;;    - The face for this is `info-xref-bookmarked' by default, but
;;      you can set the face to use for a given Info bookmark using
;;      `C-x f' (command `Info-set-face-for-bookmarked-xref').  This
;;      gives you an easy way to classify nodes and show the class of
;;      a node by its links.  Uses faces to make clear which nodes are
;;      most important to you, or which are related to this or that
;;      general topic.
;;
;;    - You can use command `Info-make-node-unvisited' to make a node
;;      be considered unvisited.  By default the node at point is
;;      used.  For a node that is not bookmarked this also gives links
;;      to the node face `info-xref', which indicates that their
;;      targets are unvisited.  If for some reason you want to make
;;      links to a bookmarked node also have this face then just use
;;      command `Info-set-face-for-bookmarked-xref', specifying face
;;      `info-xref'.
;;
;;    - If option `Info-node-access-invokes-bookmark-flag' is non-nil
;;      then going to a bookmarked Info node invokes its bookmark, so
;;      that the node metadata (such as number of visits) gets
;;      updated.  Command `Info-toggle-node-access-invokes-bookmark'
;;      toggles the option value.
;;
;;    - You can automatically bookmark nodes you visit, by enabling
;;      mode `bmkp-info-auto-bookmark-mode'.  Toggle the mode off
;;      anytime you do not want to record Info visits.
;;
;;    - In the bookmark-list display (from `C-x r l') you can sort
;;      bookmarks by the time of last visit (`s d') or by the number
;;      of visits (`s v').  This gives you an easy way to see which
;;      parts of which Info manuals you have visited most recently and
;;      how much you have visited them.
;;
;;  * Editable, outline-enabled tables of contents (TOCs).  Command
;;    `Info-toc-outline' (bound to `O') opens a separate Info buffer
;;    showing the table of contents (TOC).  This is similar to the
;;    standard command `Info-toc' (bound to `T'), but the buffer is
;;    cloned from the manual and is in `outline-minor-mode'.  Also,
;;    there is no redundancy, by default: each TOC entry is listed
;;    only once, not multiple times.  (This is controlled by option
;;    `Info-toc-outline-no-redundancy-flag'.)
;;
;;    - You can have any number of such TOCs, for the same manual or
;;      for different manuals.
;;
;;    - Outline minor mode lets you hide and show, and promote and
;;      demote, various parts of the TOC tree for a manual.  And since
;;      the TOC is editable you can make other changes to it: sort
;;      parts of it, delete parts of it, duplicate parts of it, move
;;      parts aroundin an ad hoc way, and so on.  Info+ makes the
;;      outlining commands behave, so that hidden Info text
;;      (e.g. markup text such as `*note'...`::' surrounding links) is
;;      kept hidden.
;;
;;    - Especially when combined with `Info-persist-history-mode',
;;      command `Info-change-visited-status' (`C-x DEL', see below),
;;      and the Info+ bookmarking enhancements (e.g., special link
;;      highlighting and persistently tracking the number of visits
;;      per node), `Info-toc-outline' gives you a way to organize
;;      access and visibility of a manual's nodes, to reflect how you
;;      use it.
;;
;;  * Additional, finer-grained Info highlighting.  This can make a
;;    big difference in readability.
;;
;;    - In the Emacs Lisp manual, reference items are highlighted, so
;;      they stand out.  This means: constants, commands, functions,
;;      macros, special forms, syntax classes, user options, and other
;;      variables.
;;
;;    - Single-quoted text, like `text' or ‘text’, and double-quoted
;;      text, like "text" or “text”, is highlighted if option
;;      `Info-fontify-quotations' is non-`nil'.  If the non-nil value
;;      is `t' (the default) then, for the case of `...', only text
;;      quoted on the same line is highlighted.  If the non-nil value
;;      is `multiline' then even multiline text quoted with `...' is
;;      highlighted.
;;
;;    - Angle-bracketed names, like <tab>, are highlighted if
;;      `Info-fontify-angle-bracketed-flag' and
;;      `Info-fontify-quotations' are both non-`nil'.
;;
;;    - Isolated single quotes and backquote chars, as in 'foobar and
;;      `foobar, are highlighted if `Info-fontify-quotations' and
;;      `Info-fontify-isolated-quote-flag' are both non-`nil'.
;;
;;    - Non-nil option `Info-fontify-indented-text-chars' means
;;      fontify text that is indented at least that many characters
;;      (default 10).  In the Elisp manual this often means blocks of
;;      code and ASCII-art diagrams.  But in general there's no
;;      telling what is indented at any given level, so caveat emptor.
;;      Think of this as an experimental feature.
;;
;;    - Emphasized text, that is, text enclosed in underscore
;;      characters, like _this is emphasized text_, is
;;      highlighted if `Info-fontify-emphasis-flag' is non-`nil'.
;;      (But if internal variable `info-fontify-emphasis' is `nil'
;;      then there is no such highlighting, and that option has no
;;      effect.)
;;
;;    - Glossary words, that is, words that are defined in a manual's
;;      `Glossary' node, are highlighted and linked to their glossary
;;      entries, if option `Info-fontify-glossary-words' is non-nil.
;;      By default, a mouseover on such a link shows a tooltip with
;;      the word's definition from the glossary.  (Currently only the
;;      Emacs and Semantic manuals have `Glossary' nodes, as far as I
;;      know.)
;;
;;    - Text between two delimiters that you specify, if the car of
;;      option `Info-fontify-custom-delimited' is non-nil.
;;
;;    - Any extra highglighting you want in a node, as defined by the
;;      value of variable `Info-fontify-extra-function'.
;;
;;    - Be aware that any such highlighting is not 100% foolproof.
;;      Especially for a manual such as Emacs or Elisp, where
;;      arbitrary keys and characters can be present anywhere, the
;;      highlighting can be thrown off.
;;
;;    - You can cycle or toggle the `Info-fontify-*' options from the
;;      `Info' menu, or using command `Info-cycle-fontify-quotations'
;;      or an `Info-toggle-fontify-*' command.  For example, command
;;      `Info-toggle-fontify-emphasis' toggles option
;;      `Info-fontify-emphasis-flag'.
;;
;;  * Optionally showing breadcrumbs in the mode line or the header
;;    line, or both. See where you are in the Info hierarchy, and
;;    access higher nodes directly.
;;
;;    - In the mode line.  Turned on by default.
;;
;;      See ‘Toggle Breadcrumbs’ in the `mouse-3' mode-line menu and
;;      `Toggle Breadcrumbs in Mode Line' in the `Info' menu (in the
;;      menu-bar or in the minor-mode indicator). You can customize
;;      option `Info-breadcrumbs-in-mode-line-mode' if you want to
;;      turn this off by default. (Available for Emacs 23+ only.)
;;
;;    - In the header (just below the header line).
;;
;;      (I also added this to vanilla Emacs 23.)  This is OFF by
;;      default in `Info+'.  See `Toggle Breadcrumbs in Header Line'
;;      in `Info' menu.  Be aware that unlike breadcrumbs in the mode
;;      line, this can occasionally throw off the destination accuracy
;;      of cross references and searches slightly.
;;
;;  * Optional automatic renaming of Info buffers to include the
;;    manual (file) and node names, using minor mode
;;    `info-manual+node-buffer-name-mode'.  You can use option
;;    `info-buffer-name-function' to customize the format of the
;;    buffer names.
;;
;;  * Additional commands, including:
;;
;;    - `Info-virtual-book' (bound to `v') – Open a virtual Info
;;      manual of saved nodes from any number of manuals.  The nodes
;;      are those saved in option `Info-virtual-book'.  With `C-u',
;;      bookmarked Info nodes are also included.  (If you use Icicles,
;;      see also `icicle-Info-virtual-book'.)
;;
;;    - `Info-persist-history-mode' - Enabling this minor mode saves
;;      the list of your visited Info nodes between Emacs sessions.
;;      Together with command `Info-history' (bound to `L' by
;;      default), this gives you a persistent virtual manual of the
;;      nodes you have visited in the past.  If the mode is enabled
;;      then the list of visited nodes is saved to the file named by
;;      option `Info-saved-history-file' when you quit Emacs (not
;;      Info) or when you kill an Info buffer.
;;
;;      (If you also use library Bookmark+ then you can bookmark Info
;;      nodes, including automatically.  This records how many times
;;      you have visited each node and when you last did so.)
;;
;;    - `Info-change-visited-status' (bound to `C-x DEL') - Toggle or
;;      set the visited status of the node at point or the nodes in
;;      the active region.  Useful if you use
;;      `Info-fontify-visited-nodes' to show you which nodes you have
;;      visited.  No prefix arg: toggle.  Non-negative prefix arg: set
;;      to visited.  Negative prefix arg: set to unvisited.
;;
;;    - `Info-save-current-node' (bound to `.') – Save the name of the
;;      current node to list `Info-saved-nodes', for use by `v'
;;      (`Info-virtual-book').
;;
;;    - `Info-merge-subnodes' – Integrate the current Info node with
;;      its subnodes (the nodes in its Menu), perhaps recursively.
;;
;;      Use `Info-merge-subnodes' to extract a self-contained report
;;      (possibly the whole manual) from an Info manual.  The report
;;      is itself an Info buffer, with hyperlinks and normal Info
;;      behavior.
;;
;;      There are various prefix-argument possibilities that govern
;;      just how subnodes are treated (recursively or not, for
;;      instance).  There are a few user options that let you
;;      customize the report appearance.
;;
;;
;;  The following bindings are made here for Info-mode:
;;
;;    `?'              `describe-mode' (replaces `Info-summary')
;;    `+'              `Info-merge-subnodes'
;;    `.'              `Info-save-current-node'
;;    `a'              `info-apropos'
;;    `G'              `Info-goto-node-web'
;;    `O'              `Info-toc-outline'
;;    `v'              `Info-virtual-book'
;;    `mouse-4'        `Info-history-back'
;;    `mouse-5'        `Info-history-forward'
;;    `S-down-mouse-2' `Info-mouse-follow-nearest-node-new-window'
;;    `S-RET'          `Info-follow-nearest-node-new-window'
;;
;;  The following bindings are made here for merged Info buffers:
;;
;;    `.'              `beginning-of-buffer'
;;    `b'              `beginning-of-buffer'
;;    `q'              `quit-window'
;;    `s'              `nonincremental-re-search-forward'
;;    `M-s'            `nonincremental-re-search-forward'
;;    `TAB'            `Info-next-reference'
;;    `ESC TAB'        `Info-prev-reference'
;;
;;  The global binding `C-h r' is changed from `info-emacs-manual' to
;;  `info-manual', which behaves the same except if you use a prefix
;;  arg.  With a prefix arg you can open any manual, choosing either
;;  from all installed manuals or from those that are already shown in
;;  Info buffers.
;;
;;  The following behavior defined in `info.el' has been changed:
;;   "*info" has been removed from `same-window-buffer-names', so that
;;   a separate window can be used if you so choose.
;;
;;  Suggestion: Use a medium-dark background for Info.  Try, for
;;  example, setting the background to "LightSteelBlue" in your
;;  `~/.emacs' file.  You can do this as follows:
;;
;;         (setq special-display-buffer-names
;;               (cons '("*info*" (background-color . "LightSteelBlue"))
;;                     special-display-buffer-names))
;;
;;  Alternatively, you can change the background value of
;;  `special-display-frame-alist' and set `special-display-regexps' to
;;  something matching "*info*":
;;
;;         (setq special-display-frame-alist
;;               (cons '(background-color . "LightSteelBlue")
;;                     special-display-frame-alist))
;;         (setq special-display-regexps '("[ ]?[*][^*]+[*]"))
;;
;;  If you do use a medium-dark background for Info, consider
;;  customizing face to a lighter foreground color - I use "Yellow".
;;
;;  Also, consider customizing face `link' to remove its underline
;;  attribute.
;;
;;  This file should be loaded after loading the standard GNU file
;;  `info.el'.  So, in your `~/.emacs' file, do this:
;;  (eval-after-load "info" '(require 'info+))
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2021/03/07 dadams
;;     Added: info-good-fixed-pitch-font-families, info-remap-default-face-cookie.
;;     Face info-fixed-pitch: Merge attributes from first family found in info-good-fixed-pitch-font-families.
;;     Info-remap-default-face-to-variable-pitch: Set info-remap-default-face-cookie.
;;     Info-variable-pitch-text-mode: No longer on Info-mode-hook - takes effect immediately.
;;     Info-fontify-indented-text-chars: Default value is now nil (no-op), not 10.
;;     Info-fontify-indented-text: Allow arbitrary indentation level, not just 10.
;; 2021/05/06 dadams
;;     Added Info-remap-default-face-to-variable-pitch, Info-variable-pitch-text-mode, face info-fixed-pitch,
;;           Info-fontify-indented-text-chars, Info-fontify-indented-text.
;;     Faces *-custom-delimited, *(-double)-quoted-name, *-string, *-isolated-quote, *-reference-item:
;;       Inherit from info-fixed-pitch, not from font-lock-string-face.
;;     Info-fontify-node: Use Info-fontify-indented-text if Info-fontify-indented-text-chars.
;; 2021/01/13 dadams
;;     Info-search: Deactivate mark only if search moves to a different node or isearchp-deactivate-region-flag
;;                  is undefined or non-nil.
;; 2020/11/14 dadams
;;     Info-fontify-quotations, Info-fontify-custom-delimited, info-display-manual:
;;       Use ignore-errors instead of nil condition-case.
;; 2020/11/12 dadams
;;     Added: Info-fontify-extra-function.
;;     Info-fontify-node: Invoke Info-fontify-extra-function if non-nil.
;; 2020/11/08 dadams
;;     Be able to use glossary of another manual (Emacs manual, by default) for manuals that don't have one:
;;       Added: Info-glossary-fallbacks-alist (option), info-fallback-manual-for-glossary.
;;       Info-find-node-2, Info-fontify-glossary-words: Use fallback glossary, if specified.
;;       Info-find-node-2: Don't try to get/create hash table if it already exists.
;;       Info-get-glossary-hash-table-create:
;;         If manual already has a hash table, return it.  Return to (original node in) original manual.
;;       Info-goto-glossary-definition: Add manual to destination, so go to fallback glossary, if appropriate.
;; 2020/11/04 dadams
;;     Added: face info-custom-delimited, option and function Info-fontify-custom-delimited,
;;            var info-custom-delimited-same-line-regexp, info-custom-delim-1, info-custom-delim-2,
;;            Info-define-custom-delimiting, Info-toggle-fontify-custom-delimited.
;;     Info-mode-menu: Added Info-define-custom-delimiting, Info-toggle-fontify-custom-delimited.
;;     Info-fontify-node: Added custom-delimited fontifying( Info-fontify-custom-delimited).
;; 2020/11/02 dadams
;;     Faces info-file, info-*-item, info-xref-bookmarked: Tweaked defaults.
;; 2020/11/01 dadams
;;     Added: info--user-search-failed, (redefinition of) Info--search-cl-loop.
;;     Info-search: Bind isearchp-restrict-to-region-flag to (not Info-isearch-search), for isearch+.el.
;;                  Update for recent Emacs as of 26.3.
;;     Info-isearch-search: Updated for Emacs 25+.
;; 2020/10/30 dadams
;;     Added: Info-toggle-fontify-all, Info-toggle-fontify-reference-items, Info-toggle-fontify-visited-nodes.
;;     Info-mode-menu: Added those toggle commands to submenu Toggle/Cycle.
;;     info-(quotation|quoted+<>)(-same-line)-regexp: Use +, not *, for all but "..." string.
;;     Info-fontify-quotations: Adjust doc to reflect new regexps for same line (only "..." is not same line).
;;                              Use \\= to ensure ` and ' appear without conversion.
;;     info-isolated-(back)quote-regexp: Simplify to just any char after ` and before '.  (Performance.)
;;     Info-emphasis-regexp: Use single word as default, to avoid converting names in code.
;;     Info-fontify-glossary-words: Use text property font-lock-face, not face.
;;     Face info-isolated-backquote: Use PaleGreen1, not Chartreuse1, for background.
;; 2020/10/28 dadams
;;     Info-mode-menu: Typo: had Info-toggle-fontify-glossary-words instead of Info-fontify-glossary-words as var.
;;     Info-get-glossary-hash-table-create: Bind Info-fit-frame-flag to nil, to avoid unnecessary frame-fit.
;;     info-glossary-link-map: Added follow-link.
;;     Info-fontify-glossary-words: Swapped order of help-echo text: put mouse-2 text before definition, so it
;;                                  gets changed to mouse-1 when mouse-1-click-follows-link is non-nil.
;; 2020/10/27 dadams
;;     Added: Info-glossary.
;; 2020/10/26 dadams
;;     Added: Info-toggle-fontify-glossary-words, Info--member-string-nocase, Info-link-faces.
;;     Info-fontify-node, Info-fontify-glossary-words: Made glossary stuff work also with Emacs < 24.
;;     Info-fontify-node: Move Info-fontify-glossary-words after link highlighting.
;;     Info-fontify-glossary-words: Don't fontify glossary words in an Index.  Don't fontify a word in Glossary
;;                                  unless its occurrence is in a definition other than its own.
;; 2020/10/25 dadams
;;     Added:
;;       info-glossary-word face, Info-fontify-glossary-words option and function, Info-case-insensitive-string=,
;;       Info-case-insensitive-string-hash, Info-get-glossary-hash-table-create, Info-goto-glossary-definition,
;;       info-glossary-link-map, Info-no-glossary-manuals.
;;     Renamed: info-fontify-(quotations|reference-items) to Info-fontify-(quotations|reference-items).
;;     Info-find-node-2: create glossary-words hash table.
;;     Info-fontify-node: If Info-fontify-glossary-words then fontify glossary words.
;; 2020/10/23 dadams
;;     Added: info-isolated-backquote, info-isolated-backquote-regexp, info-isolated-quote-regexp.
;;     Renamed: Info-toggle-fontify-single-quote to Info-toggle-fontify-isolated-quote,
;;              Info-fontify-single-quote-flag to Info-fontify-isolated-quote-flag
;;              info-single-quote to info-isolated-quote.
;;     info-isolated-quote face: changed default value.
;;     info-fontify-quotations: Handle Info-fontify-isolated-quote-flag - separate cl-loops.
;; 2020/10/19 dadams
;;     Quotation highlighting is now same-line only, by default.
;;       Added: info-quotation-same-line-regexp, info-quoted+<>-same-line-regexp.
;;       Renamed: Info-fontify-quotations-flag to Info-fontify-quotations,
;;                Info-toggle-fontify-quotations to Info-cycle-fontify-quotations,
;;                Toggle submenu to Toggle/Cycle.
;;       Info-fontify-quotations: 3 values now, not just Boolean.
;;       info-fontify-quotations: Handle info-quotation-same-line-regexp, info-quoted+<>-same-line-regexp.
;; 2020/10/17 dadams
;;     Do not bind mouse-4 and mouse-5 to history movement on systems where they scroll window instead.
;; 2020/10/13 dadams
;;     Info-fontify-node (Emacs 24.2+): Use header-line-highlight for mouse-face in header.
;; 2020/10/09 dadams
;;     Info-read-bookmarked-node-name: remove-if-not -> bmkp-remove-if-not.
;;     Everywhere: added nil second arg to looking-back (arg is required now).
;;     Added more defvars to quiet byte-compiler, for Emacs 27+.
;; 2020/09/26 dadams
;;     Info-goto-emacs-key-command-node: If this-file is nil then return nil.
;; 2020/08/30 dadams
;;     Added: Info-bookmark-use-only-node-not-file-flag, redefinition of Info-bookmark-jump (fixes Emacs
;;            bug #42993), Info-search-case-sensitively-next.
;;     Restructure Info menu (fixes Emacs bug #43115).
;; 2020/05/20 dadams
;;     Info-insert-dir: Removed use of Info-following-node-name.  Emacs Dev replaced it by its code.
;; 2020/04/21 dadams
;;     Added: info-buffer-name-function, info-buffer-name-function-default, info-rename-buffer,
;;            info-manual+node-buffer-name-mode.
;; 2019/05/31 dadams
;;     Info-emphasis-regexp: Add another possible value to doc string.
;; 2018/09/21 dadams
;;     Added: Info--pop-to-buffer-same-window.
;;     Info-find-node, Info-(next|prev|up), info-display-manual:
;;       Use Info--pop-to-buffer-same-window, not switch-to-buffer.
;; 2018/09/09 dadams
;;     Added: redefinitions of Info-backward-node, Info-directory, Info-forward-node, Info-history-back,
;;            Info-history-forward, Info-next, Info-prev, Info-up.
;; 2018/06/14 dadams
;;     Added: redefinitions of info-apropos, Info-apropos-matches.
;;     bmkp-string-match-p - > string-match-p everywhere.
;; 2018/06/03 dadams
;;     info-quotation-regexp, info-quoted+<>-regexp:
;;       Use shy groups everywhere.  [CHAR] -> CHAR, \\CHAR -> CHAR.  Added equivalent rx sexps.
;;     info-fontify-reference-items, Info-node-name-at-point: [\n] -> \n.
;; 2018/04/12 dadams
;;     Info-read-node-name: Use Info-minibuffer-history, not Info-history, for completing-read.
;;     Info-find-node(-2): Added arg STRICT-CASE, moving arg MSG to the end.
;;     Info-find-node-2: Updated for Emacs 25+ - use filepos-to-bufferpos etc.
;; 2017/11/17 dadams
;;     Info-TOC-outline stuff needs Info-virtual-nodes.  Thx to Mike Fitzgerald.
;;     http -> https everywhere.
;; 2017/11/09 dadams
;;     info-quotation-regexp, info-quoted+<>-regexp:
;;       Added \\ to first alternative of each ... type, to exclude \ from it.
;; 2017/09/23 dadams
;;     Info-url-for-node: Fix per TeXInfo manual - encode embedded hyphens etc.
;; 2017/08/30 dadams
;;     Renamed: Info-refontify-toc-outline-region to Info-toc-outline-refontify-region.
;; 2017/08/28 dadams
;;     Added: Info-refontify-toc-outline-region.
;;     Info-refontify-toc-outline-region:
;;       Add Info-refontify-toc-outline-region to post-command-hook and bind to C-x M-l.
;;     Info-toc-outline: Turn off Info-breadcrumbs-in-mode-line-mode in TOC buffer.
;;     Info-change-visited-status: Typo: go-to-char.
;; 2017/08/25 dadams
;;     Added: Info-change-visited-status.  Bound to `C-x DEL (instead of Info-make-node-unvisited).
;;     Info-node-name-at-point: Replace newline chars by spaces.
;;     Info-toc-outline: Pass NEWNAME arg to clone-buffer, instead of explicitly renaming buffer.
;; 2017/08/22 dadams
;;     Added: Info-toc-outline, Info-outline-demote, Info-outline-promote, Info-toc-outline-no-redundancy-flag,
;;            Info-toc-outline-find-node, Info-toc-outline-map, Info-toc-outline-refontify-links, redefinition of
;;            outline-invisible-p.
;;     Bind Info-toc-outline to O.
;;     Info-mode-menu: Added Editable Outline TOC item for Info-toc-outline.
;;     Info-node-access-invokes-bookmark-flag, Info-toggle-node-access-invokes-bookmark, Info-goto-node advice:
;;       Reserve for Emacs 24.4+.
;; 2017/08/10 dadams
;;     Info-goto-node: Define it for Emacs 23 also.
;;     Info-mode-menu:
;;       Add menu items for Info-toggle-node-access-invokes-bookmark, Info-toggle-fontify-bookmarked-xrefs.
;; 2017/08/07 dadams
;;     Added: Info-make-node-unvisited.  Bound to C-x DEL.
;; 2017/08/06 dadams
;;     Added: Info-bookmarked-node-xref-faces, Info-read-bookmarked-node-name,
;;            Info-set-face-for-bookmarked-xref.
;;     Bind Info-set-face-for-bookmarked-xref to C-x f.
;;     Info-describe-bookmark: If no bookmarked node name at point, use Info-read-bookmarked-node-name.
;;     Info-bookmark-for-node: Made NODE arg optional - if nil then read the node name.  Added LOCALP arg.
;;     Info-fontify-node (Emacs 24.2+): Get face for bookmarked xref from bmkp-info-face tag value, if any.
;;                                      Call Info-bookmark-for-node with arg LOCALP.
;; 2017/08/04 dadams
;;     Info-describe-bookmark: Use Info-bookmark-name-at-point, not Info-node-name-at-point.
;;     Info-goto-node: Do it only for Emacs 24.2+.
;; 2017/08/02 dadams
;;     Info-goto-node: Define only if can soft-require bookmark+.el.
;;                     No-op if NODE is in Info-index-nodes.
;;                     Bind Info-node-access-invokes-bookmark-flag to nil while invoking bookmark.
;;                     Use bookmark--jump-via with ignore as display function, instead of bookmark-jump.
;; 2017/07/30 dadams
;;     Added advice of Info-goto-node, to respect Info-node-access-invokes-bookmark-flag.
;;     Removed redefinitions of Info-follow-nearest-node, Info-try-follow-nearest-node.
;;     Replaced Info-follow-xref-bookmarks-flag by Info-node-access-invokes-bookmark-flag.
;;     Replaced Info-toggle-follow-bookmarked-xrefs by Info-toggle-node-access-invokes-bookmark.
;;     Info-bookmark-for-node, Info-bookmark-named-at-point: Include manual name in bookmark name.
;; 2017/07/29 dadams
;;     Added: Info-fontify-bookmarked-xrefs-flag, face info-xref-bookmarked, Info-describe-bookmark,
;;            Info-bookmark-for-node, Info-bookmark-name-at-point, Info-bookmark-named-at-point,
;;            Info-bookmark-name-for-node, Info-toggle-fontify-bookmarked-xrefs,
;;            Info-follow-xref-bookmarks-flag, Info-toggle-follow-bookmarked-xrefs.
;;     Added (redefinition of): Info-follow-nearest-node, Info-try-follow-nearest-node.
;;     Info-fontify-node (24.2+): Respect Info-fontify-bookmarked-xrefs-flag.
;;     Bind Info-describe-bookmark to C-h C-b.
;; 2017/02/20 dadams
;;     Added: Info-saved-history-file, Info-persist-history-mode, Info-save-history-list,
;;            Info-restore-history-list.
;;     Added autoload cookies: Info-breadcrumbs-in-mode-line-mode, Info-set-breadcrumbs-depth,
;;           Info-search, Info-mouse-follow-nearest-node, info-display-manual.
;; 2017/01/09 dadams
;;     Info-find-emacs-command-nodes: Updated to handle LINE-NUMBER (Emacs 24.5+).
;; 2016/12/13 dadams
;;     Removed obsolete face aliases: info-menu-5, Info-title-*-face.
;; 2016/12/11 dadams
;;     Added defvars for isearch(-regexp)-lax-whitespace for Emacs 24.1 and 24.2.
;; 2016/12/10 dadams
;;     Use string as 3rd arg to make-obsolete.
;; 2016/10/31 dadams
;;     info-quotation-regexp: Typo: misplaced curly double-quote.  Thx to Don March.
;; 2016/07/02 dadams
;;     Added: Info-toggle-fontify-emphasis, Info-breadcrumbs-in-header-flag, Info-emphasis-regexp,
;;            Info-fontify-emphasis-flag, info-fontify-emphasis, and face info-emphasis.
;;     Added some doc from Emacs Wiki to commentary.
;;     Info-mode-menu:
;;       Add toggle indicators.  Moved toggle commands to Toggle submenu.  Added Info-toggle-fontify-emphasis.
;;     Info-fontify-node: Fontify emphasis.
;; 2015/09/14 dadams
;;     info-double-quoted-name: Changed default colors.
;; 2015/09/13 dadams
;;     Added face info-double-quoted-name.
;;     info-quotation-regexp, info-quoted+<>-regexp: Added pattern for curly double-quotes (“...”).
;;                                                   Use shy groups for all parts.
;;     info-fontify-quotations: Fontify text between curly double-quotes (“...”).
;; 2015/03/19 dadams
;;     info-quoted+<>-regexp: Highlight <...> only if the first char is alphabetic.
;; 2015/03/06 dadams
;;     Added: info-manual.  Bound it globally to C-h r.
;;     Info-fontify-node (Emacs 24.1.N+): Updated per Emacs 24.4: allow Info-fontify-maximum-menu-size to be t.
;;     info-display-manual: Updated for Emacs 25: use info--manual-names with prefix arg.
;; 2015/02/28 dadams
;;     Added: redefinition of Info-read-node-name.
;;     Info-goto-node-web, Info-url-for-node: Use Info-current-node as default.
;; 2014/12/21 dadams
;;     Added: Info-goto-node-web, Info-url-for-node.
;;     Reorganized.  Code cleanup.  Improved commentary.  Added index links.
;;     Info-toggle-breadcrumbs-in-header-line: Added 3rd arg to make-obsolete.
;;     Info-breadcrumbs-in-mode-line-mode: (default-value 'mode-line-format), not default-mode-line-format,
;;     Info-display-node-default-header: (goto-char (point-min)), not (beginning-of-buffer).
;;     Info-merge-subnodes: with-current-buffer, not save-excursion + set-buffer.
;; 2014/05/04 dadams
;;     REMOVED SUPPORT for Emacs 20-22.  That support is offered by a new library now: info+20.el.
;;     Added coding:utf-8 declaration.  Replace \x2018, \x2019 with literal ‘ and ’, since now Emacs 23+.
;; 2014/05/03 dadams
;;     info-quotation-regexp, info-quoted+<>-regexp: Handle also curly single quotes (Emacs 24.4+).
;;                                                   Removed double * and moved openers outside \(...\) group.
;;     info-fontify-quotations: Handle also curly single quotes (Emacs 24.4+).
;; 2014/03/04 dadams
;;     Renamed Info-toggle-breadcrumbs-in-header-line to Info-toggle-breadcrumbs-in-header.
;;       Declared old name obsolete.
;; 2014/03/02 dadams
;;     Info-find-file: Go to directory if no previous file (per Emacs 24.4+).
;;     Info-find-node-2 (Emacs > 22): Go to Top node at end, if no history.
;; 2013/10/17 dadams
;;     Added: Info-search-beg, Info-search-end, Info-isearch-search-p.
;;     Added redefinition: Info-isearch-wrap, Info-isearch-search.
;;     Info-display-node-default-header, Info-merge-subnodes: Renamed node-name to infop-node-name.
;; 2013/03/17 dadams
;;     Added: Info-history-clear, macro info-user-error (and font-lock it).  Advised: Info-history.
;;     Use info-user-error instead of error, where appropriate.
;; 2013/02/26 dadams
;;     Info-mode-menu and Info-mode doc string: Removed Info-edit, Info-enable-edit (now obsolete).
;; 2013/02/09 dadams
;;     Info-read-node-name-1: Removed Emacs 23+ redefinition.
;; 2013/02/03 dadams
;;     Added: Info-fontify-angle-bracketed-flag, Info-toggle-fontify-angle-bracketed,
;;            Info-toggle-fontify-quotations, Info-toggle-fontify-single-quote, info-quoted+<>-regexp.
;;     info-fontify-quotations: Fixed case for Info-toggle-fontify-single-quote = nil.
;;                              Handle also Info-fontify-angle-bracketed-flag.
;;     Added  Info-fontify-*-flag to Info menu (so menu bar and C-mouse-3).
;; 2012/09/24 dadams
;;     Info-search. Info-mode: Applied latest Emacs 24 updates by Juri (from 2012-09-12).
;; 2012/08/25 dadams
;;     Info-fontify-node: Hide any empty lines at end of node (fixes bug #12272).
;; 2012/08/24 dadams
;;     info-fontify-reference-items: Fontify parameters on continuation lines also.
;;     Info-fontify-node: Juri's fix for Emacs bug #12187.
;;     Reverted Juri's change from 08/20, since Juri fixed it elsewhere afterward.
;; 2012/08/21 dadams
;;     Call tap-put-thing-at-point-props after load thingatpt+.el.
;; 2012/08/20 dadams
;;     Applied Juri's fix for Emacs bug #12230:
;;       Added: Info-file-attributes.
;;       Info-find-file: Clear caches of modified Info files.
;; 2012/08/18 dadams
;;     Invoke tap-define-aliases-wo-prefix if thingatpt+.el is loaded.
;; 2012/08/12 dadams
;;     Added: info-constant-ref-item (face).
;;     info-fontify-reference-items: Handle constants, using face info-constant-ref-item.
;;     Info-toggle-breadcrumbs-in-header-line, Info-save-current-node: Added MSGP arg.
;; 2012/08/10 dadams
;;     Info-search: Use latest Emacs 24 msg: _end of node_, not _initial node_.
;; 2012/08/09 dadams
;;     Info-fontify-node: Updated guards for Emacs 24 versions.
;; 2012/07/28 dadams
;;     Info-fontify-node: Typo on guard: (/= 1 emacs-minor-version) should have been =, not /=.
;; 2012/07/17 dadams
;;     Added redefinition of Info-fontify-node for post-Emacs 24.1.
;;     Added redefinitions of Info-insert-dir, Info(-directory)-find-node, with args controlling msgs.
;;     info-find-node-2: Added optional arg NOMSG.
;;     Info-find-emacs-command-nodes, Info-goto-emacs(-key)-command-node: Added optional arg MSGP.
;;     Info-search, Info-save-current-node: Show messages only if interactive-p.
;; 2012/01/15 dadams
;;     Added: info-display-manual (redefinition).
;;     Info-find-file: Do not define for < Emacs 23.2 - no virtual books.
;; 2011/11/15 dadams
;;     Added: redefinition of Info-find-file for Emacs 23+, to handle virtual books.
;; 2011/08/23 dadams
;;     Removed hard-code removal of info from same-window-(regexps|buffer-names).  Thx to PasJa.
;; 2011/02/06 dadams
;;     info-user-option-ref-item: Corrected background for light-bg case.
;; 2011/02/03 dadams
;;     All deffaces: Provided default values for dark-background screens too.
;; 2011/01/04 dadams
;;     Removed autoload cookies from non def* sexps.  Added for defgroup and defface.
;; 2010/05/27 dadams
;;     Added: Info-set-mode-line.
;;     Info-find-node-2:
;;       Added redefinition of it for Emacs 23.2 (they keep twiddling it).
;;       Do not call Info-insert-breadcrumbs-in-mode-line.  Do that in Info-set-mode-line now.
;; 2010/04/06 dadams
;;     Added: Info-breadcrumbs-in-header-flag, Info-toggle-breadcrumbs-in-header-line,
;;            Info-breadcrumbs-in-mode-line-mode, Info-set-breadcrumbs-depth,
;;            Info-insert-breadcrumbs-in-mode-line, Info-breadcrumbs-depth-internal.
;;     Added to Info-mode-menu (Emacs 23+): Info-breadcrumbs-in-mode-line-mode.
;;     Info-find-node-2 (Emacs 23+): Add breadcrumbs to header line & mode line only according to vars.
;;     Info-fontify-node (Emacs 23+): Handle breadcrumbs in header only if flag says to.
;; 2010/01/12 dadams
;;     Info-find-node for Emacs 20, Info-find-node-2 for Emacs 21, 22, Info-search:
;;       save-excursion + set-buffer -> with-current-buffer.
;; 2010/01/10 dadams
;;     Info-find-node-2 for Emacs 23+: Updated for Emacs 23.2 (pretest) - virtual function stuff.
;; 2009/12/13 dadams
;;     Typo: Incorrectly used Emacs 22 version for Emacs 21 also.
;; 2009/12/11 dadams
;;     info-fontify-(node|quotations|reference-items), Info-merge-subnodes:
;;       Use font-lock-face property, not face, if > Emacs 21.
;; 2009/08/03 dadams
;;     Updated for Emacs 23.1 release: Info-find-node-2, Info-fontify-node, Info-search: new version.
;; 2009/06/10 dadams
;;     Added: Info-fontify-reference-items-flag, Info-mode-syntax-table.
;;     Info-mode: Use Info-mode-syntax-table, not text-mode-syntax-table.
;;     Info-fontify-node: Fontify ref items if *-reference-items-flag, not just for Elisp manual.
;;     Renamed: info-elisp-* to info-*.
;; 2009/06/09 dadams
;;     info-fontify-quotations: Allow \ before ', just not before`.
;; 2009/06/08 dadams
;;     info-fontify-quotations: Rewrote, using better regexp.  Don't fontify escaped ` or '.
;;       Fontify `\', `\\', etc.  Respect Info-fontify-single-quote-flag.
;;     Added: info-single-quote, Info-fontify-single-quote-flag, info-quotation-regexp.
;;     info-quoted-name: Changed face spec to (:inherit font-lock-string-face :foreground "DarkViolet")
;; 2009/05/25 dadams
;;     Info-virtual-book: Treat info-node bookmarks too.
;; 2009/05/23 dadams
;;     Added: Info-mode for Emacs 23.
;;            They added Info-isearch-filter, Info-revert-buffer-function, Info-bookmark-make-record.
;; 2009/05/22 dadams
;;     Added: Info-saved-nodes, Info-save-current-node, Info-virtual-book.  Added to Info-mode-menu.
;;     Bind info-apropos, Info-save-current-node, Info-virtual-book to a, ., and v.
;;     Info-mode: Updated doc string.
;; 2009/04/26 dadams
;;     Info-merge-subnodes: Bind inhibit-field-text-motion to t, for end-of-line.
;; 2008/10/07 dadams
;;     Require cl.el at compile time for all Emacs versions, because of case.
;; 2008/10/05 dadams
;;     Added: Info-read-node-name-1, Info-read-node-name-2.
;; 2008-07-11 dadams
;;     Info-fontify-node (Emacs 22+): Protect histories when getting ancestor nodes for breadcrumbs.
;;     (Emacs 22+) Don't change faces info-menu-header, *-title-*, *(-header)-node, header-line.
;;     (Emacs 20, 21): Removed bold and italic attributes from info-node and info-xref.
;;     Removed commented out defface for info-xref and info-node.
;;     Face info-file: Blue, not DarkBlue, foreground, by default.
;; 2008/06/12 dadams
;;     Info-fontify-node (Emacs 22+):
;;       Prevent infinite recursion from Info-goto-node calling Info-fontify-node.
;;       Fixed for nil Info-hide-note-references.
;; 2008/06/10 dadams
;;     Info-fontify-node (Emacs 22+): Added breadcrumbs.
;; 2008/03/06 dadams
;;     info-mode: Use fboundp for Info-clone-buffer, not version test, for Emacs 22+. Thx to Sebastien Vauban.
;; 2008/02/01 dadams
;;     Info-mode: Renamed Info-clone-buffer-hook to Info-clone-buffer for Emacs 22.1.90.
;; 2008/01/08 dadams
;;     Info-search (Emacs 22): Removed phony pred arg.
;; 2008/01/06 dadams
;;     Removed soft require of Icicles due to cirular dependency.  Thx to Tennis Smith.
;; 2007/11/27 dadams
;;     Info-search: Use icicle-read-string-completing, if available.
;;     Added soft require Icicles.
;; 2007/11/20 dadams
;;     Info-subtree-separator: Escaped slashes in doc string: \f -> \\f.
;; 2007/09/26 dadams
;;     Better default color for info-quoted-name.  Added group face to all deffaces.
;; 2007/09/25 dadams
;;     Bound Info-mouse-*-new-* to S-down-mouse-2, not S-mouse-2, because of mouse-scan-lines-or-M-:.
;;     Info-goto-emacs-command-node: Convert completion default value to string.
;; 2007/08/27 dadams
;;     Info-fontify-node: Ensure Info-fontify-node is a string when fontifiy quotations. Updated for Emacs 22.
;; 2007/07/13 dadams
;;     Info-find-node: Redefine only for Emacs < 21.
;; 2006/09/15 dadams
;;     Info-mouse-follow-nearest-node redefinition is only for Emacs >= 22.
;;     Changed Emacs 22 tests to just (>= emacs-major-version 22).
;;     Bind tool-bar-map for Emacs 21.  Otherwise, binding of [tool-bar] gives an error (why?).
;; 2006/08/18 dadams
;;     Everywhere: Corrected previous change: minibuffer-selected-window to window-minibuffer-p.
;; 2006/08/14 dadams
;;     Everywhere: fit-frame only if not a minibuffer window.
;; 2006/08/12 dadams
;;     Info-merge-subnodes: Bug fixes:
;;       Added concat for insertion of main node when recursive-display-p is negative.
;;       Don't recurse down Index menus.
;;       When checking for subnodes menu, check for nonfile menu item also.
;;       After come back from recursion, go back to Info buffer before trying to go back in history.
;;       Call fit-frame at end.
;; 2006/06/10 dadams
;;     Added: Info(-mouse)-follow-nearest-node-new-window.  Bound to S-RET, S-mouse-2.
;; 2006/03/31 dadams
;;     info-menu-header: Removed :underline, because links are underlined in Emacs 22.
;;     No longer use display-in-minibuffer.
;; 2006/01/08 dadams
;;     Added: redefinition of Info-mouse-follow-nearest-node.
;; 2006/01/07 dadams
;;     Added :link for sending bug report.
;; 2006/01/06 dadams
;;     Added defgroup Info-Plus and used it. Added :link.
;; 2005/12/30 dadams
;;     Moved everything from setup-info.el to here, after getting rid of some of it.
;;     Use defface for all faces.  Renamed faces, without "-face".
;;     Use minibuffer-prompt face, not info-msg-face.
;;     No longer require setup-info.el.  No longer require cl.el when compile.
;; 2005/11/21 dadams
;;     Info-search for Emacs 22: Don't display repeat `s' message if isearch-mode.
;; 2005/11/09 dadams
;;     Info-fontify-node: Updated to reflect latest CVS (replaced Info-escape-percent header).
;; 2005/10/31 dadams
;;     Use nil as init-value arg in calls to completing-read, everywhere.
;; 2005/07/04 dadams
;;     info-fontify-quotations: Use font-lock-face property, instead of face, for Emacs 22.
;;                              Wrap re-search-forward in condition-case for stack overflow.
;; 2005/07/02 dadams
;;     Info-search: fit-frame. Added Emacs 22 version too.
;;     Info-goto-emacs-command-node, Info-goto-emacs-key-command-node, Info-merge-subnodes:
;;       Use Info-history-back for Emacs 22.
;;     Info-mode: Added Emacs 22 version.
;; 2005/06/23 dadams
;;     Info-fontify-node: Fontify reference items if in Emacs-Lisp manual.
;;     Added: info-fontify-reference-items
;; 2005/05/17 dadams
;;     Updated to work with Emacs 22.x.
;; 2004/11/20 dadams
;;     Info-find-emacs-command-nodes: bug fix: regexp (cmd-desc) was only for Emacs 21.
;;     Refined to deal with Emacs 21 < 21.3.50 (soon to be 22.x)
;; 2004/10/09 dadams
;;     info-fontify-quotations:
;;       1) Allow all characters inside `...'.
;;       2) Treat case of "..." preceded by backslashes
;;     Info-fontify-node (for Emacs 21): Moved info-fontify-quotations before fontification of titles.
;; 2004/10/07 dadams
;;     Renamed Info-resize-frame-p to Info-fit-frame-flag.
;; 2004/10/05 dadams
;;     Improved regexp treatment further for fontifying quotations.
;; 2004/10/04 dadams
;;     Improved regexp treatment for fontifying quotations.
;;       Added info-fontify-quotations. Removed info-fontify-strings-p.
;;       Renamed Info-fontify-quotations-p to Info-fontify-quotations-flag.
;; 2004/10/03/dadams
;;     Major update: updated to work with Emacs 21 also.
;;       Made require of setup-info.el mandatory.
;;       Removed all variables and keys to setup-info.el.
;;       Renamed to Emacs 21 names and only define for Emacs < 21: emacs-info -> info-emacs-manual.
;; 2004/09/28 dadams
;;     Removed dir-info (same as Info-directory).
;;     Renamed to Emacs 21 names and only define for Emacs < 21: emacs-lisp-info -> menu-bar-read-lispref
;; 2004/06/01 dadams
;;     Renamed: Info-fit-frame-p to Info-resize-frame-p, shrink-frame-to-fit to resize-frame.
;; 2000/09/27 dadams
;;     1. Added: Info-fit-frame-p.
;;     2. Info-find-node: added shrink-frame-to-fit.
;; 1999/04/14 dadams
;;     Info-fontify-node: Fontify indexes too.
;; 1999/04/14 dadams
;;     1. Added vars: info-file-face, info-menu-face, info-node-face, info-quoted-name-face, info-string-face,
;;                    info-xref-face.
;;     2. No longer use (or define) faces: info-node, info-file, info-xref, info-menu-5, info-quoted-name,
;;                                         info-string.
;;     3. Info-fontify-node: Use new face variables instead of faces in #2, above.
;;        Corrected: node names in info-node-face (was xref). Use info-menu-face for * and menu item.
;;     4. Info-mode: Redefined like original, but: no make-face's; use face vars.
;;                   Added user options description to doc string.
;; 1999/04/08 dadams
;;     Info-goto-emacs-key-command-node: regexp-quote pp-key for Info-search.
;; 1999/04/07 dadams
;;     Info-goto-emacs-key-command-node: a) msgs only if interactive, b) return nil if not found, else non-nil,
;;       c) "is undefined" -> "doc not found", d) use display-in-minibuffer more, e) corrected error handler.
;; 1999/04/01 dadams
;;     1. Added: (remove-hook 'same-window-buffer-names "*info*").
;;     2. Info-find-node: switch-to-buffer-other-window -> pop-to-buffer.
;; 1999/03/31 dadams
;;     1. Added (put 'Info-goto-emacs-(key-)command-node 'info-file "emacs").
;;     2. Info-find-node: Mention searched file in error messages.
;;     3. Added (replacement): Info-find-emacs-command-nodes, with progress msg.
;;     4. a. Info-goto-emacs-key-command-node: Use global-map, unless menu item.
;;        b. Added message "Not found using Index ...".
;; 1999/03/31 dadams
;;     1. Info-goto-emacs(-key)-command-node: Only display-in-minibuffer if
;;        interactive-p.
;;     2. Info-goto-emacs-key-command-node: Messages: "key"; other entries.
;; 1999/03/31 dadams
;;     1. Added (put 'info 'info-file "emacs") so find doc on `info' cmd.
;;     2. Info-goto-emacs-command-node:
;;        a. Added message when =< 1 match.
;;        b. Return num-matches if found.
;;        c. Uses `display-in-minibuffer' instead of `message'.
;;     3. a. Wrapped call to Info-search in condition-case, not if.
;;        b. Info-goto-emacs-key-command-node: Return num-matches if found.
;; 1999/03/30 dadams
;;     1. Added Info menu bar menu.
;;     2. Info-goto-emacs-command-node: Only error if interactive-p.
;;     3. Info-goto-emacs-key-command-node:
;;        a. Print key in msgs
;;        b. If Info-goto-emacs-command-node doesn't find it, then try Info-search.
;;           If found & interactive-p, then msg ("repeat").  Else error.
;;     4. Info-search: Msg ("repeat") if found & interactive-p.
;; 1999/03/17 dadams
;;     1. Updated to correspond with Emacs 34.1 version.
;;     2. Protect with fboundp.
;; 1996/07/11 dadams
;;     Added redefinitions of Info-goto-emacs-(key-)command-node.
;; 1996/04/26 dadams
;;     Put escaped newlines on long-line strings.
;; 1996/04/16 dadams
;;     Added: info-file, info-quoted-name, info-string, Info-fontify-quotations-flag, info-fontify-strings-p.
;;     Take into account in Info-fontify-node.
;; 1996/02/23 dadams
;;     1. Changed binding of Info-merge-subnodes back to `r', but now requires user confirmation when invoked.
;;     2. Info-subtree-separator: Incorporates "\n* ".  variable-interactive prop.
;; 1996/02/22 dadams
;;     display-Info-node-subtree:
;;       1. display-Info-node-subtree -> Info-merge-subnodes (renamed).
;;       2. Changed binding of Info-merge-subnodes from `r' to `C-d'.
;;       3. Don't pick up text between menu-item-line and "\n* ".  Hardwire "\n* ".
;;       4. Untabify menu-item-line, so can count chars to underline.
;;       5. indent-rigidly, not indent-region.
;; 1996/02/22 dadams
;;     1. Bind describe-mode and display-Info-node-subtree.
;;     2. Added redefinition of Info-mode: Only the doc string was changed.
;;     3. Added Info-subtree-separator.
;;     3. display-Info-node-subtree: Info-subtree-separator. Doc. Garbage-collect.
;; 1996/02/22 dadams
;;     Info-merge-subnodes: Rewrote, adding optional args.  Renamed (defaliased) to display-Info-node-subtree.
;; 1996/02/22 dadams
;;     Added redefinition of Info-merge-subnodes (cleanup, corrections).
;; 1996/02/20 dadams
;;     1. Make info-node, info-xref, info-menu-5 here. (Diff faces than before.)
;;     2. Added redefinition of Info-find-node.  (Uses other window.)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:

(require 'info)
(eval-when-compile (require 'cl-lib)) ;; case

;; These are optional, for cosmetic purposes.
(require 'thingatpt nil t) ;; (no error if not found): symbol-at-point

(when (and (require 'thingatpt+ nil t) ;; (no error if not found): symbol-nearest-point
           (fboundp 'tap-put-thing-at-point-props)) ; >= 2012-08-21
  (tap-define-aliases-wo-prefix)
  (tap-put-thing-at-point-props))

(require 'strings nil t) ;; (no error if not found): concat-w-faces
(require 'fit-frame nil t) ;; (no error if not found): fit-frame

;; Took this out because it leads to a circular `require' dependency.
;; (require 'icicles nil t) ;; (no error if not found): icicle-read-string-completing

;; Quiet the byte compiler a bit.
;;
(defvar apropos-regexp)                 ; In `apropos.el'.
(defvar bookmark-alist)                 ; In `bookmark.el'.
(defvar bookmark-make-record-function)  ; In `bookmark.el'.
(defvar browse-url-new-window-flag)     ; In `browse-url.el'.
(defvar desktop-save-buffer)
(defvar header-line-format)
(defvar Info-breadcrumbs-depth)
(defvar Info-breadcrumbs-depth-internal)
(defvar Info-breadcrumbs-in-header-flag)
(defvar Info-breadcrumbs-in-mode-line-mode)
(defvar Info-current-node-virtual)
(defvar Info-bookmarked-node-xref-faces) ; Here, Emacs 24.2+, with Bookmark+.
(defvar Info-fontify-bookmarked-xrefs-flag) ; Here, Emacs 24.2+, with Bookmark+.
(defvar Info-fontify-visited-nodes)
(defvar Info-hide-note-references)
(defvar Info-history-list)
(defvar Info-history-skip-intermediate-nodes) ; Emacs 24+
(defvar Info-isearch-initial-node)
(defvar Info-isearch-search)
(defvar Info-last-search)
(defvar Info-link-keymap)
(defvar Info-menu-entry-name-re)
(defvar Info-next-link-keymap)
(defvar Info-mode-line-node-keymap)
(defvar Info-node-spec-re)
(defvar Info-persist-history-mode)
(defvar Info-point-loc)
(defvar Info-prev-link-keymap)
(defvar Info-read-node-completion-table)
(defvar Info-refill-paragraphs)
(defvar Info-saved-history-file)
(defvar Info-saved-nodes)
(defvar Info-search-case-fold)
(defvar Info-search-history)
(defvar Info-search-whitespace-regexp)
(defvar info-tool-bar-map)
(defvar Info-up-link-keymap)
(defvar Info-use-header-line)
(defvar infop-node-name)                 ; Here, in `Info-merge-subnodes'.
(defvar isearch-adjusted)                ; In `isearch.el', Emacs 25+.
(defvar isearch-filter-predicate)        ; In `isearch.el', Emacs 23+.
(defvar isearch-lax-whitespace)          ; In `isearch.el'.
(defvar isearch-regexp-lax-whitespace)   ; In `isearch.el'.
(defvar isearchp-deactivate-region-flag) ; In `isearch+.el'.
(defvar isearchp-reg-beg)                ; In `isearch+.el'.
(defvar isearchp-reg-end)                ; In `isearch+.el'.
(defvar mouse-wheel-up-event)            ; In `mwheel.el', Emacs 22+.
(defvar outline-heading-alist)           ; In `outline.el'.
(defvar widen-automatically)

;;;;;;;;;;;;;;;;;;;;

(provide 'info+)
(require 'info+) ;; Ensure loaded before compiling.

;;;;;;;;;;;;;;;;;;;;


;;(@* "Macros")
;;; Macros -----------------------------------------------------------

(defmacro info-user-error (&rest args)
  "`user-error' if defined, otherwise `error'."
  `(if (fboundp 'user-error) (user-error ,@args) (error ,@args)))

(font-lock-add-keywords
 'emacs-lisp-mode
 '(("(\\(info-user-error\\)\\>" 1 font-lock-warning-face)))

;;; KEYS & MENUS ;;;;;;;;;;;;;;;;;;;;;;;;

(define-key Info-mode-map "?"               'describe-mode) ; Don't use `Info-summary'.
(define-key Info-mode-map "+"               'Info-merge-subnodes)
(define-key Info-mode-map "."               'Info-save-current-node)
(define-key Info-mode-map "a"               'info-apropos)
(define-key Info-mode-map "G"               'Info-goto-node-web)
(define-key Info-mode-map "O"               'Info-toc-outline)
(define-key Info-mode-map "v"               'Info-virtual-book)
(define-key Info-mode-map (kbd "C-x DEL")   'Info-change-visited-status)
;; Mouse back and forward buttons
(define-key Info-mode-map [S-down-mouse-2]  'Info-mouse-follow-nearest-node-new-window)
(define-key Info-mode-map [S-return]        'Info-follow-nearest-node-new-window)

;; For other than `w32-win' and `ns-win', `mouse-4' and `mouse-4' scroll, so cannot be used for history movement.
(when (and (boundp 'mouse-wheel-up-event) ; Emacs 22+
           (eq mouse-wheel-up-event 'wheel-down))
  (define-key Info-mode-map [mouse-4]       'Info-history-back)
  (define-key Info-mode-map [mouse-5]       'Info-history-forward))

;;(@* "Faces (Customizable)")
;;; Faces (Customizable) ---------------------------------------------

;;;###autoload
(defgroup Info-Plus nil
  "Various enhancements to Info."
  :group 'info
  :link `(url-link :tag "Send Bug Report"
                   ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
info+.el bug: \
&body=Describe bug here, starting with `emacs -q'.  \
Don't forget to mention your Emacs and library versions."))
  :link '(url-link :tag "Other Libraries by Drew"
          "https://www.emacswiki.org/emacs/DrewsElispLibraries")
  :link '(url-link :tag "Download" "https://www.emacswiki.org/emacs/download/info%2b.el")
  :link '(url-link :tag "Description" "https://www.emacswiki.org/emacs/InfoPlus")
  :link '(emacs-commentary-link :tag "Commentary" "info+")
  )

(defvar info-good-fixed-pitch-font-families '("Lucida Console" "Lucida Sans Typewriter"
                                              "Consolas" "ProggyVector" "OCR A Extended")
  "Some good fixed-pitch font families.
The default for face `info-fixed-pitch' inherits from the first one
available, checked in list order.")

;;;###autoload
(defface info-fixed-pitch
  `((t (:inherit fixed-pitch
                 ,@(let ((family (catch 'info-fixed-pitch
                                   (dolist (fam  info-good-fixed-pitch-font-families)
                                     (when (member fam (font-family-list))
                                       (throw 'info-fixed-pitch fam))))))
                     (and family `(:family ,family))))))
  "Fixed-pitch face for Info.
The default value inherits from face `fixed-pitch'.  And if you have a
font family listed in variable `info-good-fixed-pitch-font-families',
then the face attributes of the first one you have listed there are
merged with those of face `fixed-pitch'.

By default, face `info-fixed-pitch' is inherited by faces
`info-custom-delimited',`info-double-quoted-name',
`info-isolated-quote', `info-quoted-name', `info-reference-item', and
`info-string'."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-custom-delimited
  '((((background dark)) (:inherit info-fixed-pitch :foreground "Red"))
    (t (:inherit info-fixed-pitch :foreground "Red")))
  "Face for text surrounded by custom delimiter chars on the same line."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-double-quoted-name        ; For “...”
  '((((background dark)) (:inherit info-fixed-pitch :foreground "Cyan"))
    (t (:inherit info-fixed-pitch :foreground "DarkOrange")))
  "Face for names enclosed in curly double-quotes (“...”) in `info'."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-emphasis                  ; For _..._
  '((t (:inherit italic)))
  "Face for emphasizing text enclosed with underscores (_..._) in `info'."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-indented-text
  '((((background dark)) (:inherit info-fixed-pitch :foreground "DarkBlue"))
    (t (:inherit info-fixed-pitch :foreground "DarkBlue")))
  "Face for indented text such as that used in a code block."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-file
  '((((background dark)) (:inherit info-reference-item :foreground "Yellow"))
    (t (:inherit info-reference-item :foreground "Blue")))
  "Face for file heading labels in `info'." :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-glossary-word
  '((t (:box (:line-width 1 :style pressed-button))))
  "Face for first occurrences of glossary words in an `info' node."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-menu
  '((((background dark)) (:foreground "Yellow"))
    (t (:foreground "Blue")))
  "Face used for menu items in `info'." :group 'Info-Plus :group 'faces)

;; FWIW, I use a `LightSteelBlue' background for `*info*', and I use `yellow' for this face.
;;;###autoload
(defface info-quoted-name               ; For ‘...’ and `...'
  ;; Inheriting now also from `fixed-pitch'.
  ;; But see Emacs bug #44316.  If that gets fixed then maybe revisit this default definition somehow.
  ;;     '((((background dark)) (:inherit fixed-pitch :foreground "#6B6BFFFF2C2C")) ; ~ bright green
  ;;       (((background light)) (:inherit fixed-pitch :foreground "DarkViolet"))
  '((((background dark)) (:inherit info-fixed-pitch :foreground "#6B6BFFFF2C2C")) ; ~ bright green
    (((background light)) (:inherit info-fixed-pitch :foreground "DarkViolet"))
    (t (:foreground "yellow")))
  "Face for quoted names (‘...’ or `...') in `info'."
  :group 'Info-Plus :group 'faces)

;; FWIW, I use a `LightSteelBlue' background for `*info*', and I use `red3' for this face.
;;;###autoload
(defface info-string                    ; For "..."
  ;; See comment for `info-quoted-name'.
  '((((background dark)) (:inherit info-fixed-pitch :foreground "Orange"))
    (t (:inherit info-fixed-pitch :foreground "red3")))
  "Face for strings (\"...\") in `info'."
  :group 'Info-Plus :group 'faces)

;;;###autoload
(defface info-isolated-quote    ; For 'foobar, '(...) etc.
  ;; See comment for `info-quoted-name'.
  '((((background dark))
     (:inherit info-fixed-pitch :foreground "Green"  :background "#46462C2C1111")) ; ~ very dark brown
    (t (:inherit info-fixed-pitch :foreground "Magenta" :background "SlateGray2")))
  "Face for an isolated single-quote mark (') in `info'.
That is, one that is not part of `...'."
  :group 'Info-Plus :group 'faces)
(define-obsolete-face-alias 'info-single-quote' info-isolated-quote "2020-10-22")

;;;###autoload
(defface info-isolated-backquote        ; For `foobar, `(...) etc.
  '((((background dark)) (:inherit info-isolated-quote :background "Magenta"))
    (t (:inherit info-isolated-quote :background "PaleGreen1")))
  "Face for an isolated backquote mark (`) in `info'.
That is, one that is not part of `...'."
  :group 'Info-Plus :group 'faces)

;; Standard faces from vanilla Emacs `info.el', but without `:weight', `:height' and `:inherit'.
;;;###autoload
(defface info-title-1
  '((((type tty pc) (class color) (background dark))  :foreground "yellow" :weight bold)
    (((type tty pc) (class color) (background light)) :foreground "brown"  :weight bold))
  "Face for info titles at level 1."
  :group 'info)

;;;###autoload
(defface info-title-2
  '((((type tty pc) (class color)) :foreground "lightblue" :weight bold))
  "Face for info titles at level 2."
  :group 'info)

;;;###autoload
(defface info-title-3
  '((((type tty pc) (class color)) :weight bold))
  "Face for info titles at level 3."
  :group 'info)

;;;###autoload
(defface info-title-4
  '((((type tty pc) (class color)) :weight bold))
  "Face for info titles at level 4."
  :group 'info)

;;; Faces for highlighting reference items
;;;###autoload
(defface info-command-ref-item
  '((((background dark)) (:inherit info-reference-item :foreground "#7474FFFF7474")) ; ~ light green
    (t (:inherit info-reference-item :foreground "Blue")))
  "Face used for \"Command:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-constant-ref-item
  '((((background dark))
     (:inherit info-reference-item :foreground "DeepPink"))
    (t (:inherit info-reference-item :foreground "DeepPink")))
  "Face used for \"Constant:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-function-ref-item
  '((((background dark))
     (:inherit info-reference-item :foreground "#4D4DDDDDDDDD")) ; ~ cyan
    (t (:inherit info-reference-item :foreground "DarkBlue")))
  "Face used for \"Function:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-macro-ref-item
  '((((background dark))
     (:inherit info-reference-item :foreground "Yellow"))
    (t (:inherit info-reference-item :foreground "DarkMagenta")))
  "Face used for \"Macro:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-reference-item
  ;; See comment for `info-quoted-name'.
  '((((background dark)) (:inherit info-fixed-pitch :background "gray12"))
    (t (:inherit info-fixed-pitch :background "gray88")))
  "Face used for reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-special-form-ref-item
  '((((background dark))
     (:inherit info-reference-item :foreground "Green")) ; ~ pink
    (t (:inherit info-reference-item :foreground "Magenta")))
  "Face used for \"Special Form:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-syntax-class-item
  '((((background dark))
     (:inherit info-reference-item :foreground "#FFFF9B9BFFFF")) ; ~ pink
    (t (:inherit info-reference-item :foreground "DarkGreen")))
  "Face used for \"Syntax Class:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-user-option-ref-item
  '((t (:inherit info-reference-item :foreground "Red")))
  "Face used for \"User Option:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)
;;;###autoload
(defface info-variable-ref-item
  '((((background dark))
     (:inherit info-reference-item :foreground "Orange"))
    (t (:inherit info-reference-item :foreground "FireBrick")))
  "Face used for \"Variable:\" reference items in `info' manual."
  :group 'Info-Plus :group 'faces)

(when (and (require 'bookmark+ nil t) ; Emacs 24.2+ (do not bother for Emacs 23-24.1)
           (or (> emacs-major-version 24)  (and (= emacs-major-version 24)  (> emacs-minor-version 1))))

  (defface info-xref-bookmarked
    '((((background dark)) (:foreground "Violet"))
      (t (:foreground "DarkGreen")))
    "Face for bookmarked Info nodes."
    :group 'Info-Plus :group 'faces)

  )

;;(@* "User Options (Customizable)")
;;; User Options (Customizable) --------------------------------------

;; This and the version of function `Info-bookmark-jump' defined here are also defined in `bookmark+-1.el',
;; so that their feature is available if you use either `Info+' or `Bookmark+'.
;;
;;;###autoload
(defcustom Info-bookmark-use-only-node-not-file-flag t
  "Non-nil means an Info bookmark uses only the node name.
The recorded Info file name is ignored.  This means use only manuals
corresponding to the current Emacs session, regardless of the Emacs
version or platform used to record the bookmark.

A nil value means use the manuals whose absolute file names are
recorded in the bookmarks.  (But if the file doesn't exist or is
unreadable, then act as if the value is non-nil.)

A non-nil value means you can use the same bookmark with different
Emacs installations, including on different platforms.  A nil value
means that you can use a bookmark to consult the Info manual for a
different Emacs version from that of the current session."
  :type 'boolean :group 'Info-Plus)

;;;###autoload
(defcustom Info-breadcrumbs-in-header-flag nil
  "Non-nil means breadcrumbs are shown in the header line."
  :type 'boolean :group 'Info-Plus)

(defun info-buffer-name-function-default (file node)
  "Default function value for `info-buffer-name-function'."
  (format "*info* (%s) %s" file node))

;;;###autoload
(defcustom info-buffer-name-function 'info-buffer-name-function-default
  "Function to name Info buffer, or nil to use default buffer naming.
This is used by `info-manual+node-buffer-name-mode' and command
`info-rename-buffer'.

The function must accept the current Info file and node names as its
first two args, in that order."
  :type '(choice
          (const    :tag "Use default Info buffer naming" nil)
          (function :tag "Function accepting Info file and node names, returning string"))
  :group 'Info-Plus)

;;;###autoload
(defcustom Info-display-node-header-fn 'Info-display-node-default-header
  "Function to insert header by `Info-merge-subnodes'."
  :type 'function :group 'Info-Plus)

;;;###autoload
(defcustom Info-emphasis-regexp "_\\(\\sw+\\)_"
  "Regexp to match text enclosed in underscore (`_') characters.

The default value matches the following (enclosed in underscores):
word, punctuation, and whitespace characters, plus hyphens, with at
least one word character.  Hyphen is included explicitly because it
generally has symbol syntax in Info.

Some possible values include:

_\\(\\sw+\\)_\t\t  (single words)

_\\(\\sw+\\(\\s-+\\sw+\\)*\\)_\t  (single words, maybe whitespace-separated)

_\\([^_\\n]+\\)_\t\t  (anything except underscore and newline chars)

_\\([^_]+\\)_\t\t  (anything except underscore chars)

_\\(\\(\\s-\\|\\sw\\|\\s.\\)+\\)_ (word, punctuation, whitespace)

_\\(\\(\\sw\\(\\s-\\|\\sw\\|\\s.\\)*\\)\\|\\(\\(\\s-\\|\\sw\\|\\s.\\)\\sw*\\)\\)_

_\\(\\(\\sw\\(\\s-\\|\\sw\\|\\s.\\|\\s(\\|\\s)\\)*\\)\\|
\\(\\(\\s-\\|\\sw\\|\\s.\\|\\s(\\|\\s)\\)\\sw*\\)\\)_ (but joined, with no newline)
  (like previous, but also open and close delimiters, such as ()[])

Note that any value can be problematic for some Info text - see
`Info-fontify-emphasis-flag'."
  :type 'regexp :group 'Info-Plus)

;;;###autoload
(defcustom Info-fit-frame-flag t
  "Non-nil means call `fit-frame' on Info buffer."
  :type 'boolean :group 'Info-Plus :group 'Fit-Frame)

;;;###autoload
(defcustom Info-fontify-angle-bracketed-flag t
  "Non-nil means `info' fontifies text within <...>.
A non-nil value has no effect unless `Info-fontify-quotations' is also
non-nil.

Note: This fontification can never be 100% reliable.  It aims to be
useful in most Info texts, but it can occasionally result in
fontification that you might not expect.  This is not a bug; it is
part of the design to be able to appropriately fontify a great variety
of texts.  Set this flag to nil if you do not find this fontification
useful.  You can use command `Info-toggle-fontify-angle-bracketed' to
toggle the option value."
  :type 'boolean :group 'Info-Plus)

(when (and (require 'bookmark+ nil t) ; Emacs 24.2+ (do not bother for prior)
           (or (> emacs-major-version 24)  (and (= emacs-major-version 24)  (> emacs-minor-version 1))))

  (defcustom Info-bookmarked-node-xref-faces '()
    "List of faces to use to classify bookmarked nodes.
The faces are used for links to bookmarked nodes.  They classify nodes
by serving as the values of bookmark tag \"bmkp-info-face\".

You can use any face for such a link.  The faces in this option list
are just provided as defaults when you are asked to enter a face for a
node link. "
    :type '(repeat face) :group 'Info-Plus)

  (defcustom Info-fontify-bookmarked-xrefs-flag t
    "Non-nil means fontify references to bookmarked nodes.
The face used is `info-xref-bookmarked'."
    :type 'boolean :group 'Info-Plus)

  )

;;;###autoload
(defcustom Info-fontify-custom-delimited (list nil ?' ?')
  "Non-nil means `info' fontifies text between delimiters you specify.
The text that is highlighted matches the value of variable
`info-custom-delimited-same-line-regexp'.

The option value is a list (ON/OFF BEG END), where:

 ,* Non-nil ON/OFF means fontifying is on, and nil means it is OFF.
 ,* BEG is the beginning delimiter character.
 ,* END is the ending delimiter character.

By default, this fontifying is off.  When turned on, by default the
text between apostrophes ('...') is fontified.

You can use command `Info-toggle-fontify-custom-delimited' to toggle
this fontifying on/off.  With a prefix arg, that command also prompts
you for the (new) delimiters to use.

You can use command `Info-define-custom-delimiting' to just do the
latter: set the delimiters.

For example, if you have an Info file that uses {...}, you can
highlight the enveloped ... text by setting the delimiters to chars {
and }, and turning the option on."
  :type 'boolean :group 'Info-Plus)

;;;###autoload
(defcustom Info-fontify-emphasis-flag t
  "Non-nil means `info' fontifies text between underscores (`_').
The text that is highlighted matches the value of option
`Info-emphasis-regexp'.

Note 1:
This fontification hides the underscores that surround text that is
emphasized.  Because this fontification is not 100% reliable (see Note
2), in cases where it is inappropriate or unhelpful you might want to
see the hidden underscore characters.  You can toggle showing all
hidden text (not just hidden underscores) using `M-x visible-mode'.
See (info) `Help-Inv' for more information about this.

Note 2:
This fontification can never be 100% reliable.  It aims to be useful
in most Info texts, but it can occasionally result in fontification
that you might not expect.  This is not a bug; it is part of the
design to be able to appropriately fontify a great variety of texts.
Set this flag to nil if you do not find this fontification useful.
You can use command `Info-toggle-fontify-emphasis' to toggle the
option value.

Note 3:
If internal variable `info-fontify-emphasis' is `nil' then emphasis is
never highlighted, and this option has no effect.  This gives you a
way to turn off all matching of `Info-emphasis-regexp'."
  :type 'boolean :group 'Info-Plus)

;;;###autoload
(defcustom Info-fontify-glossary-words t
  "Non-nil means `info' fontifies first occurrences of glossary words.
In addition, you can click `mouse-2' on such a highlighted word, or
use `RET' on it, to go to its definition in the `Glossary' node of the
current manual.

You can optionally also have a mouseover action show the definition
immediately, as a tooltip (or in the echo area if `tooltip-mode' is
turned off).

,* A value of `link-only' means do not also show the definition on
  mouseover.

,* Any other non-nil value means show the definition on mouseover.

Glossary terms of more than one word are not highlighted or linked.

This option has no effect for a manual that has no node named
`Glossary'.

Note: This fontification can never be 100% reliable.  It aims to be
useful in most Info texts, but it can occasionally result in
fontification that you might not expect.  This is not a bug; it is
part of the design to be able to appropriately fontify a great variety
of texts.  Set this flag to nil if you do not find this fontification
useful.  You can use command `Info-toggle-fontify-glossary-words' to
toggle the option value."
  :type '(choice
          (const :tag "OFF - don't fontify and link glossary words"   nil)
          (const :tag "Fontify and link, but don't show tooltip"      link-only)
          (other :tag "Fontify, link, and show tooltip on mouseover"  t))
  :group 'Info-Plus)

;;;###autoload
(defcustom Info-fontify-indented-text-chars nil
  "A number means fontify text indented at least that many chars.
The default value is nil, which does nothing - no such fontifying.

The indented text is fontified with face `info-indented-text', which
by default uses a fixed-pitch font.

This can be useful especially if minor mode
`Info-variable-pitch-text-mode' is enabled, by keeping indented code
block, ASCII-art diagrams etc. in a fixed-pitch font.

A value of 10 works well for the Elisp manual.  But be aware that no
number works well across multiple manuals, because indented text at
any level is not necessarily something you want to fontify.

This fontification is not done for nodes named `Top', in order to
avoid fontifying continuation lines of menu-item descriptions."
  :type '(choice
          (const   :tag "OFF - don't fontify indented text"   nil)
          (integer :tag "Fontify text indented at least this many chars" :value 10))
  :group 'Info-Plus)


(define-obsolete-variable-alias 'Info-fontify-single-quote-flag 'Info-fontify-isolated-quote-flag "2020-10-22")
;;;###autoload
(defcustom Info-fontify-isolated-quote-flag t
  "Non-nil means `info' fontifies ' when not preceded by `....
A non-nil value has no effect unless `Info-fontify-quotations' is also
non-nil.

Note: This fontification can never be 100% reliable.  It aims to be
useful in most Info texts, but it can occasionally result in
fontification that you might not expect.  This is not a bug; it is
part of the design to be able to appropriately fontify a great variety
of texts.  Set this flag to nil if you do not find this fontification
useful.  You can use command `Info-toggle-fontify-isolated-quote' to
toggle the option value."
  :type 'boolean :group 'Info-Plus)


(define-obsolete-variable-alias 'Info-fontify-quotations-flag 'Info-fontify-quotations "2020-10-19")
;;;###autoload
(defcustom Info-fontify-quotations t
  "Non-nil means `info' fontifies text between quotes.
This applies to double-quoted text (“...” or \"...\") and text
between single-quotes (‘...’ or \\=`...\\=').

A value of `multiline' means fontify all such quotations, even those
that span multiple lines.

Any other non-nil value (`t' is the default value) means highlight all
such quotations, but in the case of all except \"...\" (strings), do
so only if the quoted sexp is all on the same line.

Note: This fontification can never be 100% reliable.  It aims to be
useful in most Info texts, but it can occasionally result in
fontification that you might not expect.  This is not a bug; it is
part of the design to be able to appropriately fontify a great variety
of texts.  Set this flag to nil if you do not find this fontification
useful.  You can use command `Info-cycle-fontify-quotations' to
cycle the option value."
  :type '(choice
          (const :tag "OFF - no quotations"                      nil)
          (const :tag "All quotations, even multiline"           multiline)
          (other :tag "All quotations, but on same-line except \"...\"" t))
  :group 'Info-Plus)

;;;###autoload
(defcustom Info-fontify-reference-items-flag t
  "Non-nil means `info' fontifies reference items such as \"Function:\"."
  :type 'boolean :group 'Info-Plus)

;;;###autoload
(defcustom Info-glossary-fallbacks-alist '((emacs . t))
  "Alist of fallback manuals to use for glossary links.
Each element is of the form (GLOSSARY-MANUAL . MANUALS).  The glossary
of GLOSSARY-MANUALis used to create glossary links for each manual in
MANUALS, if it has no glossary of its own.  If MANUALS is `t' then all
manuals use the glossary of GLOSSARY-MANUAL.

This has no effect if option `Info-fontify-glossary-words' is nil."
  :type '(alist
          :key-type   (symbol :tag "Fallback manual (use its glossary)")
          :value-type (choice
                       (repeat (symbol :tag "A manual that uses fallback manual's glossary"))
                       (const :tag "Use fallback for all manuals with no glossary" t)))
  :group 'Info-Plus)

(when (and (require 'bookmark+ nil t)   ; Emacs 24.4+
           (or (> emacs-major-version 24)  (and (= emacs-major-version 24)  (> emacs-minor-version 3))))

  (defcustom Info-node-access-invokes-bookmark-flag t
    "Non-nil means invoke the bookmark when you access an Info node.
This applies to Info bookmarks whose names correspond to the default
name.  This is normally the full node name, `(MANUAL) NODE', where
MANUAL is the lowercase name of the Info manual.  For example, node
`Modes' in the Emacs manual has full name `(emacs) Modes', and the
bookmark must have that same name.

This automatic bookmark invocation can be useful to update the
bookmark data, such as the number of visits to the node."
    :type 'boolean :group 'Info-Plus)

  )

(when (fboundp 'advice-add)             ; Emacs 24.4+

  (defcustom Info-saved-history-file (locate-user-emacs-file "info-history" ".emacs.info-history")
    "File where `Info-persist-history-mode' saves `Info-history-list'."
    :type '(file :must-match t) :group 'Info-Plus)

  )

;;;###autoload
(defcustom Info-saved-nodes ()
  "List of Info node names you can visit using `\\<Info-mode-map>\\[Info-virtual-book]'.
Each node name is a string.  The node name can be absolute, including
a filename, such as \"(emacs)Basic\", or it can be relative, such as
\"Basic\".
You can customize this option, but you can also add node names to it
easily using `\\[Info-save-current-node]' (`Info-save-current-node')."
  :type '(repeat (string :tag "Node name")) :group 'info)

;;;###autoload
(defcustom Info-subtree-separator "\n* "
  "A string used to separate Info node descriptions.
Inserted by `Info-merge-subnodes' just before each node title.
Setting this to a string that includes a form-feed (^L), such as
\"\\f\\n* \", will cause a page break before each node description.

Use command `set-variable' to set this, quoting any control characters
you want to include, such as form-feed (^L) and newline (^J), with ^Q.
For example, type `^Q^L^Q^J* ' to set this to \"\\f\\n* \"."
  :type 'string :group 'Info-Plus)

;;;###autoload
(defcustom Info-toc-outline-no-redundancy-flag t
  "Non-nil means `Info-toc-outline' TOC has no redundancy.
If nil then section headings from the TOC manual are included, and
nodes can be repeated because they are in more than one section."
  :type 'boolean :group 'Info-Plus)


;;(@* "Internal Variables")
;;; Internal Variables -----------------------------------------------

(defvar info-fontify-emphasis t
  "Non-nil means allow `Info-fontify-emphasis-flag' to work.
If nil then emphasis is never fontified, regardless of that flag.")

(defvar Info-fontify-extra-function nil
  "If non-nil then a function used to provide additional highlighting.
The function is passed no arguments.

The function is invoked by `Info-fontify-node', before fontifying
reference items (`Info-fontify-reference-items').  When it is called,
point is at `point-min' in the node to be fontified.")

(defvar info-glossary-link-map (let ((map  (make-sparse-keymap)))
                                 (define-key map (kbd "RET")   'Info-goto-glossary-definition)
                                 (define-key map [mouse-2]     'Info-goto-glossary-definition)
                                 (define-key map [follow-link] 'mouse-2)
                                 map)
  "Keymap for glossary-word links.")

(defvar Info-link-faces '(info-xref info-xref-visited info-xref-bookmarked)
  "List of `font-lock-face' property faces used for links in Info.
Used to prevent glossary-word highlighting and linking from overriding
node links, when` Info-fontify-glossary-words' is non-nil.")

;; I reported this as Emacs bug #3312.  If it gets fixed, this can be removed.
(defvar Info-mode-syntax-table
  (let ((table  (copy-syntax-table text-mode-syntax-table)))
    (modify-syntax-entry ?'    "." table) ; Punctuation syntax for apostrophe (').
    (modify-syntax-entry ?\240 "." table) ; Punctuation syntax for non-breaking space.
    table)
  "Syntax table for `info'.")

(defvar Info-merged-map nil "Keymap for merged Info buffer.")
(if Info-merged-map
    nil
  (setq Info-merged-map  (make-keymap))
  (suppress-keymap Info-merged-map)
  (define-key Info-merged-map "." 'beginning-of-buffer)
  (define-key Info-merged-map "\t" 'Info-next-reference)
  (define-key Info-merged-map "\e\t" 'Info-prev-reference)
  (define-key Info-merged-map "b" 'beginning-of-buffer)
  (define-key Info-merged-map "q" 'quit-window)
  (define-key Info-merged-map "s" 'nonincremental-re-search-forward)
  (define-key Info-merged-map "\M-s" 'nonincremental-re-search-forward))

(defvar Info-no-glossary-manuals '(info efaq efaq-32 elisp eintr
                                        ada-mode ccmode idlwave
                                        octave-mode org vhdl-mode
                                        nxml-mode erc eudc
                                        emacs-gnutls gnus mh-e
                                        mairix-el message newsticker
                                        pgg rcirc sasl sc sieve tramp
                                        autotype bovine calc dired-x
                                        ede edt eieio ert eww epa
                                        ebrowse ediff eshell flymake
                                        forms htmlfontify ido pcl-cvs
                                        reftex remember ses srecode
                                        speedbar todo-mode vip viper
                                        wisent woman auth cl dbus
                                        emacs-mime smtpmail url widget)
  ;; Emacs and Semantic manuals have a glossary.
  "List of Info manuals that have no manuals.
The elements are symbols whose names can be used as string arg to
`info'.

You can set this manually, but you need not do so.  Manuals are added
automatically, when Emacs can't find a `Glossary' node in them.")

(defvar Info-breadcrumbs-depth-internal Info-breadcrumbs-depth
  "Current breadcrumbs depth for Info.")

;; Match has, inside “...”, "...", ‘...’, or `...', zero or more of these characters:
;;   - any character except ”, ", ’, or ', respectively
;;   - \ followed by any character
;;
;; The regexp matches also ‘...’, `...', “...”, and "..." where at least one of the
;; ‘, ’, `, ', “, ”, or " is escaped by a backslash.
;; So we check those cases explicitly and do not highlight them.
;;
(defvar info-quotation-regexp
  (concat
   "\"\\(?:[^\"\\]\\|\\\\\\(?:.\\|\n\\)\\)*\"\\|" ; "..."
   "`\\(?:[^']\\|\\\\\\(?:.\\|\n\\)\\)+'\\|"      ; `...'
   "‘\\(?:[^’]\\|\\\\\\(?:.\\|\n\\)\\)+’\\|"      ; ‘...’
   "“\\(?:[^”]\\|\\\\\\(?:.\\|\n\\)\\)+”"         ; “...”
   )
  "Regexp to match `...', ‘...’, “...”, \"...\".
If ... contains an end char then that char must be backslashed.")

;; (rx (or (seq ?\"
;;              (zero-or-more (or (not (any ?\" ?\\))  (seq ?\\ anything)))
;;              ?\")
;;         (seq ?\`
;;              (zero-or-more (or (not (any ?'))  (seq ?\\ anything)))
;;              ?\')
;;         (seq ?‘
;;              (zero-or-more (or (not (any ?’))  (seq ?\\ anything)))
;;              ?’)
;;         (seq ?“
;;              (zero-or-more (or (not (any ?”))  (seq ?\\ anything)))
;;              ?”)))

(defvar info-quotation-same-line-regexp
  (concat
   "\"\\(?:[^\"\\]\\|\\\\\\(?:.\\|\n\\)\\)*\"\\|" ; "..."
   "`\\(?:[^\n']\\|\\\\\\(?:.\\|\n\\)\\)+'\\|"    ; `...' on one line
   "‘\\(?:[^\n’]\\|\\\\\\(?:.\\|\n\\)\\)+’\\|"    ; ‘...’ on one line
   "“\\(?:[^\n”]\\|\\\\\\(?:.\\|\n\\)\\)+”"       ; “...” on one line
   )
  "`info-quotation-regexp', but on same line (all but \"...\").")

;; (rx (or (seq ?\"
;;              (zero-or-more (or (not (any ?\" ?\\))  (seq ?\\ anything)))
;;              ?\")
;;         (seq ?\`
;;              (one-or-more  (or (not (any ?\n ?'))   (seq ?\\ anything)))
;;              ?\')
;;         (seq ?‘
;;              (one-or-more  (or (not (any ?\n ?’))   (seq ?\\ anything)))
;;              ?’)
;;         (seq ?“
;;              (one-or-more  (or (not (any ?\n ?”))   (seq ?\\ anything)))
;;              ?”)))

(defvar info-quoted+<>-regexp
  (concat
   "\"\\(?:[^\"\\]\\|\\\\\\(?:.\\|\n\\)\\)*\"\\|"             ; "..."
   "`\\(?:[^']\\|\\\\\\(?:.\\|\n\\)\\)+'\\|"                  ; `...'
   "‘\\(?:[^’]\\|\\\\\\(?:.\\|\n\\)\\)+’\\|"                  ; ‘...’
   "“\\(?:[^”]\\|\\\\\\(?:.\\|\n\\)\\)+”\\|"                  ; “...”
   "<\\(?:[[:alpha:]][^>]*\\|\\(?:\\\\\\(?:.\\|\n\\)\\)+\\)>" ; <...>
   )
  "Same as `info-quotation-regexp', but matches also <...>.
If ... contains an end char then that char must be backslashed.")

;; (rx (or (seq ?\"
;;              (zero-or-more (or (not (any ?\" ?\\))  (seq ?\\ anything)))
;;              ?\")
;;         (seq ?\`
;;              (zero-or-more (or (not (any ?'))       (seq ?\\ anything)))
;;              ?\')
;;         (seq ?‘
;;              (zero-or-more (or (not (any ?’))       (seq ?\\ anything)))
;;              ?’)
;;         (seq ?“
;;              (zero-or-more (or (not (any ?”))       (seq ?\\ anything)))
;;              ?”)
;;         (seq ?<
;;              (or (seq (any alpha) (zero-or-more (not (any ?>))))
;;                  (zero-or-more (seq ?\\ anything)))
;;              ?>)))

(defvar info-quoted+<>-same-line-regexp
  (concat
   "\"\\(?:[^\"\\]\\|\\\\\\(?:.\\|\n\\)\\)*\"\\|"               ; "..."
   "`\\(?:[^\n']\\|\\\\\\(?:.\\|\n\\)\\)+'\\|"                  ; `...'
   "‘\\(?:[^\n’]\\|\\\\\\(?:.\\|\n\\)\\)+’\\|"                  ; ‘...’
   "“\\(?:[^\n”]\\|\\\\\\(?:.\\|\n\\)\\)+”\\|"                  ; “...”
   "<\\(?:[[:alpha:]][^\n>]*\\|\\(?:\\\\\\(?:.\\|\n\\)\\)+\\)>" ; <...>
   )
  "`info-quoted+<>-same-line-regexp', but on same line (all but \"...\").")

;; (rx (or (seq ?\"
;;              (zero-or-more (or (not (any ?\" ?\\))  (seq ?\\ anything)))
;;              ?\")
;;         (seq ?\`
;;              (one-or-more  (or (not (any ?\n ?'))   (seq ?\\ anything)))
;;              ?\')
;;         (seq ?‘
;;              (one-or-more  (or (not (any ?\n ?’))   (seq ?\\ anything)))
;;              ?’)
;;         (seq ?“
;;              (one-or-more  (or (not (any ?\n ?”))   (seq ?\\ anything)))
;;              ?”)
;;         (seq ?<
;;              (or (seq (any alpha) (zero-or-more (not (any ?\n ?>))))
;;                  (one-or-more (seq ?\\ anything)))
;;              ?>)))

(defvar info-custom-delimited-same-line-regexp "'\\(?:[^\n']\\|\\\\\\(?:.\\|\n\\)\\)+'"
  "Regexp to match text between custom delimiters.
You can use command `Info-define-custom-delimiting' (or command
`Info-toggle-fontify-custom-delimited' with `C-u') to define the
regexp.  They prompt you for the delimiters to use.

\(You can of course also let-bind this in Lisp code.\)")

(defvar info-isolated-quote-regexp "\\(.\\|\n\\)'"
  ;; Another possibility: "[^']'"
  ;; "[^`]\\(?:[^\n']\\|\\\\\\(?:.\\|\n\\)\\)*'" ; Can be way too slow in rare cases.
  "Regexp to match an isolated single-quote character.
That is, one that is not part of `...'.")

(defvar info-isolated-backquote-regexp "`\\(.\\|\n\\)"
  ;; Another possibility: "[^`]`"
  ;; OK in practice, since backquote is rarer than quote, but still, play safe as with quote.
  ;; "\\(`\\)\\(?:[^\n']\\|\\\\\\(?:.\\|\n\\)\\)*[^']"
  "Regexp to match an isolated backquote character.
That is, one that is not part of `...'.")

(defvar Info-toc-outline-map (let ((map  (make-sparse-keymap))) (set-keymap-parent map Info-mode-map))
  "Keymap for Info TOC with outlining.")

;;(@* "New Commands")
;;; New Commands -----------------------------------------------------

;; Make `Info-find-emacs-command-nodes' look for these commands in the Emacs manual.
;; In particular, don't look for command `info' in Info manual, because that has no index.
(put 'info 'info-file "emacs")
(put 'Info-goto-emacs-command-node 'info-file "emacs")
(put 'Info-goto-emacs-key-command-node 'info-file "emacs")

;;;###autoload (autoload 'Info-mouse-follow-nearest-node-new-window "info+")
(defun Info-mouse-follow-nearest-node-new-window (click)
  "Open the link at the mouse pointer in a new window."
  (interactive "e")
  (Info-mouse-follow-nearest-node click t))

;;;###autoload (autoload 'Info-follow-nearest-node-new-window "info+")
(defun Info-follow-nearest-node-new-window ()
  "Open the link near the text cursor in a new window."
  (interactive)
  (Info-follow-nearest-node t))

;;;###autoload (autoload 'Info-history-clear "info+")
(defun Info-history-clear (&optional msgp)
  "Clear Info history and reload current manual."
  (interactive (progn (unless (y-or-n-p "Clear the Info history? ") (info-user-error "OK, canceled"))
                      (list t)))
  (setq Info-history       ()
        Info-history-list  ())
  (when (derived-mode-p 'Info-mode) (revert-buffer nil t))
  (when msgp (message "Info history cleared")))

(when (fboundp 'advice-add)             ; Emacs 24.4+

  (define-minor-mode Info-persist-history-mode
      "Automatically persist the Info history in `Info-saved-history-file'."
    :init-value nil :global t :group 'Info-Plus
    (cond (Info-persist-history-mode
           (add-hook 'kill-emacs-hook 'Info-save-history-list)
           (advice-add 'Info-kill-buffer :before 'Info-save-history-list)
           (advice-add 'Info-directory :after 'Info-restore-history-list))
          (t
           (remove-hook 'kill-emacs-hook 'Info-save-history-list)
           (advice-remove 'Info-kill-buffer 'Info-save-history-list)
           (advice-remove 'Info-directory 'Info-restore-history-list))))

  )

(when (> emacs-major-version 23) ; Emacs 23 `revert-buffer' invokes a brain-dead `kill-buffer' etc.

  (defun Info-change-visited-status (start end &optional arg)
    "Change whether the nodes in the region have been visited.
If the region is not active then act on only the node at point.
No prefix arg means toggle the visited status of each node.
A non-negative prefix arg means consider the nodes visited.
A negative prefix arg means consider the nodes not visited."
    (interactive "r\nP")
    (let ((toggle   (not arg))
          (visit    (and arg  (natnump (prefix-numeric-value arg))))
          (unvisit  (and arg  (not (natnump (prefix-numeric-value arg)))))
          (opoint   (point))
          (omark    (mark))
          (active   mark-active)
          (file     (Info-find-file Info-current-file))
          node visitedp trim)
      (unless mark-active (setq start  (setq end  (point))))
      (save-excursion
        (goto-char start)
        (while (<= (point) end)
          (unless (setq node  (Info-node-name-at-point)) (Info-next-reference))
          (when (setq node  (Info-node-name-at-point))
            (save-match-data
              (string-match "\\s *\\((\\s *\\([^\t)]*\\)\\s *)\\s *\\|\\)\\(.*\\)" node)
              (setq node  (match-string 3 node))
              (setq trim  (string-match "\\s +\\'" node)))
            (when trim (setq node  (substring node 0 trim)))
            (when (or (not node)  (string= node "")) (setq node  "Top"))
            (setq visitedp  (member (list file node) Info-history-list))
            (if (and visitedp  (or toggle  unvisit))
                (setq Info-history-list  (delete (list file node) Info-history-list))
              (if (and (not visitedp)  (or toggle  visit))
                  (setq Info-history-list  (cons (list file node) Info-history-list)))))
          (when (> (forward-line 1) 0) (goto-char (point-max)))))
      (when (derived-mode-p 'Info-mode) (revert-buffer nil t))
      (when omark (set-mark omark))
      (goto-char opoint)
      (message (if toggle
                   "Node visited status toggled"
                 (format "Node visited status is now %s" (if visit 'VISITED 'UNvisited))))
      (if (not active)
          (deactivate-mark)
        (activate-mark)
        (setq deactivate-mark  nil))))

  )

;; Not bound.  Use `Info-change-visited-status' instead.
;;
;;;###autoload (autoload 'Info-make-node-unvisited "info+")
(defun Info-make-node-unvisited (node &optional msgp)
  "Reset the visited status of NODE to unvisited."
  (interactive (list (or (Info-node-name-at-point)  (Info-read-node-name "Node: " Info-current-node))
                     t))
  (let (file trim)
    (save-match-data
      (string-match "\\s *\\((\\s *\\([^\t)]*\\)\\s *)\\s *\\|\\)\\(.*\\)" node)
      (setq file  (if (= (match-beginning 1) (match-end 1)) "" (match-string 2 node))
            node  (match-string 3 node)
            trim  (string-match "\\s +\\'" file))
      (when trim (setq file  (substring file 0 trim)))
      (setq trim  (string-match "\\s +\\'" node)))
    (when trim (setq node  (substring node 0 trim)))
    (when (or (not node)  (string= node "")) (setq node  "Top"))
    (when (or (not file)  (string= file "")) (setq file  Info-current-file))
    (setq file               (Info-find-file file)
          Info-history-list  (remove (list file (substring-no-properties node)) Info-history-list))
    ;; Emacs 23 has brain-dead `kill-buffer', which is invoked by `revert-buffer' and deletes
    ;; the window/frame if dedicated.
    (when (and (> emacs-major-version 23)  (derived-mode-p 'Info-mode)) (revert-buffer nil t))
    (when msgp (message "Node %sis now unvisited"
                        (if (string= "dir" Info-current-file) ""
                          (format "`%s%s' "
                                  (if (equal file Info-current-file)
                                      ""
                                    (format "(%s) " (file-name-nondirectory file)))
                                  node))))))

;; I made this a global minor mode and turned it on by default, contrary to "the rules".
;; I did this so (a) users could easily customize it but (b) it would be on by default, otherwise.
;;
;;;###autoload (autoload 'Info-breadcrumbs-in-mode-line-mode "info+")
(define-minor-mode Info-breadcrumbs-in-mode-line-mode
    "Toggle the use of breadcrumbs in Info mode line.
With arg, show breadcrumbs iff arg is positive.
Change the default behavior by customizing option
`Info-breadcrumbs-in-mode-line-mode'."
  :init-value t :global t :group 'mode-line :group 'Info-Plus
  (if (not Info-breadcrumbs-in-mode-line-mode)
      (setq Info-breadcrumbs-depth-internal  0
            mode-line-format                 (default-value 'mode-line-format))
    (setq Info-breadcrumbs-depth-internal  Info-breadcrumbs-depth)
    (Info-insert-breadcrumbs-in-mode-line)))

;;;###autoload (autoload 'Info-toggle-breadcrumbs-in-header "info+")
(defun Info-toggle-breadcrumbs-in-header (&optional msgp)
  "Toggle option `Info-breadcrumbs-in-header-flag'.
Toggles showing breadcrumbs in the Info header (top of the node).
This means the area at the top of the node, not the separate header
line from non-nil `Info-use-header-line'."
  (interactive "p")
  (setq Info-breadcrumbs-in-header-flag  (not Info-breadcrumbs-in-header-flag))
  (when msgp (message "Showing breadcrumbs in Info header is now %s"
                      (if Info-breadcrumbs-in-header-flag "ON" "OFF"))))

(defalias 'Info-toggle-breadcrumbs-in-header-line 'Info-toggle-breadcrumbs-in-header)
(make-obsolete 'Info-toggle-breadcrumbs-in-header-line 'Info-toggle-breadcrumbs-in-header "2014/03/04")


(when (boundp 'Info-node-access-invokes-bookmark-flag) ; Emacs 24.4+

  (defun Info-toggle-node-access-invokes-bookmark (&optional msgp)
    "Toggle option `Info-node-access-invokes-bookmark-flag'."
    (interactive "p")
    (setq Info-node-access-invokes-bookmark-flag  (not Info-node-access-invokes-bookmark-flag))
    (when (eq major-mode 'Info-mode)
      (font-lock-defontify)
      (let ((modp               (buffer-modified-p))
            (inhibit-read-only  t))
        (Info-fontify-node))
      (when msgp (message "`Info-node-access-invokes-bookmark-flag' is now %s"
                          (if Info-node-access-invokes-bookmark-flag 'ON 'OFF)))))

  )

(defvar info-remap-default-face-cookie nil
  "Cookie returned by `Info-remap-default-face-to-variable-pitch'.")

;;;###autoload (autoload 'Info-remap-default-face-to-variable-pitch "info+")
(defun Info-remap-default-face-to-variable-pitch ()
  "Remap face `default' to face `variable-pitch'."
  (setq info-remap-default-face-cookie  (face-remap-add-relative 'default 'variable-pitch)))

;;;###autoload (autoload 'Info-variable-pitch-text-mode "info+")
(define-minor-mode Info-variable-pitch-text-mode
  "Use a variable-pitch font for Info text."
  :init-value nil :global t :group 'Info-Plus
  (unless (derived-mode-p 'Info-mode) (info))
  (cond (Info-variable-pitch-text-mode
         (Info-remap-default-face-to-variable-pitch))
        (info-remap-default-face-cookie
         (face-remap-remove-relative info-remap-default-face-cookie))))

;;;###autoload (autoload 'info-manual+node-buffer-name-mode "info+")
(define-minor-mode info-manual+node-buffer-name-mode
  "Name Info buffers using the Info manual (file) and node names."
  :init-value nil :global t :group 'Info-Plus
  (if (and info-buffer-name-function  info-manual+node-buffer-name-mode)
      (add-hook 'Info-selection-hook #'info-rename-buffer)
    (remove-hook 'Info-selection-hook #'info-rename-buffer)))

;;;###autoload (autoload 'info-rename-buffer "info+")
(defun info-rename-buffer (&optional msgp)
  "Rename current Info buffer, per `info-buffer-name-function'.
To do this automatically when you visit any Info buffer, use
`info-manual+node-buffer-name-mode'."
  (interactive "p")
  (when info-buffer-name-function
    (unless Info-current-file (error "This function must be invoked from Info"))
    (let* ((manual    (file-name-sans-extension (file-name-nondirectory Info-current-file)))
           (node      Info-current-node)
           (bufname   (funcall info-buffer-name-function manual node)))
      (unless (equal (buffer-name) bufname)
        (rename-buffer bufname t)
        (when msgp (message "Info buffer renamed to `%s'" bufname))))))


(when (and (require 'bookmark+ nil t) ; Emacs 24.2+ (do not bother for prior)
           (or (> emacs-major-version 24)  (and (= emacs-major-version 24)  (> emacs-minor-version 1))))

  (defun Info-set-face-for-bookmarked-xref (node)
    "Specify the face to use for Info links to bookmarked NODE.
Sets the value of bookmark tag \"bmkp-info-face\" to a face symbol you
name.

If option `Info-bookmarked-node-xref-faces' is non-nil then only the
faces in that list are available for completion, but you can enter any
face name.  If that option is nil then all faces are available for
completion.

NODE defaults to the bookmarked node named at point.  If none then you
are prompted for NODE."
    (interactive (list (or (Info-bookmark-name-at-point)  (Info-read-bookmarked-node-name))))
    (let* ((alist  (bmkp-info-alist-only))
           (bmk    (bmkp-get-bookmark-in-alist node t alist)))
      (unless bmk (error "No Info bookmark for node `%s'" node))
      (bmkp-set-tag-value bmk "bmkp-info-face"
                          (if Info-bookmarked-node-xref-faces
                              (intern (completing-read "Face: " Info-bookmarked-node-xref-faces
                                                       (lambda (ff) (memq ff (face-list)))))
                            (read-face-name "Face" 'info-xref-bookmarked)))))

  (define-key Info-mode-map (kbd "C-x f") 'Info-set-face-for-bookmarked-xref)


  (defun Info-toggle-fontify-bookmarked-xrefs (&optional msgp)
    "Toggle option `Info-fontify-bookmarked-xrefs-flag'."
    (interactive "p")
    (setq Info-fontify-bookmarked-xrefs-flag  (not Info-fontify-bookmarked-xrefs-flag))
    (when (eq major-mode 'Info-mode)
      (font-lock-defontify)
      (let ((modp               (buffer-modified-p))
            (inhibit-read-only  t))
        (Info-fontify-node))
      (when msgp (message "`Info-fontify-bookmarked-xrefs-flag' is now %s"
                          (if Info-fontify-bookmarked-xrefs-flag 'ON 'OFF)))))

  )

(defsubst info-custom-delim-1 ()
  "Beginning custom delimiter."
  (cadr Info-fontify-custom-delimited))

(defsubst info-custom-delim-2 ()
  "Ending custom delimiter."
  (car (cddr Info-fontify-custom-delimited)))

;;;###autoload (autoload 'Info-define-custom-delimiting "info+")
(defun Info-define-custom-delimiting (&optional msgp)
  "Read custom delimiter chars and set fontifying regexp from them.
You can also do this when toggling fontification of the delimited text
with command `Info-toggle-fontify-custom-delimited', by using a prefix
argument.

The default value uses ' (apostrophe) for both beginning and ending
delimiter, with the result that in '...' the ... is fontified."
  (interactive "p")
  (let ((read-fn  (if (fboundp 'read-char-from-minibuffer)
                      'read-char-from-minibuffer ; Emacs 27+
                    'read-char-exclusive)))
    (setcar (cdr Info-fontify-custom-delimited)  (funcall read-fn "Beginning delimiter (character): "
                                                          'INHERIT-INPUT-METHOD 5))
    (setcar (cddr Info-fontify-custom-delimited) (funcall read-fn "Ending delimiter (character): "
                                                          'INHERIT-INPUT-METHOD 5))
    (setq info-custom-delimited-same-line-regexp  (format "[%c]\\(?:[^\n%c]\\|\\\\\\(?:.\\|\n\\)\\)+[%c]"
                                                          (info-custom-delim-1)
                                                          (info-custom-delim-2)
                                                          (info-custom-delim-2))))
  (when msgp (message "Custom delimiters are now `%c' and `%c'" (info-custom-delim-1) (info-custom-delim-2))))

;;;###autoload (autoload 'Info-toggle-fontify-custom-delimited "info+")
(defun Info-toggle-fontify-custom-delimited (&optional newp msgp)
  "Toggle option `Info-fontify-custom-delimited'.
With a prefix arg, also set the beginning and ending delimiter chars -
you are prompted for the chars to use."
  (interactive "P\np")
  (setq Info-fontify-custom-delimited (cons (not (car Info-fontify-custom-delimited))
                                            (cdr Info-fontify-custom-delimited)))
  (when newp (call-interactively #'Info-define-custom-delimiting))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-custom-delimited' is now %s%s"
                        (if (car Info-fontify-custom-delimited) 'ON 'OFF)
                        (if newp
                            (format ", with delimiters %c and %c" (info-custom-delim-1) (info-custom-delim-2))
                          "")))))

;;;###autoload (autoload 'Info-toggle-fontify-all "info+")
(defun Info-toggle-fontify-all (&optional msgp)
  "Toggle all Info+ fontify options.
This turns all of these options off (sets them to nil), if any of them
is on, and it turns them all on, if any is off:

 Info-fontify-angle-bracketed-flag
 Info-fontify-bookmarked-xrefs-flag (if defined)
 Info-fontify-emphasis-flag
 Info-fontify-glossary-words
 Info-fontify-isolated-quote-flag
 Info-fontify-quotations
 Info-fontify-reference-items-flag
 Info-fontify-visited-nodes"
  (interactive "p")
  (let ((opts  (append '(Info-fontify-angle-bracketed-flag
                         Info-fontify-emphasis-flag
                         Info-fontify-glossary-words
                         Info-fontify-isolated-quote-flag
                         Info-fontify-quotations
                         Info-fontify-reference-items-flag
                         Info-fontify-visited-nodes)
                       (and (boundp 'Info-fontify-bookmarked-xrefs-flag)
                            '(Info-fontify-bookmarked-xrefs-flag)))))
    (if (or Info-fontify-angle-bracketed-flag
            (and (boundp 'Info-fontify-bookmarked-xrefs-flag)
                 Info-fontify-bookmarked-xrefs-flag)
            Info-fontify-emphasis-flag
            Info-fontify-glossary-words
            Info-fontify-isolated-quote-flag
            Info-fontify-quotations
            Info-fontify-reference-items-flag
            Info-fontify-visited-nodes)
        (dolist (opt  opts) (set opt nil))
      (dolist (opt  opts) (set opt t))))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "Info+ fontify options are now ALL %s"
                        (if Info-fontify-angle-bracketed-flag 'ON 'OFF)))))

;;;###autoload (autoload 'Info-toggle-fontify-angle-bracketed "info+")
(defun Info-toggle-fontify-angle-bracketed (&optional msgp)
  "Toggle option `Info-fontify-angle-bracketed-flag'."
  (interactive "p")
  (setq Info-fontify-angle-bracketed-flag  (not Info-fontify-angle-bracketed-flag))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-angle-bracketed-flag' is now %s"
                        (if Info-fontify-angle-bracketed-flag 'ON 'OFF)))))

;;;###autoload (autoload 'Info-toggle-fontify-emphasis "info+")
(defun Info-toggle-fontify-emphasis (&optional msgp)
  "Toggle option `Info-fontify-emphasis-flag'."
  (interactive "p")
  (unless info-fontify-emphasis (error "`info-fontify-emphasis' must be non-nil to use this command"))
  (setq Info-fontify-emphasis-flag  (not Info-fontify-emphasis-flag))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-emphasis-flag' is now %s"
                        (if Info-fontify-emphasis-flag 'ON 'OFF)))))

;;;###autoload (autoload 'Info-toggle-fontify-glossary-words "info+")
(defun Info-toggle-fontify-glossary-words (&optional msgp)
  "Toggle option `Info-fontify-glossary-words'."
  (interactive "p")
  (setq Info-fontify-glossary-words  (not Info-fontify-glossary-words))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-glossary-words' is now %s" (if Info-fontify-glossary-words 'ON 'OFF)))))

;;;###autoload (autoload 'Info-toggle-fontify-isolated-quote "info+")
(defun Info-toggle-fontify-isolated-quote (&optional msgp)
  "Toggle option `Info-fontify-isolated-quote-flag'."
  (interactive "p")
  (setq Info-fontify-isolated-quote-flag  (not Info-fontify-isolated-quote-flag))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-isolated-quote-flag' is now %s"
                        (if Info-fontify-isolated-quote-flag 'ON 'OFF)))))
(define-obsolete-function-alias 'Info-toggle-fontify-single-quote 'Info-toggle-fontify-isolated-quote
  "2020-10-22")

;;;###autoload (autoload 'Info-toggle-fontify-reference-items "info+")
(defun Info-toggle-fontify-reference-items (&optional msgp)
  "Toggle option `Info-fontify-reference-items-flag'."
  (interactive "p")
  (setq Info-fontify-reference-items-flag  (not Info-fontify-reference-items-flag))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-reference-items-flag' is now %s"
                        (if Info-fontify-reference-items-flag 'ON 'OFF)))))

;;;###autoload (autoload 'Info-toggle-fontify-visited-nodes "info+")
(defun Info-toggle-fontify-visited-nodes (&optional msgp)
  "Toggle option `Info-fontify-visited-nodes'."
  (interactive "p")
  (setq Info-fontify-visited-nodes  (not Info-fontify-visited-nodes))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node))
    (when msgp (message "`Info-fontify-visited-nodes' is now %s"
                        (if Info-fontify-visited-nodes 'ON 'OFF)))))

;;;###autoload (autoload 'Info-cycle-fontify-quotations "info+")
(defun Info-cycle-fontify-quotations (&optional msgp)
  "Cycle option `Info-fontify-quotations'.
The three states are off (nil), multiline (symbol `multiline'), and
same line (other non-nil value)."
  (interactive "p")
  (setq Info-fontify-quotations  (case Info-fontify-quotations
                                   ((nil)  t)
                                   ((t)    'multiline)
                                   (t      nil)))
  (when (eq major-mode 'Info-mode)
    (font-lock-defontify)
    (let ((modp               (buffer-modified-p))
          (inhibit-read-only  t))
      (Info-fontify-node)))
  (when msgp (message "`Info-fontify-quotations' is now %s" (case Info-fontify-quotations
                                                              ((nil)      'OFF)
                                                              (multiline  "on (MULTILINE too)")
                                                              (t          "on (SAME LINE only)")))))

;;;###autoload (autoload 'Info-save-current-node "info+")
(defun Info-save-current-node (&optional msgp)
  "Save name of current Info node to list `Info-saved-nodes'."
  (interactive "p")
  (unless (eq major-mode 'Info-mode) (info-user-error "You must be in Info to use this command"))
  (unless Info-current-node          (info-user-error "No current Info node"))
  (unless Info-current-file          (info-user-error "No Info file"))
  (add-to-list 'Info-saved-nodes (concat "(" (file-name-nondirectory Info-current-file) ")"
                                         Info-current-node))
  (when msgp (message (format "Node `%s' saved" Info-current-node))))

(when (require 'bookmark+ nil t)

  (defun Info-describe-bookmark (&optional node show-definition-p)
    "Describe bookmark for NODE (default: bookmarked node named at point).
With a prefix argument, show the internal definition of the bookmark.

If there is no bookmarked node named at point then you are prompted
for the name of one.

When called from Lisp, NODE is a full node name: `(MANUAL) NODE'.
That is, it corresponds to a default Info bookmark name."
    (interactive
     (list (or (Info-bookmark-name-at-point)  (Info-read-bookmarked-node-name))
           current-prefix-arg))
    (let* ((alist  (bmkp-info-alist-only))
           (bmk    (or (bmkp-get-bookmark-in-alist node t alist)
                       (bmkp-read-bookmark-for-type "Info" alist nil nil 'bmkp-info-history "Describe "))))
      (bmkp-describe-bookmark bmk show-definition-p)))

  (defun Info-read-bookmarked-node-name (&optional localp)
    "Read and return the name of a bookmarked Info node.
A bookmarked node name has the form \"(MANUAL) NODE\", referring to
NODE in MANUAL.
Optional arg LOCALP means read a node name from the current manual."
    (let* ((completion-ignore-case  t)
           (bmks                    (bmkp-remove-if-not
                                     (lambda (bmk) (string-match-p
                                               (if (and localp  Info-current-file)
                                                   (format "\\`(%s) "
                                                           (file-name-sans-extension
                                                            (file-name-nondirectory Info-current-file)))
                                                 "(\\([^)]+\\)) \\([^)]*\\)")
                                               (bmkp-bookmark-name-from-record bmk)))
                                     (bmkp-info-alist-only)))
           (bmk                     (completing-read "Bookmarked node: " bmks nil t nil 'bmkp-info-history)))
      (while (equal bmk "") (setq bmk  (completing-read "Bookmarked node: " bmks nil t nil 'bmkp-info-history)))
      bmk))

  )


;;; Support for TOC with Outline support ---------------------


;; REPLACE ORIGINAL in `outline.el':
;;
;; Changed from `defsubst' to `defun'.  See Emacs bug #28080.
;;
(defun outline-invisible-p (&optional pos)
  "Non-nil if the character after point has been made invisible by Outline."
  (eq (get-char-property (or pos (point)) 'invisible) 'outline))


(when (boundp 'Info-virtual-nodes)      ; Emacs 23.4+

  (add-to-list 'Info-virtual-nodes '("\\`\\*TOC Outline\\* (.*)\\'" (find-node . Info-toc-outline-find-node)))

  (defun Info-toc-outline (&optional arg)
    "Go to a node with a table of contents (TOC) in `outline-minor-mode'.
The TOC is created from the tree structure of Info menus.

In this node you can use the commands and menu items of
`outline-minor-mode' to navigate, hide/show, delete, or rearrange
parts of the TOC.  Start with menu-bar menu `Outline' to see what is
possible.

,* With no prefix arg:

  - If buffer `*TOC Outline* (MANUAL)' exists, where MANUAL is the
    manual/file name for the current manual, then pop to it.
  - Else create that buffer for the current manual, and pop to it.

,* With a plain prefix arg (`C-u'):

  Pop to a new TOC buffer, `*TOC Outline* (MANUAL)' (or `*TOC
  Outline*<N> (MANUAL)', N=1,2,3...), for the current MANUAL.

,* With any other prefix arg (e.g. `M--'):

  Reuse the current Info buffer, going to a node `*TOC Outline*'
  for the current manual."
    (interactive (list (if (consp current-prefix-arg) 'clone current-prefix-arg)))
    (unless (derived-mode-p 'Info-mode)   (info-user-error "You must be in Info to use this command"))
    (unless Info-current-node             (info-user-error "No current Info node"))
    (unless Info-current-file             (info-user-error "No Info file"))
    (when (equal Info-current-file "dir") (info-user-error "No TOC for Info Directory - choose a manual"))
    (if (and (not arg)  (get-buffer (format "*TOC Outline* (%s)" (file-name-nondirectory Info-current-file))))
        (pop-to-buffer (format "*TOC Outline* (%s)" (file-name-nondirectory Info-current-file)))
      (when (or (not arg)  (eq arg 'clone))
        (clone-buffer (format "*TOC Outline* (%s)" (file-name-nondirectory Info-current-file)) t))
      (Info-breadcrumbs-in-mode-line-mode -1)
      (setq mark-ring  ()) ;`clone-buffer' causes this to be needed, if `*info*' buffer has no mark.
      (Info-find-node Info-current-file (format "*TOC Outline* (%s)" (file-name-nondirectory Info-current-file)))
      (let ((prev-node  (nth 1 (car Info-history)))
            prev-posn)
        (goto-char (point-min))
        (when (setq prev-posn  (search-forward (concat "*Note " prev-node ":") nil t))
          (setq prev-posn  (- prev-posn (length prev-node) 2)))
        (goto-char (or prev-posn  (point-min))))))

  (defun Info-toc-outline-find-node (filename nodename &optional _no-going-back)
    "TOC-specific implementation of `Info-find-node-2'."
    (let* ((curr-file  (substring-no-properties (or filename Info-current-file)))
           (curr-node  (substring-no-properties (or nodename Info-current-node)))
           (node-list  (Info-toc-nodes curr-file)))
      (insert (format "\n\^_\nFile: %s,  Node: %s,  Up: Top\n\n" curr-file curr-node))
      (let ((title  (format "Contents (%s)" (file-name-nondirectory curr-file))))
        (insert title "\n" (make-string (length title) ?*) "\n\n"))
      (insert "*Note Top::\n")
      (Info-toc-insert (nth 3 (assoc "Top" node-list)) node-list 0 curr-file) ; `Top' nodes
      (unless (bobp)
        (let ((Info-hide-note-references   'hide)
              (Info-fontify-visited-nodes  nil))
          (setq Info-current-file  filename
                Info-current-node  (format "*TOC Outline* (%s)" (file-name-nondirectory curr-file)))
          (goto-char (point-min))
          (narrow-to-region (or (re-search-forward "\n[\^_\f]\n" nil t)  (point-min)) (point-max))
          (Info-fontify-node)
          (widen))))
    (set (make-local-variable 'inhibit-read-only) t)
    (goto-char (point-min))
    (search-forward "Contents" nil t)
    (forward-line 3)
    ;; If `Info-toc-outline-no-redundancy-flag' is non-nil then remove redundancies.
    ;; Else give non-links face `info-title-4'.
    (save-excursion
      (let ((note-re  "^[\t]*[*]Note "))
        (while (not (eobp))
          (if (re-search-forward note-re (line-end-position) t)
              (if (and Info-toc-outline-no-redundancy-flag ; Remove node line if already listed.
                       (let ((node  (buffer-substring-no-properties (point) (line-end-position))))
                         (save-excursion (beginning-of-line) (re-search-backward (concat note-re node) nil t))))
                  (delete-region (line-beginning-position) (line-beginning-position 2))
                (save-excursion ; Indent previous line to same column, if it was a heading.
                  (let ((col  (current-column)))
                    (forward-line -1)
                    (unless (re-search-forward note-re (line-end-position) t)
                      (insert (propertize " " 'display `(space :align-to ,col))))))
                (forward-line 1))
            (if Info-toc-outline-no-redundancy-flag
                (delete-region (line-beginning-position) (line-beginning-position 2))
              ;; The line is a section heading.  Put face `info-title-4' on it.
              (put-text-property (line-beginning-position 1) (line-end-position 1) 'face 'info-title-4)
              (unless (looking-at "\\s-") (insert "\n"))
              (forward-line 1))))))
    (outline-minor-mode 1)
    (define-key Info-toc-outline-map [remap outline-promote] 'Info-outline-promote)
    (define-key Info-toc-outline-map [remap outline-demote]  'Info-outline-demote)
    (define-key Info-toc-outline-map "\C-x\M-l" 'Info-toc-outline-refontify-region)
    (use-local-map Info-toc-outline-map)
    (setq outline-regexp  "[\t]*[*]Note ") ; Include no "^" here.
    (set (make-local-variable 'Info-hide-note-references) 'hide)
    (add-hook 'post-command-hook 'Info-toc-outline-refontify-region nil 'LOCAL)
    (buffer-enable-undo))

  (defun Info-toc-outline-refontify-region (&optional start end forcep)
    "In Info `*TOC Outline*' buffer, refontify region.
Interactively, if region is not active or is empty, refontify buffer.
From Lisp:
 ,* Do nothing if not in a `*TOC Outline* buffer or if buffer has not
   been modified.
 ,* START defaults to `point-min', END defaults to `point-max'."
    (interactive (let* ((regionp  (use-region-p))
                        (st       (if regionp (region-beginning) (point-min)))
                        (en       (if regionp (region-end) (point-max))))
                   (list st en t)))
    (setq start  (or start  (point-min))
          end    (or end    (point-max)))
    (let ((buff  (buffer-name)))
      (when (or forcep  (and buff
                             (buffer-modified-p)
                             (string-match-p "\\`\\*TOC Outline\\* ([^)]+)" buff)
                             (derived-mode-p 'Info-mode)))
        (Info-toc-outline-refontify-links start end))))

  (defun Info-outline-promote (&optional which)
    "Promote headings higher up the tree.
If `transient-mark-mode' is on and the mark is active, promote
headings in the region (from a Lisp program, pass the symbol `region'
for WHICH).
Otherwise:
 ,* With no prefix arg, promote the current heading and all headings in
   the subtree (from a Lisp program, pass symbol `subtree' for WHICH);
 ,* with a prefix arg, promote just the current heading (from a Lisp
   program, pass nil for WHICH, or do not pass any argument).

This is a version of `outline-promote' for use with Info.  It
refontifies the buffer to hide the link prefix `*Note'."
    (interactive (list (if (and transient-mark-mode  mark-active)
                           'region
                         (outline-back-to-heading)
                         (and (not current-prefix-arg)  'subtree))))
    (let (start end)
      (cond ((eq which 'region)
             (outline-map-region 'Info-outline-promote
                                 (setq start  (copy-marker (region-beginning)))
                                 (prog1 (region-end)
                                   (setq end  (save-excursion
                                                (goto-char (region-end))
                                                (copy-marker (line-end-position)))))))
            (which
             (outline-map-region 'Info-outline-promote
                                 (setq start  (copy-marker (point)))
                                 (save-excursion (outline-get-next-sibling) (setq end  (copy-marker (point))))))
            (t
             (outline-back-to-heading t)
             (setq start  (copy-marker (point))
                   end    (copy-marker (line-end-position)))
             (let* ((head     (match-string-no-properties 0))
                    (level    (save-match-data (funcall outline-level)))
                    (up-head  (or (outline-head-from-level (1- level) head)
                                  (save-excursion ; Use the parent heading, if it is really one level less.
                                    (save-match-data
                                      (outline-up-heading 1 t)
                                      (and (= (1- level)  (funcall outline-level))
                                           (match-string-no-properties 0))))
                                  (error "Cannot promote - already at highest level"))))
               (unless (rassoc level outline-heading-alist) (push (cons head level) outline-heading-alist))
               (replace-match up-head nil t))))
      (Info-toc-outline-refontify-links start end)))

  (defun Info-outline-demote (&optional which)
    "Demote headings lower down the tree.
If `transient-mark-mode' is on and the mark isactive, demote headings
in the region (from a Lisp program, pass symbol `region' for WHICH).
Otherwise:
 ,* Without a prefix arg, demote current heading and all headings in the
 subtree (from a Lisp program, pass symbol `subtree' for WHICH).
 ,* With a prefix arg, demote just the current heading (from a Lisp
 program, pass nil for WHICH, or do not pass any argument).

This is a version of `outline-demote' for use with Info.  It
refontifies the buffer to hide link prefix `*Note'."
    (interactive (list (if (and transient-mark-mode  mark-active)
                           'region
                         (outline-back-to-heading)
                         (and (not current-prefix-arg)  'subtree))))
    (let (start end)
      (cond ((eq which 'region)
             (outline-map-region 'Info-outline-demote
                                 (setq start  (copy-marker (region-beginning)))
                                 (prog1 (region-end)
                                   (setq end  (save-excursion
                                                (goto-char (region-end))
                                                (copy-marker (line-end-position)))))))
            (which
             (outline-map-region 'Info-outline-demote
                                 (setq start  (copy-marker (point)))
                                 (save-excursion (outline-get-next-sibling) (setq end  (copy-marker (point))))))
            (t
             (setq start  (copy-marker (point))
                   end    (copy-marker (line-end-position)))
             (let* ((head       (match-string-no-properties 0))
                    (level      (save-match-data (funcall outline-level)))
                    (down-head  (or (outline-head-from-level (1+ level) head)
                                    (save-excursion
                                      (save-match-data
                                        (while (and (progn (outline-next-heading) (not (eobp)))
                                                    (<= (funcall outline-level) level)))
                                        (when (eobp) ; Try again from beginning of buffer.
                                          (goto-char (point-min))
                                          (while (and (progn (outline-next-heading) (not (eobp)))
                                                      (<= (funcall outline-level) level))))
                                        (unless (eobp)
                                          (looking-at outline-regexp)
                                          (match-string-no-properties 0))))
                                    (error "Cannot demote - already at lowest level"))))
               (unless (rassoc level outline-heading-alist) (push (cons head level) outline-heading-alist))
               (replace-match down-head nil t))))
      (Info-toc-outline-refontify-links start end)))

  (defun Info-toc-outline-refontify-links (begin end)
    "Refontify TOC cross references between buffer positions BEGIN and END."
    ;; (interactive "r") ; Not really intended as a command, but might be handy sometimes (?).
    (save-excursion
      (let* ((inhibit-read-only     t)
             (case-fold-search      t)
             (fontify-bookmarked-p  (and (boundp 'Info-fontify-bookmarked-xrefs-flag)
                                         Info-fontify-bookmarked-xrefs-flag))
             (node-not-too-large    (and (or fontify-bookmarked-p  Info-fontify-visited-nodes)
                                         Info-fontify-maximum-menu-size
                                         (or (eq t Info-fontify-maximum-menu-size)
                                             (< (- (point-max) (point-min)) Info-fontify-maximum-menu-size))))
             (fontify-bookmarked-p  (and node-not-too-large  fontify-bookmarked-p))
             (fontify-visited-p     (and node-not-too-large  Info-fontify-visited-nodes))
             paragraph-markers rbeg rend)
        (goto-char begin)
        (while (re-search-forward "\\(\\*Note[ \n\t]+\\)\\([^:]*\\)\\(:[ \t]*\\([^.,:(]*\\)\\(\\(([^)]\
,*)\\)[^.,:]*\\)?[,:]?\n?\\)" end t)
          (let ((start  (match-beginning 0))
                (next   (point))
                other-tag)
            (when Info-hide-note-references
              (when (not (eq Info-hide-note-references 'hide)) ; *Note is often used where *note should have been.
                (goto-char start)
                (skip-syntax-backward " ")
                (when (memq (char-before) '(?\( ?\[ ?\{))
                  (skip-syntax-backward " (")) ; Check whether the paren is preceded by an end of sentence.
                (setq other-tag  (cond ((save-match-data (looking-back "\\<see" nil)) "")
                                       ((save-match-data (looking-back "\\<in" nil)) "")
                                       ((memq (char-before) '(nil ?\. ?! ??)) "See ")
                                       ((save-match-data (save-excursion (search-forward "\n\n" start t))) "See ")
                                       (t "see "))))
              (goto-char next)
              (add-text-properties
               (match-beginning 1)
               (or (save-match-data (let ((start1  (match-beginning 1))) ; Don't hide \n after *Note
                                      (and (string-match "\n" (match-string 1))  (+ start1 (match-beginning 0)))))
                   (match-end 1))
               (if other-tag
                   `(display ,other-tag front-sticky nil rear-nonsticky t)
                 '(invisible t front-sticky nil rear-nonsticky t))))
            (add-text-properties
             (match-beginning 2) (match-end 2)
             (list 'help-echo (if (or (match-end 5)  (not (equal (match-string 4) "")))
                                  (concat "mouse-2: go to " (or (match-string 5)  (match-string 4)))
                                "mouse-2: go to this node")
                   'mouse-face 'highlight))
            (setq rbeg  (match-beginning 2)
                  rend  (match-end 2))
            (let (node)
              (put-text-property
               rbeg
               rend
               'font-lock-face
               (if (and (or Info-fontify-visited-nodes  fontify-bookmarked-p)
                        (save-match-data
                          (setq node  (replace-regexp-in-string
                                       "^[ \t]+" ""
                                       (replace-regexp-in-string
                                        "[ \t\n]+" " "
                                        (or (match-string-no-properties 5)
                                            (and (not (equal (match-string 4) ""))
                                                 (match-string-no-properties 4))
                                            (match-string-no-properties 2)))))
                          (let* ((hl               Info-history-list)
                                 (external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                 (file             (if external-link-p
                                                       (file-name-nondirectory
                                                        (match-string-no-properties 1 node))
                                                     Info-current-file))
                                 res)
                            (when external-link-p
                              (setq node  (if (equal (match-string 2 node) "")
                                              "Top"
                                            (match-string-no-properties 2 node))))
                            (or (and fontify-bookmarked-p  (Info-bookmark-name-for-node node))
                                (progn
                                  (while hl
                                    (if (and (string-equal node (nth 1 (car hl)))
                                             (equal file (if (and external-link-p  (stringp (caar hl)))
                                                             (file-name-nondirectory (caar hl))
                                                           (caar hl))))
                                        (setq res  (car hl)
                                              hl   nil)
                                      (setq hl  (cdr hl))))
                                  res)))))
                   (let ((bmk  (and fontify-bookmarked-p  (Info-bookmark-for-node node 'LOCALP))))
                     (if bmk
                         (or (bmkp-get-tag-value bmk "bmkp-info-face")  'info-xref-bookmarked)
                       'info-xref-visited))
                 'info-xref)))
            (save-excursion ; For multiline ref, unfontify newline and surrounding whitespace
              (goto-char rbeg)
              (save-match-data (while (re-search-forward "\\s-*\n\\s-*" rend t nil)
                                 (remove-text-properties (match-beginning 0) (match-end 0) '(font-lock-face t)))))
            (when (memq Info-hide-note-references '(t hide))
              (add-text-properties (match-beginning 3) (match-end 3)
                                   '(invisible t front-sticky nil rear-nonsticky t))
              ;; Unhide the file name of the external reference in parens
              (when (and (match-string 6)  (not (eq Info-hide-note-references 'hide)))
                (remove-text-properties (match-beginning 6) (match-end 6)
                                        '(invisible t front-sticky nil rear-nonsticky t)))
              (save-match-data ; Unhide newline because hidden newlines cause too long lines
                (let ((beg3  (match-beginning 3))
                      (end3  (match-end 3)))
                  (when (and (string-match "\n[ \t]*" (match-string 3))
                             (not (save-match-data (save-excursion (goto-char (1+ end3)) (looking-at "[.)]*$")))))
                    (remove-text-properties (+ beg3 (match-beginning 0)) (+ beg3 (match-end 0))
                                            '(invisible t front-sticky nil rear-nonsticky t))))))
            (when (and Info-refill-paragraphs  Info-hide-note-references)
              (push (set-marker (make-marker) start) paragraph-markers)))))
      (goto-char (point-max))
      (skip-chars-backward "\n") ; Hide any empty lines at the end of the node.
      (when (< (1+ (point)) (point-max)) (put-text-property (1+ (point)) (point-max) 'invisible t))
      (set-buffer-modified-p nil)))

  )




;; Note: This is not super-clean code (it's kind of a hack job).
;;;###autoload (autoload 'Info-merge-subnodes "info+")
(defun Info-merge-subnodes (&optional recursive-display-p recursive-call-p)
  "Integrate current node with nodes referred to in its Menu.

Displays the current Info node, together with the nodes in its Menu.
Buffer `*Info: NODE*' is used for the display, where NODE is the name
of the current node.  The contents of this node's subnodes (the nodes
named in this node's Menu) are included in the buffer, following the
contents of the current node.

Optional arg RECURSIVE-DISPLAY-P (prefix arg if interactive) governs
the way menus of subnodes are treated:

  If nil, nothing additional happens.  Subnode menus are not explored.
  Only the current node and its immediate subnodes are documented, in
  the single display buffer `*Info: NODE*'.

  If non-nil, then the subnodes of a node are treated in the same way
  as the parent node, recursively: If any of them has, itself, a Menu,
  then that menu's subnodes are also explored, and so on.

    If RECURSIVE-DISPLAY-P is zero, then a single display buffer is
    used for all of the nodes explored.  Otherwise, a separate display
    buffer is used for each subnode that has a Menu (see next).

      Use this when you want a single, flat compilation of the current
      node and all of its subnodes.  It is less appropriate when the
      current node has several levels of subnodes: The flattened
      result can be difficult to read.

    If RECURSIVE-DISPLAY-P is positive, then the contents of each
    subnode are displayed twice: once in the parent node's display,
    and once in the subnode's own display.

      Use this when the current node has several levels of subnodes
      and you want each display buffer to be self-contained.

    If RECURSIVE-DISPLAY-P is negative, then there is no redundancy: A
    subnode's contents are only displayed in its parent's buffer.  The
    subnode's own display buffer only contains the contents of its own
    subnodes.

      Use this when the current node has several levels of subnodes
      and you want no redundancy between the display buffers.

The user option (variable) `Info-subtree-separator' is a string to be
inserted by `Info-merge-subnodes' just before the title of each
node (preceding its description).  By default it is \"\\n* \", producing
a node title resembling a menu item.  Setting this to \"\\f\\n* \" will
cause a page break before each node description.  For more on setting
this variable, type \\<Info-mode-map>`\\[describe-variable] Info-subtree-separator'.

------

Optional second arg RECURSIVE-CALL-P is only for internal use.  It is
used to indicate whether (non-nil) or not (nil) this is a recursive
\(i.e. not a top-level) call to `Info-merge-subnodes'.  Non-nil
means that this is a subnode, and that its contents should only be
included in the present display if RECURSIVE-DISPLAY-P is also
non-nil.  For proper operation when RECURSIVE-DISPLAY-P is zero, the
non-nil value of RECURSIVE-CALL-P should be the node name of the
top-level call to `Info-merge-subnodes'."
  (interactive "P")
  (when (interactive-p)
    (unless (y-or-n-p "Do you really want to integrate this node with its \
subnodes (outside Info)? ")
      (info-user-error (substitute-command-keys
                        "OK.  If you are not sure what this command is about, type \
`\\[describe-function] Info-merge-subnodes'.")))) ; Defined in `help.el'.
  (garbage-collect)
  (setq recursive-display-p  (and recursive-display-p  (prefix-numeric-value recursive-display-p)))
  (let* ((buf                        (current-buffer)) ; Info buffer
         (single-buf-p               (and recursive-display-p  (zerop recursive-display-p)))
         (infop-node-name            (or (and single-buf-p  recursive-call-p)  Info-current-node))
         (rep-buf                    (get-buffer-create (concat "*Info: " infop-node-name "*"))) ; Merge buffer.
         (more                       t)
         (inhibit-field-text-motion  t) ; Just to be sure, for `end-of-line'.
         token oldpt strg menu-item-line ind)

    (when (interactive-p)
      (message "Processing node `%s' and %ssubnodes..." infop-node-name
               (if recursive-display-p "all of its " "its immediate ")))
    (save-window-excursion
      (goto-char (point-min))
      (forward-line 1)
      (setq strg  (buffer-substring (point) (point-max))) ; Node contents.
      (goto-char (point-min))
      (setq more  (search-forward "* menu" nil t))
      (forward-line 1)

      ;; Merge buffer: Insert buffer header and main node's contents, if not recursive or
      ;;                                                              do want redundancy.
      ;;               Then insert each subnode (unless this is an Index).
      (switch-to-buffer-other-window rep-buf)
      (unless (and recursive-call-p  single-buf-p)
        (erase-buffer)
        (funcall Info-display-node-header-fn) ; Insert header.
        (insert (concat "\n\n" (and (or (not recursive-call-p) ; Top-level call.
                                        (and recursive-display-p ; Redundancy desired.
                                             (> recursive-display-p 0)))
                                    strg)))) ; Insert main node's contents.

      (unless  (string-match "\\s-*Index$" infop-node-name) ; Don't recurse down Index menus.

        ;; Insert menu items and possibly their subnodes.
        (save-excursion
          (while more

            ;; Info buffer: Get menu item token.
            (set-buffer buf)
            (end-of-line)
            (setq oldpt  (point)
                  more   (search-forward "\n* " nil t)) ; Possible next menu item.
            (unless more (goto-char (point-max)))
            (while (and (not (eobp))    ; Search for a real menu item.
                        (not (setq token  (Info-get-token ; File menu item.
                                           (point) "\\* " "\\* \\([^:]*\\)::")))
                        (not (setq token  (Info-get-token ; Nonfile menu item.
                                           (point) "\\* "
                                           "\\* [^:]*:[ \t]+\\([^\t,.\n]+\\)[\t,.\n]"))))
              (setq more  (search-forward "\n* " nil t)))
            (unless token (setq more  nil)) ; No menu item. Done.

            ;; Treat subnode (menu item).
            (when more

              ;; Merge buffer: Insert separator line.
              (set-buffer rep-buf)
              (goto-char (point-max))
              (insert Info-subtree-separator) ; Ready for next menu item.

              ;; Info buffer: Go to subnode.
              (set-buffer buf)
              (Info-goto-node token)
              (goto-char (point-min))
              (forward-line 1)
              (setq strg  (buffer-substring (point) (point-max))) ; Pick up subnode contents.

              ;; Go back to parent node and get menu-item line.
              (Info-history-back)
              (let ((inhibit-read-only  t)) ; Get untabified menu-item line, so can count
                (buffer-enable-undo) (undo-start) ; chars to underline.
                (untabify (point) (save-excursion (forward-line 1) (point)))
                (setq menu-item-line  (buffer-substring-no-properties
                                       (save-excursion (beginning-of-line) (forward-char 2) (point))
                                       (save-excursion (forward-line 1) (point))))
                (when pending-undo-list (undo-more 1)) ; Only if did something.
                (buffer-disable-undo))
              ;; Merge buffer: Insert menu-item line, underline it, and insert subnode contents.
              (set-buffer rep-buf)
              (insert menu-item-line)
              (setq ind  (1+ (length menu-item-line)))
              (while (> ind 0) (insert "=") (setq ind  (1- ind))) ; Underline menu item.
              (insert "\n")
              (put-text-property (save-excursion (forward-line -2) (point))
                                 (save-excursion (forward-line 1) (point))
                                 'font-lock-face 'info-file)
              (setq oldpt  (point))
              (insert strg)             ; Insert subnode contents.
              (indent-rigidly oldpt (point) 2)
              ;; Recursive call: Insert subnode's subnodes, if there are any.
              ;; Again, though, don't recurse down Index menus.
              (when (and recursive-display-p  (not (string-match "\\s-*Index$" token)))
                ;; Info buffer: Go back to subnode.
                ;; If it has a menu, then treat its subnodes, recursively.
                (with-current-buffer buf
                  (Info-goto-node token)
                  (when (search-forward "* menu" nil t)
                    (forward-line 1) (end-of-line)
                    (when (and (search-forward "\n* " nil t)
                               (or (Info-get-token (point) "\\* " "\\* \\([^:]*\\)::") ; file menu item
                                   (Info-get-token (point) "\\* " ; nonfile menu item
                                                   "\\* [^:]*:[ \t]+\\([^\t,.\n]+\\)[\t,.\n]")))
                      (Info-merge-subnodes recursive-display-p infop-node-name)))
                  (set-buffer buf) ; Info buffer: Go back to parent node.
                  (Info-history-back)))
              (set-buffer buf))))))     ; Info buffer
    ;; Merge buffer
    (switch-to-buffer-other-window rep-buf)
    (when (and (one-window-p t)  (not (window-minibuffer-p)) (fboundp 'fit-frame) ; Defined in `fit-frame.el'.
               Info-fit-frame-flag)
      (fit-frame))
    (goto-char (point-min))
    (set-buffer-modified-p nil)
    (use-local-map Info-merged-map)
    (when (interactive-p)
      (message "Processing node `%s' and %ssubnodes... done" infop-node-name
               (if recursive-display-p "all of its " "its immediate ")))))

;;;###autoload (autoload 'Info-virtual-book "info+")
(defun Info-virtual-book (book nodes &optional include-bookmark-nodes-p)
  "Open a virtual Info BOOK, with a menu of Info NODES.
BOOK is a string naming the virtual book.
NODES is a list of strings naming Info nodes.
  Each node name is normally absolute, that is, a
  filename-plus-nodename string such as \"(emacs)Basic\".  But if you
  call this command from an Info buffer, then a node name can be
  relative, such as \"Basic\".
Non-nil optional arg INCLUDE-BOOKMARK-NODES-P means that all Info
nodes recorded as bookmarks are included in the virtual book.

Interactively, you are prompted for the name of the virtual book, and
the nodes are those in `Info-saved-nodes'.

Interactively, a prefix argument says to include Info nodes recorded
as bookmarks.

In addition to creating a virtual book by customizing option
`Info-saved-nodes', you can add nodes to that option (and thus to the
virtual book) using \\<Info-mode-map>`\\[Info-save-current-node]' (`Info-save-current-node')."
  (interactive (list (read-from-minibuffer "Virtual book name: " nil nil nil nil "Virtual Book")
                     Info-saved-nodes
                     current-prefix-arg))
  (unless nodes (setq nodes  Info-saved-nodes))
  (when include-bookmark-nodes-p
    (unless (require 'bookmark+ nil t) (require 'bookmark nil t))
    (bookmark-maybe-load-default-file)
    (let ((bm-nodes  ())
          node file)
      (dolist (bm  bookmark-alist)
        (when (setq node  (cdr (assq 'info-node bm)))
          (setq file  (bookmark-get-filename bm))
          (push (concat "(" (file-name-nondirectory (cdr (assq 'filename bm))) ")" node) bm-nodes)))
      (setq nodes  (append nodes bm-nodes))))
  (unless (and nodes  (stringp (car nodes))) ; Minimal sanity check.
    (info-user-error (if (interactive-p) "No saved Info nodes" "No Info nodes")))
  (unless (stringp book) (setq book  "Virtual Book")) ; Non-interactive - NODESET is a list.
  (let ((file  (and (stringp Info-current-file)  (concat "(" (file-name-nondirectory Info-current-file) ")"))))
    (with-current-buffer (get-buffer-create " *info-toc*")
      (let ((inhibit-read-only  t)
            sans-file filep)
        (erase-buffer)
        (goto-char (point-min))
        (insert "\n\^_\nFile: toc,  Node: Top,  Up: (dir)\n\n")
        (insert book "\n" (make-string (length book) ?*) "\n\n")
        (insert "* Menu:\n\n")
        (while nodes
          (if (setq filep  (string-match "^([^)]+)" (car nodes)))
              (setq sans-file  (substring (car nodes) (match-end 0)))
            (setq sans-file  (car nodes)))
          ;; (insert "* " sans-file ": " (car nodes) ".\n")
          (insert "* " sans-file ": "
                  (concat (and (not filep)  (or file  "(**INFO FILE UNKNOWN**)")) (car nodes))
                  ".\n")
          (setq nodes  (cdr nodes))))
      (unless (bobp)
        (let ((Info-hide-note-references   'hide)
              (Info-fontify-visited-nodes  nil))
          (Info-mode)
          (setq Info-current-file  'toc Info-current-node "Top")
          (goto-char (point-min))
          (narrow-to-region (or (re-search-forward "\n[\^_\f]\n" nil t)  (point-min)) (point-max))
          (Info-fontify-node)
          (widen)))))
  (info)
  (Info-find-node 'toc "Top"))

;;;###autoload (autoload 'Info-goto-node-web "info+")
(defun Info-goto-node-web (node &optional flip-new-win)
  "Use `browse-url' to go to Info node NODE using a Web browser.
With a prefix arg, reverse the effect of option
`browse-url-new-window-flag'.

NODE is the name of a node in the GNU Emacs or Elisp manual.
Alternatively, NODE can have the form (MANUAL)NODE, where MANUAL is
\"emacs\" or \"elisp\" and NODE is the name of the node in that
manual.  Empty NODE in (MANUAL) defaults to the `Top' node."
  (interactive (list (Info-read-node-name "Go to node: " Info-current-node) current-prefix-arg))
  (require 'browse-url)
  (unless Info-current-file (error "This command must be invoked from Info"))
  (browse-url (Info-url-for-node node) (list (if flip-new-win
                                                 (not browse-url-new-window-flag)
                                               browse-url-new-window-flag))))

;; See https://www.gnu.org/software/texinfo/manual/texinfo/html_node/
;;             HTML-Xref-Node-Name-Expansion.html
;;
;; 1. The standard ASCII letters (a-z and A-Z) are not modified. All
;;    other characters may be changed as specified below.
;;
;; 2. The standard ASCII numbers (0-9) are not modified except when a
;;    number is the first character of the node name. In that case, see
;;    below.
;;
;; 3. Multiple consecutive space, tab and newline characters are
;;    transformed into just one space. (It’s not possible to have
;;    newlines in node names with the current implementation, but we
;;    specify it anyway, just in case.)
;;
;; 4. Leading and trailing spaces are removed.
;;
;; 5. After the above has been applied, each remaining space character is
;;    converted into a ‘-’ character.
;;
;; 6. Other ASCII 7-bit characters are transformed into ‘_00xx’, where xx
;;    is the ASCII character code in (lowercase) hexadecimal. This includes
;;    ‘_’, which is mapped to ‘_005f’.
;;
;; 7. If the node name does not begin with a letter, the literal string
;;    ‘g_t’ is prefixed to the result. (Due to the rules above, that
;;    string can never occur otherwise; it is an arbitrary choice,
;;    standing for “GNU Texinfo”.) This is necessary because XHTML
;;    requires that identifiers begin with a letter.
;;
;;;###autoload (autoload 'Info-url-for-node "info+")
(defun Info-url-for-node (node)
  "Return a URL for NODE, a node in the GNU Emacs or Elisp manual.
Alternatively, NODE can have the form (MANUAL)NODE, where MANUAL is
\"emacs\" or \"elisp\" and NODE is the name of the node in that
manual.  Empty NODE in (MANUAL) defaults to the `Top' node."
  (interactive (list (Info-read-node-name "Node: " Info-current-node)))
  (unless Info-current-file (error "This command must be invoked from Info"))
  (let (file url)
    (string-match "\\s *\\((\\s *\\([^\t)]*\\)\\s *)\\s *\\|\\)\\(.*\\)" node)
    (setq file  (if (= (match-beginning 1) (match-end 1)) "" (match-string 2 node))
          node  (match-string 3 node))
    (when (equal node "") (setq node  "index")) ; `Top' node.
    (let ((trim  (string-match "\\s +\\'" file)))
      (when trim (setq file (substring file 0 trim))))
    (let ((trim  (string-match "\\s +\\'" node)))
      (when trim (setq node (substring node 0 trim))))
    (when (equal file "") (setq file  Info-current-file))
    (setq file  (file-name-sans-extension (file-name-nondirectory file)))
    (unless (member file '("emacs" "elisp"))
      (error "Manual cannot be `%s'; it can only be `emacs' or `elisp'" file))
    (setq node  (mapconcat (lambda (ch)
                             (if (or (< ch 32) ; ^@^A-^Z^[^\^]^^^-
                                     (and (<= 33 ch)   (<= ch 47)) ; !"#$%&'()*+,-./
                                     (and (<= 58 ch)   (<= ch 64)) ; :;<=>?@
                                     (and (<= 91 ch)   (<= ch 96)) ; [\]_`
                                     (and (<= 123 ch)  (<= ch 127))) ; {|}~ DEL
                                 (format "_00%x" ch)
                               (char-to-string ch)))
                           node
                           ""))
    (setq node  (replace-regexp-in-string "[ \t]+" "-" node t t))
    (unless (string-match-p "[[:alpha:]]" node) (setq node  (concat "g_t" node)))
    (setq url  (concat "https://www.gnu.org/software/emacs/manual/html_node/"
                       file "/" node ".html"))
    (message "URL: %s" url)
    url))

;;;###autoload (autoload 'info-manual "info+")
(defun info-manual (arg) ; Bound to `C-h r' globally (replaces `info-emacs-manual').
  "Display a manual in Info mode - by default, the Emacs manual.
With a prefix arg, prompt for the manual name.
With a numeric prefix arg, only currently visited manuals are
candidates."
  (interactive "P")
  (if arg
      (let ((current-prefix-arg  (numberp arg))) (call-interactively #'info-display-manual))
    (info "emacs")))

(global-set-key [remap info-emacs-manual] 'info-manual) ; `C-h r'



(easy-menu-define
    Info-merged-menu Info-merged-map
  "Menu for merged `info' buffers."
  '("Info"
    ["Next Link" Info-next-reference t]
    ["Previous Link" Info-prev-reference t]
    ["Search (regexp)" Info-search t]
    ["Quit" quit-window t]))

(easy-menu-define
  Info-mode-menu Info-mode-map
  "Menu for Info files."
  '("Info"
    ("Index"
     ["Find with Index..." Info-index :help "Look for a string in the index"]
     ["Find Again with Index" Info-index-next
      :active Info-index-alternatives :help "Look for string again in index"]
     ["Find In All Indexes..." info-apropos :help "Look for a string in the indexes of all manuals"]
     ["Virtual Index..." Info-virtual-index
      :visible (fboundp 'Info-virtual-index) :help "Open virtual index matching input pattern"])
    ("Search"
     ["Incrementally..." isearch-forward :help "Search incrementally (`C-r': backward)"]
     ["Incrementally...(Regexp)" isearch-forward-regexp
      :help "Search for regular expression incrementally (`C-M-r': backward)"]
     ["Non-incrementally...(Regexp)" Info-search :help "Search nonincrementally for regular expression"]
     ["  Again" Info-search-next :help "Search nonincrementally for another occurrence"]
     ["Non-incrementally Case-Sensitively..." Info-search-case-sensitively
      :help "Search nonincrementally and case sensitively for regular expression"]
     ["  Again" Info-search-case-sensitively-next
      :help "Search nonincrementally and case sensitively for another occurrence"])
    ("History"
     ["Back (History)" Info-history-back
      :active Info-history :help "Go back in history to the last node you were at"]
     ["Forward (History)" Info-history-forward :active Info-history-forward :help "Go forward in history"]
     ["History List" Info-history :active Info-history-list :help "Go to menu of visited nodes"])
    ("Navigation"
     ("Menu Item" ["You should never see this" report-emacs-bug t])
     ("Reference" ["You should never see this" report-emacs-bug t])
     ["Top" Info-directory :help "Go to the list of manuals (Info top level)"]
     ["Up" Info-up :active (Info-check-pointer "up") :help "Go up in the Info tree"]
     ["Next" Info-next :active (Info-check-pointer "next") :help "Go to the next node"]
     ["Previous" Info-prev :active (Info-check-pointer "prev[ious]*") :help "Go to the previous node"]
     ["Go to Node..." Info-goto-node :help "Go to a named node"]
     ["Go to Node on Web..." Info-goto-node-web :help "Go to a named node on the Web (HTML doc)"]

     "--"
     ["Forward" Info-forward-node :help "Go forward one node, considering all as a sequence"]
     ["Backward" Info-backward-node :help "Go backward one node, considering all as a sequence"]
     ["First in File" Info-top-node :help "Go to top node of file"]
     ["Last in File" Info-final-node :help "Go to final node in this file"]
     ["Beginning of This Node" beginning-of-buffer :help "Go to beginning of this node"])
    ("Toggle/Cycle"
     ["Highlighting All" Info-toggle-fontify-all
      :help "Toggle all Info+ fontify options"]
     ["Highlighting ‘...’ or `...', and \"...\"" Info-cycle-fontify-quotations
      :help "Cycle option `Info-fontify-quotations'"]
     ["Highlighting <...>" Info-toggle-fontify-angle-bracketed
      :style toggle :selected Info-fontify-angle-bracketed-flag
      :help "Toggle option `Info-fontify-angle-bracketed-flag'"]
     ["Highlighting Isolated ' and `" Info-toggle-fontify-isolated-quote
      :style toggle :selected Info-fontify-isolated-quote-flag
      :help "Toggle option `Info-fontify-isolated-quote-flag'"]
     ["Highlighting Glossary Words" Info-toggle-fontify-glossary-words
      :style toggle :selected Info-fontify-glossary-words
      :help "Toggle option `Info-fontify-glossary-words'"]
     ["Highlighting Reference Items" Info-toggle-fontify-reference-items
      :style toggle :selected Info-fontify-reference-items-flag
      :help "Toggle option `Info-fontify-reference-items-flag'"]
     ["Highlighting _..._ (emphasis)" Info-toggle-fontify-emphasis
      :visible info-fontify-emphasis :style toggle :selected Info-fontify-emphasis-flag
      :help "Toggle option `Info-fontify-emphasis-flag'"]
     ["Highlighting Custom Delimited" Info-toggle-fontify-custom-delimited
      :style toggle :selected (car Info-fontify-custom-delimited)
      :help "Toggle option `Info-fontify-custom-delimited'"]
     ["     Set Custom Delimiters" Info-define-custom-delimiting
      ;; < Emacs 27, doesn't work if menu used with mouse, because first read is swallowed by mouse event.
      :visible (fboundp 'read-char-from-minibuffer)
      :help "Read custom delimiter chars and set fontifying regexp from them."]
     ["Highlighting Visited Nodes" Info-toggle-fontify-visited-nodes
      :style toggle :selected Info-fontify-visited-nodes
      :help "Toggle option `Info-fontify-visited-nodes'"]
     ["Highlighting Bookmarked Links" Info-toggle-fontify-bookmarked-xrefs
      :style toggle :selected (and (boundp 'Info-fontify-bookmarked-xrefs-flag)
                                   Info-fontify-bookmarked-xrefs-flag)
      :visible (fboundp 'Info-toggle-fontify-bookmarked-xrefs)
      :help "Toggle option `Info-fontify-bookmarked-xrefs-flag'"]
     ["Bookmark Access On Visit" Info-toggle-node-access-invokes-bookmark
      :style toggle :selected (and (boundp 'Info-node-access-invokes-bookmark-flag)
                                   Info-node-access-invokes-bookmark-flag)
      :visible (fboundp 'Info-toggle-node-access-invokes-bookmark)
      :help "Toggle option `Info-node-access-invokes-bookmark-flag'"]
     ["Breadcrumbs in Mode Line" Info-breadcrumbs-in-mode-line-mode
      :style toggle :selected Info-breadcrumbs-in-mode-line-mode
      :help "Toggle showing breadcrumbs in the mode line"]
     ["Breadcrumbs in Node Header" Info-toggle-breadcrumbs-in-header
      :style toggle :selected Info-breadcrumbs-in-header-flag
      :help "Toggle showing breadcrumbs in the node header"])
    ["Table of Contents (TOC)" Info-toc :help "Go to table of contents"]
    ["Editable Outline TOC" Info-toc-outline :help "Go to editable table of contents with outline support"]
    ["Virtual Book" Info-virtual-book :help "Open table of contents of a virtual book" :active Info-saved-nodes]
    ["Save Current Node" Info-save-current-node :help "Save current node name for virtual book"]
    "--"
    ["Clone Info Buffer" clone-buffer :help "Create a twin copy of the current Info buffer."]
    ["Copy Node Name" Info-copy-current-node-name :help "Copy the name of the current node into the kill ring"]
    ["Merge Subnodes" Info-merge-subnodes :help "Integrate current node with nodes referred to in its Menu"]
    "--"
    ["Quit Info" Info-exit :help "Exit from Info"]))

;;(@* "Replacements for Existing Functions")
;;; Replacements for Existing Functions -------------------------------


;; REPLACE ORIGINAL in `info.el':
;;
;; Added prefix arg.
;;
(defadvice Info-history (around clear-info-hist-with-prefix-arg first (&optional clearp) activate)
  "With a prefix arg, clear the history instead, upon confirmation."
  (interactive "P")
  (if (not (ad-get-arg 0))
      ad-do-it
    (when (equal "*History*" Info-current-file) (Info-up))
    (call-interactively #'Info-history-clear)))


;; REPLACE ORIGINAL in `info.el':
;;
;; Respect option `Info-node-access-invokes-bookmark-flag'.
;;
(when (boundp 'Info-node-access-invokes-bookmark-flag) ; Emacs 24.4+

  (defadvice Info-goto-node (around bmkp-invoke-Info-bookmark activate)
    "Respect option `Info-node-access-invokes-bookmark-flag'.
If the option is non-nil then a bookmark for the node is invoked when
the node is visited, provided that the bookmark name has the default
form: `(MANUAL) NODE' (e.g.,`(emacs) Modes')."
    (if Info-node-access-invokes-bookmark-flag
        (let ((node  (ad-get-arg 0)))
          (if (member node (Info-index-nodes))
              ad-do-it
            (let ((bmk  (and Info-node-access-invokes-bookmark-flag  (Info-bookmark-for-node node))))
              (if bmk
                  (let ((Info-node-access-invokes-bookmark-flag  nil)) (bookmark--jump-via bmk 'ignore))
                ad-do-it))))
      ad-do-it))

  )


;; REPLACE ORIGINAL in `info.el':
;;
;; Added optional arg DEFAULT.
;;
(defun Info-read-node-name (prompt &optional default)
  (let* ((completion-ignore-case           t)
         (Info-read-node-completion-table  (Info-build-node-completions))
         (nodename                         (completing-read
                                            prompt 'Info-read-node-name-1 nil t nil
                                            'Info-minibuf-history default)))
    (if (equal nodename "")
        (or default  (Info-read-node-name prompt))
      nodename)))


;; REPLACE ORIGINAL in `info.el':
;;
;; Added optional arg LITERALP.  Use apropos matching, not literal-string matching, by default.
;; Prefix arg matches literally.  Use other window, unless already in Info.
;;
(defun info-apropos (pattern &optional literalp)
  "Search indexes of all known Info files on your system for apropos PATTERN.
Build a menu of the possible matches.

With a prefix arg, match PATTERN as a literal string, not as a regexp
or keywords.

Just as for commands such as `apropos', PATTERN can be a word, a list
of words (separated by spaces), or a regexp (using some regexp special
characters).  If it is a word, search for matches for that word as a
substring.  If it is a list of words, search for matches for any
two (or more) of those words."
  (interactive (list (apropos-read-pattern "index entries") current-prefix-arg))
  (apropos-parse-pattern pattern)
  (if (equal apropos-regexp "")
      (Info-find-node Info-apropos-file "Top")
    (let ((nodes  Info-apropos-nodes)
          nodename)
      (while (and nodes  (not (string-match apropos-regexp (nth 1 (car nodes)))))
        (setq nodes  (cdr nodes)))
      ;; Use another window, if not already in Info.
      (unless (eq major-mode 'Info-mode) (pop-to-buffer "*info*"))
      (if nodes
          (Info-find-node Info-apropos-file (caar nodes))
        (setq nodename  (format "Index for ‘%s’" apropos-regexp))
        (push (list nodename
                    apropos-regexp
                    (Info-apropos-matches apropos-regexp (and (not literalp) 'REGEXP)))
              Info-apropos-nodes)
        (Info-find-node Info-apropos-file nodename)))))


;; REPLACE ORIGINAL in `info.el':
;;
;; Added optional arg REGEXP-P.
;;
(defun Info-apropos-matches (string &optional regexp-p)
  "Collect STRING matches from all known Info files on your system.
Return a list of matches where each element is in the format
\((FILENAME INDEXTEXT NODENAME LINENUMBER)).

Non-nil optional REGEXP-P means interpret STRING as a regexp, instead
of trying to match it literally."
  ;; Emacs 23 has an `interactive' spec here, for no reason.
  (unless (string= string "")
    (let ((pattern       (format "\n\\* +\\([^\n]*\\(%s\\)[^\n]*\\):[ \t]+\
\\([^\n]+\\)\\.\\(?:[ \t\n]*(line +\\([0-9]+\\))\\)?"
                                 (if regexp-p string (regexp-quote string))))
          (ohist         Info-history)
          (ohist-list    Info-history-list)
          (current-node  Info-current-node)
          (current-file  Info-current-file)
          manuals matches node nodes)
      (let ((Info-fontify-maximum-menu-size  nil))
        (Info-directory)
        ;; `current-node' and `current-file' are nil if you invoke `info-apropos' as the first Info command.
        ;; (`info-apropos' loads `info.el'.)
        ;; In that case, use `(DIR)Top', to avoid an error after search is complete.
        (unless current-node (setq current-file  Info-current-file
                                   current-node  Info-current-node))
        (message "Searching indices...")
        (goto-char (point-min))
        (re-search-forward "\\* Menu: *\n" nil t)
        (while (re-search-forward "\\*.*: *(\\([^)]+\\))" nil t)
          (add-to-list 'manuals (match-string 1))) ; Ensure no duplicates in MANUALS, so the `dolist' runs faster.
        (dolist (manual  (nreverse manuals))
          (message "Searching %s" manual)
          (condition-case err
              (if (setq nodes  (Info-index-nodes (Info-find-file manual)))
                  (save-excursion
                    (Info-find-node manual (car nodes))
                    (while
                        (progn
                          (goto-char (point-min))
                          (while (re-search-forward pattern nil t)
                            (let ((entry     (match-string-no-properties 1))
                                  (nodename  (match-string-no-properties 3))
                                  (line      (match-string-no-properties 4)))
                              (add-text-properties
                               (- (match-beginning 2) (match-beginning 1))
                               (- (match-end 2) (match-beginning 1))
                               '(face info-index-match) entry)
                              (setq matches  (cons (list manual entry nodename line)
                                                   matches))))
                          (setq nodes  (cdr nodes)
                                node   (car nodes)))
                      (Info-goto-node node))))
            (error (message "%s" (if (eq (car-safe err) 'error) (nth 1 err) err))
                   (sit-for 1 t)))))
      (Info-find-node current-file current-node)
      (setq Info-history       ohist
            Info-history-list  ohist-list)
      (message "Searching indices...done")
      (or (nreverse matches)  t))))


;; REPLACE ORIGINAL in `info.el':
;;
;; Added final clause to `cond', to handle virtual books.  (Emacs 23.2+)
;;
(when (or (> emacs-major-version 23)  (and (= emacs-major-version 23)  (> emacs-minor-version 1)))

  (defun Info-find-file (filename &optional noerror)
    "Return expanded FILENAME, or t if FILENAME is \"dir\".
Optional second argument NOERROR, if t, means if file is not found
just return nil (no error)."
    ;; Convert filename to lower case if not found as specified.
    ;; Expand it.
    (cond
      ((Info-virtual-call (Info-virtual-fun 'find-file filename nil) filename noerror))
      ((stringp filename)
       (let (temp temp-downcase found)
         (setq filename  (substitute-in-file-name filename))
         (let ((dirs  (if (string-match "^\\./" filename)
                          '("./") ; If specified name starts with `./' then just try current dir.
                        (if (file-name-absolute-p filename)
                            '(nil) ; No point in searching for an absolute file name
                          (if Info-additional-directory-list
                              (append Info-directory-list Info-additional-directory-list)
                            Info-directory-list)))))
           ;; Fall back on the installation directory if we can't find the info node anywhere else.
           (when installation-directory
             (setq dirs  (append dirs (list (expand-file-name "info" installation-directory)))))
           ;; Search the directory list for file FILENAME.
           (while (and dirs  (not found))
             (setq temp           (expand-file-name filename (car dirs))
                   temp-downcase  (expand-file-name (downcase filename) (car dirs)))
             ;; Try several variants of specified name.
             (let ((suffix-list  Info-suffix-list)
                   (lfn          (if (fboundp 'msdos-long-file-names) (msdos-long-file-names) t)))
               (while (and suffix-list  (not found))
                 (cond ((info-file-exists-p (info-insert-file-contents-1 temp (car (car suffix-list)) lfn))
                        (setq found  temp))
                       ((info-file-exists-p (info-insert-file-contents-1 temp-downcase (car (car suffix-list))
                                                                         lfn))
                        (setq found  temp-downcase))
                       ((and (fboundp 'msdos-long-file-names)
                             lfn
                             (info-file-exists-p (info-insert-file-contents-1 temp (car (car suffix-list))
                                                                              nil)))
                        (setq found  temp)))
                 (setq suffix-list  (cdr suffix-list))))
             (setq dirs  (cdr dirs))))
         (if found
             (setq filename  found)
           (if noerror
               (setq filename  nil)
             (unless Info-current-file (Info-directory)) ; If no previous Info file, go to directory.
             (info-user-error "Info file `%s' does not exist" filename)))
         filename))
      ((member filename '(apropos history toc))  filename))) ; Handle virtual books - `toc'.
  )


;; REPLACE ORIGINAL in `info.el':
;;
;; Added optional arg NOMSG.
;;
(defun Info-find-node (filename nodename &optional no-going-back strict-case nomsg)
  "Go to an Info node specified as separate FILENAME and NODENAME.
NO-GOING-BACK is non-nil if recovering from an error in this function;
it says do not attempt further (recursive) error recovery.

Look first for a case-sensitive match for NODENAME.  If none is found
then try a case-insensitive match, unless STRICT-CASE is non-nil.

Non-nil NOMSG means do not show a status message."
  (info-initialize)
  (setq filename  (Info-find-file filename))
  ;; Go into Info buffer.
  (or (eq major-mode 'Info-mode)  (Info--pop-to-buffer-same-window "*info*"))
  ;; Record the node we are leaving, if we were in one.
  (and (not no-going-back)
       Info-current-file
       (push (list Info-current-file Info-current-node (point)) Info-history))
  (Info-find-node-2 filename nodename no-going-back strict-case nomsg))


;; REPLACE ORIGINAL in `info.el':
;;
;; 1. Added optional arg NOMSG.
;; 2. Call `fit-frame' if `Info-fit-frame-flag'.
;; 3. If `Info-fontify-glossary-words' and NODENAME is `Glossary' then create glossary-words hash table.
;;
(defun Info-find-node-2 (filename nodename &optional no-going-back strict-case nomsg)
  "Helper for `Info-find-node'.
\(Same arguments.)"
  (buffer-disable-undo (current-buffer))
  (or (eq major-mode 'Info-mode)  (Info-mode))
  (widen)
  (setq Info-current-node  nil)
  (unwind-protect
      (let ((case-fold-search  t)
            (virtual-fun       (and (fboundp 'Info-virtual-fun) ; Emacs 23.2.
                                    (Info-virtual-fun 'find-node (or filename  Info-current-file) nodename)))
            anchorpos)
        (cond ((functionp virtual-fun)
               (let ((filename  (or filename  Info-current-file)))
                 (setq buffer-read-only               nil
                       Info-current-file              filename
                       Info-current-subfile           nil
                       Info-current-file-completions  ()
                       buffer-file-name               nil)
                 (erase-buffer)
                 (Info-virtual-call virtual-fun filename nodename no-going-back)
                 (set-marker Info-tag-table-marker nil)
                 (setq buffer-read-only  t)
                 (set-buffer-modified-p nil)
                 (if (> emacs-major-version 24)
                     (setq Info-current-node-virtual  t)
                   (set (make-local-variable 'Info-current-node-virtual) t))))
              ((not (and (or (not (boundp 'Info-current-node-virtual))  (not Info-current-node-virtual))
                         (or (null filename)  (equal Info-current-file filename))))
               ;; Switch files if necessary
               (let ((inhibit-read-only  t))
                 (when (and (boundp 'Info-current-node-virtual)  Info-current-node-virtual)
                   ;; When moving from a virtual node.
                   (if (> emacs-major-version 24)
                       (setq Info-current-node-virtual  nil)
                     (set (make-local-variable 'Info-current-node-virtual) nil))
                   (unless filename (setq filename  Info-current-file)))
                 (setq Info-current-file              nil
                       Info-current-subfile           nil
                       Info-current-file-completions  ()
                       buffer-file-name               nil)
                 (erase-buffer)
                 ;; Erase any memory of the previous coding-system, so that `info-insert-file-contents' sets the
                 ;; buffer's encoding to what the Info file specifies.
                 (set-buffer-file-coding-system 'undecided t)
                 (cond ((eq filename t)        (Info-insert-dir nomsg))
                       ((eq filename 'apropos) (insert-buffer-substring " *info-apropos*"))
                       ((eq filename 'history) (insert-buffer-substring " *info-history*"))
                       ((eq filename 'toc)     (insert-buffer-substring " *info-toc*"))
                       (t (info-insert-file-contents filename nil)
                          (setq default-directory  (file-name-directory filename))))
                 (set-buffer-modified-p nil)
                 (if (> emacs-major-version 24)
                     (setq Info-file-supports-index-cookies  (Info-file-supports-index-cookies filename))
                   (set (make-local-variable 'Info-file-supports-index-cookies)
                        (Info-file-supports-index-cookies filename)))
                 ;; See whether file has a tag table.  Record the location if yes.
                 (goto-char (point-max))
                 (forward-line -8)
                 ;; Use string-equal, not equal, to ignore text props.
                 (if (not (or (string-equal nodename "*")
                              (not (search-forward "\^_\nEnd tag table\n" nil t))))
                     (let (pos)
                       ;; We have a tag table.  Find its beginning.  Is this an indirect file?
                       (search-backward "\nTag table:\n")
                       (setq pos  (point))
                       (if (save-excursion (forward-line 2) (looking-at "(Indirect)\n"))
                           ;; It is indirect.
                           ;; Copy it to another buffer and record that the tag table is in that buffer.
                           (let ((buf     (current-buffer))
                                 (tagbuf  (or Info-tag-table-buffer
                                              (generate-new-buffer " *info tag table*"))))
                             (setq Info-tag-table-buffer  tagbuf)
                             (with-current-buffer tagbuf
                               (buffer-disable-undo (current-buffer))
                               (setq case-fold-search  t)
                               (erase-buffer)
                               (insert-buffer-substring buf))
                             (set-marker Info-tag-table-marker (match-end 0) tagbuf))
                         (set-marker Info-tag-table-marker pos)))
                   (set-marker Info-tag-table-marker nil))
                 (setq Info-current-file  filename))))
        (if (string-equal nodename "*") ; Use `string-equal', not `equal', to ignore text props.
            (progn (setq Info-current-node  nodename) (Info-set-mode-line))
          ;; Possibilities:
          ;;
          ;; 1. Anchor found in tag table
          ;; 2. Anchor *not* in tag table
          ;;
          ;; 3. Node found in tag table
          ;; 4. Node *not* found in tag table, but found in file
          ;; 5. Node *not* in tag table, and *not* in file
          ;;
          ;; *Or* the same, but in an indirect subfile.
          ;;
          ;;
          ;; Search file for a suitable node.
          (let ((guesspos  (point-min))
                (regexp    (concat "\\(Node:\\|Ref:\\) *\\("  (if (stringp nodename) (regexp-quote nodename) "")
                                   "\\) *[,\t\n\177]")))
            (catch 'foo
              ;; First, search a tag table, if any
              (when (marker-position Info-tag-table-marker)
                (let* ((m      Info-tag-table-marker)
                       (found  (if (or (> emacs-major-version 24) ; Emacs 24.4+
                                       (and (= emacs-major-version 24)  (> emacs-minor-version 3)))
                                   (Info-find-in-tag-table m regexp strict-case)
                                 (Info-find-in-tag-table m regexp))))
                  (when found           ; FOUND is (ANCHOR POS MODE)
                    (let ((filepos  (nth 1 found))) ; File position in bytes.
                      ;; If this is an indirect file, determine which file really holds this node and read it in.
                      (unless (eq (nth 2 found) 'Info-mode)
                        ;; The current buffer must be the *info* buffer on entry to `Info-read-subfile'.
                        ;; Thus the hackery above.
                        (setq filepos  (Info-read-subfile filepos)))
                      (setq guesspos  (if (fboundp 'filepos-to-bufferpos)
                                          (filepos-to-bufferpos filepos 'approximate)
                                        filepos)))
                    (when (nth 0 found) ; Handle anchor
                      (goto-char (setq anchorpos  guesspos)) (throw 'foo t)))))
              ;; Else we may have a node, which we search for.
              (goto-char (max (point-min) (- (if (> emacs-major-version 24) guesspos (byte-to-position guesspos))
                                             1000)))
              ;; Now search from our advised position (or from beg of buffer) to find the actual node.
              ;; First, check whether the node is right where we are, in case the buffer begins with a node.
              (when (> emacs-major-version 24)
                (let ((pos  (Info-find-node-in-buffer regexp strict-case)))
                  (when pos (goto-char pos) (throw 'foo t)))
                ;; If the Texinfo source had an @ifnottex block of text before the Top node,
                ;; makeinfo 5.0 and 5.1 mistakenly omitted that block's size from the starting
                ;; position of the 1st subfile, which makes GUESSPOS overshoot the correct
                ;; position by the length of that text.  So we try again with a larger slop.
                (goto-char (max (point-min) (- guesspos 10000))))
              (let ((pos  (if (<= emacs-major-version 23)
                              (Info-find-node-in-buffer regexp)
                            (Info-find-node-in-buffer regexp strict-case))))
                (when pos (goto-char pos) (throw 'foo t)))
              (when (string-match "\\([^.]+\\)\\." nodename)
                (let (Info-point-loc)
                  (Info-find-node-2 filename (match-string 1 nodename) no-going-back strict-case nomsg))
                (widen)
                (throw 'foo t))
              ;; No such anchor in tag table or node in tag table or file
              (info-user-error "No such node or anchor: `%s'" nodename))
            (Info-select-node)
            (goto-char (point-min))
            (forward-line 1)            ; skip header line
            (when (and (not (fboundp 'Info-breadcrumbs)) ; Before Emacs 23.2
                       Info-breadcrumbs-in-header-flag
                       (> Info-breadcrumbs-depth 0))
              (forward-line 1))         ; skip breadcrumbs line
            (cond (anchorpos
                   (let ((new-history  (list Info-current-file (substring-no-properties nodename))))
                     ;; Add anchors to the history too
                     (setq Info-history-list  (cons new-history (delete new-history Info-history-list))))
                   (goto-char anchorpos))
                  ((numberp Info-point-loc)
                   (forward-line (- Info-point-loc 2))
                   (setq Info-point-loc  nil))
                  ((stringp Info-point-loc)
                   (Info-find-index-name Info-point-loc)
                   (setq Info-point-loc  nil)))))
        (when (and (one-window-p t)
                   (not (window-minibuffer-p))
                   (fboundp 'fit-frame) ; Defined in `fit-frame.el'.
                   Info-fit-frame-flag)
          (fit-frame))
        (when (and Info-fontify-glossary-words  (not (equal nodename "Glossary")))
          (let* ((manual  (file-name-sans-extension (file-name-nondirectory Info-current-file)))
                 (ht-var  (intern (concat manual "-glossary-hash-table"))))
            ;; If no glossary hash table, try to get one, possibly using fallback manual.
            (unless (and (boundp ht-var)  (hash-table-p (symbol-value ht-var)))
              (Info-get-glossary-hash-table-create (info-fallback-manual-for-glossary manual))))))
    ;; If we did not finish finding the specified node, go to the previous one or to `Top' node.
    (unless (or Info-current-node  no-going-back)
      (if Info-history
          (let ((hist  (car Info-history)))
            (setq Info-history  (cdr Info-history))
            (Info-find-node (nth 0 hist) (nth 1 hist) t t nomsg) ; Pass STRICT-CASE?  Emacs bug #31137.
            (goto-char (nth 2 hist)))
        (Info-find-node Info-current-file "Top" t t nomsg)))) ; Pass STRICT-CASE?  Emacs bug #31137.
  (Info-set-mode-line))

(defun Info-get-glossary-hash-table-create (&optional manual resetp)
  "Get glossary hash table for MANUAL, creating it if it doesn't exist.
MANUAL defaults to \"emacs\".
Non-nil RESETP means re-create an existing hash table."
  (unless (equal "dir" Info-current-file)
    (unless manual (setq manual  "emacs"))
    (let ((ht-var               (intern (concat manual "-glossary-hash-table")))
          (omanual              Info-current-file)
          (onode                Info-current-node)
          (Info-fit-frame-flag  nil))
      (if (and (boundp ht-var)  (hash-table-p (symbol-value ht-var)))
          (symbol-value ht-var)
        (when (and (or (not (boundp ht-var))  resetp)
                   (not (memq (intern manual) Info-no-glossary-manuals)))
          (if (not (ignore-errors (progn (Info-find-node manual "Glossary" 'NO-GOING-BACK) t)))
              (progn (add-to-list 'Info-no-glossary-manuals (intern manual))
                     (Info-find-node manual onode 'NO-GOING-BACK nil 'NOMSG))
            (let (def dbeg dend term)
              (re-search-forward "Glossary\n\\*+\n")
              (eval `(defvar ,ht-var nil ,(format "Glossary hash table for manual %s." (capitalize manual))))
              (set ht-var (make-hash-table :test 'Info-case-insensitive-string=))
              (while (not (eobp))
                (setq def  "")
                (re-search-forward "^[^[:space:]].*")
                (setq term  (match-string 0)
                      dbeg  (match-end 0))
                (forward-char)
                ;; Skip over any blank lines between term and its definition.
                ;; This is the case for glossary entry `Text', for instance.
                (while (looking-at-p "^$") (forward-line))
                (setq dbeg  (point))
                (while (looking-at-p "^[[:space:]].*") ; Gather lines of the definition.
                  (setq def  (concat def (buffer-substring dbeg (progn (forward-line)
                                                                       (setq dbeg  (point)))))))
                (setq def  (replace-regexp-in-string "\\(     \\)" "" def nil nil 1)
                      def  (replace-regexp-in-string "\\`\n+" "" def)
                      def  (replace-regexp-in-string "\n\n\\'" "" def))
                (puthash term def (symbol-value ht-var))))
            (Info-find-node omanual onode nil nil 'NOMSG)))))))

(defun info-fallback-manual-for-glossary (manual)
  "Name of manual whose glossary is to be used for MANUAL, or nil if none."
  (catch 'info-fallback-manual-for-glossary
    (dolist (entry  Info-glossary-fallbacks-alist)
      (when (or (eq t (cdr entry))  (memq (intern manual) (cdr entry)))
        (throw 'info-fallback-manual-for-glossary (symbol-name (car entry)))))
    nil))

(define-hash-table-test
  'Info-case-insensitive-string=
  'Info-case-insensitive-string=
  'Info-case-insensitive-string-hash)

(defun Info-case-insensitive-string= (string1 string2)
  "Return non-nil if STRING1 and STRING2 are the same, ignoring case."
  (eq t (compare-strings string1 nil nil string2 nil nil 'IGNORE-CASE)))

(defun Info-case-insensitive-string-hash (string)
  "Return hash code for `upcase' of STRING."
  (sxhash (upcase string)))


;; REPLACE ORIGINAL in `info.el':
;;
;; Pass non-nil NOMSG arg to `Info-insert-dir'.
;;
(defun Info-directory-find-node (filename nodename &optional no-going-back nomsg)
  "Directory-specific implementation of Info-find-node-2."
  (Info-insert-dir 'NOMSG))


;; REPLACE ORIGINAL in `info.el':
;;
;; Added optional arg NOMSG.  If non-nil then do not show progress messages.
;;
(defun Info-insert-dir (&optional nomsg)
  (if (and Info-dir-contents
           Info-dir-file-attributes
           (eval (cons 'and ; Verify that none of the files we used has changed since we used it.
                       (mapcar (lambda (elt)
                                 (let ((curr (file-attributes (file-truename (car elt))))) ; Handle symlinks
                                   (when curr (setcar (nthcdr 4 curr) 0)) ; Don't compare the access time.
                                   (setcar (nthcdr 4 (cdr elt)) 0)
                                   (equal (cdr elt) curr)))
                               Info-dir-file-attributes))))
      (progn (insert Info-dir-contents) (goto-char (point-min)))
    (let ((dirs              (if Info-additional-directory-list
                                 (append Info-directory-list Info-additional-directory-list)
                               Info-directory-list))
          (dir-file-attrs    ())
          (case-fold-search  t) ; Bind this in case the user sets it to nil.
          problems ; This is set non-nil if we find a problem in some input files.
          buffers buffer others nodes dirs-done)
      (while dirs  ; Search the directory list for the directory file.
        (let ((truename (file-truename (expand-file-name (car dirs)))))
          (or (member truename dirs-done)
              (member (directory-file-name truename) dirs-done)
              ;; Try several variants of specified name.  Try upcasing, appending `.info', or both.
              (let* (file
                     (attrs  (or (progn (setq file  (expand-file-name "dir" truename)) (file-attributes file))
                                 (progn (setq file  (expand-file-name "DIR" truename)) (file-attributes file))
                                 (progn (setq file  (expand-file-name "dir.info" truename))
                                        (file-attributes file))
                                 (progn (setq file  (expand-file-name "DIR.INFO" truename))
                                        (file-attributes file))
                                 ;; Shouldn't really happen, but sometimes does, eg on Debian systems with
                                 ;; buggy packages; so may as well try it.
                                 ;; https://lists.gnu.org/archive/html/emacs-devel/2012-03/msg00005.html
                                 (progn (setq file  (expand-file-name "dir.gz" truename))
                                        (file-attributes file)))))
                (setq dirs-done  (cons truename (cons (directory-file-name truename) dirs-done)))
                (when attrs
                  (with-current-buffer (generate-new-buffer " info dir")
                    (unless (or buffers  nomsg) (message "Composing main Info directory..."))
                    (condition-case nil
                        ;; Index nodes include null bytes.  DIR files should not have indices, but who knows...
                        (let ((inhibit-null-byte-detection  t))
                          (insert-file-contents file)
                          (set (make-local-variable 'Info-dir-file-name) file)
                          (push (current-buffer) buffers)
                          (push (cons file attrs) dir-file-attrs))
                      (error (kill-buffer (current-buffer))))))))
          (unless (cdr dirs)
            (set (make-local-variable 'Info-dir-contents-directory) (file-name-as-directory (car dirs))))
          (setq dirs  (cdr dirs))))
      (unless buffers  (info-user-error "Can't find the Info directory node"))
      ;; Distinguish the dir file that comes with Emacs from all the others.  Yes, that is really what this
      ;; is supposed to do.  The definition of `Info-directory-list' puts it first on that list and so last in
      ;; `buffers' at this point.
      (setq buffer  (car (last buffers))
            others  (delq buffer buffers))
      ;; Insert the entire original dir file as a start; note that we've already saved its default directory
      ;; to use as the default directory for the whole concatenation.
      (save-excursion (insert-buffer-substring buffer))
      (dolist (other  others) ; Look at each of the other buffers, one by one.
        (let (this-buffer-nodes)
          (with-current-buffer other    ; In each, find all the menus.
            (goto-char (point-min))
            (while (re-search-forward "^\\* Menu:" nil t) ; Find each menu, and add an elt to NODES for it.
              (while (and (zerop (forward-line 1))  (eolp)))
              (let ((beg  (point))
                    nodename end)
                (re-search-backward "^\^_")
                (search-forward "Node: ")
                (setq nodename  (and (looking-at (Info-following-node-name-re))  (match-string-no-properties 1)))
                (search-forward "\n\^_" nil 'move)
                (beginning-of-line)
                (setq end  (point))
                (push (list nodename other beg end) this-buffer-nodes)))
            (if (assoc-string "top" this-buffer-nodes t)
                (setq nodes  (nconc this-buffer-nodes nodes))
              (setq problems  t)
              (unless nomsg (message "No `top' node in %s" Info-dir-file-name))))))
      (re-search-forward "^\\* Menu:") ; Add to the main menu a menu item for each other node.
      (forward-line 1)
      (let ((menu-items  '("top"))
            (end         (save-excursion (search-forward "\^_" nil t) (point))))
        (dolist (node  nodes)
          (let ((nodename  (car node)))
            (save-excursion
              (or (member (downcase nodename)  menu-items)
                  (re-search-forward (concat "^\\* +" (regexp-quote nodename) "::") end t)
                  (progn (insert "* " nodename "::" "\n") (push nodename menu-items)))))))
      (dolist (node  nodes) ; Now take each node of each of the other buffers and merge it into the main buffer.
        (let ((case-fold-search  t)
              (nodename          (car node)))
          (goto-char (point-min))
          ;; Find the like-named node in the main buffer.
          (if (re-search-forward (concat "^\^_.*\n.*Node: " (regexp-quote nodename) "[,\n\t]") nil t)
              (progn (search-forward "\n\^_" nil 'move) (beginning-of-line) (insert "\n"))
            (goto-char (point-max))     ; If none exists, add one.
            (insert "\^_\nFile: dir\tNode: " nodename "\n\n* Menu:\n\n"))
          ;; Merge text from the other buffer's menu into the menu in the like-named node in the main buffer.
          (apply 'insert-buffer-substring (cdr node))))
      (Info-dir-remove-duplicates)
      ;; Kill all the buffers we just made, including the special one excised.
      (mapc 'kill-buffer (cons buffer buffers))
      (goto-char (point-min))
      (unless nomsg (message "Composing main Info directory...%s"
                             (if problems "problems encountered, see `*Messages*'" "done")))
      (set (make-local-variable 'Info-dir-contents) (buffer-string))
      (set (make-local-variable 'Info-dir-file-attributes) dir-file-attrs)))
  (setq default-directory  Info-dir-contents-directory))


;; REPLACE ORIGINAL in `info.el':
;;
;; Handle `Info-breadcrumbs-in-mode-line-mode'.
;;
(defun Info-set-mode-line ()
  "Set the Info mode line.
If `Info-breadcrumbs-in-mode-line-mode' is non-nil, insert breadcrumbs."
  (if Info-breadcrumbs-in-mode-line-mode
      (Info-insert-breadcrumbs-in-mode-line)
    (setq mode-line-buffer-identification  (nconc (propertized-buffer-identification "%b")
                                                  (list
                                                   (concat
                                                    " ("
                                                    (if (stringp Info-current-file)
                                                        (replace-regexp-in-string
                                                         "%" "%%" (file-name-nondirectory Info-current-file))
                                                      (format "*%S*" Info-current-file))
                                                    ") "
                                                    (if Info-current-node
                                                        (propertize
                                                         (replace-regexp-in-string
                                                          "%" "%%" Info-current-node)
                                                         'face 'mode-line-buffer-id
                                                         'help-echo
                                                         "mouse-1: scroll forward, mouse-3: scroll back"
                                                         'mouse-face 'mode-line-highlight
                                                         'local-map Info-mode-line-node-keymap)
                                                      "")))))))

(defun Info-insert-breadcrumbs-in-mode-line ()
  (let ((nodes   (Info-toc-nodes Info-current-file))
        (node    Info-current-node)
        (crumbs  ())
        (depth   Info-breadcrumbs-depth-internal)
        (text    ""))
    ;; Get ancestors from the cached parent-children node info
    (while (and (not (equal "Top" node))  (> depth 0))
      (setq node  (nth 1 (assoc node nodes)))
      (when node (push node crumbs))
      (setq depth  (1- depth)))
    ;; Add bottom node.
    (setq crumbs  (nconc crumbs (list Info-current-node)))
    (when crumbs
      ;; Add top node (and continuation if needed).
      (setq crumbs  (cons "Top" (if (member (pop crumbs) '(nil "Top"))
                                    crumbs
                                  (cons nil crumbs))))
      (dolist (node  crumbs)
        (let ((crumbs-map  (make-sparse-keymap))
              (menu-map    (make-sparse-keymap "Breadcrumbs in Mode Line")))
          (define-key crumbs-map [mode-line mouse-3] menu-map)
          (when node
            (define-key menu-map [Info-prev]
              `(menu-item "Previous Node" Info-prev
                          :visible ,(Info-check-pointer "prev[ious]*") :help "Go to the previous node"))
            (define-key menu-map [Info-next]
              `(menu-item "Next Node" Info-next
                          :visible ,(Info-check-pointer "next") :help "Go to the next node"))
            (define-key menu-map [separator] '("--"))
            (define-key menu-map [Info-breadcrumbs-in-mode-line-mode]
              `(menu-item "Toggle Breadcrumbs" Info-breadcrumbs-in-mode-line-mode
                          :help "Toggle displaying breadcrumbs in the Info mode-line"
                          :button (:toggle . Info-breadcrumbs-in-mode-line-mode)))
            (define-key menu-map [Info-set-breadcrumbs-depth]
              `(menu-item "Set Breadcrumbs Depth" Info-set-breadcrumbs-depth
                          :help "Set depth of breadcrumbs to show in the mode-line"))
            (setq node  (if (equal node Info-current-node)
                            (propertize
                             (replace-regexp-in-string "%" "%%" Info-current-node)
                             'face 'mode-line-buffer-id
                             'help-echo "mouse-1: Scroll back, mouse-2: Scroll forward, mouse-3: Menu"
                             'mouse-face 'mode-line-highlight
                             'local-map
                             (progn
                               (define-key crumbs-map [mode-line mouse-1] 'Info-mouse-scroll-down)
                               (define-key crumbs-map [mode-line mouse-2] 'Info-mouse-scroll-up)
                               crumbs-map))
                          (propertize
                           node
                           'local-map (progn (define-key crumbs-map [mode-line mouse-1]
                                               `(lambda () (interactive) (Info-goto-node ,node)))
                                             (define-key crumbs-map [mode-line mouse-2]
                                               `(lambda () (interactive) (Info-goto-node ,node)))
                                             crumbs-map)
                           'mouse-face 'mode-line-highlight
                           'help-echo "mouse-1, mouse-2: Go to this node; mouse-3: Menu")))))
        (let ((nodetext  (if (not (equal node "Top"))
                             node
                           (concat (format "(%s)" (if (stringp Info-current-file)
                                                      (file-name-nondirectory Info-current-file)
                                                    ;; Some legacy code can still use a symbol.
                                                    Info-current-file))
                                   node))))
          (setq text  (concat text (if (equal node "Top") "" " > ") (if node nodetext "...")))))
      (make-local-variable 'mode-line-format) ; Needed for Emacs 21+.
      (setq mode-line-format  text))))



;;; ;; REPLACE ORIGINAL in `info.el':
;;; ;;
;;; ;; BUG FIX (bug #1085, reported 2008-10-04).
;;; ;; 1. Match closing paren, if present.
;;; ;; 2. If only opening paren and CODE = t, then wrap each file name in ().
;;; ;;
;;;   (defun Info-read-node-name-1 (string predicate code)
;;;   "Internal function used by `Info-read-node-name'.
;;; See `completing-read' for a description of arguments and usage."
;;;     (cond ((string-match "\\`(\\([^)]*\\))\\'" string) ; e.g. (emacs) or (emacs-mime)
;;;            (cond ((eq code nil) string)
;;;                  ((eq code t) (list string))
;;;                  (t t)))
;;;           ((string-match "\\`(\\([^)]*\\)\\'" string) ; e.g. (emacs
;;;            (let ((ctwc  (completion-table-with-context
;;;                          "("
;;;                          (apply-partially
;;;                           'completion-table-with-terminator ")"
;;;                           (apply-partially 'Info-read-node-name-2
;;;                                            Info-directory-list
;;;                                            (mapcar 'car Info-suffix-list)))
;;;                          (match-string 1 string)
;;;                          predicate
;;;                          code)))
;;;              (cond ((eq code nil) ctwc)
;;;                    ((eq code t) (mapcar (lambda (file) (concat "(" file ")")) ctwc))
;;;                    (t t))))
;;;           ((string-match "\\`(" string) ; e.g. (emacs)Mac OS or (jlkj - just punt.
;;;            (cond ((eq code nil) string)
;;;                  ((eq code t) nil)
;;;                  (t t)))
;;;           ;; Otherwise use Info-read-node-completion-table - e.g. Mac OS
;;;           (t (complete-with-action code Info-read-node-completion-table string predicate))))



;; REPLACE ORIGINAL in `info.el':
;;
;; 1. Added optional arg MSGP.
;; 2. Added in-progress message ("Looking...")
;; 3, Return nil if not found.
;;
(defun Info-find-emacs-command-nodes (command &optional msgp)
  "Return a list of locations documenting COMMAND.
The `info-file' property of COMMAND says which Info manual to search.
If COMMAND has no property, the variable `Info-file-list-for-emacs'
defines heuristics for which Info manual to try.

The locations are of the format used in variable `Info-history', that
is, (FILENAME NODENAME BUFFERPOS), where BUFFERPOS is the line number
of the first element of the returned list (which is treated specially
in `Info-goto-emacs-command-node'), and 0 for the other elements of
the list."
  (let ((where      ())
        (cmd-desc   (concat "^\\* +" (regexp-quote (symbol-name command))
                            "\\( <[0-9]+>\\)?:\\s *\\(.*\\)\\."
                            "\\(?:[ \t\n]+(line +\\([0-9]+\\))\\)?"))
        (info-file  "emacs")            ;default
        line-number)
    ;; Determine which info file this command is documented in.
    (if (get command 'info-file)
        (setq info-file  (get command 'info-file))
      ;; If it doesn't say explicitly, test its name against
      ;; various prefixes that we know.
      (let ((file-list  Info-file-list-for-emacs))
        (while file-list
          (let* ((elt               (car file-list))
                 (name              (if (consp elt) (car elt) elt))
                 (file              (if (consp elt) (cdr elt) elt))
                 (case-fold-search  nil)
                 (regexp            (concat "\\`" (regexp-quote name) "\\(\\'\\|-\\)")))
            (if (string-match regexp (symbol-name command))
                (setq info-file  file
                      file-list  ()))
            (setq file-list  (cdr file-list))))))
    (when msgp (message "Looking for command `%s' in Info manual `%s'..."
                        command (file-name-nondirectory info-file)))
    (save-excursion
      (condition-case nil
          (progn (Info-find-node info-file "Top" (not msgp))
                 (or (and (search-forward "\n* menu:" nil t)
                          (re-search-forward "\n\\* \\(.*\\<Index\\>\\)" nil t))
                     (info-user-error "Info file `%s' appears to lack an index" info-file)))
        (error nil))                    ; Return nil: not found.
      (goto-char (match-beginning 1))
      ;; Bind Info-history to nil, to prevent the index nodes from
      ;; getting into the node history.
      (let ((Info-history       ())
            (Info-history-list  ())
            node
            (nodes              (Info-index-nodes)))
        (Info-goto-node (car nodes))
        (while (progn (goto-char (point-min))
                      (while (re-search-forward cmd-desc nil t)
                        (setq where        (cons (list Info-current-file (match-string-no-properties 2) 0)
                                                 where)
                              line-number  (and (match-beginning 3)  (string-to-number (match-string 3)))))
                      (and (setq nodes  (cdr nodes)
                                 node   (car nodes))))
          (Info-goto-node node)))
      (if (and line-number  where)
          (cons (list (nth 0 (car where)) (nth 1 (car where)) line-number) (cdr where))
        where))))


;; REPLACES ORIGINAL in `info.el':
;;
;; 1. Uses `completing-read' in interactive spec, with `symbol-nearest-point'
;;    (defined in `thingatpt+.el') or `symbol-at-point' (defined in `thingatpt.el').
;; 2. Added optional arg MSGP (interactive-p).
;; 3. Message if single node found.
;; 4. Returns `num-matches' if found; nil if not.
;; 4. Pass MSGP to `Info-find-emacs-command-nodes'.
;;
;;;###autoload
(defun Info-goto-emacs-command-node (command &optional msgp)
  "Go to the Info node in the Emacs manual for command COMMAND.
The command is found by looking it up in Emacs manual's indexes,
or in another manual found via COMMAND's `info-file' property or
the variable `Info-file-list-for-emacs'.
COMMAND must be a symbol or string."
  (interactive
   (let ((symb  (cond ((fboundp 'symbol-nearest-point) (symbol-nearest-point))
                      ((fboundp 'symbol-at-point)      (symbol-at-point))
                      (t nil)))
         (enable-recursive-minibuffers t))
     (list (intern (completing-read "Find documentation for command: "
                                    obarray 'commandp t nil nil (symbol-name symb) t))
           t)))
  (unless (commandp command)
    (signal 'wrong-type-argument (list 'commandp command)))
  (let ((where  (Info-find-emacs-command-nodes command msgp)))
    (if where
        (let ((num-matches  (length where)))
          ;; Get Info running, and pop to it in another window.
          (save-window-excursion (info))
          (unless (eq major-mode 'Info-mode) (pop-to-buffer "*info*"))
          ;; Bind Info-history to nil, to prevent the last Index node visited by
          ;; `Info-find-emacs-command-nodes' from being pushed onto the history.
          (let ((Info-history       ())
                (Info-history-list  ()))
            (Info-find-node (car (car where)) (car (cdr (car where)))))
          (if (<= num-matches 1)
              (when msgp (message "This info node documents command `%s'." command))

            ;; (car where) will be pushed onto Info-history
            ;; when/if they go to another node.  Put the other
            ;; nodes that were found on the history.
            (setq Info-history  (nconc (cdr where) Info-history))
            (when msgp
              (message "Found %d other entr%s.  Use %s to see %s."
                       (1- num-matches) (if (> num-matches 2) "ies" "y")
                       (substitute-command-keys "\\<Info-mode-map>\\[Info-history-back]")
                       (if (> num-matches 2) "them" "it"))))
          num-matches)                  ; Return num-matches found.
      (and (interactive-p)              ; Return nil for unfound.
           (info-user-error "No documentation found for command `%s'" command)))))


;; REPLACES ORIGINAL in `info.el':

;; 1. If key's command is not found, then `Info-search' for key sequence in text.
;; 2. Added optional arg MSGP (interactive-p).
;; 3. Message for repeating.
;; 4. Return non-nil for found, nil for not found.
;;
;;;###autoload
(defun Info-goto-emacs-key-command-node (key &optional msgp)
  "Go to the node in the Emacs manual describing command bound to KEY.
KEY is a string.

Interactively, if the binding is `execute-extended-command', then a
command is read.

The command is found by looking it up in Emacs manual's indexes,
or in another manual's index found via COMMAND's `info-file' property
or the variable `Info-file-list-for-emacs'.

If key's command cannot be found by looking in indexes, then
`Info-search' is used to search for the key sequence in the info text."
  (interactive "kFind documentation for key: \np")
  (let ((command  (lookup-key global-map key))
        (pp-key   (key-description key)))
    (when (natnump command) (setq command  (key-binding key))) ; E.g. menu item.
    (cond ((null command)
           (when msgp (message "No doc found for key sequence `%s'." pp-key))
           nil)                         ; RETURN nil: not found.
          ((and (interactive-p)  (eq command 'execute-extended-command)) ; Read a new command name.
           (Info-goto-emacs-command-node (read-command "Find documentation for command: ") msgp))
          (t
           (let ((this-file        Info-current-file)
                 (this-node        Info-current-node)
                 (num-cmd-matches  (Info-goto-emacs-command-node command msgp)))
             (cond (num-cmd-matches
                    ;; Found key's command via a manual index.
                    (when msgp
                      (if (<= num-cmd-matches 1)
                          (message "This info node documents key `%s'." pp-key)
                        (message
                         (substitute-command-keys
                          (concat "Found %d other entr%s.  Use "
                                  "\\<Info-mode-map>`\\[Info-history-back]' to see %s."))
                         (1- num-cmd-matches) (if (> num-cmd-matches 2) "ies" "y")
                         (if (> num-cmd-matches 2) "them" "it"))))
                    num-cmd-matches)  ; RETURN num-cmd-matches: found.
                   (this-file
                    ;; Couldn't find key's command via a manual index.
                    ;; Get back to where we were, if in Info.
                    ;; Would be better if there were a save-xxx-excursion-xxx
                    ;; that would work.
                    (Info-goto-node (concat "(" this-file ")" this-node))
                    ;; Would be better to now try looking for the key in indexes (e.g. Key
                    ;; Index). Instead, just look for the key sequence in the text.
                    (when msgp
                      (message "Not found using Index. Searching for \"%s\" in text..." pp-key)
                      (sit-for 3))
                    (condition-case err
                        (progn
                          (Info-search (regexp-quote pp-key))
                          (when msgp
                            (message (substitute-command-keys
                                      "Use \\<Info-mode-map>`\\[Info-search] RET' to search again for `%s'.")
                                     pp-key))
                          t)            ; RETURN t: found.
                      (search-failed (when msgp (message "No documentation found for key `%s'." pp-key))
                                     nil))) ; RETURN nil: not found.
                   (t nil))))))) ; RETURN nil: not found.


;; REPLACES ORIGINAL in `info.el':
;;
;; 1. File name in face `info-file'.
;; 2. If `Info-fontify-emphasis-flag', fontify _..._.
;; 3. If `Info-fontify-indented-text-chars' then fontify text indented at least that many chars.
;; 4. If `Info-fontify-quotations', fontify ‘...’ and `...' in face `info-quoted-name',
;;    “...” in face `info-double-quoted-name', and "..." in face `info-string'.
;; 5. If `Info-fontify-quotations' and `Info-fontify-angle-bracketed-flag' then
;;    fontify <...> in face `info-quoted-name'.
;; 6. If `Info-fontify-quotations' and `Info-fontify-isolated-quote-flag' then fontify
;;    isolated ' and ` in faces `Info-isolated-quote' and `Info-isolated-backquote', respectively.
;;
(when (not (fboundp 'Info-breadcrumbs)) ; Emacs 23.1, not 23.2+

  (defun Info-fontify-node ()
    "Fontify the node."
    (save-excursion
      (let* ((inhibit-read-only  t)
             (case-fold-search   t)
             paragraph-markers
             (not-fontified-p ; the node hasn't already been fontified
              (not (let ((where  (next-single-property-change (point-min) 'font-lock-face)))
                     (and where  (not (= where (point-max)))))))
             (fontify-visited-p ; visited nodes need to be re-fontified
              (and Info-fontify-visited-nodes
                   ;; Don't take time to refontify visited nodes in huge nodes
                   Info-fontify-maximum-menu-size
                   (< (- (point-max) (point-min)) Info-fontify-maximum-menu-size)))
             rbeg rend)

        ;; Fontify EMPHASIS: _..._
        ;;
        ;; Do this first because it can remove existing highlighting.
        (when info-fontify-emphasis
          (goto-char (point-min))
          (when (and font-lock-mode  not-fontified-p)
            (while (re-search-forward Info-emphasis-regexp nil t)
              (let ((fn  (if Info-fontify-emphasis-flag #'add-text-properties #'remove-text-properties)))
                (funcall fn (match-beginning 0) (1+ (match-beginning 0))
                         '(invisible t front-sticky nil rear-nonsticky t))
                (funcall fn (1- (match-end 0)) (match-end 0)
                         '(invisible t front-sticky nil rear-nonsticky t))
                (funcall fn (match-beginning 1) (match-end 1) '(font-lock-face info-emphasis))))))

        ;; Fontify HEADER LINE
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^File: \\([^,: \t]+\\),?[ \t]+"))
          (put-text-property (match-beginning 1) (match-end 1) 'font-lock-face 'info-file))
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^\\(File: [^,: \t]+,?[ \t]+\\)?"))
          (while (looking-at "[ \t]*\\([^:, \t\n]+\\):[ \t]+\\([^:,\t\n]+\\),?")
            (goto-char (match-end 0))
            (let* ((nbeg  (match-beginning 2))
                   (nend  (match-end 2))
                   (tbeg  (match-beginning 1))
                   (tag   (match-string 1)))
              (if (string-equal (downcase tag) "node")
                  (put-text-property nbeg nend 'font-lock-face 'info-header-node)
                (put-text-property nbeg nend 'font-lock-face 'info-header-xref)
                (put-text-property tbeg nend 'mouse-face 'highlight)
                (put-text-property tbeg nend
                                   'help-echo (concat "mouse-2: Go to node " (buffer-substring nbeg nend)))
                ;; Always set up the text property keymap.
                ;; It will either be used in the buffer
                ;; or copied in the header line.
                (put-text-property tbeg nend 'keymap
                                   (cond
                                    ((string-equal (downcase tag) "prev") Info-prev-link-keymap)
                                    ((string-equal (downcase tag) "next") Info-next-link-keymap)
                                    ((string-equal (downcase tag) "up"  ) Info-up-link-keymap))))))
          (when (and Info-breadcrumbs-in-header-flag  (> Info-breadcrumbs-depth 0))
            (Info-insert-breadcrumbs))

          ;; Treat header line.
          (when Info-use-header-line
            (goto-char (point-min))
            (let* ((header-end  (line-end-position))
                   (header
                    ;; If we find neither Next: nor Prev: link, show the entire
                    ;; node header.  Otherwise, don't show the File: and Node:
                    ;; parts, to avoid wasting precious space on information that
                    ;; is available in the mode line.
                    (if (re-search-forward "\\(next\\|up\\|prev[ious]*\\): " header-end t)
                        (progn (goto-char (match-beginning 1))
                               (buffer-substring (point) header-end))
                      (if (re-search-forward "node:[ \t]*[^ \t]+[ \t]*" header-end t)
                          (concat "No next, prev or up links  --  "
                                  (buffer-substring (point) header-end))
                        (buffer-substring (point) header-end)))))
              (put-text-property (point-min) (1+ (point-min))
                                 'header-line (replace-regexp-in-string
                                               "%"
                                               ;; Preserve text properties on duplicated `%'.
                                               (lambda (s) (concat s s)) header))
              ;; Hide the part of the first line that is in the header, if it is just part.
              (cond ((and Info-breadcrumbs-in-header-flag  (> Info-breadcrumbs-depth 0))
                     (put-text-property (point-min) (1+ header-end) 'invisible t))
                    ((not (bobp))
                     ;; Hide the punctuation at the end, too.
                     (skip-chars-backward " \t,")
                     (put-text-property (point) header-end 'invisible t))))))

        ;; Fontify INDENTED TEXT (e.g. code blocks, ASCII diagrams).
        (goto-char (point-min))
        (when (and Info-fontify-indented-text-chars  (not (equal "Top" Info-current-node)))
          (Info-fontify-indented-text))

        ;; Fontify QUOTATIONS: ‘...’, `...', “...”, and "..."
        (goto-char (point-min))
        (when Info-fontify-quotations (Info-fontify-quotations))

        ;; Fontify CUSTOM-DELIMITED: text between custom delimiters
        (goto-char (point-min))
        (when (car Info-fontify-custom-delimited) (Info-fontify-custom-delimited))

        ;; Fontify EXTRA: something else
        (when Info-fontify-extra-function
          (goto-char (point-min))
          (funcall Info-fontify-extra-function))

        ;; Fontify REFERENCE ITEMS: `-- Function:', `-- Variable:', etc.
        (goto-char (point-min))
        (when Info-fontify-reference-items-flag (Info-fontify-reference-items))

        ;; Fontify TITLES
        (goto-char (point-min))
        (when (and font-lock-mode not-fontified-p)
          (while (and (re-search-forward "\n\\([^ \t\n].+\\)\n\\(\\*\\*+\\|==+\\|--+\\|\\.\\.+\\)$" nil t)
                      ;; Only consider it as an underlined title if the ASCII
                      ;; underline has the same size as the text.  A typical
                      ;; counter example is when a continuation "..." is alone
                      ;; on a line.
                      (= (string-width (match-string 1))
                         (string-width (match-string 2))))
            (let* ((c     (preceding-char))
                   (face  (cond ((= c ?*) 'info-title-1)
                                ((= c ?=) 'info-title-2)
                                ((= c ?-) 'info-title-3)
                                (t        'info-title-4))))
              (put-text-property (match-beginning 1) (match-end 1)
                                 'font-lock-face face))
            ;; This is a serious problem for trying to handle multiple
            ;; frame types at once.  We want this text to be invisible
            ;; on frames that can display the font above.
            (when (memq (framep (selected-frame)) '(x pc w32 ns))
              (add-text-properties (1- (match-beginning 2)) (match-end 2)
                                   '(invisible t front-sticky nil rear-nonsticky t)))))

        ;; Fontify CROSS REFERENCES
        (goto-char (point-min))
        (when (or not-fontified-p  fontify-visited-p)
          (while (re-search-forward
                  "\\(\\*Note[ \n\t]+\\)\\([^:]*\\)\\(:[ \t]*\\([^.,:(]*\\)\\(\\(([^)]\
,*)\\)[^.,:]*\\)?[,:]?\n?\\)"
                  nil t)
            (let ((start  (match-beginning 0))
                  (next   (point))
                  other-tag)
              (when not-fontified-p
                (when Info-hide-note-references
                  (when (and (not (eq Info-hide-note-references 'hide))
                             (> (line-number-at-pos) 4)) ; Skip breadcrumbs
                    ;; *Note is often used where *note should have been
                    (goto-char start)
                    (skip-syntax-backward " ")
                    (when (memq (char-before) '(?\( ?\[ ?\{))
                      ;; Check whether the paren is preceded by
                      ;; an end of sentence
                      (skip-syntax-backward " ("))
                    (setq other-tag  (cond ((save-match-data (looking-back "\\<see" nil))
                                            "")
                                           ((save-match-data (looking-back "\\<in" nil))
                                            "")
                                           ((memq (char-before) '(nil ?\. ?! ??))
                                            "See ")
                                           ((save-match-data
                                              (save-excursion (search-forward "\n\n" start t)))
                                            "See ")
                                           (t "see "))))
                  (goto-char next)
                  (add-text-properties (match-beginning 1)
                                       (or (save-match-data
                                             (let ((start1  (match-beginning 1))) ; Don't hide \n after *Note
                                               (and (string-match "\n" (match-string 1))
                                                    (+ start1 (match-beginning 0)))))
                                           (match-end 1))
                                       (if other-tag
                                           `(display ,other-tag front-sticky nil rear-nonsticky t)
                                         '(invisible t front-sticky nil rear-nonsticky t))))
                (add-text-properties (match-beginning 2) (match-end 2)
                                     (list 'help-echo (if (or (match-end 5)  (not (equal (match-string 4) "")))
                                                          (concat "mouse-2: go to " (or (match-string 5)
                                                                                        (match-string 4)))
                                                        "mouse-2: go to this node")
                                           'mouse-face 'highlight)))
              (when (or not-fontified-p  fontify-visited-p)
                (setq rbeg  (match-beginning 2)
                      rend  (match-end 2))
                (put-text-property
                 rbeg
                 rend
                 'font-lock-face
                 ;; Display visited nodes in a different face
                 (if (and Info-fontify-visited-nodes
                          (save-match-data
                            (let* ((node
                                    (replace-regexp-in-string
                                     "^[ \t]+" ""
                                     (replace-regexp-in-string
                                      "[ \t\n]+" " "
                                      (or (match-string-no-properties 5)
                                          (and (not (equal (match-string 4) ""))
                                               (match-string-no-properties 4))
                                          (match-string-no-properties 2)))))
                                   (external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                   (file             (if external-link-p
                                                         (file-name-nondirectory
                                                          (match-string-no-properties 1 node))
                                                       Info-current-file))
                                   (hl               Info-history-list)
                                   res)
                              (when external-link-p
                                (setq node  (if (equal (match-string 2 node) "")
                                                "Top"
                                              (match-string-no-properties 2 node))))
                              (while hl
                                (if (and (string-equal node (nth 1 (car hl)))
                                         (equal file (if (and external-link-p (stringp (caar hl)))
                                                         (file-name-nondirectory (caar hl))
                                                       (caar hl))))
                                    (setq res  (car hl)
                                          hl   nil)
                                  (setq hl  (cdr hl))))
                              res)))
                     'info-xref-visited
                   'info-xref))
                ;; For multiline ref, unfontify newline and surrounding whitespace
                (save-excursion
                  (goto-char rbeg)
                  (save-match-data (while (re-search-forward "\\s-*\n\\s-*" rend t nil)
                                     (remove-text-properties (match-beginning 0) (match-end 0)
                                                             '(font-lock-face t))))))
              (when not-fontified-p
                (when (memq Info-hide-note-references '(t hide))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t front-sticky nil rear-nonsticky t))
                  ;; Unhide the file name of the external reference in parens
                  (if (and (match-string 6)  (not (eq Info-hide-note-references 'hide)))
                      (remove-text-properties (match-beginning 6) (match-end 6) '(invisible t front-sticky nil
                                                                                            rear-nonsticky t)))
                  ;; Unhide newline because hidden newlines cause too long lines
                  (save-match-data (let ((beg3  (match-beginning 3))
                                         (end3  (match-end 3)))
                                     (if (and (string-match "\n[ \t]*" (match-string 3))
                                              (not (save-match-data (save-excursion (goto-char (1+ end3))
                                                                                    (looking-at "[.)]*$")))))
                                         (remove-text-properties (+ beg3 (match-beginning 0))
                                                                 (+ beg3 (match-end 0))
                                                                 '(invisible t front-sticky nil
                                                                             rear-nonsticky t))))))
                (when (and Info-refill-paragraphs  Info-hide-note-references)
                  (push (set-marker (make-marker) start) paragraph-markers))))))

        ;; REFILL PARAGRAPHS (experimental feature)
        (when (and not-fontified-p  Info-refill-paragraphs  paragraph-markers)
          (let ((fill-nobreak-invisible          t)
                (fill-individual-varying-indent  nil)
                (paragraph-start                 "\f\\|[ \t]*[-*]\\|[ \t]*$")
                (paragraph-separate              ".*\\.[ \t]*\n[ \t]\\|[ \t]*[-*]\\|[ \t\f]*$")
                (adaptive-fill-mode              nil))
            (goto-char (point-max))
            (dolist (m  paragraph-markers)
              (when (< m (point))
                (goto-char m)
                (beginning-of-line)
                (let ((beg  (point)))
                  (when (zerop (forward-paragraph))
                    (fill-individual-paragraphs beg (point) nil nil)
                    (goto-char beg))))
              (set-marker m nil))))

        ;; Fontify MENU ITEMS
        (goto-char (point-min))
        (when (and (or not-fontified-p  fontify-visited-p)
                   (search-forward "\n* Menu:" nil t)
                   Info-fontify-maximum-menu-size ; Don't take time to annotate huge menus
                   (< (- (point-max) (point)) Info-fontify-maximum-menu-size))
          (let ((n  0)
                cont)
            (while (re-search-forward (concat "^\\* Menu:\\|\\(?:^\\* +\\(" Info-menu-entry-name-re "\\)\\(:"
                                              Info-node-spec-re "\\([ \t]*\\)\\)\\)")
                                      nil t)
              (when (match-beginning 1)
                (when not-fontified-p
                  (setq n  (1+ n))
                  (if (and (<= n 9)  (zerop (% n 3))) ; visual aids to help with 1-9 keys
                      (put-text-property (match-beginning 0) (1+ (match-beginning 0))
                                         'font-lock-face 'info-menu-star)))
                (when not-fontified-p
                  (add-text-properties
                   (match-beginning 1) (match-end 1)
                   (list 'help-echo (if (and (match-end 3)  (not (equal (match-string 3) "")))
                                        (concat "mouse-2: go to " (match-string 3))
                                      "mouse-2: go to this node")
                         'mouse-face 'highlight)))
                (when (or not-fontified-p  fontify-visited-p)
                  (put-text-property
                   (match-beginning 1) (match-end 1)
                   'font-lock-face
                   ;; Display visited menu items in a different face
                   (if (and Info-fontify-visited-nodes
                            (save-match-data
                              (let* ((node             (if (equal (match-string 3) "")
                                                           (match-string-no-properties 1)
                                                         (match-string-no-properties 3)))
                                     (external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                     (file             (if external-link-p
                                                           (file-name-nondirectory
                                                            (match-string-no-properties 1 node))
                                                         Info-current-file))
                                     (hl               Info-history-list)
                                     res)
                                (when external-link-p
                                  (setq node  (if (equal (match-string 2 node) "")
                                                  "Top"
                                                (match-string-no-properties 2 node))))
                                (while hl
                                  (if (and (string-equal node (nth 1 (car hl)))
                                           (equal file (if (and external-link-p (stringp (caar hl)))
                                                           (file-name-nondirectory (caar hl))
                                                         (caar hl))))
                                      (setq res  (car hl)
                                            hl   nil)
                                    (setq hl  (cdr hl))))
                                res)))
                       'info-xref-visited
                     'info-xref)))
                (when (and not-fontified-p
                           (memq Info-hide-note-references '(t hide))
                           (not (Info-index-node)))
                  (put-text-property (match-beginning 2) (1- (match-end 6)) 'invisible t)
                  ;; Unhide the file name in parens
                  (if (and (match-end 4)  (not (eq (char-after (match-end 4)) ?.)))
                      (remove-text-properties (match-beginning 4) (match-end 4) '(invisible t)))
                  ;; We need a stretchable space like :align-to but with a minimum value.
                  (put-text-property (1- (match-end 6)) (match-end 6) 'display (if (>= 22
                                                                                       (- (match-end 1)
                                                                                          (match-beginning 0)))
                                                                                   '(space :align-to 24)
                                                                                 '(space :width 2)))
                  (setq cont  (looking-at "."))
                  (while (and (= (forward-line 1) 0)  (looking-at "\\([ \t]+\\)[^*\n]"))
                    (put-text-property (match-beginning 1) (1- (match-end 1)) 'invisible t)
                    (put-text-property (1- (match-end 1)) (match-end 1) 'display (if cont
                                                                                     '(space :align-to 26)
                                                                                   '(space :align-to 24)))
                    (setq cont  t)))))))

        ;; Fontify GLOSSARY WORDS
        ;;
        ;; Do this AFTER fontifying menu items and references.
        (goto-char (point-min))
        (forward-line 4)
        (when Info-fontify-glossary-words (Info-fontify-glossary-words))

        ;; Fontify MENU HEADERS
        (goto-char (point-min))
        (when (and not-fontified-p ; Add face `info-menu-header' to any header before a menu entry
                   (re-search-forward "^\\* Menu:" nil t))
          (put-text-property (match-beginning 0) (match-end 0)
                             'font-lock-face 'info-menu-header)
          (while (re-search-forward "\n\n\\([^*\n ].*\\)\n\n?[*]" nil t)
            (put-text-property (match-beginning 1) (match-end 1)
                               'font-lock-face 'info-menu-header)))

        ;; Hide index line numbers
        (goto-char (point-min))
        (when (and not-fontified-p  (Info-index-node))
          (while (re-search-forward "[ \t\n]*(line +[0-9]+)" nil t)
            (put-text-property (match-beginning 0) (match-end 0)
                               'invisible t)))

        ;; Fontify HTTP AND FTP REFERENCES
        (goto-char (point-min))
        (when not-fontified-p
          (while (re-search-forward "\\(https?\\|ftp\\)://[^ \t\n\"`({<>})']+" nil t)
            (add-text-properties (match-beginning 0) (match-end 0)
                                 '(font-lock-face info-xref
                                                  mouse-face highlight
                                                  help-echo "mouse-2: go to this URL"))))

        ;; Hide any empty lines at the end of the node.
        (goto-char (point-max))
        (skip-chars-backward "\n")
        (when (< (1+ (point)) (point-max)) (put-text-property (1+ (point)) (point-max) 'invisible t))
        (set-buffer-modified-p nil))))

  )


;; REPLACES ORIGINAL in `info.el':
;;
;; 1. File name in face `info-file'.
;; 2. If `Info-fontify-emphasis-flag', fontify _..._.
;; 3. If `Info-fontify-indented-text-chars' then fontify text indented at least that many chars.
;; 4. If `Info-fontify-quotations', fontify ‘...’ and `...' in face `info-quoted-name',
;;    “...” in face `info-double-quoted-name', and "..." in face `info-string'.
;; 5. If `Info-fontify-quotations' and `Info-fontify-angle-bracketed-flag' then
;;    fontify <...> in face `info-quoted-name'.
;; 6. If `Info-fontify-quotations' and `Info-fontify-isolated-quote-flag' then fontify
;;    isolated ' and ` in faces `Info-isolated-quote' and `Info-isolated-backquote', respectively.
;;
(when (and (fboundp 'Info-breadcrumbs)  ; Emacs 23.2 through 24.1
           (or (= emacs-major-version 23)
               (and (= emacs-major-version 24)  (= emacs-minor-version 1))))

  (defun Info-fontify-node ()
    "Fontify the node."
    (save-excursion
      (let* ((inhibit-read-only  t)
             (case-fold-search   t)
             paragraph-markers
             (not-fontified-p ; the node hasn't already been fontified
              (not (let ((where  (next-single-property-change (point-min) 'font-lock-face)))
                     (and where  (not (= where (point-max)))))))
             (fontify-visited-p ; visited nodes need to be re-fontified
              (and Info-fontify-visited-nodes
                   Info-fontify-maximum-menu-size ; Don't take time to refontify visited nodes in huge nodes
                   (< (- (point-max) (point-min)) Info-fontify-maximum-menu-size)))
             rbeg rend)

        ;; Fontify EMPHASIS: _..._
        ;;
        ;; Do this first because it can remove existing highlighting.
        (when info-fontify-emphasis
          (goto-char (point-min))
          (when (and font-lock-mode  not-fontified-p)
            (while (re-search-forward Info-emphasis-regexp nil t)
              (let ((fn  (if Info-fontify-emphasis-flag #'add-text-properties #'remove-text-properties)))
                (funcall fn (match-beginning 0) (1+ (match-beginning 0))
                         '(invisible t front-sticky nil rear-nonsticky t))
                (funcall fn (1- (match-end 0)) (match-end 0)
                         '(invisible t front-sticky nil rear-nonsticky t))
                (funcall fn (match-beginning 1) (match-end 1) '(font-lock-face info-emphasis))))))

        ;; Fontify HEADER LINE
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^File: \\([^,: \t]+\\),?[ \t]+"))
          (put-text-property (match-beginning 1) (match-end 1) 'font-lock-face 'info-file))
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^\\(File: [^,: \t]+,?[ \t]+\\)?"))
          (while (looking-at "[ \t]*\\([^:, \t\n]+\\):[ \t]+\\([^:,\t\n]+\\),?")
            (goto-char (match-end 0))
            (let* ((nbeg  (match-beginning 2))
                   (nend  (match-end 2))
                   (tbeg  (match-beginning 1))
                   (tag   (match-string 1)))
              (if (string-equal (downcase tag) "node")
                  (put-text-property nbeg nend 'font-lock-face 'info-header-node)
                (put-text-property nbeg nend 'font-lock-face 'info-header-xref)
                (put-text-property tbeg nend 'mouse-face 'highlight)
                (put-text-property tbeg nend
                                   'help-echo (concat "mouse-2: Go to node " (buffer-substring nbeg nend)))
                ;; Always set up the text property keymap.
                ;; It will either be used in the buffer
                ;; or copied in the header line.
                (put-text-property tbeg nend 'keymap
                                   (cond
                                    ((string-equal (downcase tag) "prev") Info-prev-link-keymap)
                                    ((string-equal (downcase tag) "next") Info-next-link-keymap)
                                    ((string-equal (downcase tag) "up"  ) Info-up-link-keymap))))))

          ;; Treat header line.
          (when Info-use-header-line
            (goto-char (point-min))
            (let* ((header-end  (line-end-position))
                   (header
                    ;; If we find neither Next: nor Prev: link, show the entire
                    ;; node header.  Otherwise, don't show the File: and Node:
                    ;; parts, to avoid wasting precious space on information that
                    ;; is available in the mode line.
                    (if (re-search-forward "\\(next\\|up\\|prev[ious]*\\): " header-end t)
                        (progn (goto-char (match-beginning 1))
                               (buffer-substring (point) header-end))
                      (if (re-search-forward "node:[ \t]*[^ \t]+[ \t]*" header-end t)
                          (concat "No next, prev or up links  --  "
                                  (buffer-substring (point) header-end))
                        (buffer-substring (point) header-end)))))
              (put-text-property (point-min) (1+ (point-min))
                                 'header-line (replace-regexp-in-string
                                               "%"
                                               ;; Preserve text properties on duplicated `%'.
                                               (lambda (s) (concat s s)) header))
              ;; Hide the part of the first line that is in the header, if it is just part.
              (cond ((and Info-breadcrumbs-in-header-flag  (> Info-breadcrumbs-depth 0))
                     (let ((ov (make-overlay (point-min) (1+ header-end))))
                       (overlay-put ov 'display (Info-breadcrumbs))
                       (overlay-put ov 'evaporate t)))
                    ((not (bobp))
                     ;; Hide the punctuation at the end, too.
                     (skip-chars-backward " \t,")
                     (put-text-property (point) header-end 'invisible t))))))

        ;; Fontify INDENTED TEXT (e.g. code blocks, ASCII diagrams).
        (goto-char (point-min))
        (when (and Info-fontify-indented-text-chars  (not (equal "Top" Info-current-node)))
          (Info-fontify-indented-text))

        ;; Fontify QUOTATIONS: ‘...’, `...', “...”, and "..."
        (goto-char (point-min))
        (when Info-fontify-quotations (Info-fontify-quotations))

        ;; Fontify CUSTOM-DELIMITED: text between custom delimiters
        (goto-char (point-min))
        (when (car Info-fontify-custom-delimited) (Info-fontify-custom-delimited))

        ;; Fontify EXTRA: something else
        (when Info-fontify-extra-function
          (goto-char (point-min))
          (funcall Info-fontify-extra-function))

        ;; Fontify REFERENCE ITEMS: `-- Function:', `-- Variable:', etc.
        (goto-char (point-min))
        (when Info-fontify-reference-items-flag (Info-fontify-reference-items))

        ;; Fontify TITLES
        (goto-char (point-min))
        (when (and font-lock-mode  not-fontified-p)
          (while (and (re-search-forward "\n\\([^ \t\n].+\\)\n\\(\\*\\*+\\|==+\\|--+\\|\\.\\.+\\)$" nil t)
                      ;; Only consider it as an underlined title if the ASCII underline has the same size as the
                      ;; text.  A typical counter example is when a continuation "..." is alone on a line.
                      (= (string-width (match-string 1)) (string-width (match-string 2))))
            (let* ((c     (preceding-char))
                   (face  (cond ((= c ?*) 'info-title-1)
                                ((= c ?=) 'info-title-2)
                                ((= c ?-) 'info-title-3)
                                (t        'info-title-4))))
              (put-text-property (match-beginning 1) (match-end 1)
                                 'font-lock-face face))
            ;; This is a serious problem for trying to handle multiple
            ;; frame types at once.  We want this text to be invisible
            ;; on frames that can display the font above.
            (when (memq (framep (selected-frame)) '(x pc w32 ns))
              (add-text-properties (1- (match-beginning 2)) (match-end 2)
                                   '(invisible t front-sticky nil rear-nonsticky t)))))

        ;; Fontify CROSS REFERENCES
        (goto-char (point-min))
        (when (or not-fontified-p  fontify-visited-p)
          (while (re-search-forward
                  "\\(\\*Note[ \n\t]+\\)\\([^:]*\\)\\(:[ \t]*\\([^.,:(]*\\)\\(\\(([^)]\
,*)\\)[^.,:]*\\)?[,:]?\n?\\)"
                  nil t)
            (let ((start  (match-beginning 0))
                  (next   (point))
                  other-tag)
              (when not-fontified-p
                (when Info-hide-note-references
                  (when (and (not (eq Info-hide-note-references 'hide))
                             (> (line-number-at-pos) 4)) ; Skip breadcrumbs
                    ;; *Note is often used where *note should have been
                    (goto-char start)
                    (skip-syntax-backward " ")
                    (when (memq (char-before) '(?\( ?\[ ?\{))
                      (skip-syntax-backward " (")) ; Check whether the paren is preceded by an end of sentence
                    (setq other-tag  (cond ((save-match-data (looking-back "\\<see" nil)) "")
                                           ((save-match-data (looking-back "\\<in" nil)) "")
                                           ((memq (char-before) '(nil ?\. ?! ??)) "See ")
                                           ((save-match-data (save-excursion (search-forward "\n\n" start t)))
                                            "See ")
                                           (t "see "))))
                  (goto-char next)
                  (add-text-properties
                   (match-beginning 1)
                   (or (save-match-data
                         (let ((start1  (match-beginning 1))) ; Don't hide \n after *Note
                           (and (string-match "\n" (match-string 1))  (+ start1 (match-beginning 0)))))
                       (match-end 1))
                   (if other-tag
                       `(display ,other-tag front-sticky nil rear-nonsticky t)
                     '(invisible t front-sticky nil rear-nonsticky t))))
                (add-text-properties
                 (match-beginning 2) (match-end 2)
                 (list 'help-echo (if (or (match-end 5)  (not (equal (match-string 4) "")))
                                      (concat "mouse-2: go to " (or (match-string 5)  (match-string 4)))
                                    "mouse-2: go to this node")
                       'mouse-face 'highlight)))
              (when (or not-fontified-p  fontify-visited-p)
                (setq rbeg  (match-beginning 2)
                      rend  (match-end 2))
                (put-text-property
                 rbeg
                 rend
                 'font-lock-face
                 (if (and Info-fontify-visited-nodes ; Display visited nodes in a different face
                          (save-match-data
                            (let* ((node             (replace-regexp-in-string
                                                      "^[ \t]+" ""
                                                      (replace-regexp-in-string
                                                       "[ \t\n]+" " "
                                                       (or (match-string-no-properties 5)
                                                           (and (not (equal (match-string 4) ""))
                                                                (match-string-no-properties 4))
                                                           (match-string-no-properties 2)))))
                                   (external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                   (file             (if external-link-p
                                                         (file-name-nondirectory
                                                          (match-string-no-properties 1 node))
                                                       Info-current-file))
                                   (hl               Info-history-list)
                                   res)
                              (when external-link-p
                                (setq node  (if (equal (match-string 2 node) "")
                                                "Top"
                                              (match-string-no-properties 2 node))))
                              (while hl
                                (if (and (string-equal node (nth 1 (car hl)))
                                         (equal file (if (and external-link-p  (stringp (caar hl)))
                                                         (file-name-nondirectory (caar hl))
                                                       (caar hl))))
                                    (setq res  (car hl)
                                          hl   nil)
                                  (setq hl  (cdr hl))))
                              res)))
                     'info-xref-visited
                   'info-xref))
                (save-excursion ; For multiline ref, unfontify newline and surrounding whitespace
                  (goto-char rbeg)
                  (save-match-data
                    (while (re-search-forward "\\s-*\n\\s-*" rend t nil)
                      (remove-text-properties (match-beginning 0) (match-end 0) '(font-lock-face t))))))
              (when not-fontified-p
                (when (memq Info-hide-note-references '(t hide))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t front-sticky nil rear-nonsticky t))
                  ;; Unhide the file name of the external reference in parens
                  (when (and (match-string 6)  (not (eq Info-hide-note-references 'hide)))
                    (remove-text-properties (match-beginning 6) (match-end 6)
                                            '(invisible t front-sticky nil rear-nonsticky t)))
                  (save-match-data ; Unhide newline because hidden newlines cause too long lines
                    (let ((beg3  (match-beginning 3))
                          (end3  (match-end 3)))
                      (when (and (string-match "\n[ \t]*" (match-string 3))
                                 (not (save-match-data (save-excursion (goto-char (1+ end3))
                                                                       (looking-at "[.)]*$")))))
                        (remove-text-properties (+ beg3 (match-beginning 0))
                                                (+ beg3 (match-end 0))
                                                '(invisible t front-sticky nil rear-nonsticky t))))))
                (when (and Info-refill-paragraphs  Info-hide-note-references)
                  (push (set-marker (make-marker) start) paragraph-markers))))))

        ;; REFILL PARAGRAPHS (experimental feature)
        (when (and not-fontified-p  Info-refill-paragraphs  paragraph-markers)
          (let ((fill-nobreak-invisible          t)
                (fill-individual-varying-indent  nil)
                (paragraph-start                 "\f\\|[ \t]*[-*]\\|[ \t]*$")
                (paragraph-separate              ".*\\.[ \t]*\n[ \t]\\|[ \t]*[-*]\\|[ \t\f]*$")
                (adaptive-fill-mode              nil))
            (goto-char (point-max))
            (dolist (m  paragraph-markers)
              (when (< m (point))
                (goto-char m)
                (beginning-of-line)
                (let ((beg  (point)))
                  (when (zerop (forward-paragraph))
                    (fill-individual-paragraphs beg (point) nil nil)
                    (goto-char beg))))
              (set-marker m nil))))

        ;; Fontify MENU ITEMS
        (goto-char (point-min))
        (when (and (or not-fontified-p  fontify-visited-p)
                   (search-forward "\n* Menu:" nil t)
                   Info-fontify-maximum-menu-size ; Don't take time to annotate huge menus
                   (< (- (point-max) (point)) Info-fontify-maximum-menu-size))
          (let ((n  0)
                cont)
            (while (re-search-forward
                    (concat "^\\* Menu:\\|\\(?:^\\* +\\(" Info-menu-entry-name-re "\\)\\(:"
                            Info-node-spec-re "\\([ \t]*\\)\\)\\)")
                    nil t)
              (when (match-beginning 1)
                (when not-fontified-p
                  (setq n  (1+ n))
                  (if (and (<= n 9)  (zerop (% n 3))) ; visual aids to help with 1-9 keys
                      (put-text-property (match-beginning 0) (1+ (match-beginning 0))
                                         'font-lock-face 'info-menu-star)))
                (when not-fontified-p
                  (add-text-properties
                   (match-beginning 1) (match-end 1)
                   (list 'help-echo (if (and (match-end 3)  (not (equal (match-string 3) "")))
                                        (concat "mouse-2: go to " (match-string 3))
                                      "mouse-2: go to this node")
                         'mouse-face 'highlight)))
                (when (or not-fontified-p  fontify-visited-p)
                  (put-text-property
                   (match-beginning 1) (match-end 1)
                   'font-lock-face
                   (if (and Info-fontify-visited-nodes ; Display visited menu items in a different face
                            (save-match-data
                              (let* ((node             (if (equal (match-string 3) "")
                                                           (match-string-no-properties 1)
                                                         (match-string-no-properties 3)))
                                     (external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                     (file             (if external-link-p
                                                           (file-name-nondirectory
                                                            (match-string-no-properties 1 node))
                                                         Info-current-file))
                                     (hl               Info-history-list)
                                     res)
                                (when external-link-p
                                  (setq node  (if (equal (match-string 2 node) "")
                                                  "Top"
                                                (match-string-no-properties 2 node))))
                                (while hl
                                  (if (and (string-equal node (nth 1 (car hl)))
                                           (equal file (if (and external-link-p  (stringp (caar hl)))
                                                           (file-name-nondirectory (caar hl))
                                                         (caar hl))))
                                      (setq res  (car hl)
                                            hl   nil)
                                    (setq hl  (cdr hl))))
                                res)))
                       'info-xref-visited
                     'info-xref)))
                (when (and not-fontified-p
                           (memq Info-hide-note-references '(t hide))
                           (not (Info-index-node)))
                  (put-text-property (match-beginning 2) (1- (match-end 6)) 'invisible t)
                  ;; Unhide the file name in parens
                  (if (and (match-end 4)  (not (eq (char-after (match-end 4)) ?.)))
                      (remove-text-properties (match-beginning 4) (match-end 4) '(invisible t)))
                  ;; We need a stretchable space like :align-to but with a minimum value.
                  (put-text-property (1- (match-end 6)) (match-end 6) 'display
                                     (if (>= 22 (- (match-end 1) (match-beginning 0)))
                                         '(space :align-to 24)
                                       '(space :width 2)))
                  (setq cont  (looking-at "."))
                  (while (and (= (forward-line 1) 0)  (looking-at "\\([ \t]+\\)[^*\n]"))
                    (put-text-property (match-beginning 1) (1- (match-end 1)) 'invisible t)
                    (put-text-property (1- (match-end 1)) (match-end 1) 'display (if cont
                                                                                     '(space :align-to 26)
                                                                                   '(space :align-to 24)))
                    (setq cont  t)))))))

        ;; Fontify GLOSSARY WORDS
        ;;
        ;; Do this AFTER fontifying menu items and references.
        (goto-char (point-min))
        (forward-line 4)
        (when Info-fontify-glossary-words (Info-fontify-glossary-words))

        ;; Fontify MENU HEADERS
        (goto-char (point-min))
        ;; Add face `info-menu-header' to any header before a menu entry
        (when (and not-fontified-p  (re-search-forward "^\\* Menu:" nil t))
          (put-text-property (match-beginning 0) (match-end 0) 'font-lock-face 'info-menu-header)
          (while (re-search-forward "\n\n\\([^*\n ].*\\)\n\n?[*]" nil t)
            (put-text-property (match-beginning 1) (match-end 1) 'font-lock-face 'info-menu-header)))

        ;; Hide index line numbers
        (goto-char (point-min))
        (when (and not-fontified-p  (Info-index-node))
          (while (re-search-forward "[ \t\n]*(line +[0-9]+)" nil t)
            (put-text-property (match-beginning 0) (match-end 0)
                               'invisible t)))

       ; ; Fontify HTTP AND FTP REFERENCES
        (goto-char (point-min))
        (when not-fontified-p
          (while (re-search-forward "\\(https?\\|ftp\\)://[^ \t\n\"`({<>})']+" nil t)
            (add-text-properties (match-beginning 0) (match-end 0)
                                 '(font-lock-face info-xref
                                                  mouse-face highlight
                                                  help-echo "mouse-2: go to this URL"))))

        ;; Hide any empty lines at the end of the node.
        (goto-char (point-max))
        (skip-chars-backward "\n")
        (when (< (1+ (point)) (point-max)) (put-text-property (1+ (point)) (point-max) 'invisible t))
        (set-buffer-modified-p nil))))

  )


;; REPLACES ORIGINAL in `info.el':
;;
;; 1. File name in face `info-file'.
;; 2. If `Info-fontify-emphasis-flag', fontify _..._.
;; 3. If `Info-fontify-indented-text-chars' then fontify text indented at least that many chars.
;; 4. If `Info-fontify-quotations', fontify ‘...’ and `...' in face `info-quoted-name',
;;    “...” in face `info-double-quoted-name', and "..." in face `info-string'.
;; 5. If `Info-fontify-quotations' and `Info-fontify-angle-bracketed-flag' then
;;    fontify <...> in face `info-quoted-name'.
;; 6. If `Info-fontify-quotations' and `Info-fontify-isolated-quote-flag' then fontify
;;    isolated ' and ` in faces `Info-isolated-quote' and `Info-isolated-backquote', respectively.
;; 7. If `Info-fontify-glossary-words' then fontify glossary words.
;;
(when (or (> emacs-major-version 24)    ; Emacs 24.2+
          (and (= emacs-major-version 24)  (> emacs-minor-version 1)))

  (defun Info-fontify-node ()
    "Fontify the node."
    (save-excursion
      (let* ((inhibit-read-only     t)
             (case-fold-search      t)
             (fontify-bookmarked-p  (and (boundp 'Info-fontify-bookmarked-xrefs-flag)
                                         Info-fontify-bookmarked-xrefs-flag))
             (node-not-too-large    (and (or fontify-bookmarked-p  Info-fontify-visited-nodes)
                                         ;; Don't take time to refontify xrefs in huge nodes
                                         Info-fontify-maximum-menu-size
                                         (or (eq t Info-fontify-maximum-menu-size)
                                             (< (- (point-max) (point-min)) Info-fontify-maximum-menu-size))))
             (fontify-bookmarked-p  (and node-not-too-large  fontify-bookmarked-p))
             (fontify-visited-p     (and node-not-too-large  Info-fontify-visited-nodes))
             (not-fontified-p       (not (let ((where  (next-single-property-change (point-min) 'font-lock-face)))
                                           (and where  (not (= where (point-max)))))))
             paragraph-markers rbeg rend)

        ;; Fontify EMPHASIS: _..._
        ;;
        ;; Do this first because it can remove existing highlighting.
        (goto-char (point-min))
        (when (and font-lock-mode  not-fontified-p)
          (while (re-search-forward Info-emphasis-regexp nil t)
            (let ((fn  (if Info-fontify-emphasis-flag #'add-text-properties #'remove-text-properties)))
              (funcall fn (match-beginning 0) (1+ (match-beginning 0))
                       '(invisible t front-sticky nil rear-nonsticky t))
              (funcall fn (1- (match-end 0)) (match-end 0)
                       '(invisible t front-sticky nil rear-nonsticky t))
              (funcall fn (match-beginning 1) (match-end 1) '(font-lock-face info-emphasis)))))

        ;; Fontify HEADER LINE
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^File: \\([^,: \t]+\\),?[ \t]+"))
          (put-text-property (match-beginning 1) (match-end 1) 'font-lock-face 'info-file))
        (goto-char (point-min))
        (when (and not-fontified-p  (looking-at "^\\(File: [^,: \t]+,?[ \t]+\\)?"))
          (while (looking-at "[ \t]*\\([^:, \t\n]+\\):[ \t]+\\([^:,\t\n]+\\),?")
            (goto-char (match-end 0))
            (let* ((nbeg  (match-beginning 2))
                   (nend  (match-end 2))
                   (tbeg  (match-beginning 1))
                   (tag   (match-string 1)))
              (if (string-equal (downcase tag) "node")
                  (put-text-property nbeg nend 'font-lock-face 'info-header-node)
                (put-text-property nbeg nend 'font-lock-face 'info-header-xref)
                (put-text-property tbeg nend 'mouse-face (if (facep 'header-line-highlight) ; Emacs 26+
                                                             'header-line-highlight
                                                           'highlight))
                (put-text-property tbeg nend
                                   'help-echo (concat "mouse-2: Go to node " (buffer-substring nbeg nend)))
                ;; Set up the text property keymap.  Depending on
                ;; `Info-use-header-line', it is either used in the
                ;; buffer, or copied to the header line.  A symbol value
                ;; of the `link-args' property is handled specially by
                ;; `Info-mouse-follow-link'.
                (put-text-property tbeg nend 'keymap Info-link-keymap)
                (put-text-property tbeg nend 'link-args (intern (downcase tag))))))
          ;; Treat header line.
          (when Info-use-header-line
            (goto-char (point-min))
            (let* ((header-end  (line-end-position))
                   (header
                    ;; If we find neither Next: nor Prev: link, show the entire
                    ;; node header.  Otherwise, don't show the File: and Node:
                    ;; parts, to avoid wasting precious space on information that
                    ;; is available in the mode line.
                    (if (re-search-forward "\\(next\\|up\\|prev[ious]*\\): " header-end t)
                        (progn (goto-char (match-beginning 1))
                               (buffer-substring (point) header-end))
                      (if (re-search-forward "node:[ \t]*[^ \t]+[ \t]*" header-end t)
                          (concat "No next, prev or up links  --  "
                                  (buffer-substring (point) header-end))
                        (buffer-substring (point) header-end)))))
              (put-text-property (point-min) (1+ (point-min))
                                 'header-line (replace-regexp-in-string
                                               "%"
                                               ;; Preserve text properties on duplicated `%'.
                                               (lambda (s) (concat s s)) header))
              ;; Hide the part of the first line that is in the header, if it is just part.
              (cond ((and Info-breadcrumbs-in-header-flag  (> Info-breadcrumbs-depth 0))
                     (let ((ov  (make-overlay (point-min) (1+ header-end))))
                       (overlay-put ov 'display (Info-breadcrumbs))
                       (overlay-put ov 'evaporate t)))
                    ((not (bobp))
                     ;; Hide the punctuation at the end, too.
                     (skip-chars-backward " \t,")
                     (put-text-property (point) header-end 'invisible t)
                     ;; Hide the suffix (`.info') of the Info file name.
                     (beginning-of-line)
                     (if (re-search-forward (format "File: %s\\([^,\n\t]+\\),"
                                                    (if (stringp Info-current-file)
                                                        (file-name-nondirectory Info-current-file)
                                                      Info-current-file))
                                            header-end t)
                         (put-text-property (match-beginning 1) (match-end 1) 'invisible t)))))))

        ;; Fontify INDENTED TEXT (e.g. code blocks, ASCII diagrams).
        (goto-char (point-min))
        (when (and Info-fontify-indented-text-chars  (not (equal "Top" Info-current-node)))
          (Info-fontify-indented-text))

        ;; Fontify QUOTATIONS: ‘...’, `...', “...”, and "..."
        (goto-char (point-min))
        (when Info-fontify-quotations (Info-fontify-quotations))

        ;; Fontify CUSTOM-DELIMITED: text between custom delimiters
        (goto-char (point-min))
        (when (car Info-fontify-custom-delimited) (Info-fontify-custom-delimited))

        ;; Fontify EXTRA: something else
        (when Info-fontify-extra-function
          (goto-char (point-min))
          (funcall Info-fontify-extra-function))

        ;; Fontify REFERENCE ITEMS: `-- Function:', `-- Variable:', etc.
        (goto-char (point-min))
        (when Info-fontify-reference-items-flag (Info-fontify-reference-items))

        ;; Fontify TITLES
        (goto-char (point-min))
        (when (and font-lock-mode  not-fontified-p)
          (while (and (re-search-forward "\n\\([^ \t\n].+\\)\n\\(\\*\\*+\\|==+\\|--+\\|\\.\\.+\\)$" nil t)
                      ;; Only consider it as an underlined title if the ASCII underline has the same size as
                      ;; the text.  A typical counter example is when a continuation "..." is alone on a line.
                      (= (string-width (match-string 1)) (string-width (match-string 2))))
            (let* ((c     (preceding-char))
                   (face  (cond ((= c ?*) 'info-title-1)
                                ((= c ?=) 'info-title-2)
                                ((= c ?-) 'info-title-3)
                                (t        'info-title-4))))
              (put-text-property (match-beginning 1) (match-end 1)
                                 'font-lock-face face))
            ;; This is a serious problem for trying to handle multiple
            ;; frame types at once.  We want this text to be invisible
            ;; on frames that can display the font above.
            (when (memq (framep (selected-frame)) '(x pc w32 ns))
              (add-text-properties (1- (match-beginning 2)) (match-end 2)
                                   '(invisible t front-sticky nil rear-nonsticky t)))))

        ;; Fontify CROSS REFERENCES
        (goto-char (point-min))
        (when (or not-fontified-p  fontify-bookmarked-p  fontify-visited-p)
          (while (re-search-forward
                  "\\(\\*Note[ \n\t]+\\)\\([^:]*\\)\\(:[ \t]*\\([^.,:(]*\\)\\(\\(([^)]\
,*)\\)[^.,:]*\\)?[,:]?\n?\\)"
                  nil t)
            (let ((start  (match-beginning 0))
                  (next   (point))
                  other-tag)
              (when not-fontified-p
                (when Info-hide-note-references
                  (when (and (not (eq Info-hide-note-references 'hide))
                             (> (line-number-at-pos) 4)) ; Skip breadcrumbs
                    ;; *Note is often used where *note should have been
                    (goto-char start)
                    (skip-syntax-backward " ")
                    (when (memq (char-before) '(?\( ?\[ ?\{))
                      (skip-syntax-backward " (")) ; Check whether the paren is preceded by an end of sentence
                    (setq other-tag  (cond ((save-match-data (looking-back "\\<see" nil)) "")
                                           ((save-match-data (looking-back "\\<in" nil)) "")
                                           ((memq (char-before) '(nil ?\. ?! ??)) "See ")
                                           ((save-match-data (save-excursion (search-forward "\n\n" start t)))
                                            "See ")
                                           (t "see "))))
                  (goto-char next)
                  (add-text-properties
                   (match-beginning 1)
                   (or (save-match-data
                         (let ((start1  (match-beginning 1))) ; Don't hide \n after *Note
                           (and (string-match "\n" (match-string 1))  (+ start1 (match-beginning 0)))))
                       (match-end 1))
                   (if other-tag
                       `(display ,other-tag front-sticky nil rear-nonsticky t)
                     '(invisible t front-sticky nil rear-nonsticky t))))
                (add-text-properties
                 (match-beginning 2) (match-end 2)
                 (list 'help-echo (if (or (match-end 5)  (not (equal (match-string 4) "")))
                                      (concat "mouse-2: go to " (or (match-string 5)  (match-string 4)))
                                    "mouse-2: go to this node")
                       'mouse-face 'highlight)))
              (when (or not-fontified-p  fontify-bookmarked-p  fontify-visited-p)
                (setq rbeg  (match-beginning 2)
                      rend  (match-end 2))
                (let (node)
                  (put-text-property
                   rbeg
                   rend
                   'font-lock-face
                   (if (and (or Info-fontify-visited-nodes  fontify-bookmarked-p)
                            (save-match-data
                              (setq node  (replace-regexp-in-string
                                           "^[ \t]+" ""
                                           (replace-regexp-in-string
                                            "[ \t\n]+" " "
                                            (or (match-string-no-properties 5)
                                                (and (not (equal (match-string 4) ""))
                                                     (match-string-no-properties 4))
                                                (match-string-no-properties 2)))))
                              (let* ((external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                     (file             (if external-link-p
                                                           (file-name-nondirectory
                                                            (match-string-no-properties 1 node))
                                                         Info-current-file))
                                     (hl               Info-history-list)
                                     res)
                                (when external-link-p
                                  (setq node  (if (equal (match-string 2 node) "")
                                                  "Top"
                                                (match-string-no-properties 2 node))))
                                (or (and fontify-bookmarked-p  (Info-bookmark-name-for-node node))
                                    (progn
                                      (while hl
                                        (if (and (string-equal node (nth 1 (car hl)))
                                                 (equal file (if (and external-link-p  (stringp (caar hl)))
                                                                 (file-name-nondirectory (caar hl))
                                                               (caar hl))))
                                            (setq res  (car hl)
                                                  hl   nil)
                                          (setq hl  (cdr hl))))
                                      res)))))
                       (let ((bmk  (and fontify-bookmarked-p  (Info-bookmark-for-node node 'LOCALP))))
                         (if bmk
                             (or (bmkp-get-tag-value bmk "bmkp-info-face")  'info-xref-bookmarked)
                           'info-xref-visited))
                     'info-xref)))
                (save-excursion ; For multiline ref, unfontify newline and surrounding whitespace
                  (goto-char rbeg)
                  (save-match-data (while (re-search-forward "\\s-*\n\\s-*" rend t nil)
                                     (remove-text-properties (match-beginning 0) (match-end 0)
                                                             '(font-lock-face t))))))
              (when not-fontified-p
                (when (memq Info-hide-note-references '(t hide))
                  (add-text-properties (match-beginning 3) (match-end 3)
                                       '(invisible t front-sticky nil rear-nonsticky t))
                  ;; Unhide the file name of the external reference in parens
                  (when (and (match-string 6)  (not (eq Info-hide-note-references 'hide)))
                    (remove-text-properties (match-beginning 6) (match-end 6)
                                            '(invisible t front-sticky nil rear-nonsticky t)))
                  (save-match-data ; Unhide newline because hidden newlines cause too long lines
                    (let ((beg3  (match-beginning 3))
                          (end3  (match-end 3)))
                      (when (and (string-match "\n[ \t]*" (match-string 3))
                                 (not (save-match-data (save-excursion (goto-char (1+ end3))
                                                                       (looking-at "[.)]*$")))))
                        (remove-text-properties (+ beg3 (match-beginning 0)) (+ beg3 (match-end 0))
                                                '(invisible t front-sticky nil rear-nonsticky t))))))
                (when (and Info-refill-paragraphs  Info-hide-note-references)
                  (push (set-marker (make-marker) start) paragraph-markers))))))

        ;; REFILL PARAGRAPHS (experimental feature)
        (when (and not-fontified-p  Info-refill-paragraphs  paragraph-markers)
          (let ((fill-nobreak-invisible          t)
                (fill-individual-varying-indent  nil)
                (paragraph-start                 "\f\\|[ \t]*[-*]\\|[ \t]*$")
                (paragraph-separate              ".*\\.[ \t]*\n[ \t]\\|[ \t]*[-*]\\|[ \t\f]*$")
                (adaptive-fill-mode              nil))
            (goto-char (point-max))
            (dolist (m  paragraph-markers)
              (when (< m (point))
                (goto-char m)
                (beginning-of-line)
                (let ((beg  (point)))
                  (when (zerop (forward-paragraph))
                    (fill-individual-paragraphs beg (point) nil nil)
                    (goto-char beg))))
              (set-marker m nil))))

        ;; Fontify MENU ITEMS
        (goto-char (point-min))
        (when (and (or not-fontified-p  fontify-bookmarked-p  fontify-visited-p)
                   (search-forward "\n* Menu:" nil t)
                   Info-fontify-maximum-menu-size ; Don't take time to annotate huge menus
                   (or (eq t Info-fontify-maximum-menu-size)
                       (< (- (point-max) (point)) Info-fontify-maximum-menu-size)))
          (let ((n  0)
                cont)
            (while (re-search-forward (concat "^\\* Menu:\\|\\(?:^\\* +\\(" Info-menu-entry-name-re "\\)\\(:"
                                              Info-node-spec-re "\\([ \t]*\\)\\)\\)")
                                      nil t)
              (when (match-beginning 1)
                (when not-fontified-p
                  (setq n  (1+ n))
                  (when (and (<= n 9)  (zerop (% n 3))) ; visual aids to help with 1-9 keys
                    (put-text-property (match-beginning 0) (1+ (match-beginning 0))
                                       'font-lock-face 'info-menu-star)))
                (when not-fontified-p
                  (add-text-properties (match-beginning 1) (match-end 1)
                                       (list 'help-echo (if (and (match-end 3)
                                                                 (not (equal (match-string 3) "")))
                                                            (concat "mouse-2: go to " (match-string 3))
                                                          "mouse-2: go to this node")
                                             'mouse-face 'highlight)))
                (when (or not-fontified-p  fontify-bookmarked-p  fontify-visited-p)
                  (let (node)
                    (put-text-property
                     (match-beginning 1) (match-end 1)
                     'font-lock-face
                     (if (and (or Info-fontify-visited-nodes  fontify-bookmarked-p)
                              (save-match-data
                                (setq node  (if (equal (match-string 3) "")
                                                (match-string-no-properties 1)
                                              (match-string-no-properties 3)))
                                (let* ((external-link-p  (string-match "(\\([^)]+\\))\\([^)]*\\)" node))
                                       (file             (if external-link-p
                                                             (file-name-nondirectory
                                                              (match-string-no-properties 1 node))
                                                           Info-current-file))
                                       (hl               Info-history-list)
                                       res)
                                  (when external-link-p
                                    (setq node  (if (equal (match-string 2 node) "")
                                                    "Top"
                                                  (match-string-no-properties 2 node))))
                                  (or (and fontify-bookmarked-p  (Info-bookmark-name-for-node node))
                                      (progn
                                        (while hl
                                          (if (and (string-equal node (nth 1 (car hl)))
                                                   (equal file (if (and external-link-p  (stringp (caar hl)))
                                                                   (file-name-nondirectory (caar hl))
                                                                 (caar hl))))
                                              (setq res  (car hl)
                                                    hl   nil)
                                            (setq hl  (cdr hl))))
                                        res)))))
                         (let ((bmk  (and fontify-bookmarked-p  (Info-bookmark-for-node node 'LOCALP))))
                           (if bmk
                               (or (bmkp-get-tag-value bmk "bmkp-info-face")  'info-xref-bookmarked)
                             'info-xref-visited))
                       'info-xref))))
                (when (and not-fontified-p
                           (memq Info-hide-note-references '(t hide))
                           (not (Info-index-node)))
                  (put-text-property (match-beginning 2) (1- (match-end 6)) 'invisible t)
                  ;; Unhide the file name in parens
                  (if (and (match-end 4)  (not (eq (char-after (match-end 4)) ?.)))
                      (remove-text-properties (match-beginning 4) (match-end 4)
                                              '(invisible t)))
                  ;; We need a stretchable space like :align-to but with a minimum value.
                  (put-text-property (1- (match-end 6)) (match-end 6) 'display (if (>= 22
                                                                                       (- (match-end 1)
                                                                                          (match-beginning 0)))
                                                                                   '(space :align-to 24)
                                                                                 '(space :width 2)))
                  (setq cont  (looking-at "."))
                  (while (and (= (forward-line 1) 0)  (looking-at "\\([ \t]+\\)[^*\n]"))
                    (put-text-property (match-beginning 1) (1- (match-end 1)) 'invisible t)
                    (put-text-property (1- (match-end 1)) (match-end 1) 'display (if cont
                                                                                     '(space :align-to 26)
                                                                                   '(space :align-to 24)))
                    (setq cont  t)))))))

        ;; Fontify GLOSSARY WORDS
        ;;
        ;; Do this AFTER fontifying menu items and references.
        (goto-char (point-min))
        (forward-line 4)
        (when Info-fontify-glossary-words (Info-fontify-glossary-words))

        ;; Fontify MENU HEADERS
        (goto-char (point-min))
        (when (and not-fontified-p ; Add face `info-menu-header' to any header before a menu entry
                   (re-search-forward "^\\* Menu:" nil t))
          (put-text-property (match-beginning 0) (match-end 0) 'font-lock-face 'info-menu-header)
          (while (re-search-forward "\n\n\\([^*\n ].*\\)\n\n?[*]" nil t)
            (put-text-property (match-beginning 1) (match-end 1) 'font-lock-face 'info-menu-header)))

        ;; Hide index line numbers
        (goto-char (point-min))
        (when (and not-fontified-p  (Info-index-node))
          (while (re-search-forward "[ \t\n]*(line +[0-9]+)" nil t)
            (put-text-property (match-beginning 0) (match-end 0) 'invisible t)))

        ;; Fontify HTTP AND FTP REFERENCES
        (goto-char (point-min))
        (when not-fontified-p
          (while (re-search-forward "\\(https?\\|ftp\\)://[^ \t\n\"`({<>})']+" nil t)
            (add-text-properties
             (match-beginning 0) (match-end 0)
             '(font-lock-face info-xref mouse-face highlight help-echo "mouse-2: go to this URL"))))

        ;; Hide any empty lines at the end of the node.
        (goto-char (point-max))
        (skip-chars-backward "\n")
        (when (< (1+ (point)) (point-max)) (put-text-property (1+ (point)) (point-max) 'invisible t))
        (set-buffer-modified-p nil))))

  )

(defun Info-fontify-glossary-words ()
  "Fontify words in current node that are defined in the glossary.
The glossary is that of the current manual, if there is one.
Otherwise, it is the glossary specified by option
`Info-glossary-fallbacks-alist', if any.

Do nothing if the current node is `dir' or if the manual has no
`Glossary' node.

Don't fontify anything in an Index.  Don't fontify a word in node
`Glossary' unless its occurrence is in a definition other than its
own."
  (unless (equal "dir"   Info-current-file)
    (let* ((manual        (file-name-sans-extension (file-name-nondirectory Info-current-file)))
           (ht-var        (intern (concat manual "-glossary-hash-table")))
           (words-here    ())
           (gloss-node-p  (equal Info-current-node "Glossary"))
           wbeg wend word def)
      (unless (and (boundp ht-var)  (hash-table-p (symbol-value ht-var)))
        (setq ht-var  (intern (concat (info-fallback-manual-for-glossary manual) "-glossary-hash-table"))))
      (when (and (boundp ht-var)
                 (hash-table-p (symbol-value ht-var)) ; Just to be safe.
                 (not (string-match-p "\\bIndex\\b" Info-current-node)))
        (while (and (not (eobp))  (forward-word))
          (setq wend  (prog1 (point) (save-excursion (backward-word) (setq wbeg  (point))))
                word  (buffer-substring wbeg wend))
          (unless (or (Info--member-string-nocase word words-here) ; Fontify only the first occurrence in node.
                      ;; Don't fontify an existing link.
                      (let ((face  (get-text-property 0 'font-lock-face word)))
                        (and face  (memq face Info-link-faces))))
            (when (and (setq def  (gethash word (symbol-value ht-var))) ; WORD is defined in the glossary.
                       (or (not gloss-node-p)
                           (let ((case-fold-search  t)) ; Node is `Glossary'.  Fontify WORD only if in diff def.
                             (save-excursion
                               (forward-line 0)
                               (when (looking-at-p "[ ]+") ; Inside a definition
                                 (while (looking-at-p "[ ]+") (forward-line -1))
                                 (not (string-match-p ; Don't fontify if term being defined matches WORD.
                                       (buffer-substring (line-beginning-position) (line-end-position))
                                       word)))))))
              (setq words-here  (cons word words-here))
              (let ((link-echo  "mouse-2: go to Glossary entry for this word"))
                (add-text-properties
                 wbeg wend
                 (list 'help-echo (if (eq Info-fontify-glossary-words 'link-only)
                                      link-echo
                                    ;; Need to put `link-echo' before `def', because for the text to magically
                                    ;; change from `mouse-2' to `mouse-1' due to `mouse-1-click-follows-link'
                                    ;; the text needs to start with `mouse-2'.  This is an undocumented "feature".
                                    (concat link-echo "\n\n" def))
                       'font-lock-face 'info-glossary-word
                       'mouse-face 'highlight
                       'keymap info-glossary-link-map))))))))))

(defun Info-fontify-indented-text ()
  "Fontify text indented `Info-fontify-indented-text-chars' or more.
It is fontified using face `info-indented-text'."
  (let ((num  (abs Info-fontify-indented-text-chars)))
    (while (re-search-forward (format "^ \\{%d,\\}.*" num) nil 'NOERROR)
      (put-text-property (match-beginning 0) (match-end 0) 'font-lock-face 'info-indented-text))))

(if (> emacs-major-version 23) ; Emacs < 24 `cl-member' doesn't accept `:test'.  Just use dumb recursion.
    (defun Info--member-string-nocase (string list)
      "`cl-member' with `:test' as `Info-case-insensitive-string='."
      (cl-member string list :test #'Info-case-insensitive-string=))
  (defun Info--member-string-nocase (string list)
    "`cl-member' with `:test' as `Info-case-insensitive-string='.
But usable with Emacs < 24 too."
    (let ((lst  list))
      (and list  (if (Info-case-insensitive-string= string (car lst))
                     lst
                   (Info--member-string-nocase string (cdr lst)))))))

;;;###autoload (autoload 'Info-goto-glossary-definition "info+")
(defun Info-goto-glossary-definition (&optional event)
  "Go to definition of glossary word indicated by `mouse-2' or `RET'."
  (interactive (list last-nonmenu-event))
  (goto-char (posn-point (event-start event)))
  (let ((word  (word-at-point)))
    (ignore-errors
      (Info-goto-node (format "(%s)Glossary" (file-name-sans-extension
                                              (file-name-nondirectory
                                               (info-fallback-manual-for-glossary Info-current-file)))))
      (goto-char (point-min))
      (forward-line 4)
      (let ((case-fold-search  t)) (re-search-forward (format "^%s$" word) nil t)))))

;;;###autoload (autoload 'Info-glossary "info+")
(defun Info-glossary (term)
  "Look up a string TERM in glossary for this manual, and go to it.
If there are no exact matches for TERM, choose the first term that has
TERM as a case-insensitive substring.
Use an empty TERM name to go to the `Glossary' node itself."
  (interactive
   (progn
     (unless (derived-mode-p 'Info-mode)   (info-user-error "You must be in Info to use this command"))
     (when (equal Info-current-file "dir")
       (info-user-error "The Info directory node has no glossary; use `m' to select a manual"))
     (list (let ((completion-ignore-case  t))
             (condition-case nil
                 (completing-read
                  "Glossary term: "
                  (eval (intern (concat (file-name-sans-extension (file-name-nondirectory Info-current-file))
                                        "-glossary-hash-table"))))
               (error (error "Manual `%s' has no glossary"
                             (file-name-sans-extension (file-name-nondirectory Info-current-file)))))))))
  (condition-case nil
      (Info-goto-node "Glossary")
    (error (error "Manual `%s' has no glossary"
                  (file-name-sans-extension (file-name-nondirectory Info-current-file)))))
  (goto-char (point-min))
  (forward-line 4)
  (let ((case-fold-search  t)) (re-search-forward (format "^%s$" term) nil t)))

;;;###autoload (autoload 'Info-set-breadcrumbs-depth "info+")
(defun Info-set-breadcrumbs-depth ()
  "Set current breadcrumbs depth.
Update breadcrumbs display in mode line accordingly.
You are prompted for the depth value."
  (interactive)
  (setq Info-breadcrumbs-depth-internal  (read-number "New breadcrumbs depth: "
                                                      Info-breadcrumbs-depth-internal))
  (when Info-breadcrumbs-in-mode-line-mode (Info-insert-breadcrumbs-in-mode-line)))

(defun Info-fontify-quotations ()
  "Fontify ‘...’, `...', “...”, \"...\", <...>, and isolated ' and `.
Fontify <...> only if `Info-fontify-angle-bracketed-flag'.
Fontify isolated ' and ` only if `Info-fontify-isolated-quote-flag'.

This respects option `Info-fontify-quotations'.

 ‘...’, `...', and <...> use face `info-quoted-name'.
 “...”\t uses face `info-double-quoted-name'.
 \"...\"\t uses face `info-string'.
 '\t uses face `info-single-quote'."
  (let ((regexp    (if (eq Info-fontify-quotations 'multiline)
                       (if Info-fontify-angle-bracketed-flag
                           info-quoted+<>-regexp
                         info-quotation-regexp)
                     (if Info-fontify-angle-bracketed-flag
                         info-quoted+<>-same-line-regexp
                       info-quotation-same-line-regexp)))
        (property  'font-lock-face))
    (while (ignore-errors (re-search-forward regexp nil t))
      (cond ((and (eq (aref (match-string 0) 0) ?`) ; Single-quote wrapped backslashes: `\', `\\', `\\\', etc.
                  (goto-char (match-beginning 0))
                  (save-match-data (looking-at "\\(`\\\\+'\\)")))
             (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) property 'info-quoted-name)
             (goto-char (match-end 0)))
            ((and (eq (aref (match-string 0) 0) ?‘) ; Single-quote wrapped backslashes:
                  (goto-char (match-beginning 0)) ; ‘\’, ‘\\’, ‘\\\’, etc.
                  (save-match-data (looking-at "\\(‘\\\\+’\\)")))
             (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) property 'info-quoted-name)
             (goto-char (match-end 0)))
            ((and (memq (aref (match-string 0) 0) '(?` ?‘)) ; ‘...’, `...'
                  (goto-char (match-beginning 0)) ; If ` or ‘ is preceded by \, then skip it
                  (< (save-excursion (skip-chars-backward "\\\\")) 0))
             (goto-char (1+ (match-beginning 0))))
            ((and Info-fontify-angle-bracketed-flag
                  (eq ?< (aref (match-string 0) 0)) ; <...>: If < is preceded by \, then skip it
                  (goto-char (match-beginning 0))
                  (< (save-excursion (skip-chars-backward "\\\\")) 0))
             (goto-char (1+ (match-beginning 0))))
            ((memq (aref (match-string 0) 0) '(?` ?‘)) ; ‘...’, `...'
             (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) property 'info-quoted-name)
             (goto-char (match-end 0)) (forward-char 1))
            ((and Info-fontify-angle-bracketed-flag
                  (eq ?< (aref (match-string 0) 0))) ; <...>
             (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) property 'info-quoted-name)
             (goto-char (match-end 0)) (forward-char 1))
            ((eq (aref (match-string 0) 0) ?“) ; “...”
             (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) property 'info-double-quoted-name)
             (goto-char (match-end 0)) (forward-char 1))
            ;; Don't try to handle strings correctly.  Check only the first " for being escaped.
            ;; The second " ends the match, even if it is escaped (odd number of \s before it).
            ((and (goto-char (match-beginning 0)) ; "...": If " preceded by \, then skip it
                  (< (save-excursion (skip-chars-backward "\\\\")) 0))
             (goto-char (1+ (match-beginning 0))))
            ((and (not (string= "'" (buffer-substring (match-beginning 0) (match-end 0)))) ; "..."
                  (not (string= "’" (buffer-substring (match-beginning 0) (match-end 0)))))
             (put-text-property (match-beginning 0) (match-end 0) property 'info-string)
             (goto-char (match-end 0)) (forward-char 1))
            (t
             (goto-char (match-end 0)) (forward-char 1))))
    (when Info-fontify-isolated-quote-flag
      (goto-char (point-min))
      (while (ignore-errors (re-search-forward info-isolated-quote-regexp nil t))
        (put-text-property (1- (match-end 0)) (match-end 0) property 'info-isolated-quote)
        (goto-char (match-end 0)) (forward-char 1))
      (goto-char (point-min))
      (while (ignore-errors nil (re-search-forward info-isolated-backquote-regexp nil t))
        (put-text-property (match-beginning 0) (1+ (match-beginning 0)) property 'info-isolated-backquote)
        (goto-char (match-end 0)) (forward-char 1)))))

(defun Info-fontify-custom-delimited ()
  "Fontify text between custom delimiters."
  (while (ignore-errors (re-search-forward info-custom-delimited-same-line-regexp nil t))
    (put-text-property (1+ (match-beginning 0)) (1- (match-end 0)) 'font-lock-face 'info-custom-delimited)
    (goto-char (match-end 0)) (forward-char 1)))

(defun Info-fontify-reference-items ()
  "Fontify reference items such as \"Function:\" in Info buffer."
  (while (re-search-forward "^ --? \\(Command:\\|Constant:\\|Function:\\|Macro:\\|Special Form:\\|\
Syntax class:\\|User Option:\\|Variable:\\)\\(.*\\)\\(\n          \\(.*\\)\\)*"
                            nil t)
    (let ((symb  (intern (match-string 1))))
      (put-text-property (match-beginning 1) (match-end 1)
                         'font-lock-face (case symb
                                           ('Constant:       'info-constant-ref-item)
                                           ('Command:        'info-command-ref-item)
                                           ('Function:       'info-function-ref-item)
                                           ('Macro:          'info-macro-ref-item)
                                           ('Special\ Form:  'info-special-form-ref-item)
                                           ('Syntax\ class:  'info-syntax-class-item)
                                           ('User\ Option:   'info-user-option-ref-item)
                                           ('Variable:       'info-variable-ref-item)))
      (put-text-property (match-beginning 2) (match-end 2)
                         'font-lock-face 'info-reference-item)
      (when (match-beginning 4)
        (put-text-property (match-beginning 4) (match-end 4)
                           'font-lock-face 'info-reference-item)))))


(defun Info-search-beg () ;; `isearchp-reg-beg' is defined in library `isearch+.el' for Emacs 24.3+.
  "`isearchp-reg-beg', if defined and non-nil; else `point-min'."
  (or (and (boundp 'isearchp-reg-beg)  isearchp-reg-beg)  (point-min)))

(defun Info-search-end () ;; `isearchp-reg-end' is defined in library `isearch+.el' for Emacs 24.3+.
  "`isearchp-reg-end', if defined and non-nil; else `point-max'."
  (or (and (boundp 'isearchp-reg-end)  isearchp-reg-end)  (point-max)))

(defun Info-isearch-search-p ()
  "Return non-nil if isearch in Info searches through multiple nodes.
\(Returns nil if search is restricted to the active region.)"
  (and Info-isearch-search  (or (not (boundp 'isearchp-reg-beg))  (not isearchp-reg-beg))))


;; REPLACES ORIGINAL in `info.el':
;;
;; Use `Info-isearch-search-p', not var `Info-isearch-search'.
;;
(defun Info-isearch-wrap ()
  (if (not (Info-isearch-search-p))
      (goto-char (if isearch-forward (Info-search-beg) (Info-search-end)))
    (if (not Info-isearch-initial-node)
        (setq Info-isearch-initial-node  Info-current-node
              isearch-wrapped            nil)
      (if isearch-forward (Info-top-node) (Info-final-node))
      (goto-char (if isearch-forward (Info-search-beg) (Info-search-end))))))


;; REPLACES ORIGINAL in `info.el':
;;
;; Use `Info-isearch-search-p', not var `Info-isearch-search'.
;;
(when (= emacs-major-version 23)        ; Emacs 23 only
  (defun Info-isearch-search () ; Use `Info-isearch-search-p', not var `Info-isearch-search'.
    (if (Info-isearch-search-p)
        (lambda (string &optional bound noerror count)
          (if isearch-word
              (Info-search (concat "\\b" (replace-regexp-in-string "\\W+" "\\W+"
                                                                   (replace-regexp-in-string
                                                                    "^\\W+\\|\\W+$" "" string)
                                                                   nil t)
                                   (and (or isearch-nonincremental ; Lax version of word search
                                            (eq (length string) (length (isearch-string-state
                                                                         (car isearch-cmds)))))
                                        "\\b"))
                           bound noerror count (unless isearch-forward 'backward))
            (Info-search (if isearch-regexp string (regexp-quote string))
                         bound noerror count (unless isearch-forward 'backward)))
          (point))
      (let ((isearch-search-fun-function  nil)) (isearch-search-fun)))))


(when (> emacs-major-version 23)        ; Emacs 24+

  (unless (boundp 'isearch-lax-whitespace) ; Emacs 24.1, 24.2.

    (defvar isearch-lax-whitespace t
      "If non-nil, a space will match a sequence of whitespace chars.
When you enter a space or spaces in ordinary incremental search, it
will match any sequence matched by the regexp defined by the variable
`search-whitespace-regexp'.  If the value is nil, each space you type
matches literally, against one space.  You can toggle the value of this
variable by the command `isearch-toggle-lax-whitespace'.")

    (defvar isearch-regexp-lax-whitespace nil
      "If non-nil, a space will match a sequence of whitespace chars.
When you enter a space or spaces in regexp incremental search, it
will match any sequence matched by the regexp defined by the variable
`search-whitespace-regexp'.  If the value is nil, each space you type
matches literally, against one space.  You can toggle the value of this
variable by the command `isearch-toggle-lax-whitespace'.")

    )



  ;; REPLACES ORIGINAL in `info.el':
  ;;
  ;; 1. Use function `Info-isearch-search-p', not variable `Info-isearch-search'.
  ;; 2.
  ;;
  (defun Info-isearch-search ()
    (if (Info-isearch-search-p)
        (lambda (string &optional bound noerror count)
      (let ((isearch-symbols-fn  (if (boundp 'isearch-regexp-function)
                                         isearch-regexp-function ; Emacs 25+
                                       isearch-word)) ; Emacs 24
                (Info-search-whitespace-regexp
             (if (if isearch-regexp
                 isearch-regexp-lax-whitespace
               isearch-lax-whitespace)
             search-whitespace-regexp)))
        (Info-search
         (cond (isearch-symbols-fn
                    ;; Lax version of word search
                (let ((lax  (if (fboundp 'isearch--lax-regexp-function-p)
                                    (and (not bound)  (isearch--lax-regexp-function-p)) ; Emacs 25+
                                  (not (or isearch-nonincremental ; Emacs 24
                                           (eq (length string)
                                               (length (isearch--state-string (car isearch-cmds)))))))))
                  (when lax (setq isearch-adjusted  t))
                  (if (functionp isearch-symbols-fn)
                  (funcall isearch-symbols-fn string lax)
                (word-search-regexp string lax))))
               (isearch-regexp string)
               (t (regexp-quote string)))
         bound noerror count (unless isearch-forward 'backward)))
      (point))
      (isearch-search-fun-default)))

  )

(defun info--user-search-failed ()      ; Needed for Emacs < 24, which doesn't have `user-search-failed'.
  "`user-search-failed', if `user-error' is defined.  Else `search-failed'."
  (if (fboundp 'user-error) 'user-search-failed 'search-failed))

;; REPLACES ORIGINAL in `info.el':
;;
;; 1. Fit frame if `one-window-p'.
;; 2. Highlight the found regexp if `search-highlight'.
;; 3. If `isearch+.el' is loaded, search only the active region if `isearchp-restrict-to-region-flag' is non-nil.
;; 4. Deactivate mark only if search moves to a different node or `isearchp-deactivate-region-flag' is non-nil.
;; 5. Use `info--user-search-failed' for compatibility with older Emacs.
;;
;;;###autoload (autoload 'Info-search "info+")
(defun Info-search (regexp &optional bound _noerror _count direction)
  "Search for REGEXP, starting from point, and select node of search hit.
If DIRECTION is `backward', search backward.
Fits frame if `one-window-p'.
Highlights current location of found regexp if `search-highlight'.

If called interactively then this is a non-incremental search.  In
that case, the search-hit highlighting remains, after the search is
over.  To remove the highlighting, just start an incremental search:
`\\[isearch-forward]'."
  (interactive
   (list (let ((prompt  (if Info-search-history
                            (format "Regexp search%s (default `%s'): "
                                    (if case-fold-search "" " case-sensitively")
                                    (car Info-search-history))
                          (format "Regexp search%s: "
                                  (if case-fold-search "" " case-sensitively")))))
           (if (fboundp 'icicle-read-string-completing)
               (icicle-read-string-completing prompt nil nil 'Info-search-history)
             (read-string prompt nil 'Info-search-history)))))
  ;; Deactivate mark later, and only if moved to new node or `isearchp-deactivate-region-flag' is non-nil.
  ;; Emacs bug #45839 now also applies this fix.
  ;; (deactivate-mark)
  (when (equal regexp "") (setq regexp  (car Info-search-history)))
  (when regexp
    (prog1
        (let* ((backward                          (eq direction 'backward))
               (onode                             Info-current-node)
               (ofile                             Info-current-file)
               (opoint                            (point))
               (opoint-min                        (Info-search-beg))
               (opoint-max                        (Info-search-end))
               (ostart                            (window-start))
               (osubfile                          Info-current-subfile)
               (found                             (save-excursion
                                                    (save-restriction
                                                      (widen)
                                                      (Info--search-cl-loop regexp bound backward))))
               (isearchp-restrict-to-region-flag  (not Info-isearch-search))) ; For `isearch+.el'.

          (setq Info-search-case-fold  case-fold-search)
          (unless (or (not isearch-mode)  (not (Info-isearch-search))
                      Info-isearch-initial-node ; `Info-isearch-initial-node' is free here.
                      bound
                      (and found  (> found opoint-min)  (< found opoint-max)))
        (signal (info--user-search-failed) (list regexp "(end of node)")))

          (unless (or found  Info-current-subfile) ; If no subfiles, give error now.
            (if isearch-mode
                (signal (info--user-search-failed) (list regexp "end of manual"))
              (let ((search-spaces-regexp  Info-search-whitespace-regexp))
                (unless (if backward
                            (re-search-backward regexp nil t)
                          (re-search-forward regexp nil t))
                  (signal (info--user-search-failed) (list regexp))))))
          (when (and bound  (not found)) (signal (info--user-search-failed) (list regexp)))
          (unless (or found  bound)
        (unwind-protect
            (let ((list  ()))       ; Try other subfiles.
              (with-current-buffer (marker-buffer Info-tag-table-marker)
            (goto-char (Info-search-beg))
            (search-forward "\n\^_\nIndirect:")
            (save-restriction
              (narrow-to-region (point) (progn (search-forward "\n\^_") (1- (point))))
              (goto-char (Info-search-beg))
              (search-forward (concat "\n" osubfile ": ")) ; Find the subfile we just searched.
              (forward-line (if backward 0 1)) ; Skip that one.
              (if backward (forward-char -1))
                      ;; Make a list of all following subfiles.
                      ;; Each elt has the form (VIRT-POSITION . SUBFILENAME).
              (while (not (if backward (bobp) (eobp)))
                (if backward
                    (re-search-backward "\\(^.*\\): [0-9]+$")
                  (re-search-forward "\\(^.*\\): [0-9]+$"))
                (goto-char (+ (match-end 1) 2))
                        (setq list  (cons (cons (+ (Info-search-beg) (read (current-buffer)))
                                                (match-string-no-properties 1))
                                          list))
                (goto-char (if backward (1- (match-beginning 0)) (1+ (match-end 0)))))
              (setq list  (nreverse list)))) ; Put in forward order.
              (while list
            (when (interactive-p) (message "Searching subfile %s..." (cdar list)))
            (Info-read-subfile (caar list))
            (when backward
                      (goto-char (Info-search-end)))
            (setq list   (cdr list)
                          found  (Info--search-cl-loop regexp nil backward))
            (when found (setq list  ())))
              (if found
              (message "")
                    (signal (info--user-search-failed) `(,regexp ,@(and isearch-mode  '("end of manual"))))))
          (unless found
                (Info-read-subfile osubfile)
                (goto-char opoint)
                (Info-select-node)
                (set-window-start (selected-window) ostart))))
          (if (and (string= osubfile Info-current-subfile)  (> found opoint-min)  (< found opoint-max))
              (goto-char found)      ; Search landed in the same node.
            (widen)
            (goto-char found)
            (save-match-data (Info-select-node)))
          ;; Deactivate only if moved to new node or `isearchp-deactivate-region-flag' is undefined or non-nil.
          ;; Emacs bug #45839 now also applies this fix, but without the Isearch+ possibility.
          (unless (and (boundp 'isearchp-deactivate-region-flag)
                       (not isearchp-deactivate-region-flag)
                       (string-equal onode Info-current-node))
            (deactivate-mark))
          ;; Highlight the regexp match.  If `isearch+.el' is loaded this can highlight subgroups.
          (when search-highlight (isearch-highlight (match-beginning 0) (match-end 0))) ; Highlight regexp.
          ;; Use `string-equal', not `equal', to ignore text props.
          (or (and (string-equal onode Info-current-node)  (equal ofile Info-current-file))
              (and isearch-mode  isearch-wrapped  (eq opoint (if isearch-forward opoint-min opoint-max)))
          (setq Info-history  (cons (list ofile onode opoint) Info-history)))
          (when (and (one-window-p t)  (not (window-minibuffer-p)) ; Fit the frame, if appropriate.
                     (fboundp 'fit-frame) ; Defined in `fit-frame.el'.
                     Info-fit-frame-flag)
            (fit-frame)))
      (when (and (interactive-p)  (not isearch-mode))
        (message (substitute-command-keys
                  "Use \\<Info-mode-map>`\\[Info-search] RET' to search again for `%s'.")
                 regexp)))))


;; REPLACES ORIGINAL in `info.el', Emacs 24+:
;;
;; Use `Info-search-beg' and `Info-search-end', not `point-min' and `point-max'.
;;
(defun Info--search-cl-loop (regexp bound backward)
  (when backward
    (narrow-to-region (save-excursion ; Hide Info file header for backward search.
                        (goto-char (Info-search-beg))
                        (search-forward "\n\^_")
                        (1- (point)))
                      (Info-search-end)))
  (let ((give-up    nil)
        (found      nil)
        (beg-found  nil))
    (while (not (or give-up  (and found  (funcall isearch-filter-predicate beg-found found))))
      (let ((search-spaces-regexp  Info-search-whitespace-regexp))
        (if (funcall (if backward #'re-search-backward #'re-search-forward) regexp bound t)
            (setq found      (point)
                  beg-found  (if backward (match-end 0) (match-beginning 0)))
          (setq give-up  t
                found    nil))))
    found))

(defun Info-search-case-sensitively-next ()
  "Search for next regexp from a previous `Info-search-case-sensitively'."
  (interactive)
  (let ((case-fold-search  Info-search-case-fold))
    (if Info-search-history
        (Info-search (car Info-search-history))
      (call-interactively #'Info-search-case-sensitively))))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-next (&optional fork)       ; `n'
  "Go to the next node of this node.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (unless (derived-mode-p 'Info-mode) (Info--pop-to-buffer-same-window "*info*"))
  (Info-goto-node (Info-extract-pointer "next") fork))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-prev (&optional fork)       ; `p'
  "Go to the previous node of this node.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (unless (derived-mode-p 'Info-mode) (Info--pop-to-buffer-same-window "*info*"))
  (Info-goto-node (Info-extract-pointer "prev[ious]*" "previous") fork))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-up (&optional same-file fork) ; `u', `^'
  "Go to the superior node of this node.
If SAME-FILE is non-nil, do not move to a different Info file.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "i\nP")
  (unless (derived-mode-p 'Info-mode) (Info--pop-to-buffer-same-window "*info*"))
  (let ((old-node  Info-current-node)
        (old-file  Info-current-file)
        (node      (Info-extract-pointer "up"))
        pp)
    (when (and same-file  (string-match "^(" node)) (error "Up node is in another Info file"))
    (Info-goto-node node fork)
    (setq pp  (point))
    (goto-char (point-min))
    (cond ((and (stringp old-file)
                (search-forward "\n* Menu:" nil t)
                (re-search-forward
                 (if (string-equal old-node "Top")
                     (concat "\n\\*[^:]+: +(" (file-name-nondirectory old-file) ")")
                   (concat "\n\\* +\\(" (regexp-quote old-node)
                           ":\\|[^:]+: +" (regexp-quote old-node) "\\)"))
                 nil t))
           (beginning-of-line)
           (if (looking-at "^\\* ") (forward-char 2)))
          (t
           (goto-char pp)
           (Info-restore-point Info-history)))))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-history-back (&optional fork) ; `l'
  "Go back in the history to the last node visited.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (unless Info-history
    (funcall (if (fboundp 'user-error) #'user-error #'error)
             "This is the first Info node you have visited"))
  (let ((history-forward  (cons (list Info-current-file Info-current-node (point))
                                Info-history-forward))
        filename nodename opoint)
    (setq filename      (caar Info-history)
          nodename      (car (cdar Info-history))
          opoint        (cadr (cdar Info-history))
          Info-history  (cdr Info-history))
    (when fork
      (set-buffer (clone-buffer (concat "*info-" (if (stringp fork) fork nodename) "*") t)))
    (Info-find-node filename nodename)
    (setq Info-history          (cdr Info-history)
          Info-history-forward  history-forward)
    (goto-char opoint)))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-history-forward (&optional fork) ; `r'
  "Go forward in the history of visited nodes.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (unless Info-history-forward
    (funcall (if (fboundp 'user-error) #'user-error #'error)
             "This is the last Info node you have visited"))
  (let ((history-forward  (cdr Info-history-forward))
        filename nodename opoint)
    (setq filename  (caar Info-history-forward)
          nodename  (car (cdar Info-history-forward))
          opoint    (cadr (cdar Info-history-forward)))
    (when fork
      (set-buffer (clone-buffer (concat "*info-" (if (stringp fork) fork nodename) "*") t)))
    (Info-find-node filename nodename)
    (setq Info-history-forward  history-forward)
    (goto-char opoint)))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-directory (&optional fork)  ; `d'
  "Go to the Info directory node.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (when fork (set-buffer (clone-buffer nil t)))
  (Info-find-node "dir" "top"))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-forward-node (&optional not-down not-up no-error fork) ; `]'
  "Go forward one node, considering all nodes as forming one sequence.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "i\ni\ni\nP")
  (goto-char (point-min))
  (forward-line 1)
  (let ((case-fold-search  t))
    ;; Three possibilities, in order of priority:
    ;;     1. Next node is in a menu in this node (but not in an index)
    ;;     2. Next node is next at same level
    ;;     3. Next node is up and next
    (cond ((and (not not-down)
                (save-excursion (search-forward "\n* menu:" nil t))
                (not (Info-index-node)))
           (Info-goto-node (Info-extract-menu-counting 1) fork)
           t)
          ((save-excursion (search-backward "next:" nil t))
           (Info-next fork)
           t)
          ((and (not not-up)
                (save-excursion (search-backward "up:" nil t))
                ;; Use `string-equal', not `equal', to ignore text properties.
                (not (string-equal (downcase (Info-extract-pointer "up")) "top")))
           (let ((old-node  Info-current-node))
             (Info-up)
             (let ((old-history  Info-history)
                   success)
               (unwind-protect
                    (setq success  (Info-forward-node t nil no-error fork))
                 (or success  (Info-goto-node old-node fork)))
               (and (boundp 'Info-history-skip-intermediate-nodes) ; Emacs 24+
                    Info-history-skip-intermediate-nodes
                    (setq Info-history  old-history)))))
          (no-error nil)
          (t (user-error "No pointer forward from this node")))))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
(defun Info-backward-node (&optional fork) ; `['
  "Go backward one node, considering all nodes as forming one sequence.
If FORK is non-nil (interactively with a prefix arg), show the node in
a new Info buffer.
If FORK is a string, it is the name to use for the new buffer."
  (interactive "P")
  (let ((prevnode          (Info-extract-pointer "prev[ious]*" t))
        (upnode            (Info-extract-pointer "up" t))
        (case-fold-search  t))
    (cond ((and upnode  (string-match "(" upnode)) (user-error "First node in file"))
          ((and upnode  (or (null prevnode)
                            ;; Use `string-equal', not `equal', to ignore text properties.
                            (string-equal (downcase prevnode) (downcase upnode))))
           (Info-up fork))
          (prevnode
           ;; If we move back at the same level, go down to find the last subnode*.
           (Info-prev fork)
           (let ((old-history  Info-history)
                 node)
             (while (and (not (Info-index-node))
                         (save-excursion (search-forward "\n* Menu:" nil t)))
               (Info-goto-node (setq node  (Info-extract-menu-counting nil))))
;;; (when fork (Info-goto-node node fork))
             (and (boundp 'Info-history-skip-intermediate-nodes) ; Emacs 24+
                  Info-history-skip-intermediate-nodes
                  (setq Info-history  old-history))))
          (t (user-error "No pointer backward from this node")))))


;; REPLACES ORIGINAL in `info.el':
;; Added optional arg FORK.
;;
;;;###autoload (autoload 'Info-mouse-follow-nearest-node "info+")
(defun Info-mouse-follow-nearest-node (click &optional fork)
  "\\<Info-mode-map>Follow a node reference near point.
Like \\[Info-menu], \\[Info-follow-reference], \\[Info-next], \\[Info-prev] or \\[Info-up] \
command, depending on where you click.
At end of the node's text, moves to the next node, or up if none.

With a prefix argument, open the node in a separate window."
  (interactive "e\nP")
  (mouse-set-point click)
  (and (not (Info-try-follow-nearest-node fork))
       (save-excursion (forward-line 1) (eobp))
       (Info-next-preorder)))


;; REPLACES ORIGINAL in `info.el':
;; Use `Info-mode-syntax-table' (bug #3312).
;; Doc string changed: displays all bindings.
;;
(defun Info-mode ()
  "Provides commands for browsing through the Info documentation tree.
Documentation in Info is divided into \"nodes\", each of which discusses
one topic and contains hyperlink references to other nodes that discuss
related topics.  Info has commands to follow the references.
The most important commands to know are: \
\\<Info-mode-map>\
`\\[Info-exit]', `\\[Info-mouse-follow-nearest-node]', `\\[Info-history-back]', and `\\[Info-search]'.

Help commands
-------------
\\[describe-mode]\tDisplay this help.
\\[Info-help]\tThe Info tutorial.  Learn about Info while using it.

Selecting other nodes (basic)
-----------------------------
\\[Info-mouse-follow-nearest-node]\tFollow a node reference you click.
\tThis works with menu items, cross references, \"Next\",
\t\"Previous\" and \"Up\" references.
\tAt end of node's text, goes to \"Next\", or \"Up\" if no \"Next\".
\\[Info-follow-nearest-node]\tLike `\\[Info-mouse-follow-nearest-node]', \
except cursor location, not mouse location.
\\[Info-history-back]\tGo back to the last node you were at. (chronological)
\\[Info-history-forward]\tGo forward to where you were before using \\[Info-history-back].
\\[Info-history]\tGo to menu of visited nodes.
\\[Info-toc]\tGo to table of contents of the current Info file.
\\[Info-index]\tLook up a topic in this file's Index and move to its node.
\\[Info-index-next]\t(comma) Go to the next match from a previous \
`\\[Info-index]' command.

Structural navigation commands
------------------------------
\\[Info-menu]\tGo to a menu item's node.  Completion available for its name.
1\tGo to first menu item's node.
2, 3, 4, 5, 6, 7, 8, 9\tGo to second...ninth menu item's node.
\\[Info-next]\tGo to this node's \"Next\" node.
\\[Info-prev]\tGo to this node's \"Previous\" node.  (*not* chronological)
\\[Info-up]\tGo \"Up\" from this node to its parent node.
\\[Info-directory]\tGo to the Info directory (root) node.
\\[Info-follow-reference]\tFollow a cross reference. Prompts for name.

Moving within a node
--------------------
\\[Info-scroll-up]\tNormally, scroll forward a full screen.
\tIf node's menu appears below cursor, go to first menu item.
\tIf node's menu appears above cursor, go to parent node.
\\[Info-scroll-down]\tNormally, scroll backward.  If beginning of buffer is \
already
\tvisible, go to previous menu entry, or up if there is none.
\\[beginning-of-buffer]\tGo to beginning of node.
\\[Info-next-reference]\tMove cursor to next cross-reference or menu item in \
this node.
\\[Info-prev-reference]\tMove cursor to previous cross-reference or menu item.

Other navigation commands
-------------------------
\\[Info-exit]\tQuit Info.
\\[Info-goto-node]\tGo to a node with a given name.
\tYou may include a filename as well, as \"(FILENAME)NODENAME\".
\\[universal-argument] \\[info]\tGo to a new Info file.  (Completion \
available.)
\\[universal-argument] N \\[info]\tOpen Info with number in buffer name: *info*<N>.
\\[Info-top-node]\tGo to first node (\"Top\") of current Info file.
\\[Info-final-node]\tGo to final node of current Info file.
\\[Info-forward-node]\tGo forward a node, considering all nodes as one \
sequence.
\\[Info-backward-node]\tGo backward a node, considering all nodes as one \
sequence.

Other commands
--------------
\\[Info-save-current-node]\tSave current node name for use by `\\[Info-virtual-book]'.
\\[Info-virtual-book]\tOpen a virtual Info book of nodes saved using `\\[Info-save-current-node]'.
\\[isearch-forward]\tIsearch this Info manual for a literal string.
\\[isearch-forward-regexp]\tIsearch this Info manual for a regexp.
\\[Info-search]\tSearch this Info manual for a regexp
\\[Info-search-case-sensitively]\tLike `\\[Info-search]', but case-sensitive.
\\[info-apropos]\tLook for a string in the indexes of all manuals.
\\[Info-copy-current-node-name]\tPut name of current info node in the kill ring.
\\[clone-buffer]\tSelect a new cloned Info buffer in another window.
\\[Info-merge-subnodes]\tIntegrate current node with nodes referred to \
in its Menu.
\tDisplay the result outside of Info.  `\\[universal-argument]': Recursively.

User options you can customize
------------------------------
`Info-fontify-quotations' -
  Fontify quoted text (‘...’, `...', “...”) and strings (\"...\").
  Cycle with \\[Info-cycle-fontify-quotations].
`Info-fontify-angle-bracketed-flag' -
  Fontify angle-bracketd names (<...>).
  Toggle with \\[Info-toggle-fontify-angle-bracketed].
`Info-fontify-isolated-quote-flag' -
  Fontify isolated quote and backquote (', `).
  Toggle with \\[Info-toggle-fontify-isolated-quote].
`Info-fontify-glossary-words' -
  Fontify and link glossary words.
  Toggle with \\[Info-toggle-fontify-glossary-words].
`Info-fontify-bookmarked-xrefs-flag' -
  Fontify references to bookmarked nodes.
  Toggle with \\[Info-toggle-fontify-bookmarked-xrefs].
  (You need library Bookmark+ for this one.)
`Info-saved-nodes' - Node names you can visit using `\\[Info-virtual-book]'.
`Info-subtree-separator' - See `Info-merge-subnodes'.

Faces you can customize
-----------------------
`info-file'   - Face used for file heading labels
`info-string' - Face used for strings (e.g. \"toto\")
`info-double-quoted-name'
              - Face used for curly double-quoted names (e.g. “toto”)
`info-quoted-name'  - Face for quoted names (e.g. ‘toto’ or `toto')
`info-single-quote' - Face used for isolated single-quote (e.g. 'foo)

These are all of the current Info Mode bindings:

\\{Info-mode-map}"
  (kill-all-local-variables)
  (setq major-mode  'Info-mode
        mode-name   "Info"
        tab-width   8)
  (use-local-map Info-mode-map)
  (add-hook 'activate-menubar-hook 'Info-menu-update nil t)
  (set-syntax-table Info-mode-syntax-table)
  (setq local-abbrev-table  text-mode-abbrev-table
        case-fold-search    t
        buffer-read-only    t)
  (make-local-variable 'Info-current-file)
  (make-local-variable 'Info-current-subfile)
  (make-local-variable 'Info-current-node)
  (make-local-variable 'Info-tag-table-marker)
  (setq Info-tag-table-marker  (make-marker))
  (make-local-variable 'Info-tag-table-buffer)
  (setq Info-tag-table-buffer  nil)
  (make-local-variable 'Info-history)
  (make-local-variable 'Info-history-forward)
  (make-local-variable 'Info-index-alternatives)
  (when Info-use-header-line     ; do not override global header lines
    (setq header-line-format  '(:eval (get-text-property (point-min) 'header-line))))
  (set (make-local-variable 'tool-bar-map) info-tool-bar-map)
  ;; This is for the sake of the invisible text we use handling titles.
  (make-local-variable 'line-move-ignore-invisible)
  (setq line-move-ignore-invisible  t)
  (make-local-variable 'desktop-save-buffer)
  (make-local-variable 'widen-automatically)
  (setq widen-automatically  nil) ; `widen-automatically' is free here.
  (setq desktop-save-buffer  'Info-desktop-buffer-misc-data)
  (add-hook 'kill-buffer-hook 'Info-kill-buffer nil t)
  (add-hook 'clone-buffer-hook 'Info-clone-buffer nil t)
  (add-hook 'change-major-mode-hook 'font-lock-defontify nil t)
  (add-hook 'isearch-mode-hook 'Info-isearch-start nil t)
  ;; The `Info-*' variables are free here.
  (set (make-local-variable 'isearch-search-fun-function) 'Info-isearch-search)
  (set (make-local-variable 'isearch-wrap-function) 'Info-isearch-wrap)
  (set (make-local-variable 'isearch-push-state-function) 'Info-isearch-push-state)
  (set (make-local-variable 'isearch-filter-predicate) 'Info-isearch-filter)
  (unless (or (> emacs-major-version 24)  (and (= emacs-major-version 24)  (> emacs-minor-version 2)))
    (set (make-local-variable 'search-whitespace-regexp) Info-search-whitespace-regexp))
  (set (make-local-variable 'revert-buffer-function) 'Info-revert-buffer-function)
  (Info-set-mode-line)
  (set (make-local-variable 'bookmark-make-record-function) 'Info-bookmark-make-record)
  (run-mode-hooks 'Info-mode-hook))


;; REPLACES ORIGINAL in `info.el':
;;
;; Respect `Info-bookmark-use-only-node-not-file-flag'.
;;
;; This code and the definition of `Info-bookmark-use-only-node-not-file-flag' are also in `bookmark+-1.el',
;; so that their feature is available if you use either `Info+' or `Bookmark+'.
;;
;; Note: This function name doesn't respect the naming convention for bookmark handler functions.
;;       This name gives the impression that this is a jump command.
;;
;;;###autoload (autoload 'Info-bookmark-jump "info+")
(defun Info-bookmark-jump (bookmark)
  "Handler function for record returned by `Info-bookmark-make-record'.
BOOKMARK is a bookmark name or a bookmark record.

If `Info-bookmark-use-only-node-not-file-flag' is nil, and the
recorded Info file is readable, then use it.  If not, then go to the
recorded Info node in the manual for the current Emacs version."
  (let* ((absfile    (bookmark-prop-get bookmark 'filename))
         (file       (if (or Info-bookmark-use-only-node-not-file-flag  (not (file-readable-p absfile)))
                         (file-name-nondirectory absfile)
                       absfile))
         (info-node  (bookmark-prop-get bookmark 'info-node))
         (buf        (save-window-excursion ; Vanilla FIXME: doesn't work with frames!
                       (Info-find-node file info-node) (current-buffer))))
    (bookmark-default-handler `("" (buffer . ,buf) . ,(bookmark-get-bookmark-record bookmark)))))


;; REPLACES ORIGINAL in `info.el':
;;
;; Use completion for inputting the manual name, for all Emacs versions 23+.
;;
;;;###autoload (autoload 'info-display-manual "info+")
(defun info-display-manual (manual)
  "Display an Info buffer displaying MANUAL.
If there is an existing Info buffer for MANUAL, display it.
Otherwise, visit the manual in a new Info buffer.

With a prefix arg (Emacs 24.4+), completion candidates are limited to
currently visited manuals."
  (interactive
   (let ((manuals  (and (fboundp 'info--manual-names)
                        (ignore-errors (info--manual-names current-prefix-arg))))) ; Arg was added in Emacs 25.
     (unless manuals
       (ignore-errors
         (with-temp-buffer
           (Info-mode)
           (Info-directory)
           (goto-char (point-min))
           (re-search-forward "\\* Menu: *\n" nil t)
           (let (manual)
             (while (re-search-forward "\\*.*: *(\\([^)]+\\))" nil t)
               ;; `add-to-list' ensures no dups in `manuals', so the `dolist' runs faster.
               (setq manual  (match-string 1))
               (set-text-properties 0 (length manual) nil manual)
               (add-to-list 'manuals (list manual)))))))
     (list (completing-read "Display manual: " manuals nil t))))
  (let ((blist             (buffer-list))
        (manual-re         (concat "\\(/\\|\\`\\)" manual "\\(\\.\\|\\'\\)"))
        (case-fold-search  t)
        found)
    (dolist (buffer blist)
      (with-current-buffer buffer
        (when (and (eq major-mode 'Info-mode)
                   (stringp Info-current-file)
                   (string-match manual-re Info-current-file))
          (setq found  buffer
                blist  ()))))
    (if found
        (Info--pop-to-buffer-same-window found)
      (info-initialize)
      (info (Info-find-file manual)))))

;;(@* "Non-Interactive Functions")
;;; Non-Interactive  Functions ---------------------------------------

(defun Info-display-node-default-header ()
  "Insert node name as header."
  ;; `infop-node-name' is free here - bound in `Info-merge-subnodes'.
  (insert (if (fboundp 'concat-w-faces)
              (concat-w-faces (list 'info-title-1 infop-node-name)) ; FREE: INFOP-NODE-NAME
            infop-node-name)
          "\n")
  (goto-char (point-min))
  (center-line 2))

(defun Info-node-name-at-point ()
  "Return the Info node named at point, or nil if none."
  (save-match-data
    (let ((name
           (cond ((Info-get-token (point) "\\*note[ \n\t]+" "\\*note[ \n\t]+\\([^:]*\\):\\(:\\|[ \n\t]*(\\)?"))
                 ((Info-get-token (point) "\\* +" "\\* +\\([^:]*\\)::")) ; Menu item: node name
                 ((Info-get-token (point) "\\* +" "\\* +\\(.*\\): ") ; menu item: node name or index entry
                  (beginning-of-line)
                  (forward-char 2)
                  (Info-extract-menu-node-name nil (Info-index-node)))
                 ((Info-get-token (point) "Up: " "Up: \\([^,\n\t]*\\)"))
                 ((Info-get-token (point) "Next: " "Next: \\([^,\n\t]*\\)"))
                 ((Info-get-token (point) "File: " "File: \\([^,\n\t]*\\)"))
                 ((Info-get-token (point) "Prev: " "Prev: \\([^,\n\t]*\\)")))))
      (and name  (replace-regexp-in-string "\n+" " " name)))))

(when (require 'bookmark+ nil t)

  (defun Info-bookmark-for-node (&optional node localp)
    "Return Info bookmark for NODE, or nil if none.
Non-nil NODE can have the form `NODE' or `(MANUAL) NODE'.
If NODE is nil then read the node name.  If optional arg LOCALP is
non-nil then read the node name only from the current manual."
    (when (and node  (stringp Info-current-file)  (not (string-match-p "(\\([^)]+\\)) \\([^)]*\\)" node)))
      (setq node  (concat "(" (file-name-sans-extension (file-name-nondirectory Info-current-file)) ") " node)))
    (unless node (setq node  (Info-read-bookmarked-node-name localp)))
    (bmkp-get-bookmark-in-alist node t (bmkp-info-alist-only)))

  (defun Info-bookmark-name-for-node (node)
    "Return the name of an Info bookmark for NODE, or nil if none.
Non-nil NODE can have the form `NODE' or `(MANUAL) NODE'.
The name of the bookmark must be the default name that
`Info-bookmark-make-record' would use.  This is normally the full node
name, `(MANUAL) NODE', where MANUAL is the lowercase name of the Info
manual.  For example, node `Modes' in the Emacs manual has full
name `(emacs) Modes', and the bookmark must have that same name."
    (let ((bmk  (Info-bookmark-for-node node)))
      (and bmk  (bmkp-bookmark-name-from-record bmk))))

  (defun Info-bookmark-named-at-point ()
    "Return Info bookmark for node named at point, or nil if none.
See `Info-bookmark-name-for-node' for the form of the bookmark name."
    (let ((node  (Info-node-name-at-point)))
      (and node
           (let* ((file  (and (stringp Info-current-file)
                              (file-name-sans-extension (file-name-nondirectory Info-current-file))))
                  (bname  (if file (concat "(" file ") " node) node)))
             (bmkp-get-bookmark-in-alist bname t (bmkp-info-alist-only))))))

  (defun Info-bookmark-name-at-point ()
    "Return name of Info bookmark for node named at point, or nil if none.
See `Info-bookmark-name-for-node' for the form of the bookmark name."
    (let ((bmk   (Info-bookmark-named-at-point)))
      (and bmk  (bmkp-bookmark-name-from-record bmk))))

  (define-key Info-mode-map (kbd "C-h C-b") 'Info-describe-bookmark)

  )

(when (fboundp 'advice-add)             ; Emacs 24.4+

  (defun Info-save-history-list ()
    "Save `Info-history-list' to `Info-saved-history-file'."
    (when (and Info-persist-history-mode
               (not (string= "" Info-saved-history-file))
               (file-writable-p Info-saved-history-file)
               (not (file-directory-p Info-saved-history-file)))
      (let* ((ibuf  (catch 'Info-save-history-list
                      (dolist (buf  (buffer-list))
                        (with-current-buffer buf
                          (when (derived-mode-p 'Info-mode) (throw 'Info-save-history-list buf))))
                      nil))
             (hist  (and ibuf  (with-current-buffer ibuf Info-history-list))))
        (with-temp-file Info-saved-history-file
          (print Info-history-list (current-buffer))))))

  (defun Info-restore-history-list ()
    "Restore `Info-history-list' from `Info-saved-history-file'."
    (when (and Info-persist-history-mode
               (not (string= "" Info-saved-history-file))
               (file-readable-p Info-saved-history-file))
      (let ((buf  (let ((enable-local-variables  ()))
                    (find-file-noselect Info-saved-history-file)))
            hist)
        (unwind-protect
             (with-current-buffer buf
               (goto-char (point-min))
               (setq hist  (ignore-errors (read (current-buffer)))))
          (kill-buffer buf))
        (when hist
          (setq Info-history-list  hist)
          (when Info-fontify-visited-nodes (Info-fontify-node))))))

  )

(if (fboundp 'pop-to-buffer-same-window)
    (defalias 'Info--pop-to-buffer-same-window 'pop-to-buffer-same-window)
  (defalias 'Info--pop-to-buffer-same-window 'switch-to-buffer))

;;; ;; Not currently used.
;;; (defun Info-display-node-time-header ()
;;;   "Insert current time and node name as header."
;;;   ;; `infop-node-name' is free here - bound in `Info-merge-subnodes'.
;;;   (insert (current-time-string) "    " infop-node-name) ; FREE here: INFOP-NODE-NAME
;;;   (beginning-of-buffer)
;;;   (center-line))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; info+.el ends here
#+end_src


** mouse+.el

#+call: hash() :exports none

#+RESULTS:
: 20210601220536098434900

#+name: 20210601220536098434900
#+begin_src emacs-lisp :tangle (meq/tangle-path)
;;; mouse+.el --- Extensions to `mouse.el'.
;;
;; Filename: mouse+.el
;; Description: Extensions to `mouse.el'.
;; Author: Drew Adams
;; Maintainer: Drew Adams (concat "drew.adams" "@" "oracle" ".com")
;; Copyright (C) 1996-2018, Drew Adams, all rights reserved.
;; Created: Fri Jun 28 14:47:12 1996
;; Version: 0
;; Package-Requires: ()
;; Last-Updated: Sat Sep 22 16:42:29 2018 (-0700)
;;           By: dradams
;;     Update #: 628
;; URL: https://www.emacswiki.org/emacs/download/mouse%2b.el
;; Doc URL: https://emacswiki.org/emacs/MousePlus
;; Keywords: mouse
;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x, 24.x, 25.x, 26.x
;;
;; Features that might be required by this library:
;;
;;   `mouse', `second-sel'.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Commentary:
;;
;;    Extensions to `mouse.el'.
;;
;;  Command `mouse-flash-position' highlights the character after the
;;  mouse pointer position, even as you drag it.  This can help make
;;  it clearer exactly where a `yank' will occur when you use
;;  `mouse-2'.  When you press `mouse-2', if the highlighted position
;;  is not exactly what you want, just keep `mouse-2' held while you
;;  move to the right location.  To enable this behavior, bind
;;  `mouse-flash-position' to `down-mouse-2'.
;;
;;  Command `mouse-flash-position-or-M-x' is the same thing as
;;  `mouse-flash-position', except that it has a special behavior in
;;  the echo area (that is, the minibuffer space when the minibuffer
;;  is inactive).  In the echo area, it calls `M-x'.  To enable this
;;  behavior, bind `mouse-flash-position-or-M-x' to `down-mouse-2'.
;;
;;  Command `mouse-scan-lines' tracks the mouse position, highlighting
;;  the line at that position.  It is handy in buffers like Dired that
;;  are essentially tables with columns - it helps you to align
;;  entries that are in the same row.
;;
;;  Command `mouse-scan-lines-or-M-:' is the same thing as
;;  `mouse-scan-lines', except that it has a special behavior in the
;;  echo area.  In the echo area, it calls `M-:'.  To enable this
;;  behavior, bind `mouse-scan-lines-or-M-:' to `S-down-mouse-2'.
;;
;;  See also library `second-sel.el' for enhancements to
;;  `mouse-drag-secondary' and `mouse-secondary-save-then-kill' that
;;  use a separate ring, `secondary-selection-ring', instead of the
;;  `kill-ring'.
;;
;;
;;  Faces defined here:
;;
;;    `mouse-flash-position', `mouse-scan-lines'.
;;
;;  Commands defined here:
;;
;;    `mouse-flash-position', `mouse-flash-position-or-M-x',
;;    `mouse-M-:', `mouse-scan-lines', `mouse-scan-lines-or-M-:',
;;    `tear-off-window-if-not-alone'.
;;
;;  Non-interactive functions defined here:
;;
;;    `mouse-flash-posn-track', `mouse-move-flash-posn-overlay'.
;;
;;  Constants defined here:
;;
;;    `mouse-flash-posn-overlay', `mouse-scan-lines-overlay'.
;;
;;
;;  ***** NOTE: The following functions defined in `mouse.el' have
;;              been REDEFINED HERE:
;;
;;  `mouse-drag-region'     - If click echo area and `*Messages*' is
;;                            displayed, do `M-x', delete `*Messages*'
;;  `(mouse-)tear-off-window' - Don't delete window if it is alone in
;;                              frame.  Instead, clone frame and window.
;;  `mouse-yank-secondary' - Error if (x-get-selection 'SECONDARY)=nil
;;
;;
;;  Do this in your init file (~/.emacs or ~/_emacs):
;;
;;   (require 'mouse+)
;;
;;
;;  Suggested bindings:
;;
;;   The first sexp is NECESSARY for Emacs 24 or later, if you want to
;;   take advantage of the `mouse-drag-region' behavior defined here
;;   wrt buffer `*Messages*' and `M-x'.
;;
;;   ;; Do not use `view-echo-area-messages' for `mouse-1'.   Use
;;   ;; version of `mouse-drag-region' defined here, which does more.
;;   (when (> emacs-major-version 23)
;;     (define-key minibuffer-inactive-mode-map [down-mouse-1] nil)
;;     (define-key minibuffer-inactive-mode-map [mouse-1]      nil))
;;
;;   (global-set-key [down-mouse-2]        'mouse-flash-position-or-M-x)
;;   (global-set-key [S-down-mouse-2]      'mouse-scan-lines-or-M-:)
;;   (global-set-key [mode-line C-mouse-1] 'tear-off-window)
;;   (define-key ctl-x-5-map "1"           'tear-off-window)
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Change Log:
;;
;; 2018/09/22 dadams
;;     Moved here from frame-cmds.el: tear-off-window(-if-not-alone).
;;     (mouse-)tear-off-window(-if-not-alone): Updated per Emacs bug #32799.
;;                                             Raise error for Emacs 20.
;; 2016/12/09 dadams
;;     mouse-yank-secondary: x-get-selection -> gui-get-selection for Emacs 25+.
;; 2015/11/22 dadams
;;     mouse-drag-region: Corrected test for mouse-drag-track call to Emacs 25+.
;;     Removed lexical-binding declaration to file.
;; 2015/11/21 dadams
;;     Added lexical-binding declaration to file.  Otherwise, mouse-drag-region no longer
;;       set the region (when mouse-drag-copy-region = t).
;; 2014/07/13 dadams
;;     mouse-drag-region:
;;      Use save-window-excursion instead of trying to restore buffer.
;;      If *Messages* is selected then bury-buffer instead of delete-window.
;;      Mention in Commentary: must remove Emacs 24 binding of view-echo-area-messages.
;; 2014/05/19 dadams
;;     mouse-drag-region: Handle incompatible change for Emacs 24.4+.
;; 2011/12/19 dadams
;;     mouse-scan-lines: Use line-(beginning|end)-position, not (beginning|end)-of-line.
;; 2011/01/04 dadams
;;     Removed autoload cookie from non def* sexp.  Added for defface.
;; 2010/10/12 dadams
;;     mouse-flash-position: Updated doc string for Emacs 24.
;; 2009/04/26 dadams
;;     mouse-scan-lines: Bind inhibit-field-text-motion to t, for end-of-line.
;; 2008/09/29 dadams
;;     Added: redefinition of mouse-drag-region.
;; 2008/05/23 dadams
;;     Soft-require second-sel.el.
;;     mouse-yank-secondary: Added prefix arg treatment.
;; 2008/05/02 dadams
;;     (put 'mouse-yank-secondary 'delete-selection 'yank)
;; 2007/01/27 dadams
;;     Added: mouse-scan-lines(-overlay), mouse-scan-lines-or-M-:,
;; 2006/11/04 dadams
;;     Added: mouse-M-:.
;;     mouse-flash-position-or-M-x: Use switch-to-buffer.  Skip minibuffers.
;; 2006/11/03 dadams
;;     Added: mouse-flash-position-or-M-x.
;; 2006/08/12 dadams
;;     mouse-flash-posn-overlay: Added mouse-face to overlay.
;;     mouse-flash-posn-track:
;;       Replaced push with setq...cons, to avoid runtime require of cl.el for Emacs 20.
;; 2006/08/11 dadams
;;     Added: mouse-flash-position (face and command), mouse-flash-posn-overlay,
;;            mouse-flash-posn-track, mouse-move-flash-posn-overlay.
;; 2004/09/28 dadams
;;     Added: mouse-yank-secondary.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
;; Floor, Boston, MA 02110-1301, USA.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;; Code:


(require 'mouse)

(require 'second-sel nil t) ;; yank-secondary

;;;;;;;;;;;;;;;;;;;;;;

;;;###autoload
(defface mouse-scan-lines '((t (:background "Yellow")))
  "*Face used to temporarily highlight line at mouse position."
  :group 'mouse)

;;;###autoload
(defface mouse-flash-position '((t (:background "Yellow")))
  "*Face used to highlight mouse position temporarily."
  :group 'mouse)

(defconst mouse-scan-lines-overlay
    ;; Create and immediately delete, to get "overlay in no buffer".
    (let ((ol  (make-overlay (point-min) (point-min))))
      (delete-overlay ol)
      (overlay-put ol 'face       'mouse-scan-lines)
      (overlay-put ol 'mouse-face 'mouse-scan-lines)
      (overlay-put ol 'priority   1000000)
      ol)
  "Overlay to highlight line at mouse position.")

(defconst mouse-flash-posn-overlay
    ;; Create and immediately delete, to get "overlay in no buffer".
  (let ((ol  (make-overlay (point-min) (point-min))))
    (delete-overlay ol)
    (overlay-put ol 'face 'mouse-flash-position)
    (overlay-put ol 'mouse-face 'mouse-flash-position)
    (overlay-put ol 'priority 1000000)
    ol)
  "Overlay to highlight current mouse position.")



;;  Candidate for binding to `S-down-mouse-2'.
;;;###autoload
(defun mouse-scan-lines-or-M-: (start-event)
  "In echo area, `M-:'.  Else, highlight current line, tracking pointer."
  (interactive "e")
  (let ((win  (posn-window (event-start start-event)))
        (bufs (buffer-list))
        (M-:-cmd (key-binding "\M-:" t)))
    (cond ((and (window-minibuffer-p win) (not (minibuffer-window-active-p win)) M-:-cmd)
           (read-event)                 ; Ignore mouse up event.
           (while (string-match "\\` \\*Minibuf-[0-9]+\\*\\'" (buffer-name (car bufs)))
             (pop bufs))
           (when bufs (set-buffer (car bufs)))
           (switch-to-buffer-other-window (current-buffer))
           (call-interactively M-:-cmd nil [(meta ?:)]))
          (t
           (mouse-scan-lines start-event)))))

;;;###autoload
(defun mouse-M-: (start-event)
  "In the echo area, do `M-:'.  Otherwise, do nothing."
  (interactive "e")
  (let ((win      (posn-window (event-start start-event)))
        (bufs     (buffer-list))
        (M-:-cmd  (key-binding "\M-:" t)))
    (cond ((and (window-minibuffer-p win) (not (minibuffer-window-active-p win)) M-:-cmd)
           (read-event)                 ; Ignore mouse up event.
           (while (string-match "\\` \\*Minibuf-[0-9]+\\*\\'" (buffer-name (car bufs)))
             (pop bufs))
           (when bufs (set-buffer (car bufs)))
           (switch-to-buffer-other-window (current-buffer))
           (call-interactively M-:-cmd nil [(meta ?:)]))
          (t
           (run-hooks 'mouse-leave-buffer-hook))))) ; Let temp modes like isearch turn off.

;;;###autoload
(defun mouse-scan-lines (start-event)
  "Track mouse drags, highlighting the line under the pointer."
  (interactive "e")
  (save-excursion
    (run-hooks 'mouse-leave-buffer-hook) ; Let temporary modes like isearch turn off.
    (let* ((original-window            (selected-window))
           (echo-keystrokes            0)
           (start-posn                 (event-start start-event))
           (start-point                (posn-point start-posn))
           (start-window               (posn-window start-posn))
           (inhibit-field-text-motion  t)) ; Just to be sure, for `end-of-line'.
      (move-overlay mouse-scan-lines-overlay
                    (save-excursion (goto-char start-point) (line-beginning-position))
                    (save-excursion (goto-char start-point) (line-end-position)))
      (let (event end  end-point)
        (track-mouse
          (while (progn (setq event  (read-event))
                        (or (mouse-movement-p event)
                            (memq (car-safe event) '(switch-frame select-window))))
            (unless (memq (car-safe event) '(switch-frame select-window))
              (setq end        (event-end event)
                    end-point  (posn-point end))
              (when (and (eq (posn-window end) start-window) (integer-or-marker-p end-point))
                (move-overlay
                 mouse-scan-lines-overlay
                 (save-excursion (goto-char end-point) (line-beginning-position))
                 (save-excursion (goto-char end-point) (line-end-position)))))))
        (delete-overlay mouse-scan-lines-overlay)))))

(defun mouse-move-flash-posn-overlay (ol start end)
  "Move `mouse-flash-posn-overlay' to position END.
START is the position of the start of the current drag operation."
  (unless (= start end)
    ;; Go to START first, so that when we move to END, if it's in the middle
    ;; of intangible text, point jumps in the direction away from START.
    ;; Don't do it if START=END, otherwise a single click risks selecting
    ;; a region if it's on intangible text.  This exception was originally
    ;; only applied on entry to mouse-drag-region, which had the problem
    ;; that a tiny move during a single-click would cause the intangible
    ;; text to be selected.
    (goto-char start)
    (goto-char end)
    (setq end  (point)))
  (move-overlay ol end (min (point-max) (1+ end))))

;; Inspired from `mouse-drag-region'.  Candidate for binding to `down-mouse-2'.
;;;###autoload
(defun mouse-flash-position-or-M-x (start-event)
  "In the echo area, do `M-x'.  Otherwise, do `mouse-flash-position'."
  (interactive "e")
  (let ((win      (posn-window (event-start start-event)))
        (bufs     (buffer-list))
        (M-x-cmd  (key-binding "\M-x" t)))
    (cond ((and (window-minibuffer-p win) (not (minibuffer-window-active-p win)) M-x-cmd)
           (read-event)                 ; Ignore mouse up event.
           (while (string-match "\\` \\*Minibuf-[0-9]+\\*\\'" (buffer-name (car bufs)))
             (pop bufs))
           (when bufs (set-buffer (car bufs)))
           (switch-to-buffer-other-window (current-buffer))
           (call-interactively M-x-cmd nil [(meta ?x)]))
          (t
           (run-hooks 'mouse-leave-buffer-hook) ; Let temporary modes like isearch turn off.
           (mouse-flash-posn-track start-event)))))

;; Inspired from `mouse-drag-region'.  Candidate for binding to `down-mouse-2'.
;;;###autoload
(defun mouse-flash-position (start-event)
  "Highlight the mouse position as you drag the mouse.
This must be bound to a button-down mouse event.

If you bind this to `down-mouse-2', and `mouse-2' is bound to
`mouse-yank-primary' or `mouse-yank-at-click' (defaults for Emacs 24
and earlier, respectively), then the yank occurs just before the
highlighted character.

If you want to prevent the `mouse-2' up-button yank from taking place,
perhaps because you changed your mind, you can press and hold `C-g'
while releasing the mouse button (press `mouse-2'; drag; press `C-g';
release `mouse-2'; release `C-g')."
  (interactive "e")
  (run-hooks 'mouse-leave-buffer-hook)  ; Let temporary modes such as isearch turn off.
  (mouse-flash-posn-track start-event))

(defun mouse-flash-posn-track (start-event)
  "Track mouse drags by highlighting the mouse position"
  (mouse-minibuffer-check start-event)
  (let* ((original-window                 (selected-window))
         (echo-keystrokes                 0)
         (start-posn                      (event-start start-event))
         (start-point                     (posn-point start-posn))
         (start-window                    (posn-window start-posn))
         (start-window-start              (window-start start-window))
         (start-hscroll                   (window-hscroll start-window))
         (bounds                          (window-edges start-window))
         (make-cursor-line-fully-visible  nil)
         (top                             (nth 1 bounds))
         (bottom                          (if (window-minibuffer-p start-window)
                                              (nth 3 bounds)
                                            (1- (nth 3 bounds))))) ; Don't count mode line.
    (mouse-move-flash-posn-overlay mouse-flash-posn-overlay start-point start-point)
    (overlay-put mouse-flash-posn-overlay 'window start-window)
    (deactivate-mark)
    (unwind-protect
         (let (event end end-point last-end-point)
           (track-mouse
             (while (progn (setq event  (read-event))
                           (or (mouse-movement-p event)
                               (memq (car-safe event) '(switch-frame select-window))))
               (unless (memq (car-safe event) '(switch-frame select-window))
                 (setq end        (event-end event)
                       end-point  (posn-point end))
                 (when (numberp end-point) (setq last-end-point  end-point))
                 (cond
                   ((and (eq (posn-window end) start-window) ; Moving within original window.
                         (integer-or-marker-p end-point))
                    (mouse-move-flash-posn-overlay mouse-flash-posn-overlay
                                                   start-point end-point))
                   (t
                    (let ((mouse-row  (cddr (mouse-position))))
                      (cond
                        ((null mouse-row))
                        ((< mouse-row top)
                         (mouse-scroll-subr start-window (- mouse-row top)
                                            mouse-flash-posn-overlay start-point))
                        ((>= mouse-row bottom)
                         (mouse-scroll-subr start-window (1+ (- mouse-row bottom))
                                            mouse-flash-posn-overlay start-point)))))))))
           ;; In case we did not get a mouse-motion event for the final move of
           ;; the mouse before a drag event, pretend that we did get one.
           (when (and (memq 'drag (event-modifiers (car-safe event)))
                      (setq end        (event-end event)
                            end-point  (posn-point end))
                      (eq (posn-window end) start-window)
                      (integer-or-marker-p end-point))
             (mouse-move-flash-posn-overlay mouse-flash-posn-overlay start-point end-point))
           (when (consp event)          ; Handle the terminating event.
             (let ((fun  (key-binding (vector (car event)))))
               ;; Run the binding of the terminating up-event, if possible.
               (let* ((stop-point  (if (numberp (posn-point (event-end event)))
                                       (posn-point (event-end event))
                                     last-end-point))
                      (drag-end    (if (and stop-point (< stop-point start-point))
                                       (overlay-start mouse-flash-posn-overlay)
                                     (overlay-end mouse-flash-posn-overlay)))
                      (drag-start  (- (+ (overlay-end mouse-flash-posn-overlay)
                                         (overlay-start mouse-flash-posn-overlay))
                                      drag-end))
                      last-command this-command)
                 (delete-overlay mouse-flash-posn-overlay)
                 (when (and (= start-hscroll (window-hscroll start-window))
                            (or end-point
                                (= (window-start start-window) start-window-start)))
                   (setq unread-command-events  (cons event unread-command-events)))))))
      (delete-overlay mouse-flash-posn-overlay))))



;; REPLACES ORIGINAL in `mouse.el':
;;
;; If window is alone in its frame then just clone frame.
;; Suppress error "Attempt to delete minibuffer or sole ordinary window" in that context.
;; Use `pop-to-buffer-same-window', not `switch-to-buffer'.
;;
;;;###autoload
(defun tear-off-window (click)
  "Create a new frame displaying buffer of window clicked on.
If window is not the only one in frame, then delete it.
Otherwise, this command effectively clones the frame and window."
  (interactive
   (progn (unless (> emacs-major-version 21)
            (error "You need Emacs 22 or later for this command"))
          (list last-nonmenu-event)))   ; See bug #32799
  (mouse-minibuffer-check click)
  (let* ((window  (posn-window (event-start click)))
         (buf     (window-buffer window))
         (frame   (make-frame)))
    (select-frame frame)
    (if (fboundp 'pop-to-buffer-same-window)
        (pop-to-buffer-same-window buf)
      (switch-to-buffer buf))
    (save-window-excursion (select-window window)
                           (unless (one-window-p) (delete-window window)))))

;; This is redundant for Emacs 24.4+, but it is needed for older releases.
;;
;;;###autoload
(defalias 'mouse-tear-off-window 'tear-off-window)

;;;###autoload
(defun tear-off-window-if-not-alone (click)
  "Move selected window to a new frame, unless it is alone in its frame.
If it is alone, do nothing.  Otherwise, delete it and create a new
frame showing the same buffer."
  (interactive
   (progn (unless (> emacs-major-version 21)
            (error "You need Emacs 22 or later for this command"))
          (list last-nonmenu-event)))   ; See bug #32799
  (mouse-minibuffer-check click)
  (if (one-window-p 'NOMINI)
      (message "Sole window in frame")
    (tear-off-window click)))



;; REPLACES ORIGINAL in `mouse.el':
;; If click in echo area and `*Messages*' is already displayed,
;; then do `M-x' and delete `*Messages*' window.
;;
(when (> emacs-major-version 21)
  (defun mouse-drag-region (start-event)
    "Set the region to the text that the mouse is dragged over.
Highlight the drag area as you move the mouse.
This must be bound to a button-down mouse event.
In Transient Mark mode, the highlighting remains as long as the mark
remains active.  Otherwise, it remains until the next input event.

If the click is in the echo area, then:
  If buffer `*Messages' is not displayed, display it.
  Else run the command bound to `M-x'."
    (interactive "e")
    (let ((clickwin  (posn-window (event-start start-event))))
      (if (and (window-minibuffer-p clickwin)
               (not (minibuffer-window-active-p clickwin)))
          (let* ((Messages-buf  (get-buffer-create "*Messages*"))
                 (Messages-win  (get-buffer-window Messages-buf 'visible)))
            (if Messages-win
                (let ((M-x-cmd  (or (key-binding "\M-x" t) 'execute-extended-command)))
                  (read-event)          ; Swallow the up-event.
                  (if (eq Messages-win (selected-window))
                      (bury-buffer)
                    (delete-window Messages-win))
                  (save-window-excursion (call-interactively M-x-cmd nil [(meta ?x)])))
              (save-excursion
                (read-event)            ; Swallow the up-event.
                (set-buffer Messages-buf)
                (goto-char (point-max))
                (display-buffer (current-buffer)))))

        ;; Give temporary modes such as isearch a chance to turn off.
        (run-hooks 'mouse-leave-buffer-hook)
        (if (> emacs-major-version 24)
            (mouse-drag-track start-event)
          (mouse-drag-track start-event t))))))



;; REPLACES ORIGINAL in `mouse.el':
;;
;; 1. Use `yank-secondary' if defined.
;; 2. If `mouse-yank-at-point', insert at point regardless of click position.
;; 3. Fixes bug when (x-get-selection 'SECONDARY) returns nil.
;;
;;;###autoload
(defun mouse-yank-secondary (click arg)
  "Insert the secondary selection at the position clicked on.
Move point to the end of the inserted text.
If `mouse-yank-at-point' is non-nil, insert at point regardless of
 where you click.
If command `yank-secondary' is defined (see library `second-sel.el'),
 then a prefix arg N means insert the Nth most recent secondary
 selection."
  (interactive "e\nP")
  ;; Give temporary modes such as isearch a chance to turn off.
  (run-hooks 'mouse-leave-buffer-hook)
  (or mouse-yank-at-point (mouse-set-point click))
  (setq mouse-selection-click-count  0)
  (if (not (fboundp 'yank-secondary))
      (let ((secondary  (if (fboundp 'gui-get-selection) ; Emacs 25.1+.
                            (gui-get-selection 'SECONDARY)
                          (x-get-selection 'SECONDARY))))
        (unless secondary (error "No secondary selection"))
        (funcall (if (fboundp 'insert-for-yank) 'insert-for-yank 'insert) secondary))
    (setq this-command  'yank-secondary)
    (yank-secondary arg)))

;; Tell `delete-selection-mode' to replace active region by yanked secondary selection.
(put 'mouse-yank-secondary 'delete-selection 'yank)



;; REPLACES ORIGINAL in `mouse.el':
;; Iconify *Completions* frame after choosing completion.
;; Free variable COMPLETION-REFERENCE-BUFFER is defined in `simple.el'.
;  ;;;###autoload
;(defun mouse-choose-completion (event)
;  "Click on an alternative in the `*Completions*' buffer to choose it."
;  (interactive "e")
;  ;; Give temporary modes such as isearch a chance to turn off.
;  (run-hooks 'mouse-leave-buffer-hook)
;  (let ((buffer  (window-buffer))
;        choice
;       base-size)
;    (save-excursion
;      (set-buffer (window-buffer (posn-window (event-start event))))
;      (when completion-reference-buffer   ; Defined in `simple.el'.
;        (setq buffer  completion-reference-buffer))
;      (setq base-size  completion-base-size)
;      (save-excursion
;       (goto-char (posn-point (event-start event)))
;       (let (beg end)
;         (when (and (not (eobp)) (get-text-property (point) 'mouse-face))
;            (setq end  (point))
;            (setq beg  (1+ (point))))
;         (unless beg (error "No completion here"))
;         (setq beg  (previous-single-property-change beg 'mouse-face))
;         (setq end  (or (next-single-property-change end 'mouse-face)
;                        (point-max)))
;         (setq choice  (buffer-substring beg end)))))
;    (save-window-excursion
;      (select-window (posn-window (event-start event)))
;      (when (one-window-p t 'selected-frame) (iconify-frame (selected-frame))))
;    (choose-completion-string choice buffer base-size))) ; In `simple+.el'.

;;;;;;;;;;;;;;;;;;;;;;;

(provide 'mouse+)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; mouse+.el ends here
#+end_src