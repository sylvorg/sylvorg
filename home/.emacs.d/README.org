#+setupfile: ./settings.org
#+property: header-args:emacs-lisp+ :tangle yes

#+begin_quote
Like Chemacs, but worse! — John Oliver (... Yeah, no; I wish! Maybe some day!)
#+end_quote

* হ্যালো! Hello!

This is the beginning of my version of a literate configuration for
[[https://www.gnu.org/software/emacs/][GNU Emacs]].

They were inspired primarily by the configurations of
[[https://alhassy.github.io/emacs.d/index.html][Musa Al-hassy]]
and [[https://github.com/patrickt/emacs][Patrick Thomson]].

* Wheee!
** Electric Sheep

First of all, I don't know how to check if I'm running on my phone, so I pass in a command-line argument:

#+begin_src emacs-lisp
(defvar meq/var/phone (member "-p" command-line-args))
(delete "-p" command-line-args)
#+end_src

** Double Dutch can be beat

Then I'll remove the double dashes from scripts:

#+begin_src emacs-lisp
(when (string= (car (last command-line-args)) "--") (delete "--" command-line-args))
#+end_src

** XLR8!

These next few lines are unabashedly stolen from
[[https://github.com/hlissner][Henrik Lissner's]]
[[https://github.com/hlissner/doom-emacs/blob/develop/early-init.el][Doom Emacs' ~early-init.el~]]:

#+begin_quote
Emacs 27.1 introduced early-init.el, which is run before init.el, before
package and UI initialization happens, and before site files are loaded.
#+end_quote

#+begin_quote
A big contributor to startup times is garbage collection. We up the gc
threshold to temporarily prevent it from running, then reset it later by
enabling `gcmh-mode'. Not resetting it will cause stuttering/freezes.
#+end_quote

#+begin_src emacs-lisp
(setq gc-cons-threshold most-positive-fixnum)
#+end_src

And for the ~file-name-handler-alist~:

#+begin_src emacs-lisp
(setq meq/var/file-name-handler-alist file-name-handler-alist)
(unless (or (daemonp) noninteractive)
#+end_src

#+begin_quote
`file-name-handler-alist' is consulted on each `require', `load' and
various path/io functions. You get a minor speed up by unsetting this.
Some warning, however: this could cause problems on builds of Emacs where
its site lisp files aren't byte-compiled and we're forced to load the
*.el.gz files (e.g. on Alpine).
#+end_quote

#+begin_src emacs-lisp
    (setq-default file-name-handler-alist nil)
#+end_src

#+begin_quote
...but restore `file-name-handler-alist' later, because it is needed for
handling encrypted or compressed files, among other things.
#+end_quote

#+begin_src emacs-lisp
    (defun meq/reset-file-handler-alist-h ()
      (setq file-name-handler-alist
#+end_src

#+begin_quote
Merge instead of overwrite because there may have bene changes to
`file-name-handler-alist' since startup we want to preserve.
#+end_quote

#+begin_src emacs-lisp
            (delete-dups (append file-name-handler-alist
                                 meq/var/file-name-handler-alist))))
    (add-hook 'emacs-startup-hook #'meq/reset-file-handler-alist-h 101))
#+end_src

** Bite the gold

I would like to always prefer newer byte-compiled files, therefore, I use
[[https://emacs.stackexchange.com/a/186/31428][this answer]], by
[[https://emacs.stackexchange.com/users/50/malabarba][Malabarba]]:

#+begin_src emacs-lisp
(setq load-prefer-newer t)
#+end_src

** Remember your origins

If I ever need it, this will give me the initial directory I was in; the code is adapted from
[[https://emacs.stackexchange.com/users/1979/stefan][Stefan's]]
[[https://emacs.stackexchange.com/a/31662/31428][answer here]]:

#+begin_src emacs-lisp
(setq meq/var/initial-directory default-directory)
#+end_src

** ¯\_(ツ)_/¯

The next few bits are adapted from
[[https://www.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/?utm_source=amp&utm_medium=&utm_content=post_body][here]],
with a few quotes from myself and other scattered here and there, such as this bit
[[https://www.reddit.com/r/emacs/comments/41m7x3/why_are_you_changing_gcconsthreshold/cz3t775?utm_source=share&utm_medium=web2x&context=3][about ~gc-cons-percentage~]]:

#+begin_quote
... There's also gc-cons-percentage which performs a gc if the amount of new memory used as a percentage
of the total has increased by a certain amount.
If you set gc-cons-threshold to a large number that effectively puts gc-cons-percentage into the driving seat.
The default gc-cons-threshold is 400000 bytes, not 800000. ...
#+end_quote

#+begin_src emacs-lisp
(defvar meq/var/gc-cons-percentage gc-cons-percentage)

(add-hook 'after-init-hook
          (lambda ()
            (setq gc-cons-percentage meq/var/gc-cons-percentage)

            (defun meq/gc-on-lose-focus ()
              (unless (frame-focus-state)
                (garbage-collect)))

            (if (boundp 'after-focus-change-function)
                (add-function :after after-focus-change-function #'meq/gc-on-lose-focus))))

(setq-default gc-cons-percentage 0.6
#+end_src

Dunno /quite/ what this bit does...

#+begin_src emacs-lisp
              auto-window-vscroll nil
              frame-inhibit-implied-resize t
              inhibit-compacting-font-caches t)
#+end_src

I don't like typing ~yes~ or ~no~ all the time, so we'll shorten the answer statement a bit.

#+begin_src emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

Dunno what /this/ bit does either...

#+begin_src emacs-lisp
(fset 'view-hello-file 'ignore)
(fset 'display-startup-echo-area-message 'ignore)

(put 'narrow-to-region 'disabled nil)
(put 'up-case-rgion 'disabled nil)
(put 'downcase-region 'disabled nil)
(put 'erase-buffer 'disabled nil)

(push '(ns-transparent-titlebar . t) default-frame-alist)
(push '(ns-appearance . nil) default-frame-alist)
(push '(internal-border . 0) default-frame-alist)
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars . 0) default-frame-alist)
(push '(left-fringe . 0) default-frame-alist)
(push '(right-fringe . 0) default-frame-alist)
#+end_src

** Here's your profile

Now that that's over with, let's get the profile name; this is done by searching through the ~command-line-args~
list for the ~--profile~ argument. If found, get the profile name from the index of the ~--profile~ argument
plus 1, otherwise, set it to the default name of ~damascus~.

#+begin_src emacs-lisp
(defvar meq/var/profiled t)
(defvar meq/var/profile-name (if (member "--profile" command-line-args)
    (let* ((value (nth (1+ (seq-position command-line-args "--profile")) command-line-args)))
        (unwind-protect
            value
#+end_src

While we're at it, we'll delete the the appropriate command-line arguments as well:

#+begin_src emacs-lisp
            (delete "--profile" command-line-args)
            (delete value command-line-args))) "damascus"))
#+end_src

** Did I forget something...?

This next bit defines a function which will add arguments to the ~command-line-args~ list, if and only if it
doesn't already exist in the list and the argument is an option, as when prefixed by ~-~ or ~--~.

#+begin_src emacs-lisp
(require 'cl)
(defun meq/push-to-cla (args)
    (dolist (arg* args)
        (let* ((arg (if (stringp arg*) arg* (symbol-name arg*)))
                (already-in-list (member arg command-line-args)))
            (when (and
                    (or (string-prefix-p "-" arg) (string-prefix-p "--" arg))
                    (not already-in-list)) (add-to-list 'command-line-args arg t)))))
#+end_src

Next, for specific profiles, if applicable, we will add any arguments necessary to be able to run the profile.

#+begin_src emacs-lisp
(pcase meq/var/profile-name
    ("damascus" (meq/push-to-cla '(--literate-config)))
    ("nano" (meq/push-to-cla '(--profile-lib profiles/nano/lisp/nano.el)))
    ("graphene" (meq/push-to-cla '(--profile-lib profiles/graphene/lisp/graphene.el --literate-config))))
#+end_src

** After Vars

#+begin_src emacs-lisp
(defvar meq/var/literate-config (member "--literate-config" command-line-args))
(delete "--literate-config" command-line-args)
#+end_src

** Silva Scientiae

Let's byte-compile the library directories and add them to the load-path now;
the following bits are adapted from [[https://emacs.stackexchange.com/users/14825/nickd][NickD's answer]]
[[https://emacs.stackexchange.com/a/55415/31428][here]], and
[[https://www.emacswiki.org/emacs/LoadPath#h5o-2][from this section of the Emacs Wiki]].

The first directory to compile and add is the directory of emacs packages, as git submodules, of my project,
managed by... well... you'll see.

#+begin_src emacs-lisp
(let ((default-directory (concat pre-user-emacs-directory "lib")))
    (byte-recompile-directory default-directory nil)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+end_src

The second directory consists of the packages I develop, as git subtrees:

#+begin_src emacs-lisp
(let ((default-directory (concat pre-user-emacs-directory "siluam")))
    (byte-recompile-directory default-directory nil)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path))
#+end_src

** RESISTANCE IS FUTILE

#+begin_export html
<p align="center"><a href="https://github.com/emacscollective/borg"><img src="borg.gif"></a></p>
#+end_export

#+begin_src emacs-lisp
(setq package-enable-at-startup nil)
(require 'borg)
#+end_src

I would like to force adding the git submodules:

#+begin_src emacs-lisp
(defun meq/borg-assimilate-advice (package url &optional partially)
  "Assimilate the package named PACKAGE from URL.
If `epkg' is available, then only read the name of the package
in the minibuffer and use the url stored in the Epkg database.
If `epkg' is unavailable, the package is not in the database, or
with a prefix argument, then also read the url in the minibuffer.
With a negative prefix argument only add the submodule but don't
build and activate the drone."
  (interactive
   (nconc (borg-read-package "Assimilate package: " current-prefix-arg)
          (list (< (prefix-numeric-value current-prefix-arg) 0))))
  (borg--maybe-confirm-unsafe-action "assimilate" package url)
  (message "Assimilating %s..." package)
  (let ((default-directory borg-top-level-directory))
    (borg--maybe-reuse-gitdir package)
    (borg--call-git package "submodule" "add" "-f" "--name" package url
                    (file-relative-name (borg-worktree package)))
    (borg--sort-submodule-sections ".gitmodules")
    (borg--call-git package "add" ".gitmodules")
    (borg--maybe-absorb-gitdir package))
  (unless partially
    (borg-build package)
    (borg-activate package))
  (borg--refresh-magit)
  (message "Assimilating %s...done" package))
(advice-add #'borg-assimilate :override #'meq/borg-assimilate-advice)
#+end_src

#+begin_src emacs-lisp
(setq borg-rewrite-urls-alist '(("git@github.com:" . "https://github.com/")
                                ("git@gitlab.com:" . "https://gitlab.com/")))
(borg-initialize)
#+end_src

** Straight and a bit /too/ narrow
:PROPERTIES:
:header-args:emacs-lisp+: :tangle no
:END:

Before I was assimilated, I used [[https://github.com/raxod502][Radon Rosborough's]]
[[https://github.com/raxod502/straight.el][straight.el]]; however, problems with ~org-mode~ got to me,
and I eventually switched over to — WE ARE BORG — ... Ahem. Sorry about that. Where were we...?

Right. My straight config. Here's how I pinned packages, adapted from
[[https://github.com/raxod502/straight.el#how-do-i-pin-package-versions-or-use-only-tagged-releases][here]]:

#+begin_quote
Tell straight.el about the profiles we are going to be using.
#+end_quote

#+begin_src emacs-lisp
(setq straight-profiles
      '((nil . "default.el")
#+end_src

#+begin_quote
Packages which are pinned to a specific commit.
#+end_quote

#+begin_src emacs-lisp
        (pinned . "pinned.el")))
#+end_src

From here on out, til mentioned otherwise, the configuration is more or less again adapted from
[[https://www.reddit.com/r/emacs/comments/dppmqj/do_i_even_need_to_leverage_earlyinitel_if_i_have/?utm_source=amp&utm_medium=&utm_content=post_body][here]]:

#+begin_src emacs-lisp
(with-no-warnings
    (setq straight-vc-git-default-clone-depth 1)
    (setq straight-base-dir (meq/ued ".local/"))
    (setq straight-repository-branch "develop")
    (setq straight-build-dir (format "build-%s" emacs-version))
    (setq straight-cache-autoloads t)
    (setq straight-check-for-modifications '(check-on-save))
    (setq straight-repository-branch "develop")
    (setq straight-use-package-by-default t)
#+end_src

(Well, except for this, adapted from
[[https://github.com/hartzell/straight.el/commit/882649137f73998d60741c7c8c993c7ebbe0f77a#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R1649][here]]:)

#+begin_src emacs-lisp
    (setq straight-disable-byte-compilation (member "--no-byte-compilation" command-line-args)))
(delete "--no-byte-compilation" command-line-args)
#+end_src

And then install ~straight.el~:

#+begin_src emacs-lisp
(eval-and-compile
  (setq straight-recipes-gnu-elpa-use-mirror t)
  (setq straight-recipes-emacsmirror-use-mirror t)
  (setq bootstrap-version 5)
  (setq bootstrap-file (concat straight-base-dir "straight/repos/straight.el/bootstrap.el")))

(unless (file-exists-p bootstrap-file)
  (with-current-buffer
      (url-retrieve-synchronously
       "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
       'silent 'inhibit-cookies)
    (goto-char (point-max))
    (eval-print-last-sexp)))

(load bootstrap-file nil 'nomessage)

(autoload #'straight-x-pull-all "straight-x")
(autoload #'straight-x-freeze-versions "straight-x")
#+end_src

** The one, the only...

Now for the fun part: let's [[https://github.com/jwiegley/use-package][use-package]]
with [[https://github.com/jwiegley][John Wiegley]]!

#+begin_src emacs-lisp
(with-no-warnings
  (setq use-package-verbose t)
  (setq use-package-enable-imenu-support t))
(require 'use-package)
#+end_src

*** Sometimes defer package loading

Quoted from [[https://github.com/jwiegley/use-package#loading-packages-in-sequence][Use-Package's Loading packages in sequence]]:

#+begin_quote
NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the
declared package is to be loaded: e.g., by some :bind. If you're not using one of the mechanisms that registers autoloads, such as
:bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :defer 2 to those declarations,
your package will never be loaded.
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#notes-about-lazy-loading][Use-Package's Notes about lazy loading]]:

#+begin_quote
In almost all cases you don't need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used.
Typically, you only need to specify :defer if you know for a fact that some other package will do something to cause your package to
load at the appropriate time, and thus you would like to defer loading even though use-package isn't creating any autoloads for you.
You can override package deferral with the :demand keyword. Thus, even if you use :bind, using :demand will force loading to occur
immediately and not establish an autoload for the bound key.
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#modes-and-interpreters][Use-Package's Modes and interpreters]]:

#+begin_quote
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables.
...
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook
(all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword...
#+end_quote

Quoted from [[https://github.com/jwiegley/use-package#magic-handlers][Use-Package's Magic handlers]]:

#+begin_quote
Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches
a given regular expression.
...
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".
#+end_quote

Quoted from [[https://github.com/Kungsgeten/ryo-modal#use-package-keyword][RYO-Modal's Use-package keyword]]:

#+begin_quote
Ryo-modal also provides a use-package keyword: :ryo, which is similar to :bind in that it implies :defer t and create autoloads for the bound commands.
The keyword is followed by one or more key-binding commands, using the same syntax as used by ryo-modal-keys...
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#use-package-keywords][General's Use-package Keywords]]:

#+begin_quote
:general is similar to :bind in that it implies :defer t whenever there are bound commands that can be autoloaded
(e.g. it will not imply :defer t if the only bound command is to a lambda, for example). Whenever autoloadable commands are bound,
use-package will create autoloads for them (though this is usually not necessary).
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#ghook-keyword][General's :ghook Keyword]]:

#+begin_quote
:ghook is intended to be used to add a package’s minor mode enabling function to a user-specified hook, so that when hook is run,
the package will be loaded and the mode enabled. This means that :ghook will usually imply :defer t. While it does not always imply :defer t,
it will add any non-lambda functions to :commands (this is the same behavior as :hook).
Though this is usually unnecessary (the commands probably already have autoloads), it will in turn imply :defer t.
#+end_quote

Quoted from [[https://github.com/noctuid/general.el#gfhook-keyword][General's :gfhook Keyword]]:

#+begin_quote
Unlike :ghook, :gfhook never adds functions to :commands and therefore never implies :defer t.
This is because the functions specified are ones that should be run when turning on (or toggling) the mode(s) the package provides.
The specified functions are external to the package, could be called elsewhere, and therefore should not trigger the package to load.
#+end_quote

Also see [[https://github.com/jwiegley/use-package/issues/738#issuecomment-447631609][this comment]].

Note that I assume that [[https://github.com/jwiegley/use-package#use-package-chords][chords]]
also defer and create autoloads.

And in my experience... Not a good idea; much too confusing. Use
[[https://www.reddit.com/r/emacs/comments/j2xezg/usepackage_best_practices/][the arguments here]]
to decide whether to use this or =:defer <n>= instead.

#+begin_src emacs-lisp
(setq use-package-always-defer (member "--always-defer" command-line-args))
(delete "--always-defer" command-line-args)
#+end_src

*** And the rest

Similar to what's happening above, this bit searches the ~command-line-args~ list for the ~--always-demand~
argument, and sets ~use-package-always-demand~ accordingly and deletes the argument from the list;
it also sets the variable if Emacs is running as a daemon.

#+begin_src emacs-lisp
(setq use-package-always-demand (or (member "--always-demand" command-line-args) (daemonp)))
(delete "--always-demand" command-line-args)
#+end_src

** The Maid

This package has Emacs store most / all local files in a specific subdirectory:

#+begin_src emacs-lisp
(use-package no-littering :demand t)
#+end_src

And as stated before, from
[[https://github.com/hlissner/doom-emacs/blob/develop/early-init.el][Doom Emacs' ~early-init.el~]]:

#+begin_src emacs-lisp
(use-package gcmh :demand t :config (gcmh-mode 1))
#+end_src

** Extra, extra!

This sets up the following:
- [[https://github.com/plexus/a.el][a.el]] by [[https://github.com/plexus][Arne Brasseur]]
- [[https://github.com/rejeep/f.el][f.el]] by [[https://github.com/rejeep][Johan Andersson]]
- [[https://github.com/magnars/dash.el][dash.el]] by [[https://github.com/magnars][Magnar Sveen]]
- [[https://github.com/magnars/s.el][s.el]] by [[https://github.com/magnars][Magnar Sveen]]
- [[https://github.com/shadowrylander/meq][meq]] by yours truely! :D
- [[https://github.com/conao3/leaf.el][leaf.el]] by [[https://github.com/conao3][Naoya Yamashita]]

And finally:
- [[https://github.com/shadowrylander/use-package-extras][use-package-extras]] by yours truely! :D

#+begin_src emacs-lisp
(use-package use-package-extras
    :demand t
    :init (require 'a) (require 'dash) (require 's) (require 'f)
    :config
        (meq/up meq :load-emacs-file-preconfig ("naked"))
        (meq/up leaf :use-package-preconfig
            (use-package-ensure-system-package)
            (leaf-keywords)))
#+end_src

** Yellow Brick Executable Road

Unless I'm on Windows or a DOS-based OS, I'll need to make sure every executable available on my ~$PATH~ can be
found by Emacs as well:

#+begin_src emacs-lisp
(unless (member system-type '(windows-nt ms-dos))
    (meq/up exec-path-from-shell
        :custom
            (exec-path-from-shell-check-startup-files nil)
            (exec-path-from-shell-variables '("PATH" "MANPATH" "CACHE_HOME" "FPATH" "PYENV_ROOT"))
            (exec-path-from-shell-arguments '("-l"))
        :config
            (exec-path-from-shell-initialize)))
#+end_src

** That was fast

These are two settings I like for ~native compilation~, adapted from
[[https://github.com/daviwil/dotfiles/blob/master/Emacs.org#native-compilation][here]]:

#+begin_quote
Silence compiler warnings as they can be pretty disruptive
#+end_quote

#+begin_src emacs-lisp
(ignore-errors
    (setq native-comp-async-report-warnings-errors nil)
#+end_src

#+begin_quote
Set the right directory to store the native comp cache
#+end_quote

#+begin_src emacs-lisp
    (add-to-list 'native-comp-eln-load-path (meq/ued-local "eln-cache/")))
#+end_src

** There's no place like ~user-emacs-directory~

Now that we have ~f.el~ set up, we can set the ~user-emacs-directory~ to the root directory of the profile
being used:

#+begin_src emacs-lisp
(setq user-emacs-directory (f-full (meq/ued* "profiles" meq/var/profile-name)))
#+end_src

And, unless it's [[https://github.com/hlissner/doom-emacs][Doom Emacs]] being run,
we'll ~byte-compile~ the profile directory as well:

#+begin_src emacs-lisp
(unless (string= meq/var/profile-name "doom") (byte-recompile-directory user-emacs-directory nil))
#+end_src

Then we'll set the custom file for the profile:

#+begin_src emacs-lisp
(setq custom-file (meq/ued "custom.el"))
(meq/cl custom-file)
#+end_src

And then finally the ~auto-save-list-prefix~, as adapted from
[[https://emacs.stackexchange.com/users/2731/ebpa][ebpa's]]
[[https://emacs.stackexchange.com/a/18682/31428][answer here]]:

#+begin_src emacs-lisp
(setq auto-save-list-file-prefix user-emacs-directory)
#+end_src

** Mmm... Orange...

And now for my favorite part: ORANGE! Erm... Sorry, I meant themes. Let's byte-compile them first:

#+begin_src emacs-lisp
(byte-recompile-directory (meq/ued* "themes") nil)
#+end_src

Now we can add them to the ~custom-theme-load-path~ list:

#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path (meq/ued* "themes"))
#+end_src

Also, my themes are safe (I think...):

#+begin_src emacs-lisp
(setq custom-safe-themes t)
#+end_src

By the way, I get most of my themes from [[themer.dev][https://themer.dev/]]; bloody brilliant, it is!

** Would you like fries with that?

These are any last-minute steps before running any specific Emacs profile.

#+begin_src emacs-lisp
(let* ((spacemacs-path (meq/ued-profiles
                            "spacemacs"
                            "layers"
                            "+distributions"
                            "spacemacs-bootstrap")))
    (pcase meq/var/profile-name
        ("doom" (load (meq/ued-lib "ido-completing-read+" "ido-completing-read+.el")))
        ("spacemacs" (progn
                        (load (concat spacemacs-path "packages.el"))
                        (load (concat spacemacs-path "funcs.el"))
                        (spacemacs-bootstrap/init-use-package)))
        ("patrick" (advice-add #'reload-config :override #'(lambda nil (interactive)
                    (meq/cl (meq/ued-profiles "patrick" "readme.org")))))
        ("alhassy" (require 'quelpa-use-package))))
#+end_src

** Party in the CLA

This function can be succinctly explained in a few steps.

When the ~arg~ passed to this function exists in ~command-line-args~...

#+begin_src emacs-lisp
(defun meq/load-from-cla (arg &optional byte-compile)
    (eval `(meq/when-item-in-cla ,arg
#+end_src

Get the item after the ~arg~:

#+begin_src emacs-lisp
        (let* ((item (meq/get-next-in-cla ,arg))
#+end_src

Let's assume the item is a file:

#+begin_src emacs-lisp
                (file (expand-file-name item))
#+end_src

Does the file exist?

#+begin_src emacs-lisp
                (exists (f-exists? file))
#+end_src

If it does, is it /really/ a directory?

#+begin_src emacs-lisp
                (is-dir (and exists (f-directory? file)))
#+end_src

If it's a directory, then, well, it's a directory; if not, assume it's a file, and get it's parent directory.

#+begin_src emacs-lisp
                (dir (if is-dir file (f-dirname file))))
#+end_src

Assuming the item is a file, is it an ~org~ file?

#+begin_src emacs-lisp
                (org-file* (f-ext file))
                (org-file (and org-file* (string= org-file* "org")))
#+end_src

Now. If the file doesn't exist...

#+begin_src emacs-lisp
            (if (not exists)
#+end_src

Assume it's a function, macro, or command, and run it:

#+begin_src emacs-lisp
                (eval (intern item))
#+end_src

Otherwise, if we told ~meq/load-from-cla~ to byte-compile ~dir~:

#+begin_src emacs-lisp
                (when ,byte-compile (byte-recompile-directory dir nil))
#+end_src

Then add ~dir~ to the ~load-path~:

#+begin_src emacs-lisp
                (add-to-list 'load-path dir)
#+end_src

And finally, if ~item~ was originally a file that exists, load it, and if it's an ~org~ file,
~org-babel-load-file~ it:

#+begin_src emacs-lisp
                (meq/cl file))))))
#+end_src

*** Yay, we're early!

This bit here will load an alternate ~early-init~ for a profile if ~--profile-early-init~ is passed on the
command-line, and otherwise, load the profile's usual ~early-init~ if it exists.

#+begin_src emacs-lisp
(meq/if-item-in-cla "--profile-early-init"
    (meq/load-from-cla "--profile-early-init")
    (meq/cl "early-init.el"))
#+end_src

*** A quiet place

If there's an alternate library directory or file the user wants to load,
~--profile-early-lib~ will do the trick:

#+begin_src emacs-lisp
(meq/load-from-cla "--profile-early-lib" t)
#+end_src

* Addendum

These are just a few blocks I use regularly in my ~org~ files, whether in ~noweb~, naming, or otherwise:

** username

#+name: username
#+begin_src text
shadowrylander
#+end_src

** hash-deprecated

# Adapted From: https://www.reddit.com/r/emacs/comments/4o9f0e/anyone_have_disabled_parts_of_their_config_being/d4apjey?utm_source=share&utm_medium=web2x&context=3

#+name: hash-deprecated
#+begin_src emacs-lisp :var name="" :tangle no
(md5 (concat (replace-regexp-in-string "/" "" (
    org-format-outline-path (org-get-outline-path))) (
        nth 4 (org-heading-components)) name))
#+end_src

** hash

#+name: hash
#+begin_src emacs-lisp :tangle no
(format-time-string "%Y%m%d%H%M%S%N")
#+end_src