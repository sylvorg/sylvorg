#+setupfile: /README.org
#+include: /README.org
#+startup: show2levels

* Deprecated
** Default

#+begin_src nix :tangle default.nix
inputs@{ config, pkgs, lib, channel, stdenv, dossier, host, type, legacyPackages, ... } : with builtins; with lib; with j; let
    inherit (stdenv) system;
    efiBoot = "/boot/efi";
in {
    # Help is available in the configuration.nix(5) man page
    # and in the NixOS manual (accessible by running ‘nixos-help’).
    imports = flatten [
        (r.list { dir = ./.; })
        (map (dir': r.list { dir = ./. + "/${dir'}"; }) [ "_platforms" "_devices" ])
    ];
    config = mkMerge [{
            services.logind.lidSwitch = "hybrid-sleep";
            boot.loader = {
                systemd-boot.enable = mkForce config.vars.bootPart;
                grub = {
                    enable = mkForce false;
		            # efiSupport = true;
                    devices = [
                        "nodev"
                        # config.vars.boot
                    ];
		            version = 2;
                };
                efi = {
                    canTouchEfiVariables = mkForce true;
                    efiSysMountPoint = "/boot/efi";
                };
            };
            fileSystems = let
                inherit (attrs.fileSystems) base;
                system = "${host}/system";
            in {
                "/" = mkForce (base // { device = "${system}/root"; });
                "/nix" = mkForce (base // { device = "${system}/nix"; });
                # "${bootMount}" = mkForce { device = config.vars.boot; fsType = "vfat"; };
            };
            networking = {
                # hostId = j.shell.execString { script = ''head -c4 /dev/urandom | od -A none -t x4''; };
                # hostId = j.shell.getHostID;
                # hostId = substring 0 8 (readFile "/etc/machine-id");
                hostId = "1a2b3c4d";
            };
            nixpkgs = { inherit system; inherit (legacyPackages) overlays config; };
            console = {
                # Select internationalisation properties.
                # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
                font = "Cartograph CF Light Italic";
                keyMap = "us";
            };
            # For Yubikey SSH-GPG Authentication
            environment.shellInit = ''
                export GPG_TTY="$(tty)"
                gpg-connect-agent /bye
                export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
                echo UPDATESTARTUPTTY | gpg-connect-agent
            '';
            hardware = {
                enableRedistributableFirmware = lib.mkDefault true;
                # Enable sound
                pulseaudio.enable = true;
            };
            i18n = {
                # Select internationalisation properties.
                defaultLocale = "en_US.UTF-8";
            };
            powerManagement = {
                enable = true;
                cpuFreqGovernor = mkForce "powersave";
            };
            programs = {
                # Some programs need SUID wrappers, can be configured further or are
                # started in user sessions.
                # mtr.enable = true;
                gnupg.agent = {
                    enable = true;
                    enableSSHSupport = false;
                    pinentryFlavor = "curses";
                };

                # For use with Yubikey SSH-GPG Authentication, set to false
                ssh.startAgent = true;

                xonsh.enable = true;
                fish.enable = true;
                zsh.enable = true;
            };
            security.pam = {
                yubico = {                                                                                                                                                                                                                                                
                    enable = true;
                    debug = true;
                    mode = "challenge-response";
                };
                enableSSHAgentAuth = true;
            };
            sound.enable = true;
            system = {
                # This value determines the NixOS release from which the default
                # settings for stateful data, like file locations and database versions
                # on your system were taken. It‘s perfectly fine and recommended to leave
                # this value at the release version of the first install of this system.
                # Before changing this value read the documentation for this option
                # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
                # stateVersion = "20.09"; # Did you read the comment?
                autoUpgrade = {
                    enable = true;
                    allowReboot = false;
                    flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
                };
            };
            time.timeZone = "America/Toronto";
            zramSwap = {
                enable = true;
                algorithm = "zstd";
            };
            virtualisation = {
                xen.enable = false;
                lxd = { zfsSupport = true; };
                podman.enable = true;
                docker = {
                    storageDriver = "zfs";
                    package = pkgs.docker;
                    enableOnBoot = true;
                };
            };
        }

        # (mkIf (config.vars.minimal -> config.vars.noSwap) {
        #     swapDevices = [{ device = "/dev/zvol/${host}/swap"; }];
        # })
    ];
}
#+end_src

** Flake

#+begin_src nix :tangle flake.nix
{
    description = "default";

    inputs = rec {

        home-manager = {
            url = "github:nix-community/home-manager/master";
            # https://github.com/nix-community/home-manager/blob/master/flake.nix#L4
            # HM takes 'nixpkgs' as input
            inputs.nixpkgs.follows = "nixpkgs";
        };
        doomSnippets = {
            url = "github:hlissner/doom-snippets/master";
            flake = false;
        };
        evilOrgMode = {
            url = "github:hlissner/evil-org-mode/master";
            flake = false;
        };
        orgMode = {
            url = "github:emacs-straight/org-mode/master";
            flake = false;
        };
        doomEmacsOverlay = {
            url = "github:nix-community/emacs-overlay/master";
            flake = false;
        };
        nixDoomEmacs = {
            url = "github:vlaci/nix-doom-emacs";
            inputs = {
                nixpkgs.follows = "nixpkgs";
                doom-snippets.follows = "doomSnippets";
                evil-org-mode.follows = "evilOrgMode";
                org-mode.follows = "orgMode";
                emacs-overlay.follows = "doomEmacsOverlay";
            };
        };

        mach-nix = {
            url = "github:davhau/mach-nix/master";
            inputs.nixpkgs.follows = "nixpkgs";
        };
        niv = {
            url = "github:nmattia/niv/master";
            flake = false;
        };
        flake-utils = {
            url = "github:numtide/flake-utils/master";
            inputs.nixpkgs.follows = "nixpkgs";
        };
        nur = {
            url = "github:nix-community/nur/master";
            inputs.nixpkgs.follows = "nixpkgs";
        };

        nixpkgs-20-03.url = "github:NixOS/nixpkgs/nixos-20.03";
        nixpkgs-20-03-small.url = "github:NixOS/nixpkgs/nixos-20.03-small";
        nixpkgs-20-09.url = "github:NixOS/nixpkgs/nixos-20.09";
        nixpkgs-20-09-small.url = "github:NixOS/nixpkgs/nixos-20.09-small";
        # nixpkgs-21-03.url = "github:NixOS/nixpkgs/nixos-21.03";
        # nixpkgs-21-03-small.url = "github:NixOS/nixpkgs/nixos-21.03-small";
        # nixpkgs-21-09.url = "github:NixOS/nixpkgs/nixos-21.09";
        # nixpkgs-21-09-small.url = "github:NixOS/nixpkgs/nixos-21.09-small";
        nixpkgs-unstable.url = "github:NixOS/nixpkgs/nixos-unstable";
        nixpkgs-small.url = "github:NixOS/nixpkgs/nixos-unstable-small";
        nixpkgs-master.url = "github:NixOS/nixpkgs/master";

        nixpkgs.follows = "nixpkgs-master";

        nix = {
            url = "github:NixOS/nix/master";

            # !!! Don't change this to follow anything other than the default! !!!
            # inputs.nixpkgs.follows = "nixpkgs";
        };

    };

    outputs = inputs@{ self, nix, nixpkgs, flake-utils, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let

        dossier = let
            nl = nixpkgs.lib;
            r = import ./lib/_r.nix nl;
            _lib' = import ./lib/_lib.nix nl;
            dir = ./bits/_flakes;
        in _lib'.foldToSet (
            [
                inputs
                (getFlake (toString dir)).inputs
            ] ++ (
                map (
                    dir': (
                        getFlake (
                            toString (
                                # ./. + "/bits/_flakes/${unsafeDiscardStringContext (trace dir' dir')}"
                                dir'
                            )
                        )
                    ).inputs
                ) (
                    r.list { inherit dir; ignores = [ "flake" ]; }
                )
            )
        );

        # systems = allSystems;
        systems = defaultSystems;
        # systems = [ "x86_64-linux" ];

        base' = { inherit sets base branchOverlay lib' lib dossier nix nixpkgs make forAllSystems prefix nameChannel; };

        base = {
            pkgs = import nixpkgs {};
            lib = mkLib base.pkgs;
            stdenv = import ./lib/_stdenv.nix { inherit (base) pkgs lib; };
            config = import ./lib/_config.nix base.stdenv;
            overlays = import ./lib/_overlays.nix base.pkgs base.lib dossier "pkgs" currentSystem "def";
        };

        mkLib = pkgs: nixpkgs.lib.extend (final: prev: {
            j = import ./lib {
                inherit dossier pkgs;
                lib = final;
            };
            f = true;
            h = dossier.hlissner.lib;
        });

        pkgs = import nixpkgs { inherit (base) config overlays; system = currentSystem; };
        lib' = mkLib pkgs;
        lib = lib'.extend (final: prev: { inherit sets; });
        inherit (lib) genAttrs;

        make = import ./bits/make.nix ({ inherit base' pkgs; } // base');

        branchOverlay = cpni@{ channel, progs ? [], nvs, ignores ? [] }: import ./bits/bo.nix (cpni // base');

        sets = import ./bits/sets.nix base';

        forAllSystems = func: genAttrs systems (system: genAttrs sets.types (type:
            mapAttrs (name: value: func { inherit name value system type; }) sets.nixpkgs'
        ));

        prefix = "nixpkgs";
        nameChannel = { name, ... }: let
            channel = removePrefix prefix name;
        in if (channel == "") then "pkgs" else (removePrefix "-" channel);

    in with lib; with j; dossier // {

        inherit lib dossier inputs;
        inherit (sets) nixpkgs' hosts channels types legacyPackages;

        # TODO: Why is there infinite recursion here?
        nixosConfigurations = foldToSet
            (flatten (map (host: map (system: map (type: map (channel: let
                hostName = sets.hostNames.${system}.${type}.${channel}.${host};
            in {
                "${hostName}" = sets.nixosConfigurations'.${system}.${type}.${channel}.${host};
            }) sets.channels) sets.types) systems) sets.hosts));

    } // (eachSystem systems (system: {
        defaultPackage = nixpkgs;
    }));

}
#+end_src

** CraZFS

*** CraZFS

#+begin_src python :tangle ./crazfs/crazfs.py
#!/usr/bin/env python3.9

# Imports
import click
import pout

# From Imports
from addict import Dict as D
from baker.y import (
    ls,
    mkdir,
    mkfs,
    mount,
    rm,
    umount,
    zfs,
    zpool,
)
from collections import namedtuple
from functools import partial
from nanite import Command
from os import path as osPath
from subprocess import DEVNULL

ls.bake_(l=True, a=True, _type=str)
mkdir.bake_(p=True)
rm.bake_(r=True, _popen=dict(stderr=DEVNULL))
umount.bake_(R=True, _popen=dict(stderr=DEVNULL))
zfs.bake_(_sc="list", r=True, H=True, _type=tuple)
zfs.bake_(_sc="snapshot", r=True)
zpool.bake_(_sc="export", _popen=dict(stderr=DEVNULL))

crazfs_mnt = "/crazfs_mnt"


@click.group(
    "", invoke_without_command=True, no_args_is_help=True
)
def main():
    pass


@main.command(
    name="create", cls=Command, no_args_is_help=True,
)
@click.option("-p", "--pool-name")
@click.option("-d", "--zfs-device")
@click.option("-e", "--encrypted", is_flag=True)
@click.option("-D", "--dedup", is_flag=True)
@click.option("-S", "--swap", is_flag=True)
@click.option("-n", "--dry-run", is_flag=True)
def create(pool_name, zfs_device, encrypted, dry_run, dedup, swap):
    try:
        if (
            click.prompt(
                'THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!',
                type=str,
            )
            == "ZFS CREATE"
        ):

            zfs.bake_all_(
                _print=True if dry_run else False,
                _capture="run" if dry_run else "stdout",
            )

            options = {
                "xattr": "sa",
                "acltype": "posixacl",
                "mountpoint": "none",
                "compression": "zstd-19",
                "checksum": "edonr",
                "atime": "off",
                "relatime": "off",
            }
            if encrypted:
                options["encryption"] = "aes-256-gcm"
                options["keyformat"] = "passphrase"
            if dedup:
                options["dedup"] = "edonr,verify"

            for dataset in zfs.list():
                if pool_name in dataset:
                    zpool.export(pool_name)
                    break

            zpool.create(
                pool_name,
                zfs_device,
                f=True,
                O={
                    "repeat_with_values": [
                        f"{key}={value}"
                        for key, value in options.items()
                    ]
                },
                o={
                    "repeat_with_values": [
                        "autotrim=on",
                        "altroot=/mnt",
                    ]
                },
                _run=True,
            )

            current_datasets = [pool_name]

            def recursive_create(
                root,
                datasets,
                snaproot="base",
                snapshot="blank",
                **kwargs,
            ):
                for dataset in datasets:
                    reconstruction = ""
                    full_dataset_split = f"{root}/{dataset}".split(
                        "/"
                    )
                    for index, part in enumerate(
                        full_dataset_split
                    ):
                        if index == 0:
                            reconstruction += f"{part}"
                        else:
                            reconstruction += f"/{part}"
                        if (
                            reconstruction
                            not in current_datasets
                        ):

                            partial_cc = partial(
                                getattr(
                                    zfs,
                                    "clone"
                                    if (encrypted and dedup)
                                    else "create",
                                ),
                                f"{pool_name}/{snaproot}@{snapshot}"
                                if (encrypted and dedup)
                                else "",
                                reconstruction,
                            )

                            partial_cc(
                                o=dict(
                                    repeat_with_values=(
                                        f"{key}={value}"
                                        for key, value in kwargs.items()
                                    )
                                )
                            ) if kwargs else partial_cc()

                            current_datasets.append(
                                reconstruction
                            )

            base_datasets = [
                "reserved",
                "system",
                "virt",
                "omniverse",
                "hold",
            ]
            if (encrypted and dedup):
                zfs.create(f"{pool_name}/base", o="mountpoint=legacy")
                zfs.snapshot(f"{pool_name}/base@blank")
            else:
                base_datasets.append("base")

            recursive_create(
                pool_name,
                base_datasets,
            )

            virt_datasets = (
                "docker",
                "podman",
                "qemu",
                "vagrant",
            )
            recursive_create(
                f"{pool_name}/virt",
                virt_datasets,
                mountpoint="legacy",
            )

            system_datasets = [
                "nix",
                "persist",
                "root",
                "tmp",
            ]

            recursive_create(
                f"{pool_name}/system",
                system_datasets,
                mountpoint="legacy",
            )

            zfs.set("mountpoint=legacy", f"{pool_name}/hold")
            zfs.set("sync=disabled", f"{pool_name}/system/tmp")

            home_datasets = (
                "curtis",
                "frost",
                "shadowrylander",
            )
            recursive_double = partial(
                recursive_create,
                datasets=home_datasets,
                mountpoint="legacy",
            )
            for root in (
                f"{pool_name}/system/home",
                f"{pool_name}/virt/podman",
                f"{pool_name}/system/persist/home",
                f"{pool_name}/system/persist/cache",
            ):
                recursive_double(root=root)
    
            zfs.set("sync=disabled", f"{pool_name}/system/persist/cache")

            backup_datasets = (
                "dreadnought",
                "redstone",
                "sinnoh",
            )
            pool_party_datasets = (
                [
                    f"las/{backup}/zpax"
                    for backup in backup_datasets
                ]
                + [
                    f"las/{backup}/zsyncs"
                    for backup in backup_datasets
                ]
                + [
                    "borg/cache",
                    "jails/base",
                    "b/a",
                    "b/cl",
                    "y",
                    "z",
                ]
            )
            recursive_create(
                f"{pool_name}/{pool_name}",
                pool_party_datasets,
                mountpoint="legacy",
            )

            extra_copy_datasets = (
                f"{pool_name}/b/cj/cc",
                f"{pool_name}/b/eb",
            )
            recursive_create(
                pool_name,
                extra_copy_datasets,
                copies=2 if encrypted else 3,
                snapdir="visible",
                mountpoint="legacy",
            )

            snapdir_datasets = (
                f"{pool_name}/b/oreo",
                f"{pool_name}/b/cj/m",
                f"{pool_name}/b/cc",
                f"{pool_name}/b/p",
            )
            recursive_create(
                pool_name,
                snapdir_datasets,
                snapdir="visible",
                mountpoint="legacy",
            )

            pool_size_plus_metric = zpool.get(
                "size",
                pool_name,
                H=True,
                _type=str,
                _print=False,
            ).split()[2]

            pool_size = round(
                float(pool_size_plus_metric[:-1]), 2
            )
            pool_metric = pool_size_plus_metric[-1]

            def pool_percentage_value(percentage):
                return (
                    str(
                        round(
                            (
                                (float(percentage) / 100)
                                * pool_size
                            ),
                            2,
                        )
                    )
                    + pool_metric
                )

            zfs.set(
                f"refreservation={pool_percentage_value(15)}",
                f"{pool_name}/reserved",
            )
            zfs.set(
                f"refreservation=none",
                f"{pool_name}/virt/qemu",
            )

            if swap:
                from baker.y import getconf, mkswap
                zfs.create(
                    f"{pool_name}/swap",
                    V = "8G",
                    b = getconf("PAGESIZE", _type = str),
                    o = dict(
                        repeat_with_values = (
                            "compression=zle",
                            "sync=standard",
                            "com.sun:auto-snapshot=false",
                            "logbias=throughput",
                            "primarycache=metadata",
                            "secondarycache=none",
                        )
                    ),
                )
                mkswap(f"/dev/zvol/{pool_name}/swap", f = True)

            for base in base_datasets:
                zfs.snapshot(f"{pool_name}/{base}@blank", r = True)

        else:
            from sys import exit

            click.echo("Sorry! Not continuing.")
            exit(0)
    finally:
        if not dry_run:
            zpool.export(pool_name)


@main.command(
    name="mount",
    context_settings=dict(ignore_unknown_options=True,),
    cls=Command,
    no_args_is_help=True,
)
@click.option("-p", "--pool-name")
@click.option("-b", "--boot-device")
@click.option("-e", "--encrypted", is_flag=True)
@click.option("-S", "--swap", is_flag=True)
@click.option("-n", "--dry-run", is_flag=True)
def zmount(
    pool_name, boot_device, encrypted, dry_run, swap
):

    zfs.bake_all_(
        _print=True if dry_run else False,
        _capture="run" if dry_run else "stdout",
    )

    for dataset in zfs.list():
        if pool_name in dataset:
            break
    else:
        zpool(pool_name, f=True, _subcommand="import")

    if encrypted:
        zfs.load_key(pool_name, _capture="run")

    if osPath.isdir("/mnt"):
        umount("/mnt")
    else:
        mkdir("/mnt")

    mount(f"{pool_name}/system/root", "/mnt", t="zfs")

    for _mount in [ "nix", "persist", "tmp" ]:
        if not osPath.isdir(_ := f"/mnt/{_mount}"):
            mkdir(_)
        mount(f"{pool_name}/system/{_mount}", _, t="zfs")

    if not osPath.isdir(boot := "/mnt/boot"):
        mkdir(boot)
    # if not osPath.isdir(boot := "/mnt/boot/efi"):
    #     mkdir(boot)
    mount(boot_device, boot)

    if swap:
        from baker.y import swapon
        swapon(f"/dev/zvol/{pool_name}/swap")


if __name__ == "__main__":
    main()
#+end_src

*** Create

#+begin_src python :tangle ./crazfs/create.py
#!/usr/bin/env xonsh

# Imports
import argparse
import json

parser = argparse.ArgumentParser()
parser.add_argument("-p", "--pool-name")
parser.add_argument("-d", "--zfs-device")
parser.add_argument("-e", "--encrypted", action="store_true")
parser.add_argument("-D", "--dedup", action="store_true")
parser.add_argument("-s", "--swap", action="count")
parser.add_argument("-u", "--update", action="store_true")
parser.add_argument("-f", "--files", action="store_true")
args = parser.parse_args()

def xrun(command):
    @(command.split())

try:
    if args.update or args.files or (
        input(
            'THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\t',
        ) == "ZFS CREATE"
    ):

        resources = "../../etc/nixos/resources"

        if not (args.update or args.files):
            options = {
                "xattr": "sa",
                "acltype": "posixacl",
                "mountpoint": "none",
                "compression": "zstd-19",
                "checksum": "edonr",
                "atime": "off",
                "relatime": "off",
            }
            if args.encrypted:
                options["encryption"] = "aes-256-gcm"
                options["keyformat"] = "passphrase"
            if args.dedup:
                options["dedup"] = "edonr,verify"

            for dataset in $(zfs list -rH).split("\n"):
                if args.pool_name in dataset:
                    xrun(f"zpool export {args.pool_name}")
                    break

            command = f"zpool create -fo autotrim=on -o altroot=/mnt"

            for key, value in options.items():
                command += f" -O {key}={value}"

            xrun(f"{command} {args.pool_name} {args.zfs_device}")

        snapDir = [ "snapdir=visible" ]
        extraCopies = snapDir + [ f"copies={2 if args.encrypted else 3}" ]
        cache = [ "sync=disabled" ]
        ml = "mountpoint=legacy"
        dd = {  }
        ddd = { "datasets": {  }}
        d = "datasets"
        s = "system"

        with open(f"{resources}/datasets.json") as _datasets:
            datasets = json.load(_datasets)
            dsd = datasets[s][d]

            datasets[args.pool_name] = {
                "datasets": {
                    "b": {
                        "datasets": {
                            "a": dd,
                            "cc": { "options": snapDir },
                            "cl": dd,
                            "cj": { "datasets": {
                                "cc": { "options": extraCopies },
                                "m": { "options": snapDir }
                            }},
                            "eb": { "options": extraCopies },
                            "oreo": { "option": snapDir },
                            "p": { "options": snapDir }
                        },
                    },
                    "borg": { "datasets": { "cache": { "options": cache }}},
                    "jails": { "datasets": { "base": dd}},
                    "las": {
                        "datasets": {
                            "dreadnought": ddd,
                            "redstone": ddd,
                            "sinnoh": ddd
                        }
                    },
                    "y": dd,
                    "z": dd
                },
                "options": [ ml ]
            }

            with open(f"{resources}/users.json") as ujson:
                users = json.dump(ujson)
                for user in users.values():
                    dsd["home"][d][user] = dd
                    datasets["virt"][d]["podman"][d][user] = dd
                    for dataset in (persist := dsd["persist"][d]).keys():
                        persist[dataset][d][user] = dd

            for backup in (las := datasets[args.pool_name][d]["las"][d]).keys():
                for zz in [ "zpax", "zsyncs" ]:
                    las[backup][d][zz] = dd

            with open(f"{resources}/datasets.nix", "w+") as dnix:

                dnix.write("host: {\n")

                def recurse(ddict, dname, droot, mountpoint = ""):

                    _dataset = f"{droot}/{dname}"

                    # cc: clone or create
                    # son: snapshot or none
                    if (dname != "base") and (args.encrypted and args.dedup):
                        cc = "clone"
                        son = f"{args.pool_name}/base@root"
                    else:
                        cc = "create"
                        son = ""

                    _doptions = ddict.get("options", [])
                    if _dataset not in ( f"{args.pool_name}/{dataset}" for dataset in (
                        "system",
                        "system/root",
                        "swap",
                        "base",
                        "hold",
                        "omniverse",
                        "reserved",
                    )):
                        pn1 = args.pool_name
                        pn2 = f"{pn1}/{pn1}"

                        # TODO: Make this such that the current dataset directory
                        #       is placed under the parent directory's mountpoint
                        if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                            if mountpoint = "":
                                _mountpoint = _dataset.replace(
                                    pn2 if pn2 in _dataset else pn1
                                    "${host}",
                                    1
                                )
                            else:
                                mountpoint = _mountpoint = f"{mountpoint}/{dname}"

                        dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
                    doptions = " -o ".join(_doptions)

                    if not args.files:
                        xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
                        xrun(f"zfs snapshot -r {_dataset}@root")

                    for dataset in (ddictd := ddict.get(
                        d,
                        dd
                    )):
                        recurse(ddictd[dataset], dataset, _dataset, mountpoint)

                for dataset in datasets:
                    recurse(datasets[dataset], dataset, args.pool_name)

                dnix.write("}")

        if not args.files:
            pool_size_plus_metric = $(zpool get -H size @(args.pool_name)).split()[2]
            pool_size = round(float(pool_size_plus_metric[:-1]), 2)
            pool_metric = pool_size_plus_metric[-1]

            def pool_percentage_value(percentage):
                return (
                    str(
                        round(
                            (
                                (float(percentage) / 100)
                                * pool_size
                            ),
                            2,
                        )
                    )
                    + pool_metric
                )

            # Apparently, if python internal keywords exist in the argument, such as "set", etc.
            # the command errors out; perhaps something to raise an issue of.
            # This seems to work as an alternative.
            xrun(f"zfs set refreservation={pool_percentage_value(15)} {args.pool_name}/reserved")

        if args.swap and (not args.files):
            _swoptions = [
                "com.sun:auto-snapshot=false",
                "compression=zle",
                "logbias=throughput",
                "primarycache=metadata",
                "secondarycache=none"
                "sync=standard",
            ]
            swoptions = " -o ".join(_swoptions)

            ps = $(getconf PAGESIZE)
            xrun(f"zfs create -V {2**args.swap}G -b {ps} -o {swoptions} {args.pool_name}/swap")

            xrun(f"mkswap -f /dev/zvol/{args.pool_name}/swap")

    else:
        from sys import exit

        print("Sorry! Not continuing.")
        exit(0)

finally:
    if not args.files:
        xrun(f"zpool export {args.pool_name}")
#+end_src

*** Mount

#+begin_src python ./crazfs/mount.py
#!/usr/bin/env xonsh

# Imports
import argparse
import json

# From Imports
from collections import namedtuple
from functools import partial
from os import path as osPath
from subprocess import DEVNULL

parser = argparse.ArgumentParser()
parser.add_argument("-p", "--pool-name")
parser.add_argument("-d", "--boot-device")
parser.add_argument("-e", "--encrypted", action="store_true")
parser.add_argument("-s", "--swap", action="count")
args = parser.parse_args()

def xrun(command):
    @(command.split())

resources = "../../etc/nixos/resources"

for dataset in $(zfs list).split("\n"):
    if args.pool_name in dataset:
        break
else:
    xrun(f"zpool import -f {args.pool_name}")

if args.encrypted:
    xrun(f"zfs load-key {args.pool_name}")

if osPath.isdir("/mnt"):
    xrun("umount -R /mnt")
else:
    xrun("mkdir /mnt")

xrun(f"mount -t zfs {args.pool_name}/system/root /mnt")

with open(f"{resources}/datasets.nix") as datasets:
    for dataset in datasets.readlines()[1:-1]:
        dataset = dataset.strip().strip('"')

        r = f"{args.pool_name}/"
        sr = r + "system/"
        _mount = dataset.replace(
            sr if sr in dataset else r,
            '',
            1
        )

        if not osPath.isdir(mount := f"/mnt/{_mount}"):
            xrun(f"mkdir -p {mount}")
        xrun(f"mount -t zfs {dataset} {mount}")

if not osPath.isdir(boot := "/mnt/boot/efi"):
    xrun(f"mkdir -p {boot}")
xrun(f"mount {args.boot_device} {boot}")

if args.swap:
    xrun(f"swapon /dev/zvol/{args.pool_name}/swap")
#+end_src

*** Org-Tangle

#+name: tangle
#+begin_src emacs-lisp

#+end_src

#+begin_src shell :tangle ./crazfs/org-tangle.py


{{{tangle}}}
#+end_src

** Home-Manager

#+begin_src nix :tangle ~/.config/nixpkgs/home.nix
inputs@{
    channel,
    dossier,
    host,
    hostName,
    legacyPackages,
    lib,
    nixpkgs,
    payload,
    pkgs,
    stdenv,
    type,
    ...
}:

with builtins; with lib; with j; with payload; let
    exists = source: target: myIf.knull (pathExists source) target;
    pSource = source: "${pHomeDirectory}/${source}";
    pUser = attrs.users.primary;
    redFile = file': let file = "/${dotfiles}/${file'}"; in if (pathExists file) then (readFile (/. + file)) else "";
    emacsConfigs = ".emacs-configs";
    emacsDistros = ".emacs-distros";

    base = user: with payload.${user}; let
        pExists = source: target: myIf.knull (
            (user == pUser) && (pathExists "${pHomeDirectory}/${source}")
        ) target;

        links' = rec {
            cookiejar = {
                source = "/${host}/b/cj";
                target = "cj";
            };
            picotech = {
                source = "${cookiejar.source}/cc/.pico";
                target = ".pico";
            };
            byobu = {
                source = "${homeDirectory}/.tmux.conf";
                target = ".byobu/.tmux.conf";
            };
        };
        links = mapAttrs (link: st: {
            inherit (st) target;
            source = /. + st.source;
        }) (filterAttrs (link: st: pathExists (/. + st.source)) links');

        baseOptions = {
            # force = true;
        };
 
        imports = inputs // {
            inherit
                baseOptions
                homeDirectory
                dotfiles
                redFile
                exists
                pExists
                links
                pSource
                pUser
                emacsConfigs
                emacsDistros;
        };
    in {
        activation = ''
            peru \
                --file=${homeDirectory}/peru.yaml \
                --sync-dir=${homeDirectory} \
                --state-dir=${homeDirectory}/.peru \
                --cache-dir=${homeDirectory}/.peru/cache \
            sync
        '';
        inherit lib;

	    nixpkgs = { inherit (stdenv) system; inherit (legacyPackages) overlays config; };

        imports = with dossier; [
            nixDoomEmacs.hmModule
            "${dossier.impermanence}/home-manager.nix"
        ];
        fonts.fontconfig.enable = mkForce true;
        programs = let
            ignores = [
                "_gsdata_"
                ".boar"
                ".git"
                "**/__pycache__"
                "**/_build"
                "**/.vscode"
                "**/*.!sync"
                "**/*.bts"
                "**/*.envrc"
                "**/*.swp"
                "**/*.sync"
                "**/*.test.*"
                "**/*.tmp"
                "**/deprecated"
                "**/dist"
                "**/result"
                "**/tests"
                "**/unfinished"
                "temp"
            ];
            userName  = "shadowrylander";
            userEmail = "aiern@protonmail.com";
            shellAliases = {
                n = "exit";
                c = "clear";
            };
            vim = import ./vim.nix imports;
        in {
            git = baseOptions // {
                # File at ~/.config/git/config
                enable = true;
                package = pkgs.git;
                attributes = [
                    "*.sec filter=git-crypt diff=git-crypt"
                    "id_* filter=git-crypt diff=git-crypt"
                    ".gnupg/** filter=git-crypt diff=git-crypt"
                ];
                extraConfig = {
                    annex.largefiles = ''
                        include=**/__pycache__/* or \
                        include=**/dist/* or \
                        include=**/tests/* or \
                        include=**/deprecated/* or \
                        include=**/unfinished/* or \
                        include=**/.vscode/* or \
                        include=**/*.test.* or \
                        include=**/*.envrc
                    '';
                };
                inherit ignores userEmail userName;
            };
            direnv = baseOptions // {
                # File at ~/.config/direnv/direnvrc
                enable = true;
                enableBashIntegration = true;
                enableFishIntegration = true;
                enableNixDirenvIntegration = true;
                enableZshIntegration = true;
                stdlib = ''
                    use_flake() {
                        watch_file flake.nix
                        watch_file flake.lock
                        eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
                    }
                '';
            };
            inherit vim;
            neovim = baseOptions // {
                enable = true;
                # package = pkgs.neovim;
                inherit (vim) extraConfig plugins;
            };
            vscode = baseOptions // {
                enable = true;
                package = pkgs.vscode;
                # keybindings = {  };
                userSettings = {  };
                extensions = with pkgs.vscode-extensions; [
                    bbenoist.Nix
                    dhall.dhall-lang
                    dhall.vscode-dhall-lsp-server
                    formulahendry.auto-close-tag
                    james-yu.latex-workshop
                    ms-azuretools.vscode-docker
                    ms-kubernetes-tools.vscode-kubernetes-tools
                    # ms-python.python
                    ms-python.vscode-pylance
                    ms-vscode-remote.remote-ssh
                    ms-vscode.cpptools
                    ms-vsliveshare.vsliveshare
                    pkief.material-icon-theme
                    redhat.vscode-yaml
                    skyapps.fish-vscode
                    tamasfe.even-better-toml
                    # vadimcn.vscode-lldb
                    vscodevim.vim
                    vscodevim.vimacs
                ];
            };
            mercurial = baseOptions // {
                enable = true;
                package = pkgs.mercurial;
                inherit ignores userEmail userName;
                ignoresRegexp = [];
                extraConfig = redFile ".hgrc";
            };
            zsh = import ./zshrc.nix (imports // { inherit shellAliases; });
            fish = baseOptions // {
                enable = false;
                package = pkgs.fish;
                functions = shellAliases // {
                    sf= "source ~/.config/fish/config.fish";
                    djn = ''
                        docker run -p 8888:8888 -v "$PWD":/home/jovyan/work --rm jupyter/datascience-notebook
                    '';
                    elvis = "rm -rf /tmp/elvish-1000/sock && elvish";
                };
                interactiveShellInit = '' starship init fish | source '';
                plugins = [  ];
            };
            bash = baseOptions // {
                enable = true;
                enableVteIntegration = true;
                initExtra = '' eval "$(starship init bash)" '';
                inherit shellAliases;
                shellOptions = [  ];
            };
            tmux = import ./tmux.nix imports;
            doom-emacs = baseOptions // {
                enable = true;
                emacsPackage = pkgs.emacsGit-nox;
                extraConfig = '' '';
                doomPrivateDir = "${dotfiles}/.doom.d";
                emacsPackagesOverlay = final: prev: {
                    magit-delta = super.magit-delta.overrideAttrs (eprev: {
                        buildInputs = eprev.buildInputs ++ [ pkgs.git ];
                    });
                };
                # extraPackages = with pkgs."emacs${j.attrs.versions.emacs}Packages"; [ sqlite3 emacsql-sqlite3 ];
            };
            kitty = baseOptions // {
                enable = true;
                extraConfig = '' include ./theme.conf '';
                settings.font_family = "Cartograph CF Light Italic";
            };
            home-manager.enable = true;
        };
        services = {
            gpg-agent = {
                enable = true;
                enableSshSupport = false;
                pinentryFlavor = "curses";
            };
            emacs = {
                enable = true;
                package = dossier.nixDoomEmacs;
            };
        };
        home = {
            file = with links; with dossier; with (import ./funcs.nix imports); mapAttrs (n: v: { force = true; } // v) (foldToSet (flatten [
                (map redFile' [ ".config/qtile/config.py" ])
                (map withLink (attrValues links))
                (map imported [ ".xonshrc" ])
                (map baseOf [  ])
                (map (set: withTarget set.source set.target) [])
                # (map (source: homeLink homeDirectory source 0) [
                #     ".atom"
                #     ".byobu"
                #     ".config"
                #     ".emacs-profile"
                #     # ".git-crypt"
                #     # ".gnupg"
                #     ".linuxbrew"
                #     ".local"
                #     ".mozilla"
                #     ".pki"
                #     # ".ssh"
                #     ".vim-runtime"
                #     ".virtualenvs"
                #     ".vscode-oss"
                #     ".vscode"
                #     "Documents"
                #     "Downloads"
                #     "keybase"
                #     "Music"
                #     "nix-plugins"
                #     "Pictures"
                #     "Public"
                #     "Videos"
                #     ".yubico"
                #     "Templates"
                #     ".nix-channels"
                #     ".python-history"
                #     ".viminfo"
		        #     ".zsh-history"
                #     ".bash-history"
                #     ".peru"
                # ])
                # (map (source: homeLink homeDirectory source 1) (map (dir: ".cache/${dir}") [
                #     "flatpak"
                #     "gnome-software"
                #     "google-chrome-beta"
                #     "google-chrome-dev"
                #     "google-chrome"
                #     "Homebrew"
                #     "keybase"
                #     "mozilla"
                #     "nix"
                #     "pip"
                #     "pypoetry"
                #     "qtile"
                #     "starship"
                #     "vivaldi"
                #     # "Yubico"
                # ]))

                [{
                    "${homeDirectory}" = {
                        source = "/persist/${homeDirectory}";
                        recursive = true;
                    };
                    "cache" = {
                        source = "/persist/cache/${user}";
                        target = "${homeDirectory}/.cache";
                        recursive = true;
                    };
                    "keybase" = {
                        source = "${pHomeDirectory}/.key";
                        target = homeDirectory;
                        recursive = true;
                    };
                    "largefiles" = {
                        source = "/persist/largefiles";
                        target = homeDirectory;
                        recursive = true;
                    };
                    # ".doom.d/system_init.el".text = ''
                    #   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".emacsql-sqlite3}/bin")
                    #   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".sqlite3}/bin")
                    # '';

                    ".direnvrc".text = (redFile ".direnvrc") + ''
                        source $HOME/.nix-direnv/direnvrc
                        source $HOME/.config/direnv/direnvrc

                        if [ -f /run/current-system/sw/share/nix-direnv/direnvrc ]; then
                            source /run/current-system/sw/share/nix-direnv/direnvrc
                        fi
                    '';

                    "rc.elv".text = let gondolin = "github.com/tylerreckart/gondolin"; in ''
                        use epm
                        epm:install ${gondolin}
                        use ${gondolin}/gondolin
                    '';

                    ".config/kitty/theme.conf".source = "${kittyThemes}/themes/Monokai_Soda.conf";

                    ".config/powershell/Microsoft.PowerShell_profile.ps1".text = '' Invoke-Expression (&starship init powershell) '';

                    ".config/ion/initrc".text = '' eval $(starship init ion) '';

                    ".config/nixpkgs/overlays.nix".text = ''
                        (builtins.getFlake "${lib.j.paths.nixos}").legacyPackages.${stdenv.system}.${type}."${channel}".overlays
                    '';
		            ".config/nixpkgs/config.nix".text = ''
			            (builtins.getFlake "${lib.j.paths.nixos}").legacyPackages.${stdenv.system}.${type}."${channel}".config
		            '';

		            ".config/nix/nix.conf".text = j.attrs.configs.nix;
                }]
            ]));
        };
    };
in genAttrs j.attrs.allUsers base
#+end_src

** Tmux

*** Byobu

#+begin_src conf :tangle ~/byobu/.tmux.conf
# Mouse support - set to on if you want to use the mouse
# setw -g mode-mouse on
# set -g mouse-select-pane on
# set -g mouse-resize-pane on
# set -g mouse-select-window on

# enable activity alerts
setw -g monitor-activity on
set -g visual-activity on

# Center the window list
set -g status-justify centre

bind r source-file ${HOME}/.tmux.conf \; display-message "Source-file Reloaded"

# utf8 is on
set -g utf8 on
set -g status-utf8 on

# address vim mode switching delay (http://superuser.com/a/252717/65504)
set -s escape-time 0

# increase scrollback buffer size
set -g history-limit 50000

# tmux messages are displayed for 1.25 seconds
set -g display-time 1250

# refresh 'status-left' and 'status-right' more often
# set -g status-interval 1

# focus events enabled for terminals that support them
set -g focus-events on

# super useful when using "grouped sessions" and multi-monitor setup
setw -g aggressive-resize on

# ========== TMUX Plugin Manager ==========

if "test ! -d ~/.byobu/tmux_plugins/tpm" \
      "run 'git clone https://github.com/tmux-plugins/tpm ~/.byobu/tmux_plugins/tpm && ~/.byobu/tmux_plugins/tpm/bin/install_plugins'"

set-environment -g TMUX_PLUGIN_MANAGER_PATH '~/.byobu/tmux_plugins'

# List of plugins - https://github.com/tmux-plugins/tpm/blob/master/docs/tpm_not_working.md
# set -g @plugin 'tmux-plugins/tpm'
# set -g @plugin 'tmux-plugins/tmux-sensible'
# set -g @plugin 'tmux-plugins/tmux-resurrect'
# set -g @plugin 'tmux-plugins/tmux-continuum'

# Other examples:
# set -g @plugin 'github_username/plugin_name'
# set -g @plugin 'git@github.com/user/plugin'
# set -g @plugin 'git@bitbucket.com/user/plugin'

set -g @tpm_plugins 'tmux-plugins/tpm   \
        tmux-plugins/tmux-sensible                      \
        tmux-plugins/tmux-resurrect                     \
        tmux-plugins/tmux-continuum                     \
'
set -g @resurrect-dir '~/.byobu/tmux_resurrect'
set -g @resurrect-save-bash-history 'on'
set -g @continuum-save-interval '10'
set -g @continuum-boot 'on'

# Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf)
run '~/.byobu/tmux_plugins/tpm/tpm'
#+end_src

*** Tmuxinator

**** Client

#+begin_src yaml :tangle ~/.config/tmuxinator/client.yml
# /home/shadowrylander/.config/tmuxinator/master.yml

name: master
root: ~/

# Optional tmux socket
# socket_name: master

# Note that the pre and post options have been deprecated and will be replaced by
# project hooks.

# Project hooks
# Runs on project start, always
# on_project_start: command
# Run on project start, the first time
# on_project_first_start: command
# Run on project start, after the first time
# on_project_restart: command
# Run on project exit ( detaching from tmux session )
# on_project_exit: command
# Run on project stop
# on_project_stop: command

# Runs in each window and pane before window/pane specific commands. Useful for setting up interpreter versions.
# pre_window: rbenv shell 2.0.0-p247

# Pass command line options to tmux. Useful for specifying a different tmux.conf.
# tmux_options: -f ~/.tmux.mac.conf

# Change the command to call tmux.  This can be used by derivatives/wrappers like byobu.
tmux_command: byobu

# Specifies (by name or index) which window will be selected on project startup. If not set, the first window is used.
# startup_window: editor

# Specifies (by index) which pane of the specified window will be selected on project startup. If not set, the first pane is used.
# startup_pane: 1

# Controls whether the tmux session should be attached to automatically. Defaults to true.
# attach: false

windows:
  - master:
      layout: 72ed,180x58,0,0{90x58,0,0,1,89x58,91,0[89x29,91,0,16,89x28,91,30,17]}
      # Synchronize all panes of this window, can be enabled before or after the pane commands run.
      # 'before' represents legacy functionality and will be deprecated in a future release, in favour of 'after'
      # synchronize: after
      panes:
        - clear
        - clear
        - clear
  - full: clear
  # - argus: mosh argus
  - gotop: gotop
  - glances: glances
#+end_src

**** Default

#+begin_src yaml :tangle ~/.config/tmuxinator/default.yml
name: full
root: ~/

# Optional tmux socket

# socket_name: full

# Note that the pre and post options have been deprecated and will be replaced by
# project hooks.

# Project hooks
# Runs on project start, always
# on_project_start: command
# Run on project start, the first time
# on_project_first_start: command
# Run on project start, after the first time
# on_project_restart: command
# Run on project exit ( detaching from tmux session )
# on_project_exit: command
# Run on project stop
# on_project_stop: command

# Runs in each window and pane before window/pane specific commands. Useful for setting up interpreter versions.
# pre_window: rbenv shell 2.0.0-p247

# Pass command line options to tmux. Useful for specifying a different tmux.conf.
# tmux_options: -f ~/.tmux.mac.conf

# Change the command to call tmux.  This can be used by derivatives/wrappers like byobu.
tmux_command: byobu

# Specifies (by name or index) which window will be selected on project startup. If not set, the first window is used.
# startup_window: editor

# Specifies (by index) which pane of the specified window will be selected on project startup. If not set, the first pane is used.
# startup_pane: 1

# Controls whether the tmux session should be attached to automatically. Defaults to true.
# attach: false

windows:
  - default:
      layout: 72ed,180x58,0,0{90x58,0,0,1,89x58,91,0[89x29,91,0,16,89x28,91,30,17]}
      # Synchronize all panes of this window, can be enabled before or after the pane commands run.
      # 'before' represents legacy functionality and will be deprecated in a future release, in favour of 'after'
      # synchronize: after
      panes:
        - clear
        - clear
        - clear
  - full: clear
  - argus: mosh argus
  - gotop: gotop
  - glances: glances
  - wtf: wtf
#+end_src

**** Server

#+begin_src yaml :tangle ~/.config/tmuxinator/server.yml
# /home/shadowrylander/.config/tmuxinator/apprentice.yml

name: apprentice
root: ~/

# Optional tmux socket
# socket_name: apprentice

# Note that the pre and post options have been deprecated and will be replaced by
# project hooks.

# Project hooks
# Runs on project start, always
# on_project_start: command
# Run on project start, the first time
# on_project_first_start: command
# Run on project start, after the first time
# on_project_restart: command
# Run on project exit ( detaching from tmux session )
# on_project_exit: command
# Run on project stop
# on_project_stop: command

# Runs in each window and pane before window/pane specific commands. Useful for setting up interpreter versions.
# pre_window: rbenv shell 2.0.0-p247

# Pass command line options to tmux. Useful for specifying a different tmux.conf.
# tmux_options: -f ~/.tmux.mac.conf

# Change the command to call tmux.  This can be used by derivatives/wrappers like byobu.
tmux_command: byobu

# Specifies (by name or index) which window will be selected on project startup. If not set, the first window is used.
# startup_window: editor

# Specifies (by index) which pane of the specified window will be selected on project startup. If not set, the first pane is used.
# startup_pane: 1

# Controls whether the tmux session should be attached to automatically. Defaults to true.
# attach: false

windows:
  - default:
      layout: b53d,180x57,0,0{90x57,0,0,0,89x57,91,0[89x28,91,0,8,89x28,91,29,9]}
      # Synchronize all panes of this window, can be enabled before or after the pane commands run.
      # 'before' represents legacy functionality and will be deprecated in a future release, in favour of 'after'
      # synchronize: after
      panes:
        - clear
        - clear
        - clear
  - full: clear
  - gotop: gotop
  - glances: glances
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# Local Variables:
# org-babel-noweb-wrap-start: "{{{"
# org-babel-noweb-wrap-end: "}}}"
# org-confirm-babel-evaluate: nil
# org-export-allow-bind-keywords: t
# End:

** makefile

#+begin_src makefile
copy:
	rsync -avvczz --delete /mnt/c/Users/titan/persist/.doom.d/ ~/.doom.d/
tangle:
	chmod +x ~/.doom.d/org-tangle
	~/.doom.d/org-tangle ~/.doom.d/README.org
sync:
	~/.emacs.d/bin/doom sync
check:
	~/.emacs.d/bin/doom doctor
test:
	emacs -nw ~/.doom.d/README.org
doom-me:
	sudo chown -R shadowrylander:shadowrylander ~/.doom.d
doom-root:
	chown -R root:root ~/.doom.d

firstall: doom-me copy tangle sync check
.DEFAULT_GOAL=firstall

all: firstall test
dockerall: doom-root tangle sync check test
copyback:
	cp ~/.doom.d/config.el /mnt/c/Users/titan/persist/.doom.d/
	cp ~/.doom.d/init.el /mnt/c/Users/titan/persist/.doom.d/
	cp ~/.doom.d/packages.el /mnt/c/Users/titan/persist/.doom.d/
	cp ~/.doom.d/org-tangle /mnt/c/Users/titan/persist/.doom.d/
	cp ~/.doom.d/org-tangle-functions.el /mnt/c/Users/titan/persist/.doom.d/

restore:
	cp ~/.doom.d/config.el{.bak,}
view:
	cat ~/.doom.d/config.el | less
clone:
	git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d
install:
	~/.emacs.d/bin/doom install
delete:
	rm -rf ~/.emacs.d ~/.doom.d
reset: doom-me delete clone install copy tangle sync check test

build: copy
	cp /mnt/c/Users/titan/persist/README.org ./
	sudo docker build --no-cache -t test .
run:
	docker run --rm -ti --network host \
		-v ~/.gccemacs.d:/root/.emacs.d \
		-v ~/.doom.d:/root/.doom.d \
	test

docker: build run

hm:
	export NIX_PATH=nixpkgs=https://github.com/nixos/nixpkgs/archive/master.tar.gz
	chmod +x ~/.doom.d/org-tangle
	~/.doom.d/org-tangle /mnt/c/Users/titan/persist/etc/nixos/b.org
	rsync -avvczz --exclude .doom.d /mnt/c/Users/titan/persist/ ~/
	# home-manager switch -A 3ee73a --show-trace
	# home-manager switch --show-trace
	# nix-shell '<home-manager>' -A install
	# /nix/store/c6j3a93wmdh3bljiyq6k9bdkgbrlfj5n-home-manager/bin/home-manager switch --substitute -A 65df34884a79b143a95182a493213ce18bf33fef8c6395f41128eb2e5bda48f8c492f528bd175759c4c0ddfaac9344236a931efd1c2031a6f38084e64e4298d0 --show-trace --keep-going
	/nix/store/c6j3a93wmdh3bljiyq6k9bdkgbrlfj5n-home-manager/bin/home-manager switch --substitute -A 3ee73a --show-trace --keep-going
	# /nix/store/c6j3a93wmdh3bljiyq6k9bdkgbrlfj5n-home-manager/bin/home-manager switch --substitute -A 65df34884a79b143a95182a493213ce18bf33fef8c6395f41128eb2e5bda48f8c492f528bd175759c4c0ddfaac9344236a931efd1c2031a6f38084e64e4298d0 --show-trace
	# /nix/store/c6j3a93wmdh3bljiyq6k9bdkgbrlfj5n-home-manager/bin/home-manager switch --substitute -A 3ee73a --show-trace
#+end_src

** Dockerfile

#+begin_src Dockerfile
FROM andreacorallo/emacs-nativecomp
ENTRYPOINT make dockerall
RUN apt update && \
    apt install -y make ripgrep sqlite3 python git vim && \
    mkdir -p ~/org/roam
COPY ./README.org /README.org
COPY ./makefile /root/makefile
#+end_src

** NixOS
*** configs

#+call: hash() :exports none

#+RESULTS:
: 20210601184724193852200

#+name: 20210601184724193852200
#+begin_src nix
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        (imprelib.list { dir = ./.; })
        (imprelib.list { dir = ../../config; ignores = [ "datasets" ]; })
        ../../configuration.nix
        ../../hardware-configuration.nix
    ];
#+end_src

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

**** dross
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** sandshrew
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** yggdrasil
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** siluam
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

*** flakes
**** bootstrap
***** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184751675181500

#+name: 20210601184751675181500
#+begin_src nix :tangle (meq/tangle-path)
{
    description = "";
    inputs = {
        <<username>> = {
            url = "github:<<username>>/<<username>>/master";
            flake = false;
        };
        wip-pinebook-pro = {
            url = "github:<<username>>/wip-pinebook-pro/master";
            flake = false;
        };
        impermanence = {
            url = "github:nix-community/impermanence";
            flake = false;
        };
    };
    outputs = { self, ... }: {  };
}
#+end_src

*** devices
**** hyper-v
***** boot.nix

Taken from [[https://github.com/NixOS/nixos-hardware/tree/master/microsoft/hyper-v][here]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601184759139337200

#+name: 20210601184759139337200
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # REQUIRED - see: https://github.com/nixos/nixpkgs/issues/9899

        kernelModules = [ "hv_vmbus" "hv_storvsc" ];
        initrd = {
            kernelModules = [ "hv_vmbus" "hv_storvsc" ];
            availableKernelModules = [ "hv_vmbus" "hv_storvsc" ];

            # UNKNOWN - not sure if below are needed; were suggested for VirtualBox and I used them
            checkJournalingFS = false;

        };
        extraModulePackages = with pkgs.linuxPackages_latest; [ hyperv-daemons ];

        # RECOMMENDED
        # - use 800x600 resolution for text console, to make it easy to fit on screen
        kernelParams = ["video=hyperv_fb:800x600"];  # https://askubuntu.com/a/399960
        # - avoid a problem with `nix-env -i` running out of memory
        # kernel.sysctl."vm.overcommit_memory" = "1"; # https://github.com/NixOS/nix/issues/421
    };
}
#+end_src

***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184801744311100

#+name: 20210601184801744311100
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    vars.noSwap = true;
    networking = {
        wireless.enable = false;
        interfaces.eth0.useDHCP = true;
    };
    virtualisation.hypervGuest.enable = true;
}
#+end_src

**** linode
***** shared.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184803930214900

#+name: 20210601184803930214900
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    config = {
        vars.terminal = true;
        boot = {
            kernelParams = [ "console=ttyS0,19200n8" ];
            loader.grub.extraConfig = ''
                serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
                terminal_input serial;
                terminal_output serial;
            '';
        };
        networking = {
            usePredictableInterfaceNames = false;
            interfaces.eth0.useDHCP = true;
        };
    };
}
#+end_src

**** rpi
***** 3b.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184806549418800

#+name: 20210601184806549418800
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, device, ... }: with builtins; with lib; with j; {
    imports = [ ./shared.nix ];
    config = {
        vars.terminal = true;
        boot = {
            kernelParams = ["cma=256M"];
            loader = {
                raspberryPi = {
                    enable = true;
                    version = 3;
                    uboot.enable = mkForce true;
                    firmwareConfig = '' gpu_mem=256 '';
                };
            };
        };
        environment.systemPackages = with pkgs; [ libraspberrypi ];
    };
}
#+end_src

***** 4b.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184808685869700

#+name: 20210601184808685869700
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, device, sources, ... }: with builtins; with lib; with j; {
    imports = [
        ./shared.nix
        sources.nixos-hardware.nixosModules.raspberry-pi-4
    ];
    config.vars.terminal = true;
}
#+end_src

***** shared.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184810839651300

#+name: 20210601184810839651300
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    boot.kernelParams = [
        "console=ttyS1,115200n8"
        "ARCH=arm"
    ];
}
#+end_src

**** surface
***** _specialisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184813562748800

#+name: 20210601184813562748800
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (specialisation_base) patches base;
    in {
        clear = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                        });
                    }));
                })];
            };
        };
        clear_xen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest_xen_dom0.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."57";
                        });
                    }));
                })];
            };
        };
        zen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                                { patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch"; name = "BACKPORT-Linux-5.8-compat-__vmalloc"; }
                            ];
                        });
                    }));
                })];
            };
        };
        bcachefs = base.settings // {
            configuration = {
                config = {
                    nixpkgs.overlays = [(self: super: {
                        surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                                kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                            });
                        }));
                    })];
                    boot = {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
    };
}
#+end_src

***** nixpkgs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184835588960800

#+name: 20210601184835588960800
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    nixpkgs.overlays = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (specialisation_base) patches base;
    in [
        (self: super: { surface_kernel_latest = super.linuxPackages_zen.extend (
            self: (ksuper: { kernel = ksuper.kernel.override (
                base.kernel // { kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                    {
                        patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch";
                        name = "BACKPORT-Linux-5.8-compat-__vmalloc";
                    }
                ];}
            );})
        );})
    ];
}
#+end_src

***** b2.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184839546821900

#+name: 20210601184839546821900
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, device, ... }: with builtins; with lib; with j; {
    imports = [ ./shared.nix ];
    config = {
        boot.extraModprobeConfig = mkAfter '' options ipts singletouch=y '';
        powerManagement.resumeCommands = mkAfter '' modprobe ipts_surface singletouch=y '';
        services.surface-dtx-daemon.detach = mkForce ''
            #!/usr/bin/env sh
            for usb in $(ls /dev/disk/by-id).split("\n"):
                if usb and usb[:4] == "usb-":
                    for mnt in $(mount).split("\n"):
                        if mnt and usb in mnt:
                            umount @(mnt.split()[2])
        '';
    };
}
#+end_src

***** shared.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184841857888100

#+name: 20210601184841857888100
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    boot.kernelPackages = pkgs.surface_kernel_latest;
    networking.networkmanager.extraConfig = ''
        [connection]
        wifi.powersave = 2

        [device]
        wifi.scan-rand-mac-address=false
    '';
}
#+end_src

**** pinebook
***** pro.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184843916803200

#+name: 20210601184843916803200
#+begin_src nix :tangle (meq/tangle-path)
{ sources, device, ... }: { imports = [
    ./shared.nix
    "${sources.wip-pinebook-pro}/pinebook_pro.nix"
]; }
#+end_src

***** shared.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184849683569900

#+name: 20210601184849683569900
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {  }
#+end_src

**** android
***** shared.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184853359396100

#+name: 20210601184853359396100
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    vars = { terminal = true; minimal = true; };
}
#+end_src

*** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184855143779200

#+name: 20210601184855143779200
#+begin_src nix
inherit (stc) system;
pkgs = let configBase = { inherit stc; ignoredAttrs = [ "host" ];}; in j.get (configBase // { set = all.pkgs; });
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184856989112400

#+name: 20210601184856989112400
#+begin_src nix :tangle (meq/tangle-path)
{
    description = "Wheee!";

    inputs = rec {
        <<20210601184858790744200>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, flake-compat, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let

        mkOverlay = import ./overlays;

        prepkgs = import nixpkgs {
            overlays = mkOverlay {};
            config = {
                system = currentSystem;
                <<20210601184936599601300>>
            };
        };

        sources = inputs // prepkgs.j.sources;
        inherit (sources) nix;
        lib = nixpkgs.lib.extend (final: prev: {
            j = import ./lib {
                inherit sources;
                pkgs = prepkgs;
                lib = final;
            };
            h = sources.hlissner.lib;
        });

        inherit (lib) j;
        inherit (lib.j) attrs;
        fas = j.forAllSystems;
        make = {
            overlay = mkOverlay;
            pkgs = { stc, ... }: import prepkgs.j.nixpkgset.${stc.channel} {
                overlays = j.get { inherit stc; set = all.overlays; };
                config =  j.get { inherit stc; set = all.config; };
            };
            specialArgs = { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ];};
                config =  j.get (configBase // { set = all.config; });
                overlays =  j.get (configBase // { set = all.overlays; });
            in stc // {
                inherit sources inputs make all stc overlays lib;
                config' = config;
                hostName =  j.get { inherit stc; set = all.hostName; };
                stdenv =  j.get (configBase // { set = all.stdenv; });
                nixpkgs =  j.get (configBase // { set = all.nixpkgs; });
                nixpkgset = {
                    inherit (stc) system;
                    inherit overlays config;
                };
            };
            modules = { stc, ... }: [
                (with stc; [
                    (./. + "/configs/${host}")
                    (if (type == "def") then {} else (./. + "/devices/${type}/${
                        if (device == "def") then "shared.nix" else "${device}.nix"
                    }"))
                    (let path = ./. + "/platforms/${system}"; in
                        if (pathExists path) then path else {})
                ])
                (with sources; [
                    agenix.nixosModules.age
                    impermanence-flake.nixosModules.impermanence
                ])
            ];
            nixosConfiguration = { stc, ... }: lib.nixosSystem {
                <<20210601184855143779200>>
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (j.imprelib.list { dir = ./modules; })
                    (make.modules { inherit stc; })
                ];
            };
            nixosModule = { stc, ... }: nmports@{ config, ... }: { imports = flatten [
                (make.modules nmports { inherit stc; })
            ];};
        };
        all' = {
            inherit sources make;
            # type = attrs.type;
            type = [ "def" "rpi" "surface" ];
            # device = attrs.devices;
            device = [ "def" "4b" "b2" ];
            nixpkgs = prepkgs.j.nixpkgset;
            channel = prepkgs.j.channels;
            host = attrs.hosts;
            # system = allSystems;
            system = [ "aarch64-linux" "x86_64-linux" ];
            # system = defaultSystems;
        } // (genAttrs (attrNames attrs.integer-defaults) (attr: range 0 1));
        all = let
            sc = {
                all = all';
                inheritance.pkgs = import nixpkgs {};
            };
        in {
            config = fas (recursiveUpdate sc {
                func = j.config;
                inheritance.stdenvs = all.stdenv;
            });
            hostName = fas {
                all = all';
                func = j.hostName;
                attrList = attrs.stc ++ (toList "host");
            };
            overlays = fas {
                all = all';
                func = make.overlay;
            };
            pkgs = fas {
                all = all';
                func = make.pkgs;
            };
            stdenv = fas (recursiveUpdate sc { func = j.stdenv; });
            hmConfigs = fas {
                all = all';
                func = j.hostName;
                inherit (all.vars) extraListSets;
            };
            vars.extraListSets = { user = attrs.allUsers; };
        } // all';

        overlays =  j.get { stc = attrs.default-stc; set = all.overlays; };

    in with lib; with j; {

        inherit overlays lib;

        legacyPackages = all;

        nixosConfigurations = (forAllSystems' { inherit all; func = make.nixosConfiguration; }) // {
            tiny = let
                stc = lib.j.attrs.default-stc // {
                    device = "";
                    host = "";
                    system = "";
                    type = "";
                    zfs = null;
                };
            in if (with stc;
                device == "" || host == "" || system == "" || type == "" || zfs == null
            ) then (
                abort "Sorry! The device, host, type, and zfs status must be set!"
            ) else lib.nixosSystem {
                <<20210601184855143779200>>
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (make.modules { inherit stc; })
                    ({ ... }: { imports = [
                        ./modules/networking.nix
                        ./modules/boot.nix
                        ./modules/etc.nix
                        ./modules/global.nix
                        ./modules/users.nix
                        ./modules/filesystems.nix
                        ./modules/nix.nix
                        ./modules/persistence.nix
                        ./modules/variables.nix
                        ./modules/zfs.nix
                    ];})
                ];
            };
        };

        # From: https://nixos.wiki/wiki/Flakes#Getting_Instant_System_Flakes_Repl
        nix.nixPath = let path = toString ./.; in [ "repl=${path}/repl.nix" "nixpkgs=${sources.nixpkgs}" ];

    } // (eachSystem all.system (system: {  }));

}
#+end_src

**** inputs

#+name: ff
#+begin_src emacs-lisp :var name="" :var ur=""
(format-spec "%n = {
    url = \"github:%u\";
    flake = false;
};" `((?n . ,name) (?u . ,ur)))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184858790744200

#+name: 20210601184858790744200
#+begin_src nix :exports none
<<20210601184900737083000>>
<<20210601184903047234700>>
<<20210601184907763806400>>
<<20210601184909601517300>>
<<20210601184911358827500>>
<<20210601184913280508200>>
<<20210601184933880458900>>
#+end_src

***** base

#+call: hash() :exports none

#+RESULTS:
: 20210601184900737083000

#+name: 20210601184900737083000
#+begin_src nix
impermanence-flake = {
    url = "github:nix-community/impermanence/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

agenix = {
    url = "github:ryantm/agenix/main";
    inputs.nixpkgs.follows = "nixpkgs";
};

flake-utils = {
    url = "github:numtide/flake-utils/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

hlissner = {
    url = "github:hlissner/dotfiles/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

<<ff(name="flake-compat", ur="edolstra/flake-compat")>>

nixpkgs.url = "github:NixOS/nixpkgs/master";
#+end_src

***** nixos

#+call: hash() :exports none

#+RESULTS:
: 20210601184913280508200

#+name: 20210601184913280508200
#+begin_src nix
<<ff(name="extraContainer", ur="erikarvstedt/extra-container")>>
<<ff(name="nixos-surface", ur="anthe/nixos-surface")>>
nixos-hardware.url = "github:nixos/nixos-hardware/master";
#+end_src

***** kernels

#+call: hash() :exports none

#+RESULTS:
: 20210601184933880458900

#+name: 20210601184933880458900
#+begin_src nix
xanmodV5104Cacule = {
    url = "github:xanmod/linux/5.10.4-xanmod1-cacule";
    flake = false;
};
xanmodV5914Cacule = {
    url = "github:xanmod/linux/5.9.14-xanmod1-cacule";
    flake = false;
};
#+end_src

*** lib

#+call: hash() :exports none

#+RESULTS:
: 20210601184936599601300

#+name: 20210601184936599601300
#+begin_src nix
allowUnfree = true;
allowBroken = true;
allowUnsupportedSystem = true;
# preBuild = ''
#     makeFlagsArray+=(CFLAGS="-w")
#     buildFlagsArray+=(CC=cc)
# '';
permittedInsecurePackages = [
    "python2.7-cryptography-2.9.2"
];
#+end_src

**** default.nix

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601184940615217500

#+name: 20210601184940615217500
#+begin_src nix :tangle (meq/tangle-path)
inputs@{
    sources ? ({
        nixpkgs = <nixpkgs>;
    }),
    pkgs ? (import sources.nixpkgs {}),
    lib ? pkgs.lib,
    preattrs ? (import ./_preattrs.nix lib),
    prelib ? (import ./_prelib.nix preattrs lib),
    primprelib ? (import ./_primprelib.nix preattrs prelib lib),
    ...
}: with builtins; with lib; let
    explicitInputs = { inherit
        sources
        pkgs
        lib
        preattrs
        prelib
        primprelib;
    };
    templib = self: prelib
        // (with prelib; {
            attrs = preattrs // (import ./_attrs.nix explicitInputs);
            imprelib = primprelib // (import ./_imprelib.nix explicitInputs);
        })
        // (listToAttrs (map (file: nameValuePair
            file
            (import (./. + "/${file}.nix") explicitInputs)
        ) (primprelib.listNames { dir = ./.; })));

    __ = makeExtensible templib;
in __.extend (final: prev: prelib.foldToSet (attrValues prev))
#+end_src

**** _preattrs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184942521692400

#+name: 20210601184942521692400
#+begin_src nix :tangle (meq/tangle-path)
lib: with builtins; with lib; rec {
    integer-defaults = {
        minimal = 0;
        musl = 1;
        noSwap = 0;
        terminal = 0;
        zfs = 1;
    };
    default-stc = integer-defaults // {
        system = currentSystem;
        type = "def";
        device = "def";
        channel = "pkgs";
    };
    stc = attrNames default-stc;
}
#+end_src

**** _prelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184944473723100

#+name: 20210601184944473723100
#+begin_src nix :tangle (meq/tangle-path)
preattrs: lib:
with builtins;
with preattrs;
with lib;
rec {

    get = {
        stc ? preattrs.default-stc,
        set,
        ignoredAttrs ? []
    } : getAttrFromPath (
        map toString (attrValues (removeAttrs stc ignoredAttrs))
    ) set;

    # hostName = { stc ? preattrs.default-stc, ... }: substring 0 61 (hashString "sha512" (concatStrings (
    #     map toString (attrValues stc)
    # )));

    hostName = { stc ? preattrs.default-stc, ... }: concatStrings (
        map toString (attrValues stc)
    );

    forAllSystems' = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n (flatten [
            attrList
            [ "host" ]
        ])) all) // extraListSets;
        product = cartesianProductOfSets all';
    in listToAttrs (map (
        stc: nameValuePair (hostName { inherit stc; }) (func ({ inherit stc; } // inheritance))
    ) product);

    forAllSystems = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n attrList) all) // extraListSets;
        product = cartesianProductOfSets all';
    in foldToSet (map (
        # !!! There is no need to alphabetically sort the output of attrValues! !!!
        stc: setAttrByPath
            (map toString (attrValues stc))
            (func ({ inherit stc; } // inheritance))
    ) product);

    # TODO: Why is the filter necessary?
    foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);

    myIf = {
        list = condition: value: optionals condition value;
        singleton = condition: value: optional condition value;
        set = condition: value: if condition then value else {};
        num = condition: value: if condition then value else 0;
        knull = condition: value: if condition then value else null;
        empty = condition: value: if condition then value else "";
        drv = condition: evalue: value: if condition then value else evalue;
    };

    zipToSet = names: values: listToAttrs (
        map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
            if hasAttrs then names else (sort lessThan names)
        ) (
            if hasAttrs then values else (sort lessThan values)
        ))
    );

    stdenv = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        ...
    }: with stc; let
        musl = stc.musl == 1;
        arm = {
            systems = [
                "armv7a-linux"
                "armv7l-linux"
                "armv6a-linux"
                "armv6l-linux"
                "aarch64-linux"
            ];
            enable = elem system arm.systems;
            stdenv = {
                package = pkgs.clang10.stdenv;
                targetPlatform = if "armv7l-linux" then systems.examples.armv7l-hf-multiplatform
                    else systems.examples.aarch64-multiplatform;
            };
        };
        musl' = {
            enable = musl && (elem system ([
                "x86_64-linux"
            ] ++ arm.systems));
            stdenv = {
                package = pkgs.musl.stdenv;
                targetPlatform = systems.examples.musl64;
            };
        };
    in foldToSet [
        {
            inherit system;
            hostPlatform = currentSystem;
            buidPlatform = currentSystem;
        }
        (with arm; myIf.set enable stdenv)
        (with musl'; myIf.set enable stdenv)
    ];

    config = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        buildEnvOvr ? true,
        stdenvs ? {},
        stdenv ? (attrByPath (attrValues stc) (stdenv { inherit pkgs stc; }) stdenvs),
        ...
    } : with stc; {
        inherit system;
        <<20210601184936599601300>>
        ${if buildEnvOvr then null else "buildEnv"} = {
            override = { inherit stdenv; };
        };
    };

    toCapital = string: concatImapStrings (
        i: v: if (i == 0) then (toUpper v) else v
    ) (stringToCharacters string);

    generatePersistentFD = filtered: persistentDirectory: let
        _ = type: filter (n: !elem n filtered) (
            mapAttrsToList (n: v: removePrefix persistentDirectory n)
        (filterAttrs (n: v: v == type) (readDir persistentDirectory)));
    in { directories = _ "directories"; files = _ "regular"; };

    sequence = list: end: foldr (a: b: deepSeq a b) end list;
}
#+end_src

**** _primprelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184946256510900

#+name: 20210601184946256510900
#+begin_src nix :tangle (meq/tangle-path)
preattrs: prelib: lib:
with builtins;
with preattrs;
with prelib;
with lib;
rec {
    args = {
        suffix = "";
        ignores = [];
    };

    name = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        file
    }: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

    # !!! This returns a function
    filterFunc = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        ignores ? args.ignores,
        dir,
    }: let
        _ignores = flatten [
            ignores
            (let
                _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
            in if (pathExists _ignores') then (import _ignores') else [])
            [ "default" "deprecated" ]
        ];
    in file: value:
        (if noSuffix then (
            (hasSuffix ".nix" file) || (value == "directory")
        ) else (hasSuffix suffix file)) &&
        (!hasPrefix "_" file) &&
        (!elem (name { inherit suffix file noSuffix; }) _ignores);

    contents = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
    }: filterAttrs (filterFunc _args) (readDir dir);

    list = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/${n}"),

    }: let
        __args = removeAttrs _args [ "func" ];
    in mapAttrsToList func (contents __args);

    listNames = {
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir
    }: list {
        inherit suffix ignores dir;
        func = (n: v: name { inherit suffix; file = n; });
    };
}
#+end_src

**** _attrs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184948158342800

#+name: 20210601184948158342800
#+begin_src conf
keep-derivations = true
keep-outputs = true
experimental-features = nix-command flakes
allow-unsafe-native-code-during-evaluation = true
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184949937949100

#+name: 20210601184949937949100
#+begin_src nix :tangle (meq/tangle-path)
{ lib, prelib, preattrs, primprelib, ... }:
with builtins;
with prelib;
with preattrs;
with primprelib;
with lib;
rec {
    persistent = {
        files = {
            system = flatten [[ "/etc/host" ]];
            home = flatten [[
                ".emacs-profile"
                ".gitignore"
                ".globalignore"
                ".nix-channels"
                ".python-history"
                ".viminfo"
                ".zsh-history"
                "README.org"
                "LICENSE"
                "oreo.aiern.org"
            ]];
            cache = flatten [[  ]];
        };
        directories = {
            system = flatten [[
                "/etc/containers"
                "/etc/NetworkManager/system-connections"
                "/etc/nix"
                "/etc/nixos"
                "/etc/nixos/config"
                "/etc/ssh"
                "/etc/wireguard"
                "/var/lib/acme"
                "/var/lib/bluetooth"
                "/usr"
                "/bin"
                "/sbin"
                "/snap"
            ]];
            home = flatten [[
                ".atom"
                ".bash-history"
                ".byobu"
                ".caddy"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                ".z"
                "Documents"
                "Downloads"
                "etc"
                "inca"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "Videos"
            ]];
            cache = flatten [(map (dir: ".cache/${dir}") [
                "flatpak"
                "gnome-software"
                "google-chrome-beta"
                "google-chrome-dev"
                "google-chrome"
                "Homebrew"
                "keybase"
                "mozilla"
                "nix"
                "pip"
                "pypoetry"
                "qtile"
                "starship"
                "vivaldi"
            ])];
        };
    };

    persistence = {
        system = extraFD: let persistent-directory = "/persist"; in {
            "${persistent-directory}" = mkMerge [
                ({
                    directories = persistent.directories.system;
                    files = persistent.files.system;
                })
                (generatePersistentFD [ "home" "cache" ] persistent-directory)
                extraFD
            ];
        };
        home = { user ? "root", extraCache ? {}, extraFD ? {}}: let
            phu = "/persist/home/${user}";
        in mapAttrs (n: v: v // { allowOther = true; }) {
            "/persist/cache/${user}" = foldToSet [
                ({
                    directories = persistent.directories.cache;
                    files = persistent.files.cache;
                })
                extraCache
            ];
            "${phu}" = foldToSet [
                ({
                    directories = persistent.directories.home;
                    files = persistent.files.home;
                })
                (generatePersistentFD [""] phu)
                extraFD
            ];
        };
    };

    link = root: source: listToAttrs (map (
        fd: nameValuePair "${root}/${fd}" {
            source = "${source}/${fd}";
            recursive = true;
        }
    ) (attrNames (readDir source)));

    # Device Types
    types = flatten [
        (listNames { dir = ../devices; })
        [ "def" ]
    ];

    devices = [
        "4b"
        "3b"
        "pro"
        "b2"
        "def"
    ];

    hosts = listNames { dir = ../configs; };

    # hosts = listToAttrs (flatten [
    #     (map (host: nameValuePair host {}) [
    #         # "bastion"
    #         "chimchar"
    #         # "fell"
    #         # "flipper"
    #         # "infernape"
    #         # "monferno"
    #         # "murasame"
    #         # "p20"
    #         # "p5"
    #         # "piplup"
    #         # "sandshrew"
    #         "sandslash"
    #         # "siluam"
    #         # "silvester"
    #     ])
    # ]);

    configs = rec {
        prenix = ''
            <<20210601184948158342800>>
        '';
        nix = let
            MG = size: let
                mg = stringToCharacters size;
            in toString ((toInt (elemAt mg 0)) * (
                if (elemAt mg 1 == "M") then 1 else 1024
            ) * 1024 * 1024);
        in prenix + ''
            min-free = ${MG "250M"}
            max-free = ${MG "1G"}
        '';
    };
    services = {
        base = {
            enable = true;
            serviceConfig = {
                Restart = "on-failure";
                User = "<<username>>";
            };
            wantedBy = [ "multi-user.target" ];
        };
        mkdir = path: "mkdir -p /persist/${path} &> /dev/null";
    };
    users = fromJSON (readFile ../resources/users.json);

    datasets = {
        backup = [
            "system/persist"
            "virt"
            "omniverse"
            users.primary
        ];
    };

    excludedUsers = [ "root" ];
    mainUsers = attrValues users;
    allUsers = mainUsers ++ excludedUsers;
    homes = listToAttrs (map (
        user: nameValuePair user "/home/${user}"
    ) mainUsers);
    allHomes = homes // { root = "/root"; };
    commands = {
        rebuild = "nixos-rebuild --impure";
        install = "nixos-install --impure --show-trace";
    };
    fileSystems = {
        base = {
            fsType = "zfs";
            options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
        };
        supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
    };
    versions = {
        python = "39";
        emacs = "26";
    };
    ssh.keys = {
        master = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    };
    platforms = {
        arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
        imd = [ "i686-linux" "x86_64-linux" ];
    };
}
#+end_src

**** paths.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184952773228000

#+name: 20210601184952773228000
#+begin_src nix :tangle (meq/tangle-path)
{ sources, ... }: with builtins; rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches = {
        _  = "${nixos}/patches";
        surface = "${sources.nixos-surface}/linux-surface/patches";
    };
}
#+end_src

**** _imprelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184956312357000

#+name: 20210601184956312357000
#+begin_src nix :tangle (meq/tangle-path)
{ lib, primprelib, ... }:
with builtins;
with primprelib;
with lib;
rec {
    set = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
        modules ? {},

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/" + n),

    }: let
        files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
    in zipToSet
        (map (file: name { inherit suffix file; }) files)
        (map (file: import file (foldToSet [ modules inputs ])) files);
}
#+end_src

*** modules
**** guix.nix

From: https://github.com/pukkamustard/nixpkgs/blob/guix/nixos/modules/services/development/guix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184958501115000

#+name: 20210601184958501115000
#+begin_src nix :tangle (meq/tangle-path)
{config, pkgs, lib, ...}:

with lib;

let

  cfg = config.services.guix;

  buildGuixUser = i:
    {
      "guixbuilder${builtins.toString i}" = {
        group = "guixbuild";
        extraGroups = ["guixbuild"];
        home = "/var/empty";
        shell = pkgs.nologin;
        description = "Guix build user ${builtins.toString i}";
        isSystemUser = true;
      };
    };

in {

  options.services.guix = {
    enable = mkEnableOption "GNU Guix package manager";
    package = mkOption {
      type = types.package;
      default = pkgs.guix;
      defaultText = "pkgs.guix";
      description = "Package that contains the guix binary and initial store.";
    };
  };

  config = mkIf (cfg.enable) {

    users = {
      extraUsers = lib.fold (a: b: a // b) {} (builtins.map buildGuixUser (lib.range 1 10));
      extraGroups.guixbuild = {name = "guixbuild";};
    };

    systemd.services.guix-daemon = {
      enable = true;
      description = "Build daemon for GNU Guix";
      serviceConfig = {
        ExecStart="/var/guix/profiles/per-user/root/current-guix/bin/guix-daemon --build-users-group=guixbuild";
        Environment="GUIX_LOCPATH=/var/guix/profiles/per-user/root/guix-profile/lib/locale";
        RemainAfterExit="yes";

        # See <https://lists.gnu.org/archive/html/guix-devel/2016-04/msg00608.html>.
        # Some package builds (for example, go@1.8.1) may require even more than
        # 1024 tasks.
        TasksMax="8192";
      };
      wantedBy = [ "multi-user.target" ];
    };

    system.activationScripts.guix = ''

      # copy initial /gnu/store
      if [ ! -d /gnu/store ]
      then
        mkdir -p /gnu
        cp -ra ${cfg.package.store}/gnu/store /gnu/
      fi

      # copy initial /var/guix content
      if [ ! -d /var/guix ]
      then
        mkdir -p /var
        cp -ra ${cfg.package.var}/var/guix /var/
      fi

      # root profile
      if [ ! -d ~root/.config/guix ]
      then
        mkdir -p ~root/.config/guix
        ln -sf /var/guix/profiles/per-user/root/current-guix \
          ~root/.config/guix/current
      fi

      # authorize substitutes
      GUIX_PROFILE="`echo ~root`/.config/guix/current"; source $GUIX_PROFILE/etc/profile
      guix archive --authorize < ~root/.config/guix/current/share/guix/ci.guix.info.pub
    '';

    environment.shellInit = ''
      # Make the Guix command available to users
      export PATH="/var/guix/profiles/per-user/root/current-guix/bin:$PATH"

      export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"
      export PATH="$HOME/.guix-profile/bin:$PATH"
      export INFOPATH="$HOME/.guix-profile/share/info:$INFOPATH"
    '';
  };

}
#+end_src

**** bcachefs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185001135617000

# TODO: Does not work on aarch64-linux yet

#+name: 20210601185001135617000
#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, system, ... }: with builtins; with lib; with j; let b = "bcachefs"; in mkIf (
    !elem system [ "aarch64-linux" ]
) {
    boot = {
        kernelPackages = mkForce pkgs."linuxPackages_testing_${b}";
        kernelModules = [ b ];
        initrd = {
            kernelModules = [ b ];
            availableKernelModules = [ b ];
        };
        supportedFilesystems = [ "bcachefs" ];
    };
}
#+end_src

**** boot.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185002667222800

#+name: 20210601185002667222800
#+begin_src nix
loader = {
    systemd-boot = {
        enable = mkForce config.vars.bootPart;
        configurationLimit = 25;
        editor = false;
    };
    grub = {
        enable = mkForce false;
        efiSupport = true;
        devices = [ "nodev" ];
        version = 2;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';

    };
    efi = {
        canTouchEfiVariables = mkForce true;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    initScript.enable = mkForce true;
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185004200076000

#+name: 20210601185004200076000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, host, ... }: with builtins; with lib; with j; {
    boot = let
        p = attrs.users.primary;
        pHome = config.users.users.${p}.home;
    in mkMerge [{
            <<20210601185002667222800>>
            supportedFilesystems = attrs.fileSystems.supported;
            initrd = {
                inherit (config.boot) supportedFilesystems;
                compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
                network.ssh.enable = true;
            };
            postBootCommands = let
                chowned = concatStringsSep "\n" (
                    map (user:
                        "sudo -u ${user} chown -R ${user}:${user} /persist/${attrs.allHomes.${user}} /persist/cache/${user}")
                    attrs.allUsers);
            in mkAfter (''
                mkdir -p /mnt
                sudo -u ${p} chown -R ${p}:${p} /${host}
            '' + chowned);
        }
        (mkIf (!config.vars.minimal) {
            extraModprobeConfig = '' options kvm_intel_nested=1 '';
        })
    ];
}
#+end_src

**** console.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185005838819700

#+name: 20210601185005838819700
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    console = {
        # Select internationalisation properties.
        # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
        font = "Cartograph CF Light Italic";
        keyMap = "us";
    };
}
#+end_src

**** etc.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185007760601200

#+name: 20210601185007760601200
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; {
    environment.etc = let
        kata-containers = {
            default-runtime = "kata-runtime";
            # runtimes.kata-runtime.path = "${getBin pkgs.kata-containers}/bin/kata-runtime";
            runtimes.kata-runtime.path = "${getBin pkgs.kata-containers.runtime}/bin/kata-runtime";
        };
        kc = toJSON kata-containers;
    in {
        "nix/nix.conf".text = attrs.configs.nix;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/storage.conf"}.text = kc + ''
            [storage]
            driver = "zfs"
            rootless_storage_path = "/var/lib/podman/$USER"

            [storage.options]
            additionalimagestores = [
                "/var/lib/docker",
            ]

            # [storage.options.zfs]
        '';
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/libpod.conf"}.text = kc;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "docker/daemon.json"}.text = kc;
    };
}
#+end_src

**** filesystems.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185009548172600

#+name: 20210601185009548172600
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, stc, ... }: with builtins; with lib; with j; mkIf (config.vars.zfs) { fileSystems = let
    inherit (attrs.fileSystems) base;
    fileSystems' = import ../config/_datasets.nix stc.host;
in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
    mkForce (base // { device = dataset; ${
        myIf.knull (hasInfix "persist" dataset) "neededForBoot"
    } = true; })
)) fileSystems'; }
#+end_src

**** global.nix

#+begin_src text
Help is available in the configuration.nix(5) man page
and in the NixOS manual (accessible by running ‘nixos-help’).
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185011702577000

#+name: 20210601185011702577000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, nixpkgset, system, ... }: with builtins; with lib; with j; {
    nixpkgs = nixpkgset;
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. It's perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
        };
    };
    boot.binfmt.emulatedSystems = [
        "armv7l-linux"
        "aarch64-linux"
    ];

    # Flatpak
    xdg.portal.enable = mkForce (!elem system [ "aarch64-linux" ]);

    environment.pathsToLink = [ "/share/nix-direnv" ];
    zramSwap = {
        enable = true;
        algorithm = "zstd";
    };
}
#+end_src

**** hardware.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185027009881400

#+name: 20210601185027009881400
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    hardware = {
        enableRedistributableFirmware = lib.mkDefault true;
        # Enable sound
        pulseaudio.enable = true;
    };
    sound.enable = true;
}
#+end_src

**** kernel.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185030781221800

#+name: 20210601185030781221800
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # kernelPackages = pkgs.linuxPackages_latest_xen_dom0_hardened;
        # kernelPackages = pkgs."linuxPackages_xanmod_v5.10.4_cacule";
        kernelPackages = pkgs.linuxPackages_lqx;
        # kernelPackages = pkgs.linuxPackages_zen;
        kernelPatches = [
            # { name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
            {
                name = "Enable ZSTD Compression";
                patch = null;
                extraConfig = ''
                    RD_ZSTD y
                    KERNEL_ZSTD y
                    KERNEL_XZ n
                '';
            }
        ];
        # extraModulePackages = with config.boot.kernelPackages; [ anbox wireguard ];
    };
}
#+end_src

**** memory.nix

Set the =SWAP= device if:

1. The configuration is not minimal, or
2. the =noSwap= variable is set to false.

I am currently not using =SWAP= on =ZFS Zvols= due to the issues detailed
[[https://github.com/openzfs/zfs/issues/7734][here]].

#+call: hash() :exports none

#+RESULTS:
: 20210601185032403282100

#+name: 20210601185032403282100
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; mkIf (
    config.vars.minimal -> config.vars.noSwap
) { swapDevices = [{ device = "/dev/zvol/${host}/swap"; }]; }
#+end_src

**** networking.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185033854488300

#+name: 20210601185033854488300
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, hostName, ... }: with builtins; with lib; with j; {
    networking = let
        primus = "58a4bafc38c2cc6e91ba27c7f1ca910c8fba857ee02f03648450b963db2519fc";
    in {
        interfaces = map (interface:
            { inherit interface; method = "magicpacket"; }
        ) (attrNames config.networking.interfaces);
        inherit hostName;
        wireless = {
            # enable = true; # Enables wireless support via wpa_supplicant.
            enable = false; # Enables wireless support via wpa_supplicant.
            networks = {
                "Primus-17FE-2.4" = {
                    pskRaw = primus;
                    priority = 0;
                };
                "Primus-17FE" = {
                    pskRaw = primus;
                    priority = 1;
                };
            };
        };
        networkmanager.enable = mkForce true;

        # The global useDHCP flag is deprecated, therefore explicitly set to false here.
        # Per-interface useDHCP will be mandatory in the future, so this generated config
        # replicates the default behaviour.
        useDHCP = false;

        # Configure network proxy if necessary
        # proxy = {
        # default = "http://user:password@proxy:port/";
        # noProxy = "127.0.0.1,localhost,internal.domain";
        # };

        # Open ports in the firewall.
        # firewall = {
        # allowedTCPPorts = [ ... ];
        # allowedUDPPorts = [ ... ];

        # Or disable the firewall altogether.
        # enable = false;
        # };

        # wireguard.interfaces.wg0 = {
        #   generatePrivateKeyFile = true;
        #   privateKeyFile = "/persist/etc/wireguard/wg0";
        # };
    };
}
#+end_src

**** nix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185035246626000

#+name: 20210601185035246626000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = rec {
        gc = foldToSet [
            { automatic = true; }
            { dates = "monthly"; }
            # {
            #   dates = "monthly";
            #   options = "-d";
            # }
            # {
            #   dates = "daily";
            #   options = "--delete-older-than 30d";
            # }
        ];
        optimise = {
            automatic = true;
            dates = [ "05:00" ];
        };
        autoOptimiseStore = true;
        extraOptions = attrs.configs.nix;
        useSandbox = true;
        binaryCaches = flatten [
            (map (dir: "file:///${dir}/") [
                "chimchar"
                "empoleon"
            ])
        ];
        # sandboxPaths = [];
    };
}
#+end_src

**** packages.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185037079389900

#+name: 20210601185037079389900
#+begin_src nix :tangle (meq/tangle-path)
inputs@{ config, pkgs, sources, lib, ... } : { environment.systemPackages = import ../packages.nix inputs; }
#+end_src

**** persistence.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185038697262200

#+name: 20210601185038697262200
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    environment.${myIf.knull config.vars.zfs "persistence"} = attrs.persistence.system {};
}
#+end_src

**** power.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185040292063500

#+name: 20210601185040292063500
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    services.logind.lidSwitch = "hybrid-sleep";
    powerManagement = {
        enable = true;
        cpuFreqGovernor = mkForce "ondemand";
    };
}
#+end_src

**** security.nix

This is mostly for Yubikey Authentication:

#+call: hash() :exports none

#+RESULTS:
: 20210601185041882938600

#+name: 20210601185041882938600
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

**** services.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185043527440500

#+name: 20210601185043527440500
#+begin_src nix
${myIf.knull config.vars.zfs "sanoid"} = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) flatten [
        attrs.datasets.backup
        [ host ]
    ]);
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185045150190700

#+name: 20210601185045150190700
#+begin_src nix
${myIf.knull config.vars.zfs "syncoid"} = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        (mkIf vars.encrypted {
            sendOptions = "vvwRI";
            recvOptions = "vvFs";
        })
        (mkIf (!vars.encrypted) {
            recvOptions = "vvFds";
            sendOptions = "vvRI";
        })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) flatten [
        attrs.datasets.backup
        [ host ]
    ]);
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185046664836000

#+name: 20210601185046664836000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, host, system, ... }: with builtins; with lib; with j; {
    services = {
        <<20210601185043527440500>>

        <<20210601185045150190700>>

        # wakeonlan.interfaces = map (interface:
        #     { inherit interface; method = "magicpacket"; }
        # ) (attrNames config.networking.interfaces);

        flatpak.enable = !elem system [ "aarch64-linux" ];

        # For Yubikey
        udev.packages = with pkgs; [
            yubikey-personalization
            libu2f-host
        ];
        pcscd.enable = true;

        openssh = {
            enable = true;
            extraConfig = mkOrder 0 ''
                TCPKeepAlive yes
                ClientAliveCountMax 480
                ClientAliveInterval 3m
            '';
            permitRootLogin = "yes";
        };

        # Keybase
        kbfs.enable = true;
        keybase.enable = true;

        # Enable CUPS to print documents.
        printing.enable = true;

        # Enable the X11 windowing system.
        xserver = {
            enable = true;
            layout = "us";
            # xkbOptions = "eurosign:e";
            # Enable touchpad support.
            libinput = {
            enable = true;
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
            };
            # synaptics.enable = true;
            desktopManager = { xterm.enable = false; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+qtile"; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { startx.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { qtile.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+exwm"; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { exwm.enable = true; };
            # displayManager = { defaultSession = "none+qtile"; };
            displayManager = { startx.enable = true; };
            windowManager = { qtile.enable = true; };
            # displayManager = { defaultSession = "none+exwm"; };
            # windowManager = { exwm.enable = true; };
            # desktopManager.gnome3.enable = true;
            # desktopManager.gnome3.enable = true;
            # displayManager.gdm.enable = true;
        };

        ${myIf.knull config.vars.zfs "zfs"} = {
            autoScrub.enable = true;

            # Managed by Sanoid
            autoSnapshot.enable = false;
        };
    };
}
#+end_src

**** shell.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185048305544300

#+name: 20210601185048305544300
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, system, ... }: with builtins; with lib; with j; {
    programs = {
        xonsh.enable = true;
        fish = mkIf (!elem system [ "aarch64-linux" ]) {
            enable = true;
        };
        zsh.enable = true;
    };
}
#+end_src

**** _specialisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185055287903500

#+name: 20210601185055287903500
#+begin_src nix
rec {
    patches = {
        dir = rec {
            base = lib.j.paths.patches;
            "57" = "${base.surface}/5.7";
            "58" = "${base.surface}/5.8";
        };
        get = dir: with r; list {
            suffix = ".patch";
            dir = (/. + d);
            func = (file: v: { patch = file; name = name { inherit suffix file; }; });
        };
    };
    base = {
        settings = { inheritParentConfig = true; };
        kernel.extraConfig = ''
            SERIAL_DEV_BUS y
            SERIAL_DEV_CTRL_TTYPORT y
            SURFACE_SAM m
            SURFACE_SAM_SSH m
            SURFACE_SAM_SAN m
            SURFACE_SAM_DTX m
            INPUT_SOC_BUTTON_ARRAY m
            SURFACE_3_POWER_OPREGION m
            SURFACE_3_BUTTON m
            SURFACE_3_POWER_OPREGION m
            SURFACE_PRO3_BUTTON m
        '';
        patches = [
            { patch = /. + "${patches.dir.base._}/export_kernel_fpu_functions_5_3.patch"; name = "export_kernel_fpu_functions_5_3"; }
            { patch = /. + "${patches.dir.base._}/set_power_mgmt.patch"; name = "set_power_mgmt"; }
        ];
        iabg = [{ patch = /. + "${patches.dir.base._}/0110-initialize-ata-before-graphics.patch"; name = "0110-initialize-ata-before-graphics"; }];
    };
}
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185057188906700

#+name: 20210601185057188906700
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (lib.j.paths.patches) _;
        base = {
            specialisation = { inheritParentConfig = true; };
            kernel = {
                kernelPatches = specialisation_base.base.iabg;
            };
        };
    in {
        clear = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest; };
                };
            };
        };
        zen = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_zen; };
                };
            };
        };
        bcachefs = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
        clear_xen = base.specialisation // {
            inheritParentConfig = true;
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest_xen_dom0; };
                };
            };
        };
    };
}
#+end_src

**** systemd.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185059100247400

#+name: 20210601185059100247400
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    systemd = {
        packages = with pkgs; [ runit ly ];
        services = {
            runit.enable = true;
            ly.enable = true;
        };
    };
}
#+end_src

**** users.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185100896555400

#+name: 20210601185100896555400
#+begin_src nix :tangle (meq/tangle-path)
inputs@{ config, lib, pkgs, sources, stc, system, ... }: with builtins; with lib; with j; {
    users = with attrs.users; let
        base = mkMerge [{
                hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
                isNormalUser = true;
                createHome = true;
                extraGroups = [
                    "wheel"
                    "networkmanager"
                    "persist"
                ];
                openssh.authorizedKeys.keys = [
                    attrs.ssh.keys.master
                ];
                packages = import (
                    if (pathExists ../packages.nix) then ../packages.nix else ./packages.nix
                ) inputs;
            }
            (mkIf (!config.vars.minimal) {
                extraGroups = [ "libvirtd" "docker" ];
            })
        ];
    in rec {
        users = mkMerge [
            (genAttrs attrs.allUsers (user: base))
            {
                "${primary}" = {
                    uid = 4362;
                    home = attrs.allHomes.${primary};
                    description = "Jeet Ray";
                    group = primary;
                    extraGroups = [ secondary ];
                    shell = pkgs.xonsh;
                };
                "${secondary}" = {
                    uid = 1111;
                    home = attrs.allHomes.${secondary};
                    description = "Alicia Summers";
                    group = secondary;
                    extraGroups = [ primary ];
                    shell = if (!elem system [ "aarch64-linux" ]) then pkgs.fish else pkgs.zsh;
                };
                "${nightingale}" = {
                    uid = 8888;
                    home = attrs.allHomes.${nightingale};
                    description = "Curtis Nightingale";
                    group = "root";
                    extraGroups = [ primary secondary ];
                    shell = pkgs.zsh;
                };
                root = {
                    shell = mkForce pkgs.xonsh;
                    home = attrs.allHomes.root;
                    isNormalUser = mkForce false;
                    isSystemUser = mkForce true;
                };
            }
        ];

        mutableUsers = false;

        groups = {
            "${primary}" = {
                gid = config.users.users.${primary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${secondary}" = {
                gid = config.users.users.${secondary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${nightingale}" = {
                gid = config.users.users.${nightingale}.uid;
                members = [ nightingale ];
            };
        };
    };
}
#+end_src

**** variables.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185102627466300

#+name: 20210601185102627466300
#+begin_src nix
options = {
    vars = mkOption {
        default = mkDefault {  };
        type = with lib.types; attrsOf bool;
    };
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185104370957400

#+name: 20210601185104370957400
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, stc, ... }: with builtins; with lib; with j; {
    <<20210601185102627466300>>
    config.vars = {
        bootPart = mkDefault true;
        syncDevice = mkDefault false;
    } // (mapAttrs (
        n: v: mkDefault (if (isInt v) then (v == 1) else v)
    ) (default-stc // stc));
}
#+end_src

**** virtualisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185106194079000

#+name: 20210601185106194079000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; mkIf (
    !(config.vars.minimal || elem system [ "aarch64-linux" ])
) {
    virtualisation = {
        xen.enable = false;
        lxd = { zfsSupport = true; };
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

**** zfs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185108071879200

#+name: 20210601185108071879200
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; {
    boot = {
        kernelModules = [ "zfs" ];
        # loader.grub.zfsSupport = true;
        initrd = {
            postDeviceCommands = myIf.empty config.vars.zfs (mkAfter ''
                zfs rollback -r ${host}/system/root@blank
                zfs rollback -r ${host}/system/home@blank
            '');
            kernelModules = [ "zfs" ];
            availableKernelModules = [ "zfs" ];
        };
        zfs = {
            requestEncryptionCredentials = true;
            enableUnstable = true;
        };
        extraModulePackages = with config.boot.kernelPackages; [ zfsUnstable ];
    };
    # networking.hostId = substring 0 8 (readFile "/etc/machine-id");
}
#+end_src


*** overlays
**** base

#+call: hash() :exports none

#+RESULTS:
: 20210601185110013135100

#+name: 20210601185110013135100
#+begin_src nix
let
    sc = { inherit pkgs stc; };
    stdenv = j.stdenv sc;
    config = j.config (sc // { inherit stdenv; });
in flatten [
    [(final: prev: { j = rec {
        inherit config stdenv sources;
        inherit (sources) nixpkgs;
        nixpkgset = 
            let
                withNPrefix = filterAttrs (
                    n: v: (hasPrefix nprefix n) || (n == nprefix)
                ) sources;
                withoutNPrefix = mapAttrs' (name: v: nameValuePair (
                    if (name == nprefix) then prefix else (
                        replaceStrings ["${nprefix}-"] [""] name
                    )
                ) v) withNPrefix;
            in removeAttrs withoutNPrefix (flatten [
                # (filter (name: !elem name [
                #     "pkgs"
                #     "unstable"
                # ]) (attrNames withoutNPrefix))
                [  ]
            ]);
        pkgset = (
            mapAttrs (n: v: import v { inherit config; }) nixpkgset
        ) // { "${channel}" = final; };
        channels = attrNames nixpkgset;
    };})]
    # [(
    #     final: prev: {
    #         fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchurl.patch ];}); }
    # )]
    # [(
    #     final: prev: {
    #         fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchpypi.patch ];}); }
    # )]
    [
        (import sources.emacs)
        (final: prev: {
            nur = import sources.nur {
                nurpkgs = prev;
                pkgs = prev;
            };
        })
        (import ("${sources.wip-pinebook-pro}/overlay.nix"))
        # sources.emacs.overlay
        # sources.nur.overlay
    ]
    [
        # (final: prev: { nix = sources.nix.packages.${system}.nix; })
        # (final: prev: { nix = (import sources.nix).packages.${system}.nix; })
        (final: prev: { nix = prev.nixUnstable; })
        (final: prev: { niv = (import sources.niv {}).niv; })
        (final: prev: { emacs-nox = final.emacsGit-nox; })
    ]
    [
        (final: prev: {
            systemd = prev.systemd.overrideAttrs (old: { withHomed = true; });
        })
        # (final: prev: { kata-containers = prev.kata-containers; })
    ]
    [
        (final: prev: {
            extra-container = let
                pkgSrc = sources.extraContainer;
            in pkgs.callPackage pkgSrc { inherit pkgSrc; };
        })
    ]
    (
        let
            dir = sources.mozilla;
            mozilla = final: prev: listToAttrs (map (file: nameValuePair
                (removeSuffix "-overlay" file)
                (import "${dir}/${file}.nix" final prev)
            ) (filter (file: hasSuffix "-overlay" file) (j.imprelib.listNames { inherit dir; })));
        in [
            (final: prev: { firefox = final.mozilla.firefox.latest.firefox-bin; })
            (final: prev: { firefox-unbuilt = prev.firefox; })
            (final: prev: { mozilla = mozilla final prev; })
        ]
    )

    # TODO
    # (map (kernel': let
    #     kernel = "linuxPackages_${kernel'}";
    # in [( final: prev: { "${kernel}" = prev."${kernel}".extend (self:
    #     <<20210601185345398351400>>
    # );})]) [ "lqx" "testing_bcachefs" "zen" ])

    # TODO
    # (let base.mach-nix = {
    #     inherit pkgs sources lib;
    #     mach-nix = import sources.mach-nix { inherit pkgs; python = "python39"; };
    # }; in map (overlay: import overlay base.mach-nix) (j.imprelib.list { dir = ./_mach-nix; }))

    (flatten (map (file:
        [(final: prev: {
            "${j.imprelib.name { inherit file; }}" = import file {
                inherit sources pkgs lib;
            };
        })]
    ) (j.imprelib.list { dir = ./.; ignores = [ "nix" ]; })))

    # TODO
    # (
    #     <<20210601185346927223400>>
    # )
]
#+end_src

**** overrides

#+call: hash() :exports none

#+RESULTS:
: 20210601185111589161600

#+name: 20210601185111589161600
#+begin_src nix
let pkgsets' = {
    unstable = [ "git" "webkitgtk" ];
};
in flatten (mapAttrsToList (
    channel': pkglist: map (
        pkg: [(final: prev: {
            "${pkg}" = if (channel' == channel) then prev.${pkg} else final.j.pkgset.${channel'}.${pkg};
        })]
    ) pkglist
) pkgsets')
#+end_src

**** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185341615106400

#+name: 20210601185341615106400
#+begin_src nix :tangle (meq/tangle-path)
with builtins; {
    stc ? ({ system = currentSystem; channel = "pkgs"; }),
    ...
} : with stc; let

    flake = getFlake (toString ./.);

    sources = flake.inputs;

    nprefix = "nixpkgs";
    prefix = "pkgs";
    inherit (sources) nixpkgs;
    pkgs = import nixpkgs {
        inherit (stc) system;
        config = {
            <<20210601184936599601300>>
        };
    };
    lib = nixpkgs.lib.extend (final: prev: {
        j = import ../lib {
            inherit sources pkgs;
            lib = final;
        };
    });
in with lib; flatten [
    (
        <<20210601185110013135100>>
    )
    (
        <<20210601185111589161600>>
    )
    (
        # Adapted From: https://github.com/NixOS/nixpkgs/issues/75669#issuecomment-579432702
        [( self: super: { guix = self.callPackage (
            <<20210601185343563328200>>
        ) {}; })]
    )
]
#+end_src

**** guix

From: https://github.com/pukkamustard/nixpkgs/blob/guix/pkgs/development/guix/guix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185343563328200

#+name: 20210601185343563328200
#+begin_src nix
{stdenv, fetchurl}:
stdenv.mkDerivation rec
  { name = "guix-${version}";
    version = "1.0.0";

    src = fetchurl {
      url = "https://ftp.gnu.org/gnu/guix/guix-binary-${version}.${stdenv.targetPlatform.system}.tar.xz";
      sha256 = {
        "x86_64-linux" = "11y9nnicd3ah8dhi51mfrjmi8ahxgvx1mhpjvsvdzaz07iq56333";
        "i686-linux" = "14qkz12nsw0cm673jqx0q6ls4m2bsig022iqr0rblpfrgzx20f0i";
        "aarch64-linux" = "0qzlpvdkiwz4w08xvwlqdhz35mjfmf1v3q8mv7fy09bk0y3cwzqs";
        }."${stdenv.targetPlatform.system}";
    };
    sourceRoot = ".";

    outputs = [ "out" "store" "var" ];
    phases = [ "unpackPhase" "installPhase" ];

    installPhase = ''
      # copy the /gnu/store content
      mkdir -p $store
      cp -r gnu $store

      # copy /var content
      mkdir -p $var
      cp -r var $var

      # link guix binaries
      mkdir -p $out/bin
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix $out/bin/guix
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix-daemon $out/bin/guix-daemon
    '';

    meta = with stdenv.lib; {
      description = "The GNU Guix package manager";
      homepage = https://www.gnu.org/software/guix/;
      license = licenses.gpl3Plus;
      maintainers = [ maintainers.johnazoidberg ];
      platforms = [ "aarch64-linux" "i686-linux" "x86_64-linux" ];
    };

  }
#+end_src

**** kernels

This is the base extension, overriding the =nativeBuildInputs= attribute to include the =zstd= package, to facilitate =zstd=
compression for the kernel:

#+call: hash() :exports none

#+RESULTS:
: 20210601185345398351400

#+name: 20210601185345398351400
#+begin_src nix
const (super: { kernel = super.kernel.overrideDerivation (drv: {
    nativeBuildInputs = drv.nativeBuildInputs ++ [ pkgs.zstd ];
});})
#+end_src

***** xanmod cacule

Adapted from [[https://www.reddit.com/r/NixOS/comments/jtgi35/cant_build_custom_kernel/][here]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601185346927223400

#+name: 20210601185346927223400
#+begin_src nix
map (ver: let
        inherit ver;
        _ = makeExtensible { "linuxPackages_xanmod_v${ver}_cacule" = prev.recurseIntoAttrs (
            prev.linuxPackagesFor (
                prev.callPackage (
                    args@{ fetchFromGitHub, buildLinux, ... }: buildLinux (args // rec {
                        version = "${ver}-xanmod1";
                        modDirVersion = version;
                        src = sources."xanmodV${replace ["."] [""] ver}Cacule" // { extraPostFetch = '' rm $out/.config ''; };
                        kernelPatches = [];
                        # postConfigure = '' make ARCH=x86_64 mrproper '';
                        extraConfig = ''
                        #     USER_NS_UNPRIVILEGED y
                        #     FUNCTION_TRACER n
                        #     GRAPH_TRACER n
                        #     NUMA n
                            RD_ZSTD y
                            KERNEL_ZSTD y
                            KERNEL_XZ n
                        '';
                        extraMeta.branch = "${ver}-xanmod1";
                    } // (args.argsOverride or {}))
                ) {}
            )
        );};
    in [( final: prev: { "linuxPackages_xanmod_v${ver}_cacule" = _.extend (self:
        <<20210601185345398351400>>
);})]) [ "5.9.14" "5.10.4" ]
#+end_src

**** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185348536012000

#+name: 20210601185348536012000
#+begin_src nix :tangle (meq/tangle-path)
{
    description = "Overlay Sources";

    inputs = {
        <<ff(name="flake-compat", ur="edolstra/flake-compat/master")>>
        <<ff(name="emacs", ur="nix-community/emacs-overlay/master")>>
        nur.url = "github:nix-community/nur/master";
        mach-nix.url = "github:davhau/mach-nix/master";
        <<ff(name="mozilla", ur="mozilla/nixpkgs-mozilla/master")>>
        nanite = {
            url = "git+https://gitlab.com/picotech/nanotech/nanite.git";
            flake = false;
        };
        <<ff(name="niv", ur="nmattia/niv/master")>>
        nix.url = "github:nixos/nix/master";
        <<ff(name="qtile", ur="qtile/qtile/master")>>
        <<ff(name="xonsh", ur="xonsh/xonsh/main")>>
        <<ff(name="wip-pinebook-pro", ur="shadowrylander/wip-pinebook-pro/master")>>
        nixpkgs.url = "github:nixos/nixpkgs/master";
        nixpkgs-20-03.url = "github:nixos/nixpkgs/nixos-20.03";
        nixpkgs-20-03-small.url = "github:nixos/nixpkgs/nixos-20.03-small";
        nixpkgs-20-09.url = "github:nixos/nixpkgs/nixos-20.09";
        nixpkgs-20-09-small.url = "github:nixos/nixpkgs/nixos-20.09-small";
        nixpkgs-21-05.url = "github:nixos/nixpkgs/nixos-21.05";
        nixpkgs-21-05-small.url = "github:nixos/nixpkgs/nixos-21.05-small";
        nixpkgs-unstable.url = "github:nixos/nixpkgs/nixos-unstable";
        nixpkgs-unstable-small.url = "github:nixos/nixpkgs/nixos-unstable-small";
        nixpkgs-master.url = "github:nixos/nixpkgs/master";
    };

    outputs = inputs@{ self, flake-compat, ... } : {  };
}
#+end_src

*** packages.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601195930734248900

#+name: 20210601195930734248900
#+begin_src nix :tangle (meq/tangle-path)
inputs@{
    pkgs,
    lib,
    sources,
    stc,
    ...
} : with lib; with j; with stc; let
    minimal = stc.minimal == 1;
    terminal = stc.terminal == 1;
    inherit (attrs) versions;
    neither = !(minimal || terminal);
    mkifnt = myIf.drv (!terminal) pkgs.hello;
    mkifn = myIf.drv neither pkgs.hello;
    mkifnm = myIf.drv (!minimal) pkgs.hello;
in with pkgs; [ emacsGcc yadm ]
#+end_src

*** platforms
**** shared
***** armv67l.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185350150461400

#+name: 20210601185350150461400
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = {
        binaryCaches = [
            "http://nixos-arm.dezgeg.me/channel"
            "https://app.cachix.org/cache/thefloweringash-armv7"
        ];
        binaryCachePublicKeys = [
            "nixos-arm.dezgeg.me-1:xBaUKS3n17BZPKeyxL4JfbTqECsT+ysbDJz29kLFRW0=%"
            "thefloweringash-armv7.cachix.org-1:v+5yzBD2odFKeXbmC+OPWVqx4WVoIVO6UXgnSAWFtso="
        ];
    };
}
#+end_src

**** arm
***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185351622602000

#+name: 20210601185351622602000
#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        # NixOS wants to enable GRUB by default
        boot.loader.grub.enable = false;
        # Enables the generation of /boot/extlinux/extlinux.conf
        boot.loader.generic-extlinux-compatible.enable = true;

        boot.loader.systemd-boot.enable = mkForce false;
    };
}
#+end_src

**** armv6l-linux
***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185353321602000

#+name: 20210601185353321602000
#+begin_src nix :tangle (meq/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

**** armv7l-linux
***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185354863625500

#+name: 20210601185354863625500
#+begin_src nix :tangle (meq/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

**** aarch64-linux
***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185356455654500

#+name: 20210601185356455654500
#+begin_src nix :tangle (meq/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        [ ../arm ]
        (imprelib.list { dir = ./.; })
    ];
}
#+end_src

*** repl.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185357956752000

#+name: 20210601185357956752000
#+begin_src nix :tangle (meq/tangle-path)
let
  flake = builtins.getFlake (toString ./.);
  nixpkgs = import <nixpkgs> { };
in
{ inherit flake; }
// flake
// builtins
// nixpkgs
// nixpkgs.lib
// flake.nixosConfigurations
#+end_src

*** resources
**** users.json

#+call: hash() :exports none

#+RESULTS:
: 20210601185359809444000

#+name: 20210601185359809444000
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

** nix
*** nix.conf

#+begin_src nix :tangle (meq/tangle-path)
<<20211023232853007053400>>
#+end_src

* .config
** nix
*** nix.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref nix.conf
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211023232853007053400

#+name: 20211023232853007053400
#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<nix.conf>>
#+end_src

#+begin_src conf
<<20210601184948158342800>>
min-free = 262144000
max-free = 1073741824
#+end_src

* wheee.py

#+begin_src python :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3.10"
import argparse
import os
from sys import argv
from itertools import zip_longest
from subprocess import run
parser = argparse.ArgumentParser()
parser.add_argument("-D", "--directory", default="/etc/nixos")
parser.add_argument("-f", "--flake", action="store_true")
parser.add_argument("-F", "--file")
parser.add_argument("-c", "--command", default="switch")
parser.add_argument("-s", "--hash", action="store_true")
parser.add_argument("--use-hash")
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-d", "--dry-run", action="store_true")
parser.add_argument("-i", "--install", action="store_true")
parser.add_argument("-I", "--install-for")
parser.add_argument("-H", "--host", required=True)
args, unknown = parser.parse_known_args(argv[1:])

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter([
        s.removeprefix("--") if s.startswith("--") else s for s in iterable
    ])] * n
    return zip_longest(*args, fillvalue=fillvalue)

unknown = dict(grouper(unknown, 2, ""))

unknown["host"] = args.host

if args.install_for:
    match args.install_for:
        case "rpi4":
            unknown["noSwap"] = 1
            unknown["system"] = "aarch64-linux"
            unknown["type"] = "rpi"
            unknown["device"] = "4b"
        case "rpi3":
            unknown["noSwap"] = 1
            unknown["system"] = "aarch64-linux"
            unknown["type"] = "rpi"
            unknown["device"] = "3b"

commandPre = f"nix-instantiate --read-write-mode --show-trace --eval -E 'let j = import " + os.path.dirname(os.path.realpath(argv[0])) + "/etc/nixos/lib {  }; in j.hostName"

commandSet = "{ stc = j.attrs.default-stc // " + " { "
for k, v in unknown.items():
    commandSet += f'{k} = "{v}"; '
commandSet += "};"

hashCommand = " ".join([
    commandPre,
    commandSet,
    "}'",
])

flake = lambda _hash: f'--flake "{args.directory}#{_hash}"' if args.flake else ""

if args.install:
    # command = lambda _hash: f'nixos-install --impure --show-trace {flake(_hash)}'
    command = lambda _hash: f'''nix build \
        --option build-use-substitutes true \
        --option substitute true \
        --impure \
        --recreate-lock-file \
        --show-trace \
        {args.directory}#nixosConfigurations.{_hash}.config.system.build.toplevel && \
        nixos-install --system ./result'''
else:
    command = lambda _hash: f'''nixos-rebuild {args.command} \
        --option build-use-substitutes true \
        --option substitute true \
        --impure \
        --show-trace {flake(_hash)}'''


getHash = lambda: args.use_hash or run(hashCommand, shell = True, capture_output = True, text = True).stdout.strip().strip('\"')

if args.verbose or args.dry_run:
    if args.hash:
        print(hashCommand)
    else:
        _hash = getHash()
        print(command(getHash()))
if not args.dry_run:
    if args.hash:
        print(getHash())
    else:
        run(command(getHash()), shell = True)
#+end_src