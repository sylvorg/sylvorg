#+setupfile: ./settings/README.org
#+include: ./settings/README.org

* mscripts
** stow

#+begin_src xonsh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env xonsh"
import fuckit, os
from sys import argv
chmod 700 @(os.path.join(argv[1], ".ssh")) &> /dev/null
chmod +x @(os.path.join(argv[1], "run_keybase"))
@$(os.path.join(argv[1], "run_keybase"))
git -C @(os.path.join(argv[1], "keybase", "secrets")) pull
with fuckit:
    for f in $(ls -a @(os.path.join(argv[1], "keybase", "secrets", ".ssh"))).split():
        if f not in [ ".", ".." ]:
            rm @(os.path.join(argv[1], ".ssh", f))
stow -d @(os.path.join(argv[1], "keybase")) -t @(argv[1]) secrets
chmod 700 @(os.path.join(argv[1], ".ssh"))
chmod 600 @(os.path.join(argv[1], ".ssh", "*"))
#+end_src

** tangle

#+begin_src xonsh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env xonsh"
import os
from sys import argv

def runFd(dir, ext, cmd, recursive = True):
    try:
        if isinstance(ext, str): raise TypeError
        else: iter(ext)
    except TypeError: newExt = "-e " + ext
    else:
        newExt = ""
        for e in ext: newExt += f" -e {e}"
    if recursive:
        fd . @(dir) -HI @(newExt) -x @(cmd)
    else:
        fd . @(dir) -HId 1 @(newExt) -x @(cmd)

runFd(argv[1], "sh", "chmod +x", 1)
runFd(argv[1], "py", "black -l 65", 1)
for d in [
    ".config"
]:
    runFd(os.path.join(argv[1], d), "sh", "chmod +x")
    runFd(os.path.join(argv[1], d), "py", "black -l 65")
#+end_src

* makefile

#+begin_src makefile :tangle (meq/tangle-path)
.RECIPEPREFIX := |
.DEFAULT_GOAL := tangle

# Adapted From: https://www.systutorials.com/how-to-get-the-full-path-and-directory-of-a-makefile-itself/
mkfilePath := $(abspath $(lastword $(MAKEFILE_LIST)))
mkfileDir := $(dir $(mkfilePath))
emkDir := $(mkfileDir)/.emacs.d/
emkFile := $(emkDir)/makefile
emkMake := make -f $(emkFile)

bootstrap:
|nix-channel --add https://github.com/nixos/nixpkgs/archive/master/nixpkgs.tar.gz master
|nix-channel --update
|nix-env -iA master.emacs master.python310
|git -C $(mkfileDir)/<<username>>/settings checkout main
|$(mkfileDir)/<<username>>/settings/org-tangle.sh oreo.aiern.org README.org
|chmod +x $(mkfileDir)/<<username>>/wheee.py $(mkfileDir)/<<username>>/bootstrap.py
|git clone https://github.com/<<username>>/<<username>> $(mkfileDir)/<<username>>/<<username>>

README:
|yes yes | $(mkfileDir)/settings/org-tangle.sh $(mkfileDir)/README.org

both: README
|yes yes | $(mkfileDir)/settings/org-tangle.sh $(mkfileDir)/oreo.aiern.org

tangle: both
|chmod +x $(mkfileDir)/mscripts/tangle
|$(mkfileDir)/mscripts/tangle $(mkfileDir)

tangle-emacs:
|$(emkMake) tangle

tangle-all: tangle tangle-emacs

subinit:
|$(emkMake) subinit
|yadm submodule sync --recursive

emacs:
|$(emkMake) emacs
emacs-nw:
|$(emkMake) emacs-nw

stow:
|chmod +x $(mkfileDir)/mscripts/stow
|$(mkfileDir)/mscripts/stow $(mkfileDir)
#+end_src

* previous projects
** bakery

My pride and joy; based off of [[https://github.com/amoffat][Andrew Moffat's]] [[https://amoffat.github.io/sh/][sh]],
this python module allows you to import shell commands as modules as well. For example:

# How does the code below work exactly, again? Revise it!

#+begin_src python
<<20210601181755824433500>>
<<20210601181800630609300>>
<<20210601181804730771100>>
#+end_src

You might be thinking to yourself, "Cool!" And also, "...Wait what?"

*** breaking it down

-----

#+call: hash() :exports none

#+RESULTS:
: 20210601181755824433500

#+name: 20210601181755824433500
#+begin_src python
from baker.y import git
#+end_src

This will import the =git= utility from your path as a =bakery= object;
note, however, that while the statement is importing =git= from =baker.y=,
there are actually two submodules in play here: =baker= with a =y=,
and =baker= with an =i=.

To facilitate the use of =git(C = [path]).status()=, the latter submodule must be used.
This also prevents the use of something like =git()=, but, since that just shows the help text,
one can simply use =git.help()= instead.

-----

#+call: hash() :exports none

#+RESULTS:
: 20210601181800630609300

#+name: 20210601181800630609300
#+begin_src python
git.clone(
    b = "master",
    recurse_submodule = True,
    "https://github.com/<<username>>/<<username>>",
    "~/<<username>>",
    _run = True,
)
#+end_src

-----

#+call: hash() :exports none

#+RESULTS:
: 20210601181804730771100

#+name: 20210601181804730771100
#+begin_src python
print(git(C = "~/<<username>>").status())
#+end_src

*** want more information?

Get it here! https://gitlab.com/picotech/bakery

Also: eh heh heh... yeah... I like =gitlab's= grouping system... */sheepish grin/*
