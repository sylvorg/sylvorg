#+property: header-args -n -r -l "[{(<%s>)}]" :tangle-mode (identity 0444) :noweb yes :mkdirp yes
#+property: header-args:emacs-lisp :comments both

# Adapted From:
# Answer: https://stackoverflow.com/a/65232183/10827766
# User: https://stackoverflow.com/users/776405/whil
#+startup: show3levels

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* org-tangle.sh
:PROPERTIES:
:header-args:emacs-lisp+: :comments none
:END:

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<20210601225401786848500>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (message (format "\n\nNow tangling %s:\n" file))
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)

              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)

              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

* org-tangle-functions.el
:PROPERTIES:
:header-args:emacs-lisp+: :comments none
:END:

#+call: hash() :exports none

#+RESULTS:
: 20210601225401786848500

#+name: 20210601225401786848500
#+begin_src emacs-lisp :tangle (meq/tangle-path)
(let* ((file (cond
                ((file-exists-p "~/.emacs.d/settings/README.org") "~/.emacs.d/settings/README.org")
                ((file-exists-p "home/.emacs.d/settings/README.org") "home/.emacs.d/settings/README.org"))))
    (when file (org-babel-lob-ingest file)))

(defun meq/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun meq/tangle-path nil (interactive)
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (meq/get-header))))
(defun meq/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (meq/get-header)))
#+end_src

* wtt-pre

#+call: hash() :exports none

#+RESULTS:
: 20210821132334835661400

#+name: 20210821132334835661400
#+begin_src emacs-lisp
(load (concat (getenv "HOME") "/.emacs.d/early-init.el"))
(meq/up markdown-mode :mode ("\\.md\\'")
    :use-package-postconfig (yasnippet)
    :upnsd-preconfig (titan :custom (meq/var/titan-snippets-dir (meq/ued-siluam "titan" "snippets"))))
#+end_src

* wtt-post

#+call: hash() :exports none

#+RESULTS:
: 20210821140509092087900

#+name: 20210821140509092087900
#+begin_src emacs-lisp
(meq/insert-snippet "markdown titan template")
(save-buffer)
#+end_src

* wtt.sh
:PROPERTIES:
:header-args:emacs-lisp+: :comments none
:END:

#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(princ (format-time-string "%Y%m%d%H%M%S%N")) (terpri)
#+end_src

* wtt.fell.sh
:PROPERTIES:
:header-args:emacs-lisp+: :comments none
:END:

#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd fell
    :custom (meq/var/fell-snippets-dir (meq/ued-siluam "fell" "snippets"))
    :mode ("\\.fell\\.md\\'" . fell-markdown-mode))
(find-file (concat (meq/timestamp) ".fell.md"))
<<20210821140509092087900>>
#+end_src

* wtt.doc.sh
:PROPERTIES:
:header-args:emacs-lisp+: :comments none
:END:

#+begin_src emacs-lisp :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
<<20210821132334835661400>>
(meq/upnsd doc
    :custom (meq/var/doc-snippets-dir (meq/ued-siluam "doc" "snippets"))
    :mode ("\\.doc\\.md\\'" . doc-markdown-mode))
(find-file (concat (meq/timestamp) ".doc.md"))
<<20210821140509092087900>>
#+end_src

* Addendum

These are just a few blocks I use regularly in my ~org~ files, whether in ~noweb~, naming, or otherwise:

#+name: username
#+begin_src text
shadowrylander
#+end_src

# Adapted From: https://www.reddit.com/r/emacs/comments/4o9f0e/anyone_have_disabled_parts_of_their_config_being/d4apjey?utm_source=share&utm_medium=web2x&context=3

#+name: hash-deprecated
#+begin_src emacs-lisp :var name="" :tangle no
(md5 (concat (replace-regexp-in-string "/" "" (
    org-format-outline-path (org-get-outline-path))) (
        nth 4 (org-heading-components)) name))
#+end_src

#+name: hash
#+begin_src emacs-lisp :tangle no
(format-time-string "%Y%m%d%H%M%S%N")
#+end_src