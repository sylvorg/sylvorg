#!/usr/bin/env hy
(import click)
(import json)
(import os)
(import addict [Dict :as D])
(import bakery [ getconf
                 mkswap
                 mount :as Mount
                 nixos-generate-config
                 nixos-install
                 sd
                 swapon
                 umount
                 zfs
                 zpool ])
(import functools [partial])
(import pathlib [Path])
(import shutil [copy2])
(import sys [argv])
(import toolz [last])
(require hyrule [-> assoc])
(setv resources (.dirname os.path (.realpath os.path __file__)))
(defn update-datasets [host swap encrypted deduplicated [pool False]]
      (setv snap-dir     [ "snapdir=visible" ]
            extra-copies (+ snap-dir [ "copies=3" ])
            cache        [ "sync=disabled" ]
            ml           "mountpoint=legacy"
            d            "datasets"
            s            "system"
            datasets     (D (.loads json (.strip #[[
                                {
                                    "base": {  },
                                    "omniverse": {  },
                                    "reserved": {  },
                                    "shadowrylander": { "datasets": {
                                            "oreo": { "mountpoint": "/home/shadowrylander/oreo", "options": [ "snapdir=visible" ] },
                                            "sylveon": { "mountpoint": "/home/shadowrylander/sylveon", "options": [ "snapdir=visible" ] },
                                            "sylvorg": { "mountpoint": "/home/shadowrylander/sylvorg", "options": [ "snapdir=visible" ] },
                                            "syvlorg": { "mountpoint": "/home/shadowrylander/syvlorg", "options": [ "snapdir=visible" ] },
                                            "shadowrylander": { "mountpoint": "/home/shadowrylander/shadowrylander", "options": [ "snapdir=visible" ] }},
                                        "options": [ "mountpoint=legacy" ]},
                                    "system": {
                                        "datasets": {
                                            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
                                            "nix": {  },
                                            "persist": {
                                                "datasets": {
                                                    "cache": {
                                                        "datasets": { "root": {  }},
                                                        "options": [ "sync=disabled" ]
                                                    },
                                                    "home": { "datasets": { "root": {  }}}
                                                }
                                            },
                                            "root": {  },
                                            "tmp": { "datasets": { "nix": {  }}, "options": [ "sync=disabled" ] },
                                            "etc": {  },
                                            "var": {  },
                                            "usr": {  },
                                            "srv": {  },
                                            "opt": {  }
                                        },
                                        "options": [ "mountpoint=legacy" ]
                                    },
                                    "virt": {
                                        "datasets": {
                                            "docker": {  },
                                            "kvm": {  },
                                            "podman": { "datasets": {  }},
                                            "qemu": {  },
                                            "vagrant": {  },
                                            "xen": {  }
                                        },
                                        "options": [ "mountpoint=legacy", "refreservation=none" ],
                                        "mountpoint": "/var/lib"
                                    }
                                }
                         ]])))
            users        (D (.loads json (.strip #[[
                                {
                                    "primary": "shadowrylander",
                                    "secondary": "frost",
                                    "nightingale": "curtis"
                                }
                         ]]))))
      (assoc datasets host { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                             "options" [ ml ]})
      (for [user (.values users)]
           (assoc (. datasets [s] [d] home [d]) user (dict))
           (assoc (. datasets virt [d] podman [d]) user (dict))
           (for [dataset (.keys (. datasets [s] [d] persist [d]))]
                (assoc (. datasets [s] [d] persist [d] [dataset] [d]) user (dict))))
      (with [dnix (open (+ resources "/datasets.nix") "w")]
            (.write dnix "{\n")
            (defn recurse [ddict dname droot [mountpoint ""]]
                  (setv recurse/dataset (+ droot "/" dname)
                        cloning         (and (!= dname "base")
                                             (and encrypted deduplicated))
                        prefixes        (, "system"
                                           "system/root"
                                           "swap"
                                           "base"
                                           "hold"
                                           "omniverse"
                                           "reserved" ))
                  (if cloning
                      (setv clone-or-create  "clone"
                            snapshot-or-none (+ host "/base@root"))
                      (setv clone-or-create  "create"
                            snapshot-or-none ""))
                  (if (not (in recurse/dataset (lfor dataset prefixes (+ host "/" dataset))))
                      (do (if (setx recurse/mountpoint (.get ddict "mountpoint" ""))
                              (setv mountpoint recurse/mountpoint)
                              (if mountpoint
                                  (setv mountpoint (+ mountpoint "/" dname)
                                        recurse/mountpoint mountpoint)
                                  (do (setv recurse/mountpoint (.removeprefix recurse/dataset (+ host "/")))
                                      (for [prefix prefixes]
                                           (setv recurse/mountpoint (.removeprefix recurse/mountpoint (+ prefix "/"))))
                                      (setv recurse/mountpoint (+ "/" recurse/mountpoint)))))
                          (.write dnix (+ "\t\""
                                          recurse/dataset
                                          "\" = \""
                                          recurse/mountpoint
                                          "\";\n"))))
                  (if pool
                      (do (zfs :m/subcommand clone-or-create
                               :o { "repeat-with-values" (.get ddict "options" []) }
                               snapshot-or-none
                               recurse/dataset)
                          (.snapshot zfs :r True (+ recurse/dataset "@root"))))
                  (for [[key value] (.items (.get ddict d (D {  })))]
                       (recurse value key recurse/dataset mountpoint)))
            (for [[key value] (.items datasets)]
                 (recurse value key host))
            (.write dnix "}"))
      (if pool
          (let [pool-size-plus-metric (get (.get zpool :H True "size" host :m/list True :m/split True) 2)
                pool-size             (-> pool-size-plus-metric
                                          (cut 0 -1)
                                          (float)
                                          (round 2))
                pool-metric           (last pool-size-plus-metric)]
               (defn pool-percentage-value [percentage]
                     (-> percentage
                         (float)
                         (/ 100)
                         (round 2)
                         (str)
                         (+ pool-metric)
                         (return)))
               (.set zfs
                     (+ "refreservation=" (pool-percentage-value 15))
                     (+ host "/reserved"))

               ;; Apparently, if python internal keywords exist in the argument, such as "set", etc.
               ;; the command errors out; perhaps something to raise an issue of.
               ;; This seems to work as an alternative.
               ;; run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/reserved", shell = True)

               (if swap
                   (let [swoptions [ "com.sun:auto-snapshot=false"
                                     "compression=zle"
                                     "logbias=throughput"
                                     "primarycache=metadata"
                                     "secondarycache=none"
                                     "sync=standard" ]
                         page-size (getconf "PAGESIZE" :m/str True)]
                        (.create zfs
                                 :V (+ (str swap) "G")
                                 :b page-size
                                 :o { "repeat-with-values" swoptions }
                                 (+ host "/swap"))
                        (mkswap (+ "/dev/zvol" host "/swap")))))))
(setv no-host-error-message "Sorry! The host needs to be set; do this with the main command while running the subcommand!")
#@((.group click :no-args-is-help True)
   (.option click "-d" "--dazzle" :is-flag True)
   (.option click "-H" "--host")
   (.option click "-i" "--inspect" :is-flag True)
   (.option click "-p" "--print-run" :is-flag True)
   click.pass-context
   (defn bootstrap [ ctx dazzle host inspect print-run ]
         (.ensure-object ctx dict)
         (setv ctx.obj.host host)
         (if print-run (.bake-all- getconf :m/print-command-and-run True))
         (if inspect (.bake-all- getconf :m/debug True))))
#@((.command bootstrap :no-args-is-help True)
   (.option click "-a" "--all" :is-flag True)
   (.option click "-c" "--copy" :is-flag True)
   (.option click "-g" "--generate" :is-flag True)
   (.option click "-i" "--install" :is-flag True)
   (.option click "-r" "--replace" :is-flag True)
   click.pass-context
   (defn main [ ctx all copy generate install replace ]
         (.bake-all- getconf :m/sudo True)
         (if (or copy all)
             (copy2 (+ resources "/datasets.nix") "/mnt/etc/nixos/datasets.nix"))
         (if (or generate all)
             (nixos-generate-config :root "/mnt" :m/stdout-stderr True :m/dazzle True))
         (if (or replace all)
             (if ctx.obj.host
                 (sd "./hardware-configuration.nix"
                     (+ "'./hardware-configuration.nix\n"
                        "\"${builtins.fetchGit { url = \"https://github.com/shadowrylander/shadowrylander\"; }}/etc/nixos/configs/"
                        ctx.obj.host
                        "\"'")
                     "/mnt/etc/nixos/configuration.nix")
                 (raise (NameError no-host-error-message))))
         (if (or install all)
             (nixos-install :m/run True
                            :show-trace True
:option "tarball-ttl 0"
))))
#@((.command bootstrap :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-s" "--swap" :type int :default 0)
   (.option click "-z" "--zfs-device" :required True)
   click.pass-context
   (defn create [ ctx deduplicated encrypted swap zfs-device ]
         (if ctx.obj.host
             (try (if (= (input "THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN 'ZFS CREATE'!\n\t") "ZFS CREATE")
                      (let [options (D { "xattr"      "sa"
                                         "acltype"    "posixacl"
                                         "mountpoint"  "none"
                                         "compression" "zstd-19"
                                         "checksum"    "edonr"
                                         "atime"       "off"
                                         "relatime"    "off" })
                            command (partial zpool.create
                                             :f True
                                             :o { "repeat-with-values" (, "autotrim=on" "altroot=/mnt" "autoexpand=on") })]
                           (if encrypted
                               (setv options.encryption "aes-256-gcm"
                                     options.keyformat  "passphrase"))
                           (if deduplicated
                               (setv options.dedup "edonr,verify"))
                           (.export zpool :f True ctx.obj.host :m/ignore-stderr True)
                           (command :O { "repeat-with-values" (gfor [k v] (.items options) f"{k}={v}") } ctx.obj.host zfs-device)
                           (update-datasets ctx.obj.host swap encrypted deduplicated :pool True))
                      (print "Sorry; not continuing!\n\n"))
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#@((.command bootstrap :no-args-is-help True)
   (.option click "-b" "--boot-device")
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :is-flag True)
   click.pass-context
   (defn mount [ ctx boot-device deduplicated encrypted root-device swap ]
         (if ctx.obj.host
             (do (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                      (if (in ctx.obj.host dataset)
                          (break))
                      (else (.import zpool :f True ctx.obj.host)))
                 (if encrypted
                     (.load-key zfs ctx.obj.host :m/run True))
                 (try (.mkdir (Path "/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt")
                                  (umount :R True "/mnt"))))
                 (if root-device
                     (Mount root-device "/mnt")
                     (Mount :t "zfs" (+ ctx.obj.host "/system/root") "/mnt"))
                 (with [datasets (open (+ resources "/datasets.nix"))]
                       (setv dataset-dict (dfor dm
                                                (cut (.readlines datasets) 1 -1)
                                                :setv [k v] (.split dm "=")
                                                [(.strip k)
(+ "\"/mnt"
   (-> v
       (.strip)
       (.rstrip ";")
       (.lstrip "\"")))])
                ordered-dataset-dict (-> dataset-dict
                                         (.items)
                                         (sorted :key (fn [item] (get item 1)))
                                         (dict)))
          (for [[k v] (.items ordered-dataset-dict)]
               (-> v (.strip "\"") (Path) (.mkdir :parents True :exist-ok True))
               (Mount :t "zfs" k v)))
    (.mkdir (Path "/mnt/etc/nixos") :parents True :exist-ok True)
    (if boot-device
        (let [boot "/mnt/boot/efi"]
             (.mkdir (Path boot) :parents True :exist-ok True)
             (Mount boot-device boot)))
    (if swap
        (swapon (+ "/dev/zvol/" ctx.obj.host "/swap")))

    ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp") "/tmp")
    ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/tmp/nix")
    ;; (rsync :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } :delete True "/nix/" "/tmp/nix/")
    ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/nix")

    )
(raise (NameError no-host-error-message)))))
#@((.command bootstrap :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-f" "--files" :is-flag True :help "Update datasets.nix with any new datasets; the default")
   (.option click "-p" "--pool" :is-flag True :help "Update the pool and datasets.nix with any new datasets")
   (.option click "-s" "--swap" :type int :default 0)
   click.pass-context
   (defn update [ ctx deduplicated encrypted files pool swap ]
         (if ctx.obj.host
             (try (setv ud (partial update-datasets ctx.obj.host swap encrypted deduplicated))
                  (cond [files (ud)]
                        [pool (ud :pool True)]
                        [True (ud)])
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
(if (= __name__ "__main__")
    (bootstrap :obj (D {})))
