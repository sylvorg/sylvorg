#+setupfile: ./README.org
#+include: ./README.org

This can be used with =GNU Stow= as well! :D

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* .config
** yadm
*** bootstrap

#+call: hash() :exports none

#+RESULTS:
: 20210601184651836098700

#+name: 20210601184651836098700
#+begin_src sh :tangle (aiern/tangle-path) :shebang "#!/usr/bin/env bash"

#+end_src

* system
** etc
*** nixos
**** configs

#+call: hash() :exports none

#+RESULTS:
: 20210601184724193852200

#+name: 20210601184724193852200
#+begin_src nix
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        (imprelib.list { dir = ./.; })
        (imprelib.list { dir = ../../config; ignores = [ "datasets" ]; })
    ];
#+end_src

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

***** dross
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184730035302100

#+name: 20210601184730035302100
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

***** sandshrew
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184744001979300

#+name: 20210601184744001979300
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

***** yggdrasil
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184747964016700

#+name: 20210601184747964016700
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601184724193852200>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** flakes
***** bootstrap
****** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184751675181500

#+name: 20210601184751675181500
#+begin_src nix :tangle (aiern/tangle-path)
{
    description = "";
    inputs = {
        <<username>> = {
            url = "github:<<username>>/<<username>>/master";
            flake = false;
        };
        wip-pinebook-pro = {
            url = "github:<<username>>/wip-pinebook-pro/master";
            flake = false;
        };
        home-manager' = {
            url = "github:nix-community/home-manager";
            flake = false;
        };
        impermanence = {
            url = "github:nix-community/impermanence";
            flake = false;
        };
    };
    outputs = { self, ... }: {  };
}
#+end_src

***** home
****** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184754536351000

#+name: 20210601184754536351000
#+begin_src nix :tangle (aiern/tangle-path)
{
    description = "";
    inputs = {
        bass = {
            url = "github:edc/bass";
            flake = false;
        };
    };
    outputs = { self, ... }: {  };
}
#+end_src

**** devices
***** hyper-v
****** boot.nix

Taken from [[https://github.com/NixOS/nixos-hardware/tree/master/microsoft/hyper-v][here]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601184759139337200

#+name: 20210601184759139337200
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # REQUIRED - see: https://github.com/nixos/nixpkgs/issues/9899

        kernelModules = [ "hv_vmbus" "hv_storvsc" ];
        initrd = {
            kernelModules = [ "hv_vmbus" "hv_storvsc" ];
            availableKernelModules = [ "hv_vmbus" "hv_storvsc" ];

            # UNKNOWN - not sure if below are needed; were suggested for VirtualBox and I used them
            checkJournalingFS = false;

        };
        extraModulePackages = with pkgs.linuxPackages_latest; [ hyperv-daemons ];

        # RECOMMENDED
        # - use 800x600 resolution for text console, to make it easy to fit on screen
        kernelParams = ["video=hyperv_fb:800x600"];  # https://askubuntu.com/a/399960
        # - avoid a problem with `nix-env -i` running out of memory
        # kernel.sysctl."vm.overcommit_memory" = "1"; # https://github.com/NixOS/nix/issues/421
    };
}
#+end_src

****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184801744311100

#+name: 20210601184801744311100
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.noSwap = true;
        networking = {
            wireless.enable = false;
            interfaces.eth0.useDHCP = true;
        };
        virtualisation.hypervGuest.enable = true;
    };
}
#+end_src

***** linode
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184803930214900

#+name: 20210601184803930214900
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.terminal = true;
        boot = {
            kernelParams = [ "console=ttyS0,19200n8" ];
            loader.grub.extraConfig = ''
                serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
                terminal_input serial;
                terminal_output serial;
            '';
        };
        networking = {
            usePredictableInterfaceNames = false;
            interfaces.eth0.useDHCP = true;
        };
    };
}
#+end_src

***** rpi
****** 3b.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184806549418800

#+name: 20210601184806549418800
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, device, ... }: with builtins; with lib; with j; mkIf (device == "3b") {
    vars.terminal = true;
    boot = {
        kernelParams = ["cma=256M"];
        loader = {
            raspberryPi = {
                enable = true;
                version = 3;
                uboot.enable = mkForce true;
                firmwareConfig = '' gpu_mem=256 '';
            };
        };
    };
    environment.systemPackages = with pkgs; [ libraspberrypi ];
}
#+end_src

****** 4b.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184808685869700

#+name: 20210601184808685869700
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, device, ... }: with builtins; with lib; with j; mkIf (device == "4b") {
    vars.terminal = true;
    boot = {
        kernelPackages = mkOverride 49 pkgs.linuxPackages_rpi4;
        tmpOnTmpfs = true;
        initrd.availableKernelModules = [ "usbhid" "usb_storage" ];
        # ttyAMA0 is the serial console broken out to the GPIO
        kernelParams = [
            "8250.nr_uarts=1"
            "console=ttyAMA0,115200"
            "console=tty1"
            # Some gui programs need this
            "cma=128M"
        ];
        loader = {
            raspberryPi = {
                enable = true;
                version = 4;
                firmwareConfig = ''
                    dtparam=sd_poll_once=on
                    dtparam=audio=on
                '';
            };
            grub.enable = mkForce false;
            generic-extlinux-compatible.enable = true;
            
        };
    };

    services.xserver.videoDrivers = [ "fbdev" ];    
    hardware = {
        enableRedistributableFirmware = true;
        # raspberry-pi."4".fkms-3d.enable = true;
        pulseaudio.enable = true;
    };
    sound.enable = true;
    environment.systemPackages = with pkgs; [ libraspberrypi ];
}
#+end_src

****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184810839651300

#+name: 20210601184810839651300
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** surface
****** _specialisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184813562748800

#+name: 20210601184813562748800
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (specialisation_base) patches base;
    in {
        clear = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                        });
                    }));
                })];
            };
        };
        clear_xen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest_xen_dom0.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."57";
                        });
                    }));
                })];
            };
        };
        zen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                                { patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch"; name = "BACKPORT-Linux-5.8-compat-__vmalloc"; }
                            ];
                        });
                    }));
                })];
            };
        };
        bcachefs = base.settings // {
            configuration = {
                config = {
                    nixpkgs.overlays = [(self: super: {
                        surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                                kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                            });
                        }));
                    })];
                    boot = {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
    };
}
#+end_src

****** nixpkgs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184835588960800

#+name: 20210601184835588960800
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    nixpkgs.overlays = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (specialisation_base) patches base;
    in [
        (self: super: { surface_kernel_latest = super.linuxPackages_zen.extend (
            self: (ksuper: { kernel = ksuper.kernel.override (
                base.kernel // { kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                    {
                        patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch";
                        name = "BACKPORT-Linux-5.8-compat-__vmalloc";
                    }
                ];}
            );})
        );})
    ];
}
#+end_src

****** b2.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184839546821900

#+name: 20210601184839546821900
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, device, ... }: with builtins; with lib; with j; mkIf (device == "b2") {
    boot.extraModprobeConfig = mkAfter '' options ipts singletouch=y '';
    powerManagement.resumeCommands = mkAfter '' modprobe ipts_surface singletouch=y '';
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env xonsh
        for usb in $(ls /dev/disk/by-id).split("\n"):
            if usb and usb[:4] == "usb-":
                for mnt in $(mount).split("\n"):
                    if mnt and usb in mnt:
                        umount @(mnt.split()[2])
    '';
}
#+end_src

****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184841857888100

#+name: 20210601184841857888100
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        boot.kernelPackages = pkgs.surface_kernel_latest;
        networking.networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
}
#+end_src

***** pinebook
****** import.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184843916803200

#+name: 20210601184843916803200
#+begin_src nix :tangle (aiern/tangle-path)
{ sources, ... }: { imports = [ "${sources.wip-pinebook-pro}/pinebook_pro.nix" ]; }
#+end_src

****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184849683569900

#+name: 20210601184849683569900
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** android
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184853359396100

#+name: 20210601184853359396100
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config.vars = { terminal = true; minimal = true; };
}
#+end_src

**** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184855143779200

#+name: 20210601184855143779200
#+begin_src nix
inherit (stc) system;
pkgs = let configBase = { inherit stc; ignoredAttrs = [ "host" ];}; in j.get (configBase // { set = all.pkgs; });
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184856989112400

#+name: 20210601184856989112400
#+begin_src nix :tangle (aiern/tangle-path)
{
    description = "Wheee!";

    inputs = rec {
        <<20210601184858790744200>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, flake-compat, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let

        mkOverlay = import ./overlays;

        prepkgs = import nixpkgs {
            overlays = mkOverlay {};
            config = {
                system = currentSystem;
                <<20210601184936599601300>>
            };
        };

        sources = inputs // prepkgs.j.sources;
        inherit (sources) nix;
        lib = nixpkgs.lib.extend (final: prev: {
            j = import ./lib {
                inherit sources;
                pkgs = prepkgs;
                lib = final;
            };
            h = sources.hlissner.lib;
        });

        inherit (lib) j;
        inherit (lib.j) attrs;
        fas = j.forAllSystems;
        make = {
            overlay = mkOverlay;
            pkgs = { stc, ... }: import prepkgs.j.nixpkgset.${stc.channel} {
                overlays = j.get { inherit stc; set = all.overlays; };
                config =  j.get { inherit stc; set = all.config; };
            };
            specialArgs = { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ];};
                config =  j.get (configBase // { set = all.config; });
                overlays =  j.get (configBase // { set = all.overlays; });
            in stc // {
                inherit sources inputs make all stc overlays lib;
                config' = config;
                hostName =  j.get { inherit stc; set = all.hostName; };
                stdenv =  j.get (configBase // { set = all.stdenv; });
                nixpkgs =  j.get (configBase // { set = all.nixpkgs; });
                nixpkgset = {
                    inherit (stc) system;
                    inherit overlays config;
                };
            };
            modules = { stc, ... }: [
                (with stc; [
                    (./. + "/configs/${host}")
                    (if (type == "def") then {} else (./. + "/devices/${type}"))
                    (let path = ./. + "/platforms/${system}"; in
                        if (pathExists path) then path else {})
                ])
                (with sources; [
                    home-manager-flake.nixosModules.home-manager
                    agenix.nixosModules.age
                    impermanence-flake.nixosModules.impermanence
                ])
            ];
            nixosConfiguration = { stc, ... }: lib.nixosSystem {
                <<20210601184855143779200>>
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (j.imprelib.list { dir = ./modules; })
                    (make.modules { inherit stc; })
                ];
            };
            nixosModule = { stc, ... }: nmports@{ config, ... }: { imports = flatten [
                (make.modules nmports { inherit stc; })
            ];};
        };
        all' = {
            inherit sources make;
            type = attrs.types;
            device = attrs.devices;
            nixpkgs = prepkgs.j.nixpkgset;
            channel = prepkgs.j.channels;
            host = attrs.hosts;
            # system = allSystems;
            system = [ "aarch64-linux" "x86_64-linux" ];
            # system = defaultSystems;
        } // (genAttrs (attrNames attrs.integer-defaults) (attr: range 0 1));
        all = let
            sc = {
                all = all';
                inheritance.pkgs = import nixpkgs {};
            };
        in {
            config = fas (recursiveUpdate sc {
                func = j.config;
                inheritance.stdenvs = all.stdenv;
            });
            hostName = fas {
                all = all';
                func = j.hostName;
                attrList = attrs.stc ++ (toList "host");
            };
            overlays = fas {
                all = all';
                func = make.overlay;
            };
            pkgs = fas {
                all = all';
                func = make.pkgs;
            };
            stdenv = fas (recursiveUpdate sc { func = j.stdenv; });
            hmConfigs = fas {
                all = all';
                func = j.hostName;
                inherit (all.vars) extraListSets;
            };
            vars = {
                extraListSets = {
                    user = attrs.allUsers;
                } // (genAttrs attrs.home-manager-integer-defaults (attr: range 0 1));
            };
        } // all';

        overlays =  j.get { stc = attrs.default-stc; set = all.overlays; };

    in with lib; with j; {

        inherit overlays lib;

        legacyPackages = all;

        nixosConfigurations = (forAllSystems' { inherit all; func = make.nixosConfiguration; }) // {
            tiny = let
                stc = lib.j.attrs.default-stc // {
                    device = "";
                    host = "";
                    type = "";
                    zfs = null;
                };
            in if (with stc;
                device == "" || host == "" || type == "" || zfs == null
            ) then (
                abort "Sorry! The device, host, type, and zfs status must be set!"
            ) else lib.nixosSystem {
                <<20210601184855143779200>>
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (make.modules { inherit stc; })
                    ({ ... }: { imports = [
                        ./modules/networking.nix
                        ./modules/boot.nix
                        ./modules/etc.nix
                        ./modules/global.nix
                        ./modules/users.nix
                        ./modules/filesystems.nix
                        ./modules/nix.nix
                        ./modules/persistence.nix
                        ./modules/variables.nix
                        ./modules/zfs.nix
                    ];})
                ];
            };
        };

        # From: https://nixos.wiki/wiki/Flakes#Getting_Instant_System_Flakes_Repl
        nix.nixPath = let path = toString ./.; in [ "repl=${path}/repl.nix" "nixpkgs=${sources.nixpkgs}" ];

    } // (eachSystem all.system (system: {  }));

}
#+end_src

***** inputs

#+name: ff
#+begin_src emacs-lisp :var name="" :var ur=""
(format-spec "%n = {
    url = \"github:%u\";
    flake = false;
};" `((?n . ,name) (?u . ,ur)))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184858790744200

#+name: 20210601184858790744200
#+begin_src nix :exports none
<<20210601184900737083000>>
<<20210601184903047234700>>
<<20210601184907763806400>>
<<20210601184909601517300>>
<<20210601184911358827500>>
<<20210601184913280508200>>
<<20210601184933880458900>>
#+end_src

****** base

#+call: hash() :exports none

#+RESULTS:
: 20210601184900737083000

#+name: 20210601184900737083000
#+begin_src nix
home-manager-flake = {
    url = "github:nix-community/home-manager/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

impermanence-flake = {
    url = "github:nix-community/impermanence/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

agenix = {
    url = "github:ryantm/agenix/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

flake-utils = {
    url = "github:numtide/flake-utils/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

hlissner = {
    url = "github:hlissner/dotfiles/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

<<ff(name="flake-compat", ur="edolstra/flake-compat")>>

nixpkgs.url = "github:NixOS/nixpkgs/master";
#+end_src

****** tmux

#+call: hash() :exports none

#+RESULTS:
: 20210601184903047234700

#+name: 20210601184903047234700
#+begin_src nix
<<ff(name="aleclearmind", ur="aleclearmind/nested-tmux")>>
<<ff(name="oh-my-tmux", ur="gpakosz/.tmux")>>
<<ff(name="powerline", ur="powerline/powerline")>>
<<ff(name="tpm", ur="tmux-plugins/tpm")>>
#+end_src

****** editors

#+call: hash() :exports none

#+RESULTS:
: 20210601184907763806400

#+name: 20210601184907763806400
#+begin_src nix
<<ff(name="spacevim", ur="spacevim/spacevim")>>
#+end_src

****** shell

#+call: hash() :exports none

#+RESULTS:
: 20210601184909601517300

#+name: 20210601184909601517300
#+begin_src nix
<<ff(name="bashCompletions", ur="scop/bash-completion")>>
<<ff(name="grml", ur="grml/grml-etc-core")>>
#+end_src

****** terminal

#+call: hash() :exports none

#+RESULTS:
: 20210601184911358827500

#+name: 20210601184911358827500
#+begin_src nix
<<ff(name="kittyThemes", ur="dexpota/kitty-themes")>>
<<ff(name="xeroFigletFonts", ur="xero/figlet-fonts")>>
#+end_src

****** nixos

#+call: hash() :exports none

#+RESULTS:
: 20210601184913280508200

#+name: 20210601184913280508200
#+begin_src nix
<<ff(name="extraContainer", ur="erikarvstedt/extra-container")>>
<<ff(name="nixos-surface", ur="anthe/nixos-surface")>>
#+end_src

****** kernels

#+call: hash() :exports none

#+RESULTS:
: 20210601184933880458900

#+name: 20210601184933880458900
#+begin_src nix
xanmodV5104Cacule = {
    url = "github:xanmod/linux/5.10.4-xanmod1-cacule";
    flake = false;
};
xanmodV5914Cacule = {
    url = "github:xanmod/linux/5.9.14-xanmod1-cacule";
    flake = false;
};
#+end_src

**** lib

#+call: hash() :exports none

#+RESULTS:
: 20210601184936599601300

#+name: 20210601184936599601300
#+begin_src nix
allowUnfree = true;
allowBroken = true;
allowUnsupportedSystem = true;
# preBuild = ''
#     makeFlagsArray+=(CFLAGS="-w")
#     buildFlagsArray+=(CC=cc)
# '';
permittedInsecurePackages = [
    "python2.7-cryptography-2.9.2"
];
#+end_src

***** default.nix

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601184940615217500

#+name: 20210601184940615217500
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{
    sources ? ({
        nixpkgs = <nixpkgs>;
    }),
    pkgs ? (import sources.nixpkgs {}),
    lib ? pkgs.lib,
    preattrs ? (import ./_preattrs.nix lib),
    prelib ? (import ./_prelib.nix preattrs lib),
    primprelib ? (import ./_primprelib.nix preattrs prelib lib),
    ...
}: with builtins; with lib; let
    explicitInputs = { inherit
        sources
        pkgs
        lib
        preattrs
        prelib
        primprelib;
    };
    templib = self: prelib
        // (with prelib; {
            attrs = preattrs // (import ./_attrs.nix explicitInputs);
            imprelib = primprelib // (import ./_imprelib.nix explicitInputs);
        })
        // (listToAttrs (map (file: nameValuePair
            file
            (import (./. + "/${file}.nix") explicitInputs)
        ) (primprelib.listNames { dir = ./.; })));

    __ = makeExtensible templib;
in __.extend (final: prev: prelib.foldToSet (attrValues prev))
#+end_src

***** _preattrs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184942521692400

#+name: 20210601184942521692400
#+begin_src nix :tangle (aiern/tangle-path)
lib: with builtins; with lib; rec {
    integer-defaults = {
        minimal = 0;
        musl = 1;
        noSwap = 0;
        terminal = 0;
        zfs = 1;
    };
    default-stc = integer-defaults // {
        system = currentSystem;
        type = "def";
        device = "def";
        channel = "pkgs";
    };
    stc = attrNames default-stc;
    home-manager-integer-defaults = { nixos = 1; };
    home-manager-default-stc = default-stc
        // home-manager-integer-defaults
        // { user = "root"; };
    home-manager-stc = attrNames home-manager-default-stc;
}
#+end_src

***** _prelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184944473723100

#+name: 20210601184944473723100
#+begin_src nix :tangle (aiern/tangle-path)
preattrs: lib:
with builtins;
with preattrs;
with lib;
rec {

    get = {
        stc ? preattrs.default-stc,
        set,
        ignoredAttrs ? []
    } : getAttrFromPath (
        map toString (attrValues (removeAttrs stc ignoredAttrs))
    ) set;

    hostName = { stc, ... }: substring 0 61 (hashString "sha512" (concatStrings (
        map toString (attrValues stc)
    )));

    forAllSystems' = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n (flatten [
            attrList
            [ "host" ]
        ])) all) // extraListSets;
        product = cartesianProductOfSets all';
    in listToAttrs (map (
        stc: nameValuePair (hostName { inherit stc; }) (func ({ inherit stc; } // inheritance))
    ) product);

    forAllSystems = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n attrList) all) // extraListSets;
        product = cartesianProductOfSets all';
    in foldToSet (map (
        # !!! There is no need to alphabetically sort the output of attrValues! !!!
        stc: setAttrByPath
            (map toString (attrValues stc))
            (func ({ inherit stc; } // inheritance))
    ) product);

    # TODO: Why is the filter necessary?
    foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);

    myIf = {
        list = condition: value: optionals condition value;
        singleton = condition: value: optional condition value;
        set = condition: value: if condition then value else {};
        num = condition: value: if condition then value else 0;
        knull = condition: value: if condition then value else null;
        empty = condition: value: if condition then value else "";
        drv = condition: evalue: value: if condition then value else evalue;
    };

    zipToSet = names: values: listToAttrs (
        map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
            if hasAttrs then names else (sort lessThan names)
        ) (
            if hasAttrs then values else (sort lessThan values)
        ))
    );

    stdenv = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        ...
    }: with stc; let
        musl = stc.musl == 1;
        arm = {
            systems = [
                "armv7a-linux"
                "armv7l-linux"
                "armv6a-linux"
                "armv6l-linux"
                "aarch64-linux"
            ];
            enable = elem system arm.systems;
            stdenv = {
                package = pkgs.clang10.stdenv;
                targetPlatform = if "armv7l-linux" then systems.examples.armv7l-hf-multiplatform
                    else systems.examples.aarch64-multiplatform;
            };
        };
        musl' = {
            enable = musl && (elem system ([
                "x86_64-linux"
            ] ++ arm.systems));
            stdenv = {
                package = pkgs.musl.stdenv;
                targetPlatform = systems.examples.musl64;
            };
        };
    in foldToSet [
        {
            inherit system;
            hostPlatform = currentSystem;
            buidPlatform = currentSystem;
        }
        (with arm; myIf.set enable stdenv)
        (with musl'; myIf.set enable stdenv)
    ];

    config = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        buildEnvOvr ? true,
        stdenvs ? {},
        stdenv ? (attrByPath (attrValues stc) (stdenv { inherit pkgs stc; }) stdenvs),
        ...
    } : with stc; {
        inherit system;
        <<20210601184936599601300>>
        ${if buildEnvOvr then null else "buildEnv"} = {
            override = { inherit stdenv; };
        };
    };

    toCapital = string: concatImapStrings (
        i: v: if (i == 0) then (toUpper v) else v
    ) (stringToCharacters string);

    generatePersistentFD = filtered: persistentDirectory: let
        _ = type: filter (n: !elem n filtered) (
            mapAttrsToList (n: v: removePrefix persistentDirectory n)
        (filterAttrs (n: v: v == type) (readDir persistentDirectory)));
    in { directories = _ "directories"; files = _ "regular"; };

    sequence = list: end: foldr (a: b: deepSeq a b) end list;
}
#+end_src

***** _primprelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184946256510900

#+name: 20210601184946256510900
#+begin_src nix :tangle (aiern/tangle-path)
preattrs: prelib: lib:
with builtins;
with preattrs;
with prelib;
with lib;
rec {
    args = {
        suffix = "";
        ignores = [];
    };

    name = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        file
    }: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

    # !!! This returns a function
    filterFunc = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        ignores ? args.ignores,
        dir,
    }: let
        _ignores = flatten [
            ignores
            (let
                _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
            in if (pathExists _ignores') then (import _ignores') else [])
            [ "default" "deprecated" ]
        ];
    in file: value:
        (if noSuffix then (
            (hasSuffix ".nix" file) || (value == "directory")
        ) else (hasSuffix suffix file)) &&
        (!hasPrefix "_" file) &&
        (!elem (name { inherit suffix file noSuffix; }) _ignores);

    contents = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
    }: filterAttrs (filterFunc _args) (readDir dir);

    list = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/${n}"),

    }: let
        __args = removeAttrs _args [ "func" ];
    in mapAttrsToList func (contents __args);

    listNames = {
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir
    }: list {
        inherit suffix ignores dir;
        func = (n: v: name { inherit suffix; file = n; });
    };
}
#+end_src

***** _attrs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184948158342800

#+name: 20210601184948158342800
#+begin_src conf
keep-derivations = true
keep-outputs = true
experimental-features = nix-command flakes
allow-unsafe-native-code-during-evaluation = true
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601184949937949100

#+name: 20210601184949937949100
#+begin_src nix :tangle (aiern/tangle-path)
{ lib, prelib, preattrs, primprelib, ... }:
with builtins;
with prelib;
with preattrs;
with primprelib;
with lib;
rec {
    persistent = {
        files = {
            system = flatten [[ "/etc/host" ]];
            home = flatten [[
                ".emacs-profile"
                ".gitignore"
                ".nix-channels"
                ".python-history"
                ".viminfo"
                ".zsh-history"
                "README.org"
                "LICENSE"
            ]];
            cache = flatten [[  ]];
        };
        directories = {
            system = flatten [[
                "/etc/containers"
                "/etc/NetworkManager/system-connections"
                "/etc/nix"
                "/etc/nixos"
                "/etc/nixos/config"
                "/etc/ssh"
                "/etc/wireguard"
                "/var/lib/acme"
                "/var/lib/bluetooth"
            ]];
            home = flatten [[
                ".atom"
                ".bash-history"
                ".byobu"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                "Documents"
                "Downloads"
                "etc"
                "inca"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "Videos"
                users.primary
            ]];
            cache = flatten [(map (dir: ".cache/${dir}") [
                "flatpak"
                "gnome-software"
                "google-chrome-beta"
                "google-chrome-dev"
                "google-chrome"
                "Homebrew"
                "keybase"
                "mozilla"
                "nix"
                "pip"
                "pypoetry"
                "qtile"
                "starship"
                "vivaldi"
            ])];
        };
    };

    persistence = {
        system = extraFD: let persistent-directory = "/persist"; in {
            "${persistent-directory}" = mkMerge [
                ({
                    directories = persistent.directories.system;
                    files = persistent.files.system;
                })
                (generatePersistentFD [ "home" "cache" ] persistent-directory)
                extraFD
            ];
        };
        home = { user ? "root", extraCache ? {}, extraFD ? {}}: let
            phu = "/persist/home/${user}";
        in mapAttrs (n: v: v // { allowOther = true; }) {
            "/persist/cache/${user}" = foldToSet [
                ({
                    directories = persistent.directories.cache;
                    files = persistent.files.cache;
                })
                extraCache
            ];
            "${phu}" = foldToSet [
                ({
                    directories = persistent.directories.home;
                    files = persistent.files.home;
                })
                (generatePersistentFD [""] phu)
                extraFD
            ];
        };
    };

    link = root: source: listToAttrs (map (
        fd: nameValuePair "${root}/${fd}" {
            source = "${source}/${fd}";
            recursive = true;
        }
    ) (attrNames (readDir source)));

    # Device Types
    types = flatten [
        (listNames { dir = ../devices; })
        [ "def" ]
    ];

    devices = [
        "4b"
        "3b"
        "pro"
        "b2"
        "def"
    ];

    hosts = listNames { dir = ../configs; };

    # hosts = listToAttrs (flatten [
    #     (map (host: nameValuePair host {}) [
    #         # "bastion"
    #         "chimchar"
    #         # "fell"
    #         # "flipper"
    #         # "infernape"
    #         # "monferno"
    #         # "murasame"
    #         # "p20"
    #         # "p5"
    #         # "piplup"
    #         # "sandshrew"
    #         "sandslash"
    #         # "siluam"
    #         # "silvester"
    #     ])
    # ]);

    configs = rec {
        prenix = ''
            <<20210601184948158342800>>
        '';
        nix = let
            MG = size: let
                mg = stringToCharacters size;
            in toString ((toInt (elemAt mg 0)) * (
                if (elemAt mg 1 == "M") then 1 else 1024
            ) * 1024 * 1024);
        in prenix + ''
            min-free = ${MG "250M"}
            max-free = ${MG "1G"}
        '';
    };
    services = {
        base = {
            enable = true;
            serviceConfig = {
                Restart = "on-failure";
                User = "<<username>>";
            };
            wantedBy = [ "multi-user.target" ];
        };
        mkdir = path: "mkdir -p /persist/${path} &> /dev/null";
    };
    users = fromJSON (readFile ../resources/users.json);
    excludedUsers = [ "root" ];
    mainUsers = attrValues users;
    allUsers = mainUsers ++ excludedUsers;
    homes = listToAttrs (map (
        user: nameValuePair user "/home/${user}"
    ) mainUsers);
    allHomes = homes // { root = "/root"; };
    commands = {
        rebuild = "nixos-rebuild --impure";
        install = "nixos-install --impure --show-trace";
    };
    fileSystems = {
        base = {
            fsType = "zfs";
            options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
        };
        supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
    };
    versions = {
        python = "39";
        emacs = "26";
    };
    ssh.keys = {
        master = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    };
    platforms = {
        arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
        imd = [ "i686-linux" "x86_64-linux" ];
    };
}
#+end_src

***** paths.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184952773228000

#+name: 20210601184952773228000
#+begin_src nix :tangle (aiern/tangle-path)
{ sources, ... }: with builtins; rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches = {
        _  = "${nixos}/patches";
        surface = "${sources.nixos-surface}/linux-surface/patches";
    };
}
#+end_src

***** _imprelib.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184956312357000

#+name: 20210601184956312357000
#+begin_src nix :tangle (aiern/tangle-path)
{ lib, primprelib, ... }:
with builtins;
with primprelib;
with lib;
rec {
    set = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
        modules ? {},

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/" + n),

    }: let
        files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
    in zipToSet
        (map (file: name { inherit suffix file; }) files)
        (map (file: import file (foldToSet [ modules inputs ])) files);
}
#+end_src

**** modules
***** guix.nix

From: https://github.com/pukkamustard/nixpkgs/blob/guix/nixos/modules/services/development/guix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601184958501115000

#+name: 20210601184958501115000
#+begin_src nix :tangle (aiern/tangle-path)
{config, pkgs, lib, ...}:

with lib;

let

  cfg = config.services.guix;

  buildGuixUser = i:
    {
      "guixbuilder${builtins.toString i}" = {
        group = "guixbuild";
        extraGroups = ["guixbuild"];
        home = "/var/empty";
        shell = pkgs.nologin;
        description = "Guix build user ${builtins.toString i}";
        isSystemUser = true;
      };
    };

in {

  options.services.guix = {
    enable = mkEnableOption "GNU Guix package manager";
    package = mkOption {
      type = types.package;
      default = pkgs.guix;
      defaultText = "pkgs.guix";
      description = "Package that contains the guix binary and initial store.";
    };
  };

  config = mkIf (cfg.enable) {

    users = {
      extraUsers = lib.fold (a: b: a // b) {} (builtins.map buildGuixUser (lib.range 1 10));
      extraGroups.guixbuild = {name = "guixbuild";};
    };

    systemd.services.guix-daemon = {
      enable = true;
      description = "Build daemon for GNU Guix";
      serviceConfig = {
        ExecStart="/var/guix/profiles/per-user/root/current-guix/bin/guix-daemon --build-users-group=guixbuild";
        Environment="GUIX_LOCPATH=/var/guix/profiles/per-user/root/guix-profile/lib/locale";
        RemainAfterExit="yes";

        # See <https://lists.gnu.org/archive/html/guix-devel/2016-04/msg00608.html>.
        # Some package builds (for example, go@1.8.1) may require even more than
        # 1024 tasks.
        TasksMax="8192";
      };
      wantedBy = [ "multi-user.target" ];
    };

    system.activationScripts.guix = ''

      # copy initial /gnu/store
      if [ ! -d /gnu/store ]
      then
        mkdir -p /gnu
        cp -ra ${cfg.package.store}/gnu/store /gnu/
      fi

      # copy initial /var/guix content
      if [ ! -d /var/guix ]
      then
        mkdir -p /var
        cp -ra ${cfg.package.var}/var/guix /var/
      fi

      # root profile
      if [ ! -d ~root/.config/guix ]
      then
        mkdir -p ~root/.config/guix
        ln -sf /var/guix/profiles/per-user/root/current-guix \
          ~root/.config/guix/current
      fi

      # authorize substitutes
      GUIX_PROFILE="`echo ~root`/.config/guix/current"; source $GUIX_PROFILE/etc/profile
      guix archive --authorize < ~root/.config/guix/current/share/guix/ci.guix.info.pub
    '';

    environment.shellInit = ''
      # Make the Guix command available to users
      export PATH="/var/guix/profiles/per-user/root/current-guix/bin:$PATH"

      export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"
      export PATH="$HOME/.guix-profile/bin:$PATH"
      export INFOPATH="$HOME/.guix-profile/share/info:$INFOPATH"
    '';
  };

}
#+end_src

***** bcachefs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185001135617000

# TODO: Does not work on aarch64-linux yet

#+name: 20210601185001135617000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, pkgs, lib, system, ... }: with builtins; with lib; with j; let b = "bcachefs"; in mkIf (
    !elem system [ "aarch64-linux" ]
) {
    boot = {
        kernelPackages = mkForce pkgs."linuxPackages_testing_${b}";
        kernelModules = [ b ];
        initrd = {
            kernelModules = [ b ];
            availableKernelModules = [ b ];
        };
        supportedFilesystems = [ "bcachefs" ];
    };
}
#+end_src

***** boot.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185002667222800

#+name: 20210601185002667222800
#+begin_src nix
loader = {
    systemd-boot = {
        enable = mkForce config.vars.bootPart;
        configurationLimit = 25;
        editor = false;
    };
    grub = {
        enable = mkForce false;
        efiSupport = true;
        devices = [ "nodev" ];
        version = 2;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';

    };
    efi = {
        canTouchEfiVariables = mkForce true;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    initScript.enable = mkForce true;
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185004200076000

#+name: 20210601185004200076000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, host, ... }: with builtins; with lib; with j; {
    boot = let
        p = attrs.users.primary;
        pHome = config.users.users.${p}.home;
    in mkMerge [{
            <<20210601185002667222800>>
            supportedFilesystems = attrs.fileSystems.supported;
            initrd = {
                inherit (config.boot) supportedFilesystems;
                compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
            };
            postBootCommands = let
                chowned = concatStringsSep "\n" (
                    map (user:
                        "sudo -u ${user} chown -R ${user}:${user} /persist/${attrs.allHomes.${user}} /persist/cache/${user}")
                    attrs.allUsers);
            in mkAfter (''
                mkdir -p /mnt
                sudo -u ${p} chown -R ${p}:${p} /${host}
            '' + chowned);
        }
        (mkIf (!config.vars.minimal) {
            extraModprobeConfig = '' options kvm_intel_nested=1 '';
        })
    ];
}
#+end_src

***** console.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185005838819700

#+name: 20210601185005838819700
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    console = {
        # Select internationalisation properties.
        # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
        font = "Cartograph CF Light Italic";
        keyMap = "us";
    };
}
#+end_src

***** etc.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185007760601200

#+name: 20210601185007760601200
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; {
    environment.etc = let
        kata-containers = {
            default-runtime = "kata-runtime";
            # runtimes.kata-runtime.path = "${getBin pkgs.kata-containers}/bin/kata-runtime";
            runtimes.kata-runtime.path = "${getBin pkgs.kata-containers.runtime}/bin/kata-runtime";
        };
        kc = toJSON kata-containers;
    in {
        "nix/nix.conf".text = attrs.configs.nix;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/storage.conf"}.text = kc + ''
            [storage]
            driver = "zfs"
            rootless_storage_path = "/var/lib/podman/$USER"

            [storage.options]
            additionalimagestores = [
                "/var/lib/docker",
            ]

            # [storage.options.zfs]
        '';
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/libpod.conf"}.text = kc;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "docker/daemon.json"}.text = kc;
    };
}
#+end_src

***** filesystems.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185009548172600

#+name: 20210601185009548172600
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, stc, ... }: with builtins; with lib; with j; mkIf (config.vars.zfs) { fileSystems = let
    inherit (attrs.fileSystems) base;
    fileSystems' = import ../config/_datasets.nix stc.host;
in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
    mkForce (base // { device = dataset; ${
        myIf.knull (hasInfix "persist" dataset) "neededForBoot"
    } = true; })
)) fileSystems'; }
#+end_src

***** global.nix

#+begin_src text
Help is available in the configuration.nix(5) man page
and in the NixOS manual (accessible by running ‘nixos-help’).
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185011702577000

#+name: 20210601185011702577000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, nixpkgset, system, ... }: with builtins; with lib; with j; {
    nixpkgs = nixpkgset;
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. It‘s perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
        };
    };
    boot.binfmt.emulatedSystems = [
        "armv7l-linux"
        "aarch64-linux"
    ];

    # Flatpak
    xdg.portal.enable = !elem system [ "aarch64-linux" ];

    environment.pathsToLink = [ "/share/nix-direnv" ];
    zramSwap = {
        enable = true;
        algorithm = "zstd";
    };
}
#+end_src

***** hardware.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185027009881400

#+name: 20210601185027009881400
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    hardware = {
        enableRedistributableFirmware = lib.mkDefault true;
        # Enable sound
        pulseaudio.enable = true;
    };
    sound.enable = true;
}
#+end_src

***** home.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185029141785800

#+name: 20210601185029141785800
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    # home-manager.users = let
    #     stc = {}
    #     inherit (config.vars) nixos zfs;
    # in listToAttrs (map (user: nameValuePair user (import /root/.config/nixpkgs/home.nix nixos zfs stc)) attrs.allUsers);
}
#+end_src

***** kernel.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185030781221800

#+name: 20210601185030781221800
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # kernelPackages = pkgs.linuxPackages_latest_xen_dom0_hardened;
        # kernelPackages = pkgs."linuxPackages_xanmod_v5.10.4_cacule";
        kernelPackages = pkgs.linuxPackages_lqx;
        # kernelPackages = pkgs.linuxPackages_zen;
        kernelPatches = [
            # { name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
            {
                name = "Enable ZSTD Compression";
                patch = null;
                extraConfig = ''
                    RD_ZSTD y
                    KERNEL_ZSTD y
                    KERNEL_XZ n
                '';
            }
        ];
        # extraModulePackages = with config.boot.kernelPackages; [ anbox wireguard ];
    };
}
#+end_src

***** memory.nix

Set the =SWAP= device if:

1. The configuration is not minimal, or
2. the =noSwap= variable is set to false.

I am currently not using =SWAP= on =ZFS Zvols= due to the issues detailed
[[https://github.com/openzfs/zfs/issues/7734][here]].

#+call: hash() :exports none

#+RESULTS:
: 20210601185032403282100

#+name: 20210601185032403282100
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; mkIf (
    config.vars.minimal -> config.vars.noSwap
) { swapDevices = [{ device = "/dev/zvol/${host}/swap"; }]; }
#+end_src

***** networking.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185033854488300

#+name: 20210601185033854488300
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, hostName, ... }: with builtins; with lib; with j; {
    networking = let
        primus = "58a4bafc38c2cc6e91ba27c7f1ca910c8fba857ee02f03648450b963db2519fc";
    in {
        inherit hostName;
        wireless = {
            # enable = true; # Enables wireless support via wpa_supplicant.
            enable = false; # Enables wireless support via wpa_supplicant.
            networks = {
                "Primus-17FE-2.4" = {
                    pskRaw = primus;
                    priority = 0;
                };
                "Primus-17FE" = {
                    pskRaw = primus;
                    priority = 1;
                };
            };
        };
        networkmanager.enable = mkForce true;

        # The global useDHCP flag is deprecated, therefore explicitly set to false here.
        # Per-interface useDHCP will be mandatory in the future, so this generated config
        # replicates the default behaviour.
        useDHCP = false;

        # Configure network proxy if necessary
        # proxy = {
        # default = "http://user:password@proxy:port/";
        # noProxy = "127.0.0.1,localhost,internal.domain";
        # };

        # Open ports in the firewall.
        # firewall = {
        # allowedTCPPorts = [ ... ];
        # allowedUDPPorts = [ ... ];

        # Or disable the firewall altogether.
        # enable = false;
        # };

        # wireguard.interfaces.wg0 = {
        #   generatePrivateKeyFile = true;
        #   privateKeyFile = "/persist/etc/wireguard/wg0";
        # };
    };
}
#+end_src

***** nix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185035246626000

#+name: 20210601185035246626000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = rec {
        gc = foldToSet [
            { automatic = true; }
            { dates = "monthly"; }
            # {
            #   dates = "monthly";
            #   options = "-d";
            # }
            # {
            #   dates = "daily";
            #   options = "--delete-older-than 30d";
            # }
        ];
        optimise = {
            automatic = true;
            dates = [ "05:00" ];
        };
        autoOptimiseStore = true;
        extraOptions = attrs.configs.nix;
        useSandbox = true;
        binaryCaches = flatten [
            (map (dir: "file:///${dir}/") [
                "chimchar"
                "empoleon"
            ])
        ];
        # sandboxPaths = [];
    };
}
#+end_src

***** packages.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185037079389900

#+name: 20210601185037079389900
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, pkgs, sources, lib, ... } : { environment.systemPackages = import ../packages.nix inputs; }
#+end_src

***** persistence.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185038697262200

#+name: 20210601185038697262200
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    environment.${myIf.knull config.vars.zfs "persistence"} = attrs.persistence.system {};
}
#+end_src

***** power.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185040292063500

#+name: 20210601185040292063500
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    services.logind.lidSwitch = "hybrid-sleep";
    powerManagement = {
        enable = true;
        cpuFreqGovernor = mkForce "ondemand";
    };
}
#+end_src

***** security.nix

This is mostly for Yubikey Authentication:

#+call: hash() :exports none

#+RESULTS:
: 20210601185041882938600

#+name: 20210601185041882938600
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

***** services.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185043527440500

#+name: 20210601185043527440500
#+begin_src nix
${myIf.knull config.vars.zfs "sanoid"} = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) [
        host
        "system/persist"
        "virt"
        "omniverse"
    ]);
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185045150190700

#+name: 20210601185045150190700
#+begin_src nix
${myIf.knull config.vars.zfs "syncoid"} = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        (mkIf vars.encrypted {
            sendOptions = "vvwRI";
            recvOptions = "vvFs";
        })
        (mkIf (!vars.encrypted) {
            recvOptions = "vvFds";
            sendOptions = "vvRI";
        })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) [
        host
        "virt"
        "system/persist"
        "omniverse"
    ]);
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185046664836000

#+name: 20210601185046664836000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, host, system, ... }: with builtins; with lib; with j; {
    services = {
        <<20210601185043527440500>>

        <<20210601185045150190700>>

        wakeonlan.interfaces = map (interface:
            { inherit interface; method = "magicpacket"; }
        ) (attrNames config.networking.interfaces);

        flatpak.enable = !elem system [ "aarch64-linux" ];

        # For Yubikey
        udev.packages = with pkgs; [
            yubikey-personalization
            libu2f-host
        ];
        pcscd.enable = true;

        openssh = {
            enable = true;
            extraConfig = mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
            '';
            permitRootLogin = "yes";
        };

        # Keybase
        kbfs.enable = true;
        keybase.enable = true;

        # Enable CUPS to print documents.
        printing.enable = true;

        # Enable the X11 windowing system.
        xserver = {
            enable = true;
            layout = "us";
            # xkbOptions = "eurosign:e";
            # Enable touchpad support.
            libinput = {
            enable = true;
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
            };
            # synaptics.enable = true;
            desktopManager = { xterm.enable = false; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+qtile"; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { startx.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { qtile.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+exwm"; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { exwm.enable = true; };
            # displayManager = { defaultSession = "none+qtile"; };
            displayManager = { startx.enable = true; };
            windowManager = { qtile.enable = true; };
            # displayManager = { defaultSession = "none+exwm"; };
            # windowManager = { exwm.enable = true; };
            # desktopManager.gnome3.enable = true;
            # desktopManager.gnome3.enable = true;
            # displayManager.gdm.enable = true;
        };

        ${myIf.knull config.vars.zfs "zfs"} = {
            autoScrub.enable = true;

            # Managed by Sanoid
            autoSnapshot.enable = false;
        };
    };
}
#+end_src

***** shell.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185048305544300

#+name: 20210601185048305544300
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, system, ... }: with builtins; with lib; with j; {
    programs = {
        xonsh.enable = true;
        fish = mkIf (!elem system [ "aarch64-linux" ]) {
            enable = true;
        };
        zsh.enable = true;
    };
}
#+end_src

***** _specialisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185055287903500

#+name: 20210601185055287903500
#+begin_src nix
rec {
    patches = {
        dir = rec {
            base = lib.j.paths.patches;
            "57" = "${base.surface}/5.7";
            "58" = "${base.surface}/5.8";
        };
        get = dir: with r; list {
            suffix = ".patch";
            dir = (/. + d);
            func = (file: v: { patch = file; name = name { inherit suffix file; }; });
        };
    };
    base = {
        settings = { inheritParentConfig = true; };
        kernel.extraConfig = ''
            SERIAL_DEV_BUS y
            SERIAL_DEV_CTRL_TTYPORT y
            SURFACE_SAM m
            SURFACE_SAM_SSH m
            SURFACE_SAM_SAN m
            SURFACE_SAM_DTX m
            INPUT_SOC_BUTTON_ARRAY m
            SURFACE_3_POWER_OPREGION m
            SURFACE_3_BUTTON m
            SURFACE_3_POWER_OPREGION m
            SURFACE_PRO3_BUTTON m
        '';
        patches = [
            { patch = /. + "${patches.dir.base._}/export_kernel_fpu_functions_5_3.patch"; name = "export_kernel_fpu_functions_5_3"; }
            { patch = /. + "${patches.dir.base._}/set_power_mgmt.patch"; name = "set_power_mgmt"; }
        ];
        iabg = [{ patch = /. + "${patches.dir.base._}/0110-initialize-ata-before-graphics.patch"; name = "0110-initialize-ata-before-graphics"; }];
    };
}
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185057188906700

#+name: 20210601185057188906700
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<20210601185055287903500>>;
        inherit (lib.j.paths.patches) _;
        base = {
            specialisation = { inheritParentConfig = true; };
            kernel = {
                kernelPatches = specialisation_base.base.iabg;
            };
        };
    in {
        clear = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest; };
                };
            };
        };
        zen = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_zen; };
                };
            };
        };
        bcachefs = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
        clear_xen = base.specialisation // {
            inheritParentConfig = true;
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest_xen_dom0; };
                };
            };
        };
    };
}
#+end_src

***** systemd.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185059100247400

#+name: 20210601185059100247400
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    systemd = {
        packages = with pkgs; [ runit ly ];
        services = {
            runit.enable = true;
            ly.enable = true;
        };
    };
}
#+end_src

***** users.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185100896555400

#+name: 20210601185100896555400
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, lib, pkgs, sources, stc, system, ... }: with builtins; with lib; with j; {
    users = with attrs.users; let
        base = mkMerge [{
                hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
                isNormalUser = true;
                createHome = true;
                extraGroups = [
                    "wheel"
                    "networkmanager"
                    "persist"
                ];
                openssh.authorizedKeys.keys = [
                    attrs.ssh.keys.master
                ];
                packages = import (
                    if (pathExists ../packages.nix) then ../packages.nix else ./packages.nix
                ) inputs;
            }
            (mkIf (!config.vars.minimal) {
                extraGroups = [ "libvirtd" "docker" ];
            })
        ];
    in rec {
        users = mkMerge [
            (genAttrs attrs.allUsers (user: base))
            {
                "${primary}" = {
                    uid = 4362;
                    home = attrs.allHomes.${primary};
                    description = "Jeet Ray";
                    group = primary;
                    extraGroups = [ secondary ];
                    shell = pkgs.xonsh;
                };
                "${secondary}" = {
                    uid = 1111;
                    home = attrs.allHomes.${secondary};
                    description = "Alicia Summers";
                    group = secondary;
                    extraGroups = [ primary ];
                    shell = if (!elem system [ "aarch64-linux" ]) then pkgs.fish else pkgs.zsh;
                };
                "${nightingale}" = {
                    uid = 8888;
                    home = attrs.allHomes.${nightingale};
                    description = "Curtis Nightingale";
                    group = "root";
                    extraGroups = [ primary secondary ];
                    shell = pkgs.zsh;
                };
                root = {
                    shell = mkForce pkgs.xonsh;
                    home = attrs.allHomes.root;
                    isNormalUser = mkForce false;
                    isSystemUser = mkForce true;
                };
            }
        ];

        mutableUsers = false;

        groups = {
            "${primary}" = {
                gid = config.users.users.${primary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${secondary}" = {
                gid = config.users.users.${secondary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${nightingale}" = {
                gid = config.users.users.${nightingale}.uid;
                members = [ nightingale ];
            };
        };
    };
}
#+end_src

***** variables.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185102627466300

#+name: 20210601185102627466300
#+begin_src nix
options = {
    vars = mkOption {
        default = mkDefault {  };
        type = with lib.types; attrsOf bool;
    };
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185104370957400

#+name: 20210601185104370957400
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, stc, ... }: with builtins; with lib; with j; {
    <<20210601185102627466300>>
    config.vars = {
        bootPart = mkDefault true;
        syncDevice = mkDefault false;
    } // (mapAttrs (
        n: v: mkDefault (if (isInt v) then (v == 1) else v)
    ) (default-stc // stc));
}
#+end_src

***** virtualisation.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185106194079000

#+name: 20210601185106194079000
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; mkIf (
    !(config.vars.minimal || elem system [ "aarch64-linux" ])
) {
    virtualisation = {
        xen.enable = false;
        lxd = { zfsSupport = true; };
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

***** zfs.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185108071879200

#+name: 20210601185108071879200
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; {
    boot = {
        kernelModules = [ "zfs" ];
        # loader.grub.zfsSupport = true;
        initrd = {
            postDeviceCommands = myIf.empty config.vars.zfs (mkAfter ''
                zfs rollback -r ${host}/system/root@blank
                zfs rollback -r ${host}/system/home@blank
            '');
            kernelModules = [ "zfs" ];
            availableKernelModules = [ "zfs" ];
        };
        zfs = {
            requestEncryptionCredentials = true;
            enableUnstable = true;
        };
        extraModulePackages = with config.boot.kernelPackages; [ zfsUnstable ];
    };
    # networking.hostId = substring 0 8 (readFile "/etc/machine-id");
}
#+end_src


**** overlays
***** base

#+call: hash() :exports none

#+RESULTS:
: 20210601185110013135100

#+name: 20210601185110013135100
#+begin_src nix
let
    sc = { inherit pkgs stc; };
    stdenv = j.stdenv sc;
    config = j.config (sc // { inherit stdenv; });
in flatten [
    [(final: prev: { j = rec {
        inherit config stdenv sources;
        inherit (sources) nixpkgs;
        nixpkgset = 
            let
                withNPrefix = filterAttrs (
                    n: v: (hasPrefix nprefix n) || (n == nprefix)
                ) sources;
                withoutNPrefix = mapAttrs' (name: v: nameValuePair (
                    if (name == nprefix) then prefix else (
                        replaceStrings ["${nprefix}-"] [""] name
                    )
                ) v) withNPrefix;
            in removeAttrs withoutNPrefix (flatten [
                # (filter (name: !elem name [
                #     "pkgs"
                #     "unstable"
                # ]) (attrNames withoutNPrefix))
                [  ]
            ]);
        pkgset = (
            mapAttrs (n: v: import v { inherit config; }) nixpkgset
        ) // { "${channel}" = final; };
        channels = attrNames nixpkgset;
    };})]
    # [(
    #     final: prev: {
    #         fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchurl.patch ];}); }
    # )]
    # [(
    #     final: prev: {
    #         fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchpypi.patch ];}); }
    # )]
    [
        (import sources.emacs)
        (final: prev: {
            nur = import sources.nur {
                nurpkgs = prev;
                pkgs = prev;
            };
        })
        (import ("${sources.wip-pinebook-pro}/overlay.nix"))
        # sources.emacs.overlay
        # sources.nur.overlay
    ]
    [
        # (final: prev: { nix = sources.nix.packages.${system}.nix; })
        (final: prev: { nix = (import sources.nix).packages.${system}.nix; })
        (final: prev: { niv = (import sources.niv {}).niv; })
        (final: prev: { emacs-nox = final.emacsGit-nox; })
    ]
    [
        (final: prev: {
            systemd = prev.systemd.overrideAttrs (old: { withHomed = true; });
        })
        (final: prev: {
            kata-containers = prev.kata-containers or (
                prev.callPackage ./_kataContainers.nix {}
            );
        })
    ]
    (
        let
            dir = sources.mozilla;
            mozilla = final: prev: listToAttrs (map (file: nameValuePair
                (removeSuffix "-overlay" file)
                (import "${dir}/${file}.nix" final prev)
            ) (filter (file: hasSuffix "-overlay" file) (j.imprelib.listNames { inherit dir; })));
        in [
            (final: prev: { firefox = final.mozilla.firefox.latest.firefox-bin; })
            (final: prev: { firefox-unbuilt = prev.firefox; })
            (final: prev: { mozilla = mozilla final prev; })
        ]
    )

    # TODO
    # (map (kernel': let
    #     kernel = "linuxPackages_${kernel'}";
    # in [( final: prev: { "${kernel}" = prev."${kernel}".extend (self:
    #     <<20210601185345398351400>>
    # );})]) [ "lqx" "testing_bcachefs" "zen" ])

    # TODO
    # (let base.mach-nix = {
    #     inherit pkgs sources lib;
    #     mach-nix = import sources.mach-nix { inherit pkgs; python = "python39"; };
    # }; in map (overlay: import overlay base.mach-nix) (j.imprelib.list { dir = ./_mach-nix; }))

    (flatten (map (file:
        [(final: prev: {
            "${j.imprelib.name { inherit file; }}" = import file {
                inherit sources pkgs lib;
            };
        })]
    ) (j.imprelib.list { dir = ./.; ignores = [ "nix" ]; })))

    # TODO
    # (
    #     <<20210601185346927223400>>
    # )
]
#+end_src

***** overrides

#+call: hash() :exports none

#+RESULTS:
: 20210601185111589161600

#+name: 20210601185111589161600
#+begin_src nix
let pkgsets' = { unstable = [ "git" "go" "webkitgtk" ]; };
in flatten (mapAttrsToList (
    channel': pkglist: map (
        pkg: [(final: prev: {
            "${pkg}" = if (channel' == channel) then prev.${pkg} else final.j.pkgset.${channel'}.${pkg};
        })]
    ) pkglist
) pkgsets')
#+end_src

***** _mach-nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185113382242300

#+name: 20210601185113382242300
#+begin_src nix
{
  sources ? (builtins.getFlake "${./.}/.."),
  pkgs ? (import sources.nixpkgs {}),
  mach-nix ? (import sources.mach-nix { inherit pkgs; python = "python39"; }),
  ...
}
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185114873837100

#+name: 20210601185114873837100
#+begin_src nix
packagesExtra = [
    # "https://github.com/psf/requests/tarball/v2.22.0"
    (mach-nix.buildPythonPackage { src = sources.nanite; })      
    "https://files.pythonhosted.org/packages/bc/ab/c49f97516f78c2b0cacb4f45873abc4ca9872942a9c4c19ded8052c8edda/python-wifi-0.6.1.tar.bz2"
];
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185116284142400

#+name: 20210601185116284142400
#+begin_src nix
providers._defaults = "conda-forge,conda,wheel,sdist,nixpkgs";
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185118202517300

#+name: 20210601185118202517300
#+begin_src emacs-lisp :var pkg="" :var version="" :var pythonPackages=""
(format-spec "
    newPkgs = machnixPy.nixpkgs;
    pythonPackages = newPkgs.python%v.pkgs;
    %p_py_%v = newPkgs.%p.override {
        %q = newPkgs.python%vPackages;
    };
    %p_with_pkgs = %p_py_%v.overrideAttrs (oa: {
        version = \"master\";
        src = sources.%p;
        inherit pythonPath;
    });
    finalOverlay = self: super: { %p = %p_with_pkgs; };
in finalOverlay" `((?p . ,pkg) (?q . ,pythonPackages) (?v . ,version)))
#+end_src

****** qtile.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185125138787100

#+name: 20210601185125138787100
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601185113382242300>>:

with builtins; let

    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<20210601185114873837100>>
        requirements = ''
        cairocffi
        iwlib
        '';
        _.iwlib.buildInputs.add = [ pkgs.wirelesstools ];
        <<20210601185116284142400>>
        providers.cairocffi = "wheel,sdist";
    };

    pythonPath =
        oa.pythonPath
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            # From https://github.com/NixOS/nixpkgs/issues/45038
            dateutil
            dbus-python
            keyring
            mpd2
            psutil
            pyxdg
            pygobject3
            nixpkgs
        ]);

<<20210601185118202517300(pkg="qtile", version="39", pythonPackages="python37Packages")>>
#+end_src

****** xonsh.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185127082738200

#+name: 20210601185127082738200
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601185113382242300>>:

with builtins; let
    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<20210601185114873837100>>
        requirements = ''
        # add requirements here
        # jedi
        borgmatic
        dephell
        ply
        prompt_toolkit
        pygments
        pipx
        yubico-client
        ansible

        # add xontribs here
        # xonsh-direnv
        # xonsh-docker-tabcomplete
        # xonsh-vox-tabcomplete
        # xontrib-prompt-bar
        # xontrib-ssh-agent
        xonsh-autoxsh
        xontrib-autojump
        xontrib-fzf-widgets
        xontrib-kitty
        xontrib-pipeliner
        xontrib-powerline2
        xontrib-prompt-vi-mode
        xontrib-readable-traceback
        xontrib-schedule
        xontrib-z
        '';
        <<20210601185116284142400>>
    };

    pythonPath =
        (oa.pythonPath or [])
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            ply
            prompt_toolkit
            pygments
            pipx
            yubico-client
            nixpkgs
        ]);

<<20210601185118202517300(pkg="xonsh", version="39", pythonPackages="python3Packages")>>
#+end_src

***** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185341615106400

#+name: 20210601185341615106400
#+begin_src nix :tangle (aiern/tangle-path)
with builtins; {
    stc ? ({ system = currentSystem; channel = "pkgs"; }),
    ...
} : with stc; let

    flake = getFlake (toString ./.);

    sources = flake.inputs;

    nprefix = "nixpkgs";
    prefix = "pkgs";
    inherit (sources) nixpkgs;
    pkgs = import nixpkgs {
        inherit (stc) system;
        config = {
            <<20210601184936599601300>>
        };
    };
    lib = nixpkgs.lib.extend (final: prev: {
        j = import ../lib {
            inherit sources pkgs;
            lib = final;
        };
    });
in with lib; flatten [
    (
        <<20210601185110013135100>>
    )
    (
        <<20210601185111589161600>>
    )
    (
        # Adapted From: https://github.com/NixOS/nixpkgs/issues/75669#issuecomment-579432702
        [( self: super: { guix = self.callPackage (
            <<20210601185343563328200>>
        ) {}; })]
    )
]
#+end_src

***** guix

From: https://github.com/pukkamustard/nixpkgs/blob/guix/pkgs/development/guix/guix.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185343563328200

#+name: 20210601185343563328200
#+begin_src nix
{stdenv, fetchurl}:
stdenv.mkDerivation rec
  { name = "guix-${version}";
    version = "1.0.0";

    src = fetchurl {
      url = "https://ftp.gnu.org/gnu/guix/guix-binary-${version}.${stdenv.targetPlatform.system}.tar.xz";
      sha256 = {
        "x86_64-linux" = "11y9nnicd3ah8dhi51mfrjmi8ahxgvx1mhpjvsvdzaz07iq56333";
        "i686-linux" = "14qkz12nsw0cm673jqx0q6ls4m2bsig022iqr0rblpfrgzx20f0i";
        "aarch64-linux" = "0qzlpvdkiwz4w08xvwlqdhz35mjfmf1v3q8mv7fy09bk0y3cwzqs";
        }."${stdenv.targetPlatform.system}";
    };
    sourceRoot = ".";

    outputs = [ "out" "store" "var" ];
    phases = [ "unpackPhase" "installPhase" ];

    installPhase = ''
      # copy the /gnu/store content
      mkdir -p $store
      cp -r gnu $store

      # copy /var content
      mkdir -p $var
      cp -r var $var

      # link guix binaries
      mkdir -p $out/bin
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix $out/bin/guix
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix-daemon $out/bin/guix-daemon
    '';

    meta = with stdenv.lib; {
      description = "The GNU Guix package manager";
      homepage = https://www.gnu.org/software/guix/;
      license = licenses.gpl3Plus;
      maintainers = [ maintainers.johnazoidberg ];
      platforms = [ "aarch64-linux" "i686-linux" "x86_64-linux" ];
    };

  }
#+end_src

***** kernels

This is the base extension, overriding the =nativeBuildInputs= attribute to include the =zstd= package, to facilitate =zstd=
compression for the kernel:

#+call: hash() :exports none

#+RESULTS:
: 20210601185345398351400

#+name: 20210601185345398351400
#+begin_src nix
const (super: { kernel = super.kernel.overrideDerivation (drv: {
    nativeBuildInputs = drv.nativeBuildInputs ++ [ pkgs.zstd ];
});})
#+end_src

****** xanmod cacule

Adapted from [[https://www.reddit.com/r/NixOS/comments/jtgi35/cant_build_custom_kernel/][here]]:

#+call: hash() :exports none

#+RESULTS:
: 20210601185346927223400

#+name: 20210601185346927223400
#+begin_src nix
map (ver: let
        inherit ver;
        _ = makeExtensible { "linuxPackages_xanmod_v${ver}_cacule" = prev.recurseIntoAttrs (
            prev.linuxPackagesFor (
                prev.callPackage (
                    args@{ fetchFromGitHub, buildLinux, ... }: buildLinux (args // rec {
                        version = "${ver}-xanmod1";
                        modDirVersion = version;
                        src = sources."xanmodV${replace ["."] [""] ver}Cacule" // { extraPostFetch = '' rm $out/.config ''; };
                        kernelPatches = [];
                        # postConfigure = '' make ARCH=x86_64 mrproper '';
                        extraConfig = ''
                        #     USER_NS_UNPRIVILEGED y
                        #     FUNCTION_TRACER n
                        #     GRAPH_TRACER n
                        #     NUMA n
                            RD_ZSTD y
                            KERNEL_ZSTD y
                            KERNEL_XZ n
                        '';
                        extraMeta.branch = "${ver}-xanmod1";
                    } // (args.argsOverride or {}))
                ) {}
            )
        );};
    in [( final: prev: { "linuxPackages_xanmod_v${ver}_cacule" = _.extend (self:
        <<20210601185345398351400>>
);})]) [ "5.9.14" "5.10.4" ]
#+end_src

***** flake.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185348536012000

#+name: 20210601185348536012000
#+begin_src nix :tangle (aiern/tangle-path)
{
    description = "Overlay Sources";

    inputs = {
        <<ff(name="flake-compat", ur="edolstra/flake-compat/master")>>
        <<ff(name="emacs", ur="nix-community/emacs-overlay/master")>>
        nur.url = "github:nix-community/nur/master";
        mach-nix.url = "github:davhau/mach-nix/master";
        <<ff(name="mozilla", ur="mozilla/nixpkgs-mozilla/master")>>
        nanite = {
            url = "git+https://gitlab.com/picotech/nanotech/nanite.git";
            flake = false;
        };
        <<ff(name="niv", ur="nmattia/niv/master")>>
        nix.url = "github:nixos/nix/master";
        <<ff(name="qtile", ur="qtile/qtile/master")>>
        <<ff(name="xonsh", ur="xonsh/xonsh/main")>>
        <<ff(name="wip-pinebook-pro", ur="shadowrylander/wip-pinebook-pro/master")>>
        nixpkgs.url = "github:nixos/nixpkgs/master";
        nixpkgs-20-03.url = "github:nixos/nixpkgs/nixos-20.03";
        nixpkgs-20-03-small.url = "github:nixos/nixpkgs/nixos-20.03-small";
        nixpkgs-20-09.url = "github:nixos/nixpkgs/nixos-20.09";
        nixpkgs-20-09-small.url = "github:nixos/nixpkgs/nixos-20.09-small";
        nixpkgs-21-05.url = "github:nixos/nixpkgs/nixos-21.05";
        nixpkgs-21-05-small.url = "github:nixos/nixpkgs/nixos-21.05-small";
        nixpkgs-unstable.url = "github:nixos/nixpkgs/nixos-unstable";
        nixpkgs-unstable-small.url = "github:nixos/nixpkgs/nixos-unstable-small";
        nixpkgs-master.url = "github:nixos/nixpkgs/master";
    };

    outputs = inputs@{ self, flake-compat, ... } : {  };
}
#+end_src

**** packages.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601195930734248900

#+name: 20210601195930734248900
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{
    pkgs,
    lib,
    sources,
    stc,
    config,
    ...
} : with lib; with j; with stc; let
    inherit (config.vars) minimal terminal;
    inherit (attrs) versions;
    neither = !(minimal || terminal);
    mkifnt = myIf.drv (!terminal) pkgs.hello;
    mkifn = myIf.drv neither pkgs.hello;
    mkifnm = myIf.drv (!minimal) pkgs.hello;
    extra-container = let pkgSrc = sources.extraContainer; in pkgs.callPackage pkgSrc { inherit pkgSrc; };
in with pkgs; [
    autojump
    acpilight
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello appimage-run)
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello appimagekit)
    assh
    autossh
    bat
    bc
    # bcachefs-tools
    btrfs-progs
    byobu
    cascadia-code
    copyq
    coreutils
    ctop
    curl
    darling-dmg
    ddar
    diskus
    dos2unix
    elvish
    entr
    exa
    exfat
    fasd
    fd
    fff
    ffmpeg
    ffmpeg
    figlet
    filet
    fzf
    gcc
    git
    git-crypt
    git-fire
    git-lfs
    gotop
    gptfdisk
    inetutils
    libffi
    lolcat
    lorri
    micro
    mkpasswd
    monkeysphere
    mosh
    mtr
    neo-cowsay
    neovim
    niv
    nix-direnv
    nixops
    nnn
    nox
    ntfs3g
    pandoc
    par2cmdline
    parted
    peru
    pfetch
    pmutils
    ranger
    ripgrep
    rsync
    sd
    shellcheck
    silver-searcher
    snapper
    spacevim
    libguestfs
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello qemu_xen_4_10-light)
    starship
    sysstat
    thefuck
    # thermald
    tmux
    tmuxp
    tree
    udftools
    uutils-coreutils
    vagrant
    vim
    wget
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello win-qemu)
    wtf
    xclip
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello xenPackages.xen_4_10-light)
    xz
    yadm
    yubico-pam
    yubico-piv-tool
    yubikey-manager
    yubikey-personalization
    yubioath-desktop
] ++ (map mkifn [
    gnome3.gnome-boxes
    gnome3.gnome-tweaks
    google-chrome
    google-chrome-beta
    google-chrome-dev
    vivaldi
    vivaldi-ffmpeg-codecs
    vivaldi-widevine
    vscodium
]) ++ (map mkifnm [
    extra-container
    # haskellPackages.hocker
    refind
]) ++ (map mkifnt [
    alacritty
    atom
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello etcher)
    firefox
    gnome3.gnome-disk-utility
    gparted
    keybase-gui
    kitty
    libsForQt5.qtstyleplugin-kvantum
    shadowfox
    vlc
    vscode
    woeusb
    xclip
    xfce.thunar
    yubikey-manager-qt
    yubikey-personalization-gui
# ]) ++ (with pkgs.j.pkgset.20-09."emacs${versions.emacs}Packages"; [
#     (mkifnm exwm)
]) ++ (with pkgs."python${versions.python}Packages"; [
    (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello pyls-black)
    (mkifnm jupyter)
    # nixpkgs
    poetry
]) ++ (with pkgs.gitAndTools; [
    # git-annex
    git-extras
    git-hub
    gitflow
    gh
    hub
    lab
]) ++ (map (npp: mkifnm pkgs."nix-prefetch-${npp}") [
    "github"
    "docker"
    "scripts"
]) ++ (with pkgs.nur.repos; [
    (mkifnt onny.foliate)
]) ++ [
    # For emacs

    # org-roam
    sqlite

    # org-md-export-to-markdown
    nodePackages.prettier
] ++ (let
    p = "python${versions.python}Packages";
in [
    (getAttr "black" (
        if (pkgs ? black) then pkgs else pkgs."${p}"
    ))

    (myIf.drv (
        (pkgs ? black-macchiato) || (pkgs."${p}" ? black-macchiato)
    ) pkgs.hello (getAttr "black-macchiato" (
        if (pkgs ? black-macchiato) then pkgs else pkgs."${p}"
    )))

    (myIf.drv (pkgs ? duf) pkgs.hello (getAttr "duf" pkgs))
    (myIf.drv (pkgs ? gitoxide) pkgs.hello (getAttr "gitoxide" pkgs))
    (myIf.drv (pkgs ? glances) pkgs.hello (getAttr "glances" pkgs))
    (myIf.drv (pkgs ? nixos-shell) pkgs.hello (getAttr "nixos-shell" pkgs))
    (myIf.drv (pkgs ? obsidian && !neither) pkgs.hello (getAttr "obsidian" pkgs))
    (myIf.drv (pkgs ? yubikey-agent) pkgs.hello (getAttr "yubikey-agent" pkgs))
    (myIf.drv (pkgs ? zenith) pkgs.hello (getAttr "zenith" pkgs))
    (myIf.drv (pkgs."${p}" ? pipx) pkgs.hello (getAttr "pipx" pkgs."${p}"))
])
#+end_src

**** platforms
***** shared
****** armv67l.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185350150461400

#+name: 20210601185350150461400
#+begin_src nix :tangle (aiern/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = {
        binaryCaches = [
            "http://nixos-arm.dezgeg.me/channel"
            "https://app.cachix.org/cache/thefloweringash-armv7"
        ];
        binaryCachePublicKeys = [
            "nixos-arm.dezgeg.me-1:xBaUKS3n17BZPKeyxL4JfbTqECsT+ysbDJz29kLFRW0=%"
            "thefloweringash-armv7.cachix.org-1:v+5yzBD2odFKeXbmC+OPWVqx4WVoIVO6UXgnSAWFtso="
        ];
    };
}
#+end_src

***** arm
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185351622602000

#+name: 20210601185351622602000
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (file: import file inputs) (imprelib.list { dir = ./.; });
    config = {
        # NixOS wants to enable GRUB by default
        boot.loader.grub.enable = false;
        # Enables the generation of /boot/extlinux/extlinux.conf
        boot.loader.generic-extlinux-compatible.enable = true;
    };
}
#+end_src

***** armv6l-linux
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185353321602000

#+name: 20210601185353321602000
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

***** armv7l-linux
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185354863625500

#+name: 20210601185354863625500
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

***** aarch64-linux
****** default.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185356455654500

#+name: 20210601185356455654500
#+begin_src nix :tangle (aiern/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

**** repl.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185357956752000

#+name: 20210601185357956752000
#+begin_src nix :tangle (aiern/tangle-path)
let
  flake = builtins.getFlake (toString ./.);
  nixpkgs = import <nixpkgs> { };
in
{ inherit flake; }
// flake
// builtins
// nixpkgs
// nixpkgs.lib
// flake.nixosConfigurations
#+end_src

**** resources
***** users.json

#+call: hash() :exports none

#+RESULTS:
: 20210601185359809444000

#+name: 20210601185359809444000
#+begin_src json :tangle (aiern/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** nix
**** nix.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185401285170600

#+name: 20210601185401285170600
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601185855166479800>>
#+end_src

*** zsh
**** keephack

#+call: hash() :exports none

#+RESULTS:
: 20210601185403002625400

#+name: 20210601185403002625400
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185408210445400

#+name: 20210601185408210445400
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185403002625400()>>
#+end_src

* home
** .gitattributes

#+call: hash() :exports none

#+RESULTS:
: 20210601185410274391500

#+name: 20210601185410274391500
#+begin_src gitattributes :tangle (aiern/tangle-oreo)
<<20210601214257298335500>>
#+end_src

** .xonsh.d
*** fzf_tmux_dir_file.sh

#+call: hash() :exports none

#+RESULTS:
: 20210601185418661581700

#+name: 20210601185418661581700
#+begin_src sh :tangle (aiern/tangle-path)
echo $(find "$1" | fzf-tmux)
#+end_src

*** fzf_tmux_pkg.sh

#+call: hash() :exports none

#+RESULTS:
: 20210601185421600244400

#+name: 20210601185421600244400
#+begin_src sh :tangle (aiern/tangle-path)
echo $(dpkg --get-selections | fzf-tmux)
#+end_src

** .xonshrc

#+call: hash() :exports none

#+RESULTS:
: 20210601185424827789400

#+name: 20210601185424827789400
#+begin_src xonsh :tangle (aiern/tangle-oreo)
<<20210601214242951916200>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185427358430600

#+name: 20210601185427358430600
#+begin_src nix
".xonshrc".text = let
    python_ver = concatStringsSep "." (stringToCharacters attrs.versions.python);
    Channel = toCapital channel;
in with attrs.commands; ''
homeManager = True

<<20210601185424827789400>>
'' + (myIf.empty nixos ''

<<20210601185428842611300>>
'');
#+end_src

*** nixos

#+call: hash() :exports none

#+RESULTS:
: 20210601185428842611300

#+name: 20210601185428842611300
#+begin_src xonsh
#################
# NixOS ${Channel}
#################

aliases["rebuild"] = lambda args, stdin=None: $(${rebuild} @(args) -p ${host})
aliases["install"] = lambda args, stdin=None: $(${install})

# TODO: Revise this
def _deploy(args, stdin=None):
    sudo nixops create /etc/nixos/nixops/home.nix -d home
    sudo nixops set-args --arg hostName ${get {
        set = all.hostName;
        stc = (filterAttrs (n: v: elem n j.attrs.stc) stc) // { inherit (stc) host; };
    }} -d home
    if "all" in args:
        sudo nixops deploy -d home
aliases["deploy"] = _deploy
#+end_src

** zsh

#+call: hash() :exports none

#+RESULTS:
: 20210601185430439244600

#+name: 20210601185430439244600
#+begin_src nix
zsh = let zedFile = file: let
    grml = "${sources.grml}/etc/zsh/${file}";
in myIf.empty (pathExists grml) (readFile grml); in {
    enable = true;
    enableAutosuggestions = true;
    enableVteIntegration = true;
    autocd = true;

    # TODO: Maybe this could be all paths in $PATH?
    cdpath = [  ];

    defaultKeymap = "viins";
    history.extended = true;
    initExtra = '' '';
    # initExtraFirst = '' '';
    initExtraBeforeCompInit = (zedFile "zshrc") + ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    profileExtra = (zedFile "zprofile") + '' '';
    envExtra = (zedFile "zshenv") + '' '';
    loginExtra = (zedFile "zlogin") + '' '';
    logoutExtra = (zedFile "zlogout") + '' '';
    oh-my-zsh = {
        enable = false;
        plugins = [  ];
        extraConfig = '' '';
        # theme = "sushi";
        custom = "";
    };
    plugins = [  ];
    prezto = {
        enable = true;
        editor = {
            dotExpansion = true;
            keymap = "vi";
        };
        extraConfig = '' '';
        extraFunctions = [  ];
        extraModules = [  ];
        pmodules = [  ];
        pmoduleDirs = [  ];
        # prompt.theme = "paradox";
        tmux.itermIntegration = true;
        utility.safeOps = true;
    };
    inherit shellAliases;
    shellGlobalAliases = {  };
};
starship.enableZshIntegration = true;
#+end_src

** .zshrc

#+call: hash() :exports none

#+RESULTS:
: 20210601185442157612700

#+name: 20210601185442157612700
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshrc"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            ""))
    "\nsource ~/.nix-profile/etc/profile.d/hm-session-vars.sh\n"
    "eval \"$(starship init zsh)\"")
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185446405488200

#+name: 20210601185446405488200
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185442157612700()>>
#+end_src

** .zshenv

#+call: hash() :exports none

#+RESULTS:
: 20210601185451794769400

#+name: 20210601185451794769400
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshenv"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185454964123500

#+name: 20210601185454964123500
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185451794769400()>>
#+end_src

** .zprofile

#+call: hash() :exports none

#+RESULTS:
: 20210601185457701910200

#+name: 20210601185457701910200
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zprofile"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185459709528000

#+name: 20210601185459709528000
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185457701910200()>>
#+end_src

** .zlogout

#+call: hash() :exports none

#+RESULTS:
: 20210601185501472232200

#+name: 20210601185501472232200
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogout"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185503163928300

#+name: 20210601185503163928300
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185501472232200()>>
#+end_src

** .zlogin

#+call: hash() :exports none

#+RESULTS:
: 20210601185504929349900

#+name: 20210601185504929349900
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogin"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash() :exports none

#+RESULTS:
: 20210601185506839665700

#+name: 20210601185506839665700
#+begin_src sh :tangle (aiern/tangle-path)
<<20210601185504929349900()>>
#+end_src

** .config
*** yadm
**** bootstrap

#+call: hash() :exports none

#+RESULTS:
: 20210601185512741369900

#+name: 20210601185512741369900
#+begin_src sh :tangle (aiern/tangle-path) :shebang "#!/usr/bin/env bash"
<<20210601184651836098700>>
#+end_src

*** kitty

#+call: hash() :exports none

#+RESULTS:
: 20210601185514628869000

#+name: 20210601185514628869000
#+begin_src nix
kitty = {
    enable = true;
    extraConfig = readFile "${homeDirectory}/${primary.user}/home/.config/kitty/kitty.conf";
    settings.font_family = "Cartograph CF Light Italic";
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185516365354300

#+name: 338a3b4e851f416dd70aa64a977efb96
#+begin_src text
Monokai_Soda
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185517894186800

#+name: 20210601185517894186800
#+begin_src nix
".config/kitty/theme.conf".source = sources.kittyThemes + "/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf";
#+end_src

**** kitty.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185519555635200

#+name: 20210601185519555635200
#+begin_src conf :tangle (aiern/tangle-path)
include ./theme.conf
#+end_src

**** theme.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185521282472600

#+name: 20210601185521282472600
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/kittyThemes/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185522915194400

#+name: 20210601185522915194400
#+begin_src conf :tangle (aiern/tangle-path)
<<20210601185521282472600()>>
#+end_src

*** qtile

#+call: hash() :exports none

#+RESULTS:
: 20210601185525000840300

#+name: 20210601185525000840300
#+begin_src nix
".config/qtile/config.py".source = "${homeDirectory}/${primary.user}/home/.config/qtile/config.py";
#+end_src

**** config.py

#+call: hash() :exports none

#+RESULTS:
: 20210601185823132554800

#+name: 20210601185823132554800
#+begin_src python :tangle (aiern/tangle-oreo)
<<20210601214231713054800>>
#+end_src

*** fish

#+call: hash() :exports none

#+RESULTS:
: 20210601185826302626100

#+name: 20210601185826302626100
#+begin_src nix
${myIf.knull (!elem system [ "aarch64-linux" ]) "fish"} = {
    enable = true;
    package = pkgs.fish;
    functions = shellAliases // {
        sf = "source ~/.config/fish/config.fish";
    };
    interactiveShellInit = ''
        bass source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    plugins = [{ name = "bass"; src = sources'.bass; }];
};
starship.enableFishIntegration = true;
#+end_src

**** config.fish

#+call: hash() :exports none

#+RESULTS:
: 20210601185828039219300

#+name: 20210601185828039219300
#+begin_src fish :tangle (aiern/tangle-path)
bass source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias sf=source ~/.config/fish/config.fish
alias n=exit
alias c=clear
starship init fish | source
#+end_src

*** ion

#+call: hash() :exports none

#+RESULTS:
: 20210601185829828213000

#+name: 20210601185829828213000
#+begin_src nix
".config/ion/initrc".source = "${homeDirectory}/${primary.user}/home/.config/ion/initrc";
#+end_src

**** initrc

#+call: hash() :exports none

#+RESULTS:
: 20210601185831324401300

#+name: 20210601185831324401300
#+begin_src ion :tangle (aiern/tangle-path)
eval $(starship init ion)
#+end_src

*** powershell

#+call: hash() :exports none

#+RESULTS:
: 20210601185832861775500

#+name: 20210601185832861775500
#+begin_src nix
".config/powershell/Microsoft.PowerShell_profile.ps1".source = "${homeDirectory}/${primary.user}/home/.config/powershell/Microsoft.PowerShell_profile.ps1";
#+end_src

**** Microsoft.PowerShell_profile.ps1

#+call: hash() :exports none

#+RESULTS:
: 20210601185834367531900

#+name: 20210601185834367531900
#+begin_src powershell :tangle (aiern/tangle-path)
Invoke-Expression (&starship init powershell)
#+end_src

*** nixpkgs

#+call: hash() :exports none

#+RESULTS:
: 20210601185836015744100

#+name: 20210601185836015744100
#+begin_src emacs-lisp :var oc=""
(format-spec "
    with builtins;
    with (getFlake \"/etc/nixos\");
    with lib;
    with j;
let stc = legacyPackages.hostName.${getEnv \"HOSTNAME\"};
in getAttrFromPath (attrValues stc) legacyPackages.%o" `((?o . ,oc)))
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185837674888000

#+name: 20210601185837674888000
#+begin_src nix
".config/nixpkgs/overlays.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/overlays.nix";
".config/nixpkgs/config.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/config.nix";
".config/nix/nix.conf".text = attrs.configs.nix;
#+end_src

**** overlays.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185839211912000

#+name: 20210601185839211912000
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601185836015744100(oc="overlays")>>
#+end_src

**** config.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185840693626300

#+name: 20210601185840693626300
#+begin_src nix :tangle (aiern/tangle-path)
<<20210601185836015744100(oc="config")>>
#+end_src

**** home.nix

#+call: hash() :exports none

#+RESULTS:
: 20210601185842088170000

#+name: 20210601185842088170000
#+begin_src nix
sources' = (getFlake "/etc/nixos/flakes/home").inputs;
inherit (flake) all;

fromAll = category: get {
    set = all.${category};
    stc = removeAttrs (
        attrNames attrs.home-manager-integer-defaults
    ) stc;
};
pkgs = fromAll "pkgs";
overlays = fromAll "overlays";
config = fromAll "config";

integer-default-truths = mapAttrs (
    n: v: v == 1
) (filterAttrs (n: v: isInt v) stc);

primary = {
    user = attrs.users.primary;
    home = attrs.allHomes.${primary.user};
};
homeDirectory = attrs.allHomes.${user};

baseOptions = {
    # force = true;
};

userName  = primary.user;
userEmail = "aiern@protonmail.com";

links' = rec {
    cookiejar = {
        source = "/${host}/b/cj";
        target = "cj";
    };
    picotech = {
        source = "${cookiejar.source}/cc/.pico";
        target = ".pico";
    };
    byobu = {
        source = "${homeDirectory}/.tmux.conf";
        target = ".byobu/.tmux.conf";
    };
};
links = mapAttrs (link: st: {
    inherit (st) target;
    source = /. + st.source;
}) (filterAttrs (link: st: pathExists (/. + st.source)) links');

shellAliases = {
    n = "exit";
    c = "clear";
};

withLink = link: with link; { "${target}" = { inherit source; }; };

hash = user: j.hostName { stc = stc // { inherit user; }; };
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185843559082700

#+name: 20210601185843559082700
#+begin_src nix
({
    <<20210601185430439244600>>
})
({
    <<20210601213133906441600>>
})
({
    <<20210601185826302626100>>
})
({
    <<20210601185913912448600>>
})
({
    <<20210601185927098034100>>
})
({
    <<20210601185930291067900>>
})
({
    <<20210601185514628869000>>
})
({
    <<20210601185938069815900>>
})
({
    <<20210601185933359940100>>
})
({
    <<20210601185942654247100>>
})
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601213425809120100

#+name: 20210601213425809120100
#+begin_src nix
({
    <<20210601185923733355900>>
})
({
    <<20210601185427358430600>>
})
({
    <<20210601185901673235100>>
})
({
    <<20210601185829828213000>>
})
({
    <<20210601185832861775500>>
})
({
    <<20210601185906086312300>>
})
({
    <<20210601185931858588700>>
})
({
    <<20210601185939558599100>>
})
({
    <<20210601185944075672100>>
})
({
    <<20210601185525000840300>>
})
({
    <<20210601185517894186800>>
})
({
    <<20210601185837674888000>>
})
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185853098066700

#+name: 20210601185853098066700
#+begin_src nix :tangle (aiern/tangle-path)
with builtins; let
    base = { stc, all, flake, ... }:
        with builtins;
        with lib;
        with j;
        with stc;
        with integer-default-truths;
    let
        <<20210601185842088170000>>
    in rec {
        inherit lib;
        nixpkgs = { inherit (stc) system; inherit overlays config; };
        fonts.fontconfig.enable = mkForce true;
        imports = [ "${sources.impermanence}/home-manager.nix" ];
        useUserPackages = true;
        useGlobalPkgs = true;
        backupFileExtension = "bak";
        verbose = true;

        # TODO
        sharedModules = [
            {  }
        ];

        extraSpecialArgs = flake.legacyPackages.make.specialArgs { inherit stc; };

        programs = foldToSet (map (set: mapAttrs (
            n: v: baseOptions // v
        ) set) (flatten [
            [
                {
                    home-manager = {
                        enable = true;
                        path = sources.home-manager.outPath;
                    };
                }
                <<20210601185843559082700>>
            ]
        ]));

        services = {
            gpg-agent = {
                enable = true;
                enableSshSupport = false;
                pinentryFlavor = "curses";
            };
            emacs = {
                enable = true;
                package = if (programs ? emacs) then programs.emacs.package else pkgs.emacsGcc;
            };
        };

        home = let
            persistence = {
                ${
                    myIf.knull (nixos && zfs) "persistence"
                } = attrs.persistence.home { inherit user; };
            };

            seqList = [

                # !!! CAREFUL! THE ORDER HERE MATTERS! !!!
                persistence

            ];

        in sequence seqList (foldToSet [{
                packages = import ../../etc/nixos/packages.nix { inherit stc lib pkgs; };
                file = foldToSet (map (set: mapAttrs (
                    n: v: { force = true; } // v
                ) set) (flatten [
                    [
                        ({ ".hgignore".source = "${homeDirectory}/${primary.user}/home/.hgignore"; })
                        (let source = "/persist/home/root/${primary.user}"; in foldToSet [
                            (myIf.set (user == "root") (attrs.link "/" "${source}/system"))
                            (attrs.link homeDirectory "${source}/home")
                            {
                                "${primary.user}".source = source;
                                ${myIf.knull (user == "root") "/usr/local/etc/doas.conf"}.text = ''
                                    permit keepenv :wheel
                                    permit nopass keepenv root as root
                                '';
                            })
                            <<20210601213425809120100>>
                        ]
                    ]
                    (map withLink (attrValues links))
                ]));
            }
            persistence
        ]);
    };

    flake = getFlake "/etc/nixos";
    inherit (flake) all;

in with lib; with j; forAllSystems' {
    inherit all;
    func = base;
    inherit extraListSets;
    inheritance = { inherit all flake; };
}
#+end_src

*** nix
**** nix.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185855166479800

#+name: 20210601185855166479800
#+begin_src conf :tangle (aiern/tangle-path)
<<20210601184948158342800>>
min-free = 262144000
max-free = 1073741824
#+end_src

** .bashrc

#+call: hash() :exports none

#+RESULTS:
: 20210601213133906441600

#+name: 20210601213133906441600
#+begin_src nix
bash = {
    enable = true;
    enableVteIntegration = true;
    initExtra = ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    inherit shellAliases;
    shellOptions = [  ];
};
starship.enableBashIntegration = true;
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185858457019500

#+name: 20210601185858457019500
#+begin_src sh :tangle (aiern/tangle-path)
source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias c=clear
alias n=exit
alias sb=source ~/.bashrc
eval "$(starship init bash)"
#+end_src

** rc.elv

#+call: hash() :exports none

#+RESULTS:
: 20210601185901673235100

#+name: 20210601185901673235100
#+begin_src nix
"rc.elv".source = "${homeDirectory}/${primary.user}/home/rc.elv";
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185904498814800

#+name: 20210601185904498814800
#+begin_src elvish :tangle (aiern/tangle-path)
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
eval (starship init elvish)
#+end_src

** .SpaceVim.d

#+call: hash() :exports none

#+RESULTS:
: 20210601185906086312300

#+name: 20210601185906086312300
#+begin_src nix
".config/nvim" = {
    source = sources.spacevim;
    recursive = true;
};
".vim" = {
    source = sources.spacevim;
    recursive = true;
};
".SpaceVim.d/init.toml".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/init.toml";
".SpaceVim.d/autoload/vimrc.vim".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/autoload/vimrc.vim";
#+end_src

*** init.toml

#+call: hash() :exports none

#+RESULTS:
: 20210601185907580979300

#+name: 20210601185907580979300
#+begin_src conf :tangle (aiern/tangle-oreo)
<<20210601214235078130500>>
#+end_src

*** autoload
**** vimrc.vim

#+call: hash() :exports none

#+RESULTS:
: 20210601185909239055500

#+name: 20210601185909239055500
#+begin_src vimrc :tangle (aiern/tangle-oreo)
<<20210601214241093346900>>
#+end_src

** makefile

#+call: hash() :exports none

#+RESULTS:
: 20210601185910773859000

#+name: 20210601185910773859000
#+begin_src text
scop/bash-completion ~/<<username>>/resources/bashCompletions
xero/figlet-fonts ~/<<username>>/resources/xeroFigletFonts
grml/grml-etc-core ~/<<username>>/resources/grml
SpaceVim/SpaceVim ~/<<username>>/home/.vim
dexpota/kitty-themes ~/<<username>>/resources/kittyThemes
aleclearmind/nested-tmux ~/<<username>>/resources/aleclearmind
gpakosz/.tmux ~/<<username>>/resources/oh-my-tmux
powerline/powerline ~/<<username>>/resources/powerline
tmux-plugins/tpm ~/<<username>>/resources/tpm
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185912312833700

#+name: 20210601185912312833700
#+begin_src makefile :tangle (aiern/tangle-path)
.RECIPEPREFIX := |

init:
|-git clone --recurse-submodule https://github.com/<<20210601185910773859000>>
|-ln -sf home/.vim ~/<<username>>/home/.config/nvim
#+end_src

** git

#+call: hash() :exports none

#+RESULTS:
: 20210601185913912448600

#+name: 20210601185913912448600
#+begin_src nix
git = {
    # File at ~/.config/git/config
    enable = true;
    package = pkgs.git;
    lfs.enable = true;
    extraConfig = {
        core = {
            excludesfile = "${homeDirectory}/.gitignore";
            attributesfile = "${homeDirectory}/.gitattributes";
        };

        # TODO: Add the greater-than sizes
        annex.largefiles = ''
            include=**/__pycache__/* or \
            include=**/dist/* or \
            include=**/tests/* or \
            include=**/deprecated/* or \
            include=**/unfinished/* or \
            include=**/.vscode/* or \
            include=**/*.test.* or \
            include=**/*.envrc
        '';

    };
    inherit userEmail userName;
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185923733355900

#+name: 20210601185923733355900
#+begin_src nix
".gitignore".text = "${homeDirectory}/${primary.user}/home/.gitignore";
".gitattributes".text = "${homeDirectory}/${primary.user}/home/.gitattributes";
#+end_src

** .gitignore

#+call: hash() :exports none

#+RESULTS:
: 20210601185925524999600

#+name: 20210601185925524999600
#+begin_src gitignore :tangle (aiern/tangle-path)
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

** .hgrc

#+call: hash() :exports none

#+RESULTS:
: 20210601185927098034100

#+name: 20210601185927098034100
#+begin_src nix
mercurial = {
    enable = true;
    package = pkgs.mercurial;
    inherit userEmail userName;
    ignoresRegexp = [];
    extraConfig = {
        extensions = {
            # hgext = {
            #     bookmarks = "";
            #     convert = "";
            # };
            # hggit = "/usr/lib/python2.7/site-packages/hggit";
            hggit = "";
            strip = "";
            share = "";
        };
        trusted = {
            users = primary.user;
            groups = primary.user;
        };
        git.blockdothg = "false";
        ui.ignore = "${homeDirectory}/.hgignore";
    };
};
#+end_src

** .hgignore

#+call: hash() :exports none

#+RESULTS:
: 20210601185928691269400

#+name: 20210601185928691269400
#+begin_src gitignore :tangle (aiern/tangle-path)
<<20210601185925524999600>>
#+end_src

** emacs

#+call: hash() :exports none

#+RESULTS:
: 20210601185930291067900

#+name: 20210601185930291067900
#+begin_src nix
emacs = {
    enable = true;
    package = pkgs.emacsGcc;
    overrides = final: prev: {
        magit-delta = super.magit-delta.overrideAttrs (eprev: {
            buildInputs = eprev.buildInputs ++ [ pkgs.git ];
        });
    };
    # extraPackages = with pkgs."emacs${j.attrs.versions.emacs}Packages"; [
    #     sqlite3
    #     emacsql-sqlite3
    # ];
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185931858588700

#+name: 20210601185931858588700
#+begin_src nix
".emacs.d".source = "${homeDirectory}/${primary.user}/home/.emacs.d";
#+end_src

** starship

#+call: hash() :exports none

#+RESULTS:
: 20210601185933359940100

#+name: 20210601185933359940100
#+begin_src nix
starship = {
    enable = true;
    package = pkgs.starship;
    settings = {

    };
};
#+end_src

** .tmux.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185934915109100

#+name: 20210601185934915109100
#+begin_src conf :tangle (aiern/tangle-oreo)
<<20210601214259128138500>>
#+end_src

** .byobu
*** .tmux.conf

#+call: hash() :exports none

#+RESULTS:
: 20210601185936581538600

#+name: 20210601185936581538600
#+begin_src conf :tangle (aiern/tangle-oreo)
<<20210601214259128138500>>
#+end_src

** tmux

#+call: hash() :exports none

#+RESULTS:
: 20210601185938069815900

#+name: 20210601185938069815900
#+begin_src nix
<<20210601214337624066100>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185939558599100

#+name: 20210601185939558599100
#+begin_src nix
".tmuxp/default.yaml".text = "session_name: default";
#+end_src

** .direnvrc

#+call: hash() :exports none

#+RESULTS:
: 20210601185941178211700

#+name: 20210601185941178211700
#+begin_src shell :tangle (aiern/tangle-path)
source $HOME/.nix-direnv/direnvrc
source $HOME/.config/direnv/direnvrc

if [ -f /run/current-system/sw/share/nix-direnv/direnvrc ]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

** direnv

#+call: hash() :exports none

#+RESULTS:
: 20210601185942654247100

#+name: 20210601185942654247100
#+begin_src nix
direnv = {
    # File at ~/.config/direnv/direnvrc
    enable = true;
    enableBashIntegration = true;
    enableFishIntegration = true;
    enableNixDirenvIntegration = true;
    enableZshIntegration = true;
    stdlib = ''
        use_flake() {
            watch_file flake.nix
            watch_file flake.lock
            eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
        }
    '';
};
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601185944075672100

#+name: 20210601185944075672100
#+begin_src nix
".direnvrc".source = "${homeDirectory}/${primary.user}/home/.direnvrc";
#+end_src


* wheee

#+call: hash() :exports none

#+RESULTS:
: 20210601185945571372600

#+name: 98b2f4dcc6b880dfefca30da2b287931
#+begin_src python :tangle (aiern/tangle-path) :shebang "#!/usr/bin/env python3.9"
import argparse
import os
from sys import argv
from itertools import zip_longest
from subprocess import run
parser = argparse.ArgumentParser()
parser.add_argument("-D", "--directory", default="/etc/nixos")
parser.add_argument("-f", "--flake", action="store_true")
parser.add_argument("-F", "--file")
parser.add_argument("-c", "--command", default="switch")
parser.add_argument("-s", "--hash", action="store_true")
parser.add_argument("--use-hash")
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-d", "--dry-run", action="store_true")
parser.add_argument("-m", "--home-manager", action="store_true")
parser.add_argument("-i", "--install", action="store_true")
parser.add_argument("-H", "--host", required=True)
parser.add_argument("-u", "--user", default="root")
args, unknown = parser.parse_known_args(argv[1:])

homeManager = args.home_manager or args.file

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter([
        s.removeprefix("--") if s.startswith("--") else s for s in iterable
    ])] * n
    return zip_longest(*args, fillvalue=fillvalue)

unknown = dict(grouper(unknown, 2, ""))

if homeManager:
    unknown["user"] = args.user
unknown["host"] = args.host

commandPre = f"nix-instantiate --read-write-mode --show-trace --eval -E 'let j = import " + os.path.dirname(os.path.realpath(argv[0])) + "/system/etc/nixos/lib {  }; in j.hostName"

commandSet = "{ stc = j.attrs.default-stc // " + ("j.attrs.home-manager-default-stc" if homeManager else "{  }") + " // { "
for k, v in unknown.items():
    commandSet += f'{k} = "{v}"; '
commandSet += "};"

hashCommand = " ".join([
    commandPre,
    commandSet,
    "}'",
])

flake = lambda _hash: f'--flake "{args.directory}#{_hash}"' if args.flake else (
    f'-A {_hash} -f {args.file or "~/.config/nixpkgs/home.nix"}' if homeManager else ""
)

if homeManager:
    command = lambda _hash: f'''home-manager {args.command} \
    --option build-use-substitutes true \
    --option substitute {flake(_hash)}'''
elif args.install:
    # command = lambda _hash: f'nixos-install --impure --show-trace {flake(_hash)}'
    command = lambda _hash: f'''nix build \
        --option build-use-substitutes true \
        --option substitute true \
        --impure \
        --show-trace \
        {args.directory}#nixosConfigurations.{_hash}.config.system.build.toplevel && \
        nixos-install --system ./result'''
else:
    command = lambda _hash: f'''nixos-rebuild {args.command} \
        --option build-use-substitutes true \
        --option substitute \
        --impure \
        --show-trace {flake(_hash)}'''

getHash = lambda: args.use_hash or run(hashCommand, shell = True, capture_output = True, text = True).stdout.strip().strip('\"')

if args.verbose or args.dry_run:
    if args.hash:
        print(hashCommand)
    else:
        _hash = getHash()
        print(command(getHash()))
if not args.dry_run:
    if args.hash:
        print(getHash())
    else:
        run(command(getHash()), shell = True)
#+end_src

* bootstrap

# Rewrite this for python 3.9

#+call: hash() :exports none

#+RESULTS:
: 20210601190008208069700

#+name: 20210601190008208069700
#+begin_src python :tangle (aiern/tangle-path) :shebang "#!/usr/bin/env python3.9"
import argparse
import json
import os
import sys
from subprocess import run, DEVNULL, STDOUT

<<20210601190005804224800>>

resources = f'{os.environ["HOME"]}/<<username>>/system/etc/nixos/config'

try:
    if args.subcommand == "create":
        if input('THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\n\t') == "ZFS CREATE":
            <<20210601190001707883400>>
        else:
            print("Sorry; not continuing!\n\n")

    if args.subcommand == "update":
        if args.files:
            <<20210601190027596726400>>
        elif args.pool:
            <<20210601190029500156200>>
        else:
            <<20210601190027596726400>>

finally:
    if args.subcommand:
        run(f"zpool export -f {args.Pool}", shell = True, stdout=DEVNULL, stderr=STDOUT)

if args.subcommand == "mount":
    <<20210601190019160487800>>

if args.generate:
    run("nixos-generate-config --root /mnt", shell = True)

if args.move:
    run("mkdir -p /mnt/etc/nixos/config", shell = True)
    run("mv /mnt/etc/nixos/{,config/}configuration.nix", shell = True)
    run("mv /mnt/etc/nixos/{,config/}hardware-configuration.nix", shell = True)

if args.rsync:
    run("nix-env -iA nixos.rsync", shell = True)
    run("rsync -avvczz ~/<<username>>/system/ /mnt/", shell = True)

if args.install:
    run("nixos-install --show-trace", shell = True)

# TODO
if args.home_manager:
    pass

# TODO: Also include a one-stop-install, mounting, generating, copying, etc. all in one go
if args.all:
    pass
#+end_src

****** argparse

#+call: hash() :exports none

#+RESULTS:
: 20210601190005804224800

#+name: 20210601190005804224800
#+begin_src python
parser = argparse.ArgumentParser()

# From: https://gist.github.com/amarao/36327a6f77b86b90c2bca72ba03c9d3a
subparsers = parser.add_subparsers(dest='subcommand')
create = subparsers.add_parser("create")
mount = subparsers.add_parser("mount")
update = subparsers.add_parser("update")

for subparser in [ create, mount, update ]:
    subparser.add_argument("Pool")
    subparser.add_argument("-d", "--deduplicated", action="store_true")
    subparser.add_argument("-e", "--encrypted", action="store_true")

create.add_argument("-z", "--zfs-device", required=True)
create.add_argument("-s", "--swap", type=int)
mount.add_argument("-b", "--boot-device", required=True)
mount.add_argument("-s", "--swap", action="store_true")
update.add_argument("-p", "--pool", action="store_true")
update.add_argument("-f", "--files", action="store_true")

parser.add_argument("-g", "--generate", action="store_true")
parser.add_argument("-m", "--move", action="store_true")
parser.add_argument("-l", "--link", action="store_true")
parser.add_argument("-r", "--rsync", action="store_true")
parser.add_argument("-i", "--install", action="store_true")
parser.add_argument("-H", "--home-manager", action="store_true")
parser.add_argument("-a", "--all", action="store_true")

# Adapted From:
# Answer: https://stackoverflow.com/a/29312757/10827766
# User: https://stackoverflow.com/users/2664549/cgseller
if len(sys.argv) == 1:
    parser.print_help(sys.stderr)
    sys.exit(1)

args = parser.parse_args()
#+end_src

****** create

#+call: hash() :exports none

#+RESULTS:
: 20210601190001707883400

#+name: 20210601190001707883400
#+begin_src python
options = {
    "xattr": "sa",
    "acltype": "posixacl",
    "mountpoint": "none",
    "compression": "zstd-19",
    "checksum": "edonr",
    "atime": "off",
    "relatime": "off",
}

if args.encrypted:
    options["encryption"] = "aes-256-gcm"
    options["keyformat"] = "passphrase"
if args.deduplicated:
    options["dedup"] = "edonr,verify"

if os.path.isdir("/mnt"):
    run("umount -R /mnt", shell = True, stdout=DEVNULL, stderr=STDOUT)
else:
    run("mkdir /mnt", shell = True, stdout=DEVNULL, stderr=STDOUT)

run(f"zpool export -f {args.Pool}", shell = True, stdout=DEVNULL, stderr=STDOUT)

command = f"zpool create -fo autotrim=on -o altroot=/mnt"

for key, value in options.items():
    command += f" -O {key}={value}"

run(f"{command} {args.Pool} {args.zfs_device}", shell = True)

<<20210601190029500156200>>

#+end_src

******* open =f{resources}/users.json=

#+call: hash() :exports none

#+RESULTS:
: 20210601185958834005400

#+name: 20210601185958834005400
#+begin_src python
users = json.loads('''
    <<20210601185359809444000>>
'''.strip())

for user in users.values():
    dsd["home"][d][user] = dd
    datasets["virt"][d]["podman"][d][user] = dd
    for dataset in (persist := dsd["persist"][d]).keys():
        persist[dataset][d][user] = dd
#+end_src

******* open =f{resources}/_datasets.nix=
******** before opening =f{resources}/_datasets.nix=

#+call: hash() :exports none

#+RESULTS:
: 20210601190011469159700

#+name: 20210601190011469159700
#+begin_src python
with open(f"{resources}/_datasets.nix", "w") as dnix:

    dnix.write("host: {\n")

    def recurse(ddict, dname, droot, mountpoint = ""):

        _dataset = f"{droot}/{dname}"

        # cc: clone or create
        # son: snapshot or none
        if (dname != "base") and (args.encrypted and args.deduplicated):
            cc = "clone"
            son = f"{args.Pool}/base@root"
        else:
            cc = "create"
            son = ""

        prefixes = (
            "system",
            "system/root",
            "swap",
            "base",
            "hold",
            "omniverse",
            "reserved",
        )
        _doptions = ddict.get("options", [])
        if _dataset not in ( f"{args.Pool}/{dataset}" for dataset in prefixes):
            if (_mountpoint := ddict.get("mountpoint", "")):
                mountpoint = _mountpoint
            else:
                if mountpoint:
                    mountpoint += f"/{dname}"
                    _mountpoint = mountpoint
                else:
                    _mountpoint = _dataset.removeprefix(args.Pool + "/")
                    for prefix in prefixes:
                        _mountpoint = _mountpoint.removeprefix(prefix + "/")
                    _mountpoint = "/" + _mountpoint

            dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
#+end_src

******** after opening =f{resources}/_datasets.nix=

#+call: hash() :exports none

#+RESULTS:
: 20210601190013799970400

#+name: 20210601190013799970400
#+begin_src python
    for key, value in ddict.get(d, dd).items():
        recurse(value, key, _dataset, mountpoint)

for key, value in datasets.items():
    recurse(value, key, args.Pool)

dnix.write("}")
#+end_src

******* open =datasets.json=

#+call: hash() :exports none

#+RESULTS:
: 20210601190015343762700

#+name: 20210601190015343762700
#+begin_src json
{
    "base": {  },
    "hold": {  },
    "omniverse": {  },
    "reserved": {  },
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": {
                "datasets": {
                    "cache": {
                        "datasets": { "root": {  }},
                        "options": [ "sync=disabled" ]
                    },
                    "home": { "datasets": { "root": {  }}}
                }
            },
            "root": {  },
            "tmp": { "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601214823296929900

#+name: 20210601214823296929900
#+begin_src python
datasets = json.loads('''
    <<20210601190015343762700>>
'''.strip())

dsd = datasets[s][d]

datasets[args.Pool] = {
    "datasets": {
        "b": {
            "datasets": {
                "a": dd,
                "cc": { "options": snapDir },
                "cl": dd,
                "cj": { "datasets": {
                    "cc": { "options": extraCopies },
                    "m": { "options": snapDir }
                }},
                "eb": { "options": extraCopies },
                "oreo": { "option": snapDir },
                "p": { "options": snapDir }
            },
        },
        "borg": { "datasets": { "cache": { "options": cache }}},
        "jails": { "datasets": { "base": dd}},
        "las": {
            "datasets": {
                "dreadnought": ddd,
                "redstone": ddd,
                "sinnoh": ddd
            }
        },
        "y": dd,
        "z": dd
    },
    "options": [ ml ]
}

<<20210601185958834005400>>

for backup in (las := datasets[args.Pool][d]["las"][d]).keys():
    for zz in [ "zpax", "zsyncs" ]:
        las[backup][d][zz] = dd

<<20210601190011469159700>>
#+end_src

****** mount

#+call: hash() :exports none

#+RESULTS:
: 20210601190019160487800

#+name: 20210601190019160487800
#+begin_src python
import os
from collections import namedtuple
from functools import partial
from subprocess import DEVNULL

for dataset in run("zfs list -rH", shell = True, capture_output = True).stdout.decode().split("\n"):
    if args.Pool in dataset:
        break
else:
    run(f"zpool import -f {args.Pool}", shell = True)

if args.encrypted:
    run(f"zfs load-key {args.Pool}", shell = True)

if os.path.isdir("/mnt"):
    run("umount -R /mnt", shell = True, stdout=DEVNULL, stderr=STDOUT)
else:
    run("mkdir /mnt", shell = True, stdout=DEVNULL, stderr=STDOUT)

run(f"mount -t zfs {args.Pool}/system/root /mnt", shell = True)

with open(f"{resources}/_datasets.nix") as datasets:
    for __dataset in datasets.readlines()[1:-1]:
        _dataset, _mount = __dataset.split("=")
        dataset = _dataset.strip()
        mount = '"/mnt' + _mount.strip().lstrip('"').replace(
            "${host}",
            args.Pool,
        )

        if not os.path.isdir(mount):
            run(f"mkdir -p {mount}", shell = True)
        mount_command = f"mount -t zfs {dataset} {mount}"
        # print(mount_command)
        run(mount_command, shell = True)

if not os.path.isdir(boot := "/mnt/boot/efi"):
    run(f"mkdir -p {boot}", shell = True)

run(f"mount {args.boot_device} {boot}", shell = True)

if args.swap:
    run(f"swapon /dev/zvol/{args.Pool}/swap", shell = True)
#+end_src

****** update
******* before updating

#+call: hash() :exports none

#+RESULTS:
: 20210601190021157022400

#+name: 20210601190021157022400
#+begin_src python
snapDir = [ "snapdir=visible" ]
extraCopies = snapDir + [ f"copies={2 if args.encrypted else 3}" ]
cache = [ "sync=disabled" ]
ml = "mountpoint=legacy"
dd = {  }
ddd = { "datasets": {  }}
d = "datasets"
s = "system"

<<20210601214823296929900>>
#+end_src

******* after updating the pool

#+call: hash() :exports none

#+RESULTS:
: 20210601190023576455900

#+name: 20210601190023576455900
#+begin_src python
pool_size_plus_metric = run(
    f"zpool get -H size {args.Pool}",
    shell = True,
    capture_output = True
).stdout.decode().split("\n")[0].split("\t")[2]
pool_size = round(float(pool_size_plus_metric[:-1]), 2)
pool_metric = pool_size_plus_metric[-1]

def pool_percentage_value(percentage):
    return (
        str(
            round(
                (
                    (float(percentage) / 100)
                    * pool_size
                ),
                2,
            )
        )
        + pool_metric
    )

# Apparently, if python internal keywords exist in the argument, such as "set", etc.
# the command errors out; perhaps something to raise an issue of.
# This seems to work as an alternative.
run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/reserved", shell = True)

if args.swap:
    _swoptions = [
        "com.sun:auto-snapshot=false",
        "compression=zle",
        "logbias=throughput",
        "primarycache=metadata",
        "secondarycache=none",
        "sync=standard",
    ]
    swoptions = " -o ".join(_swoptions)

    ps = run("getconf PAGESIZE", shell = True, capture_output = True).stdout.decode().split("\n")[0]
    swap_command = f"zfs create -V {args.swap}G -b {ps} -o {swoptions} {args.Pool}/swap"
    run(swap_command, shell = True)

    run(f"mkswap -f /dev/zvol/{args.Pool}/swap", shell = True)
#+end_src

******* if updating the pool

#+call: hash() :exports none

#+RESULTS:
: 20210601190025663776100

#+name: 20210601190025663776100
#+begin_src python
doptions = " -o ".join(_doptions)

dataset_command = " ".join(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}".split())
snapshot_command = " ".join(f"zfs snapshot -r {_dataset}@root".split())

run(dataset_command, shell = True)
run(snapshot_command, shell = True)
#+end_src

******* files

#+call: hash() :exports none

#+RESULTS:
: 20210601190027596726400

#+name: 20210601190027596726400
#+begin_src python
<<20210601190021157022400>>

    <<20210601190013799970400>>

#+end_src

******* pool

#+call: hash() :exports none

#+RESULTS:
: 20210601190029500156200

#+name: 20210601190029500156200
#+begin_src python
<<20210601190021157022400>>

        <<20210601190025663776100>>

    <<20210601190013799970400>>

<<20210601190023576455900>>

#+end_src
