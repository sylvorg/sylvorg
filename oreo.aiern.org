#+setupfile: ./settings/README.org

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* shell.nix

#+name: 639828b5-661b-4ec3-91e3-b791753aa4df
#+begin_src nix :tangle (meq/tangle-path)
with builtins; let
    flake = import ./etc/nixos;
in with flake.legacyPackages.${currentSystem}; let
    strapper = { Python }: Python.pkgs.buildPythonApplication rec {
        pname = "strapper";
        version = "1.0.0.0";
        src = ./strapper;
        propagatedBuildInputs = with Python.pkgs; [ bakery ];
        installPhase = ''
            mkdir --parents $out/bin
            cp $src/${pname}.py $out/bin/${pname}
            cp $src/${pname}.hy $out/bin/
            chmod +x $out/bin/${pname}
            patchShebangs $out/bin/${pname}
        '';
        postInstall = "wrapProgram $out/bin/${pname} $makeWrapperArgs";
        makeWrapperArgs = [ "--prefix PYTHONPATH : ${placeholder "out"}/lib/${Python.pkgs.python.libPrefix}/site-packages" ];
    };
in mkShell rec { buildInputs = [ (callPackage strapper { }) sd rsync ]; }
#+end_src

* strapper
** setup.py

#+begin_src py :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3"
from setuptools import setup, find_packages
setup(name = 'strapper', version = '1.0.0.0', packages = find_packages(), scripts = [ "strapper.py" ])
#+end_src

** strapper.py

#+begin_src py :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3"
import hy, os
from addict import Dict
from oreo import module_installed
strapper = module_installed(os.path.dirname(os.path.realpath(__file__)) + "/strapper.hy").strapper
if __name__ == "__main__":
    strapper(obj=Dict(dict()))
#+end_src

** strapper.hy
:PROPERTIES:
:header-args:hy+: :noweb-ref 9f94385b-1c84-4e23-8efc-7689a80d2050
:END:

#+begin_src text :tangle (meq/tangle-path)
<<9f94385b-1c84-4e23-8efc-7689a80d2050>>
#+end_src

*** Imports

#+begin_src hy
(import click)
(import json)
(import oreo)
(import os)
#+end_src

**** From

#+begin_src hy
(import addict [Dict :as D])
(import bakery [ getconf
                 mkswap
                 mount :as Mount
                 nixos-generate-config
                 nixos-install
                 nixos-rebuild
                 parted
                 rsync
                 sd
                 swapon
                 umount
                 zfs
                 zpool ])
(import functools [partial])
(import pathlib [Path])
(import sys [argv])
#+end_src

**** Coconut

[[https://coconut.readthedocs.io/en/latest/index.html][Coconut]]:

#+begin_src hy
(try (import coconut *)
     (except [ImportError] None))
#+end_src

**** Toolz

[[https://github.com/pytoolz/toolz][Toolz]] and [[https://github.com/pytoolz/cytoolz/][CyToolz]]:

#+begin_src hy
(try (import cytoolz [last])
     (except [ImportError]
             (import toolz [last])))
#+end_src

*** Requires

#+begin_src hy :noweb-ref no
(require hyrule [-> assoc])
#+end_src

*** Set Resources Directory

#+begin_src hy
;; (setv resources (+ (.dirname os.path (.realpath os.path __file__)) "/etc/nixos/"))
(setv resources (+ (.getcwd os) "/etc/nixos/"))
#+end_src

*** Datasets

#+name: 03a790b2-39f2-40a3-be10-b107c73df509
#+begin_src text
reserved
#+end_src

#+name: f3568bf1-26cf-4d6f-8182-aad00b6a8d69
#+begin_src json
{
    "base": {  },
    "hold": {  },
    "omniverse": {  },
    "<<03a790b2-39f2-40a3-be10-b107c73df509>>": {  },
    "<<username>>": { "datasets": {
            "oreo": {  },
            "sylveon": {  },
            "sylvorg": {  },
            "syvlorg": {  },
            "<<reponame>>": {  },
            "uru": {  }},
        "options": [ "mountpoint=legacy" ]},
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": { "datasets": { "root": { "mountpoint": "/persist/root" }}},
            "root": {  },
            "tmp": { "datasets": { "nix": {  }}, "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

*** Update Datasets

#+begin_src hy
(defn update-datasets [host [swap 0] [encrypted False] [deduplicated False] [pool False] [root-device None] [reserved-only False]]
      (setv snap-dir     [ "snapdir=visible" ]
            extra-copies (+ snap-dir [ "copies=3" ])
            cache        [ "sync=disabled" ]
            ml           "mountpoint=legacy"
            d            "datasets"
            s            "system"
            reserved     "<<03a790b2-39f2-40a3-be10-b107c73df509>>"
            datasets     (D (.loads json (.strip #[[
                                <<f3568bf1-26cf-4d6f-8182-aad00b6a8d69>>
                         ]])))
            primary-user "<<username>>"
            users        (D (.loads json (.strip #[[
                                <<33b84622-7a1e-4a87-9c9f-fd10a3c13a8a>>
                         ]])))
            homes        (D (.loads json (.strip #[[
                                <<d0d6dd01-0986-45be-9254-23c5483b54c0>>
                         ]]))))

      #_(assoc datasets host (D { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                                     "options" [ ml ]}))

      (setv (. datasets [host]) (D { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                                     "options" [ ml ]}))

      (for [user (.values users)]

           #_(assoc (. datasets [s] [d] home [d]) user (dict))
           
           (setv (. datasets [s] [d] home [d] [user]) (dict))

           #_(assoc (. datasets [s] [d] persist [d]) user (dict))

           (setv (. datasets [s] [d] persist [d] [user]) (dict))

           #_(assoc (. datasets virt [d] podman [d]) user (dict))

           (setv (. datasets virt [d] podman [d] [user]) (dict))

           )
      (if reserved-only
          (.create zfs (+ host "/" reserved) :o "mountpoint=none")
          (do (with [dnix (open (+ resources "/datasets.nix") "w")]
                    (.write dnix (+ "host: { \n\t\""
                                    (or root-device "${host}/system/root")
                                    "\" = \"/\";"
                                    "\n"))
              (defn recurse [ddict dname droot [mountpoint ""]]
                    (setv recurse/datasets     (.list zfs :r True :o "name" :m/list True :m/ignore-stderr True)
                          recurse/datasets     (cut recurse/datasets 2 (len recurse/datasets))
                          recurse/dataset      (+ droot "/" dname)
                          recurse/real-dataset (.replace recurse/dataset "${host}" host)
                          cloning              (and (!= dname "base")
                                                    (and encrypted deduplicated))
                          prefixes             (, "system"
                                                  "system/root"
                                                  "swap"
                                                  "base"
                                                  "omniverse"
                                                  reserved ))
                    (if cloning
                        (setv clone-or-create  "clone"
                              snapshot-or-none (+ host "/base@root"))
                        (setv clone-or-create  "create"
                              snapshot-or-none ""))
                    (if (not (in recurse/real-dataset (lfor prefix prefixes (+ host "/" prefix))))
                        (do (if (setx recurse/mountpoint (.get ddict "mountpoint" ""))
                                (setv mountpoint recurse/mountpoint)
                                (if mountpoint
                                    (setv mountpoint (+ mountpoint "/" dname)
                                          recurse/mountpoint mountpoint)
                                    (do (setv recurse/mountpoint (.removeprefix recurse/dataset (+ "${host}" "/")))
                                        (for [prefix prefixes]
                                             (setv recurse/mountpoint (.removeprefix recurse/mountpoint (+ prefix "/"))))
                                        (setv recurse/mountpoint (+ "/" recurse/mountpoint)))))
                            (if (and (.startswith recurse/real-dataset (+ host "/" primary-user))
                                     (not (= recurse/real-dataset (+ host "/" primary-user))))
                                (.write dnix (+ "\t\""
                                                recurse/dataset
                                                "\" = [ "
                                                (.join " " (gfor user (.keys users) (+ "\"" (get homes user) "/" dname "\"")))
                                                " ];\n"))
                                #_(for [user (.keys users)]
                                     (.write dnix (+ "\t\""
                                                     recurse/dataset
                                                     "\" = \""
                                                     (+ (get homes user) "/" dname)
                                                     "\";\n")))
                                (.write dnix (+ "\t\""
                                                recurse/dataset
                                                "\" = \""
                                                recurse/mountpoint
                                                "\";\n")))))
                    (if (and pool (not (in recurse/real-dataset recurse/datasets)))
                        (do (zfs :m/subcommand clone-or-create
                                 :o { "repeat-with-values" (.get ddict "options" []) }
                                 snapshot-or-none
                                 recurse/real-dataset)
                            (.snapshot zfs :r True (+ recurse/real-dataset "@blank"))
                            (.hold zfs :r True "blank" (+ recurse/real-dataset "@blank"))))
                    (for [[key value] (.items (.get ddict d (D {  })))]
                         (recurse value key recurse/dataset mountpoint)))
              (for [[key value] (.items datasets)]
                   (recurse value key "${host}"))
              (.write dnix "}"))))
      (if (or pool reserved-only)
          (let [pool-size-plus-metric (get (.get zpool :H True "size" host :m/list True :m/split True) 2)
#+end_src

#+begin_src hy :noweb-ref no
                pool-size             (-> pool-size-plus-metric
                                          (cut 0 -1)
                                          float
                                          (round 2))
#+end_src

#+begin_src hy
                pool-size             (round (float (cut pool-size-plus-metric 0 -1)) 2)
#+end_src

#+begin_src hy
                pool-metric           (last pool-size-plus-metric)]
               (defn pool-percentage-value [percentage]
                     #_(-> percentage
                         float
                         (/ 100)
                         (round 2)
                         str
                         (+ pool-metric)
                         return)

                     (return (+ (str (round (/ (float percentage) 100) 2)) pool-metric))

                         )
               (.set zfs
                     (+ "refreservation=" (pool-percentage-value 15))
                     (+ host "/" reserved))

               ;; Apparently, if python internal keywords exist in the argument, such as "set", etc.
               ;; the command errors out; perhaps something to raise an issue of.
               ;; This seems to work as an alternative.
               ;; run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/{reserved}", shell = True)

               (if (not reserved-only)
                   (do (if swap
                           (let [swoptions [ "com.sun:auto-snapshot=false"
                                             "compression=zle"
                                             "logbias=throughput"
                                             "primarycache=metadata"
                                             "secondarycache=none"
                                             "sync=standard" ]
                                 page-size (getconf "PAGESIZE" :m/str True)]
                                (.create zfs
                                         :V (+ (str swap) "G")
                                         :b page-size
                                         :o { "repeat-with-values" swoptions }
                                         (+ host "/swap"))
                                (mkswap (+ "/dev/zvol" host "/swap")))))))))
#+end_src

*** Click

#+begin_src hy
(setv no-host-error-message "Sorry! The host needs to be set; do this with the main command while running the subcommand!")
#@((.group click :no-args-is-help True)
   (.option click "-d" "--dazzle" :is-flag True)
   (.option click "-H" "--host")
   (.option click "-i" "--inspect" :is-flag True)
   (.option click "-P" "--print-run" :is-flag True :cls oreo.Option :xor [ "print" ])
   (.option click "-p" "--print" :is-flag True :cls oreo.Option :xor [ "print-run" ])
   click.pass-context
   (defn strapper [ ctx dazzle host inspect print-run print ]
         (if (!= (.geteuid os) 0)
             (raise (SystemError "Sorry; this program needs to be run as root!")))
         (.ensure-object ctx dict)
         (setv ctx.obj.host host)
         (if dazzle (.bake-all- getconf :m/dazzle True))
         (if print-run (.bake-all- getconf :m/print-command-and-run True))
         (if print (.bake-all- getconf :m/print-command True))
         (if inspect (.bake-all- getconf :m/debug True))))
#+end_src

**** Main

#+begin_src hy
#@((.command strapper :no-args-is-help True
                      :context-settings { "ignore_unknown_options" True
                                          "allow_extra_args"       True })
   (.argument click "program-arguments" :nargs -1)
   (.option click "-a" "--all" :is-flag True)
   (.option click "-c" "--copy" :is-flag True)
   (.option click "-g" "--generate" :is-flag True)
   (.option click "-i" "--install" :is-flag True)
   (.option click "-b" "--install-bootloader" :is-flag True :cls oreo.Option :req-one-of [ "install" "all" ])
   (.option click "-r" "--replace" :is-flag True)
#+end_src

This can't use a default value, as that would trigger a rebuild all the time.

#+begin_src hy
   (.option click "-R" "--rebuild")
#+end_src

#+begin_src hy
   click.pass-context
   (defn main [ ctx all copy generate install program-arguments rebuild replace install-bootloader ]
         (if ctx.obj.host
             (do (.bake-all- getconf :m/sudo True)
                 (setv copy-partial (partial rsync :m/run True :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } f"{resources}/"))
                 (if rebuild
                     (do (if copy
                             (copy-partial "/etc/nixos/"))
                         (nixos-rebuild rebuild #* ctx.args :show-trace True))
                     (do (if (or copy all)
                             (do (update-datasets ctx.obj.host)
                                 (copy-partial "/mnt/etc/nixos/")))
                         (if (or generate all)
                             (nixos-generate-config :m/run True :root "/mnt"))
                         (if (or replace all)
                             (if ctx.obj.host
                                 (do (sd :m/run True
                                         "./hardware-configuration.nix"
                                         (+ "./hosts/" ctx.obj.host)
                                         "/mnt/etc/nixos/configuration.nix")
                                     (sd :m/run True
                                         "'device = \"\"'"
                                         "'device = \"!\"'"
                                         "/mnt/etc/nixos/hardware-configuration.nix"))
                                 (raise (NameError no-host-error-message))))
                         (if (or install all)
                             (let [ options [
#+end_src

From [[https://github.com/NixOS/nix/issues/2293#issuecomment-405339738][here]], and documented [[https://nixos.org/manual/nix/stable/expressions/builtins.html#:~:text=The%20fetched%20tarball%20is%20cached%20for%20a%20certain%20amount%20of%20time%20(1%20hour%20by%20default)%20in%20~/.cache/nix/tarballs/.%20You%20can%20change%20the%20cache%20timeout%20either%20on%20the%20command%20line%20with%20%2D%2Dtarball%2Dttl%20number%2Dof%2Dseconds%20or%20in%20the%20Nix%20configuration%20file%20by%20adding%20the%20line%20tarball%2Dttl%20%3D%20number%2Dof%2Dseconds.][here]]:

#+begin_quote
The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/.
You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds
or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds.
#+end_quote

#+begin_src hy
                                        "tarball-ttl 0"
#+end_src

Adapted from [[https://github.com/NixOS/nix/issues/807#issuecomment-209895935][here]]:

#+begin_src hy
                                        "build-fallback true"
#+end_src

#+begin_src hy
                                  ] ]
                                  (nixos-install #* ctx.args
                                             :I (with [f (open (+ resources "/flake.lock"))]
                                                      #[f[nixpkgs=https://github.com/nixos/nixpkgs/archive/{(. (.load json f) ["nodes"] ["<<channel>>"] ["original"] ["ref"])}.tar.gz]f])
                                             :m/run True
                                             :show-trace True
                                             :install-bootloader install-bootloader
                                             :option { "repeat-with-values" options }))))))
             (raise (NameError no-host-error-message)))))
#+end_src

**** Create

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-B" "--boot-device" :type (, str int))
   (.option click "-c" "--copies" :type int :default 1)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-M" "--host-mountpoint" :help "Use the hostname as the mountpoint" :is-flag True :cls oreo.Option :xor [ "mountpoint" ])
   (.option click "-m" "--mountpoint" :cls oreo.Option :xor [ "host-mountpoint" ])
   (.option click "-o" "--pool-options" :multiple True)
   (.option click "-O" "--dataset-options" :multiple True)
   (.option click
            "-P"
            "--partition"
            :multiple True
            :cls oreo.Option
            :xor [ "raid" ]
            :help "Set up an entire disk; a single `-P' sets up the boot partition with the size as the value passed in (with the unit, such as `2G' for 2 gibibytes),
a second `-P' sets up the swap space similarly, and subsequent invocations sets up further unformatted partitions.
The final partition will be the ZFS partition, and does not need to be specified.")
   (.option click "-p" "--pool-only" :is-flag True)
   (.option click "-r" "--raid" :cls oreo.Option :xor [ "partition" ])
   (.option click "-S" "--swap-device" :type (, str int))
   (.option click "-s" "--swap" :type int :default 0)
   (.option click "-z" "--zfs-devices" :required True :multiple True)
   click.pass-context
   (defn create [ ctx boot-device copies deduplicated encrypted host-mountpoint mountpoint dataset-options pool-options partition pool-only raid swap-device swap zfs-devices ]
         (if ctx.obj.host
             (try (if (= (input "THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN 'ZFS CREATE'!\n\t") "ZFS CREATE")
                      (let [dataset-options-dict (D { "xattr"      "sa"
                                                      "acltype"    "posixacl"
                                                      "mountpoint"  (if host-mountpoint
                                                                        (+ "/" ctx.obj.host)
                                                                        (or mountpoint "none"))
                                                      "compression" "zstd-19"
                                                      "checksum"    "edonr"
                                                      "atime"       "off"
                                                      "relatime"    "off"
                                                      "copies"      copies })
                            pool-options-dict (D { "autotrim" "on"
                                                   "altroot" "/mnt"
                                                   "autoexpand" "on" })
                            command (partial zpool.create :f True :m/run True)
                            no-raid-error-message "Sorry! For multiple zfs devices a raid configuration must be provided using `-r / --raid'!"
                            zfs-device (if (= (len zfs-devices) 1)
                                        (if raid
                                            (raise (NameError no-raid-error-message))
                                            (get zfs-devices 0))
                                        (if raid
                                            #[f[{raid} {(.join " " zfs-devices)}]f]
                                            (raise (NameError no-raid-error-message))))]
                           (if (or partition boot-device)
                               (.bake- parted :m/sudo True :s True :a "optimal" "--"))
                           (if partition
                               (do (setv zfs-name ctx.obj.host)
                                   (parted zfs-device "mklabel" "gpt")
                                   (for [[i p] (enumerate partition)]
                                        (parted zfs-device
                                                "mkpart"
                                                "primary"

                                                #_(if i (get partition (dec i)) "0%")

                                                (if i (get partition (- i 1)) "0%")

                                                p))
                                   (parted zfs-device "mkpart" "primary" (get partition -1) "100%")
                                   (parted zfs-device "name" (if (> (len partition) 1) 3 2) zfs-name)))
                           (if (or partition boot-device)
                               (if boot-device
                                   (let [ device (get boot-device 0)
                                          index  (get boot-device 1) ]
                                        (parted device "mkfs" index "fat32")
                                        (parted device "set" index "boot" "on")
                                        (parted device "set" index "esp" "on"))
                                   (do (parted zfs-device "name" 1 (+ ctx.obj.host "-boot"))
                                       (parted zfs-device "mkfs" 1 "fat32")
                                       (parted zfs-device "set" 1 "boot" "on")
                                       (parted zfs-device "set" 1 "esp" "on"))))
                           (if (or (> (len partition) 1) swap-device)
                               (if swap-device
                                   (parted (get swap-device 0) "mkfs" (get swap-device 1) "linux-swap")
                                   (do (parted zfs-device "name" 2 (+ ctx.obj.host "-swap"))
                                       (parted zfs-device "mkfs" 2 "linux-swap"))))
                           (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                                (if (in ctx.obj.host dataset)
                                    (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
                           (if encrypted
                               (setv dataset-options-dict.encryption "aes-256-gcm"
                                     dataset-options-dict.keyformat  "passphrase"))
                           (if deduplicated
                               (setv dataset-options-dict.dedup "edonr,verify"))
                           (if (.ismount os.path "/mnt")
                               (umount :R True "/mnt"))
                           (.export zpool :f True ctx.obj.host :m/ignore-stderr True)
                           (.update dataset-options-dict (dfor item pool-options :setv kv (.split item "=") [(get kv 0) (get kv 1)]))
                           (.update pool-options-dict (dfor item dataset-options :setv kv (.split item "=") [(get kv 0) (get kv 1)]))
                           (command :O { "repeat-with-values" (gfor [k v] (.items dataset-options-dict) f"{k}={v}") }
                                    :o { "repeat-with-values" (gfor [k v] (.items pool-options-dict) f"{k}={v}") }
                                    ctx.obj.host
                                    (if partition (+ "/dev/disk/by-label/" zfs-name) zfs-device))
                           (update-datasets ctx.obj.host swap encrypted deduplicated :pool True :reserved-only pool-only))
                      (print "Sorry; not continuing!\n\n"))
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

**** Mount

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-b" "--boot-device")
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :cls oreo.Option :xor [ "swap-device" ] :is-flag True)
   (.option click "-S" "--swap-device" :cls oreo.Option :xor [ "swap" ])
   (.option click "-i" "--install" :is-flag True)
   (.option click "-I" "--install-bootloader" :is-flag True)
   click.pass-context
   (defn mount [ ctx boot-device deduplicated encrypted root-device swap swap-device install install-bootloader ]
         (if ctx.obj.host
             (do (update-datasets ctx.obj.host :root-device root-device :encrypted encrypted :deduplicated deduplicated :swap swap)
                 (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                      (if (in ctx.obj.host dataset)
                          (break))
                      (else (.import zpool :f True ctx.obj.host)))
                 (if encrypted
                     (.load-key zfs ctx.obj.host))
                 (try (.mkdir (Path "/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt")
                                  (umount :R True "/mnt"))))
                 (if root-device
                     (Mount root-device "/mnt")
                     (Mount :t "zfs" (+ ctx.obj.host "/system/root") "/mnt"))
#+end_src

Taken from [[https://github.com/NixOS/nixpkgs/issues/73404#issuecomment-1011485428][here]]:

#+begin_src hy
                 (try (.mkdir (Path "/mnt/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt/mnt")
                                  (umount :R True "/mnt/mnt"))))
                 (Mount :bind True "/mnt" "/mnt/mnt")
#+end_src

#+begin_src hy
                 (.mkdir (Path "/mnt/etc/nixos") :parents True :exist-ok True)

                 (.mkdir (Path "/mnt/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/nix") "/mnt/nix")

                 (.mkdir (Path "/mnt/persist") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/persist") "/mnt/persist")

                 (if boot-device
                     (let [boot "/mnt/boot/efi"]
                          (.mkdir (Path boot) :parents True :exist-ok True)
                          (Mount boot-device boot)))
                 (if swap
                     (swapon (+ "/dev/zvol/" ctx.obj.host "/swap" :m/run True)))
                 (if swap-device
                     (swapon swap-device :m/run True))

                 (.mkdir (Path "/tmp") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp") "/tmp" :m/run True)

                 (.mkdir (Path "/tmp/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/tmp/nix" :m/run True)

                 ;; (rsync :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } :delete True "/nix/" "/tmp/nix/")
                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/nix" :m/run True)

                 (if (or install install-bootloader)
                     (.invoke ctx main :all True :install-bootloader install-bootloader)))
             (raise (NameError no-host-error-message)))))
#+end_src

**** Update

#+begin_src hy
#@((.command strapper)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-f" "--files" :is-flag True :help "Update datasets.nix with any new datasets; the default")
   (.option click "-p" "--pool" :is-flag True :help "Update the pool and datasets.nix with any new datasets")
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :type int :default 0)
   click.pass-context
   (defn update [ ctx deduplicated encrypted files pool root-device swap ]
         (if ctx.obj.host
             (try (setv ud (partial update-datasets ctx.obj.host :swap swap :encrypted encrypted :deduplicated deduplicated :root-device root-device))
                  (cond [files (ud)]
                        [pool (ud :pool True)]
                        [True (ud)])
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

*** End of strapper

#+begin_src hy :noweb-ref no
(if (= __name__ "__main__")
    (strapper :obj (D {})))
#+end_src

* default.nix

#+name: a4ca98a3-24f1-40c8-91ca-d3412e140d37
#+begin_src emacs-lisp
(getenv "HOME")
#+end_src

#+name: e47e0249-654e-41b8-a60d-eaeff38eed0e
#+begin_src emacs-lisp
(substring (shell-command-to-string "yadm gitconfig --get core.worktree") 0 -1)
#+end_src

#+begin_src nix :tangle (meq/tangle-path)
with builtins; let
    flakePath = "etc/nixos/flake.nix";
    etc = {
        root = rec {
            path = "/${flakePath}";
            exists = pathExists path;
        };
        local = rec {
            path = "${toString ./.}/${flakePath}";
            exists = pathExists path;
        };
    };
    userrepo = rec {
        path = "<<userrepo>>/${flakePath}";
        exists = pathExists path;
    };
    home = rec {
        path = "<<a4ca98a3-24f1-40c8-91ca-d3412e140d37()>>/${flakePath}";
        exists = pathExists path;
    };
    yadm = rec {
        path = "<<e47e0249-654e-41b8-a60d-eaeff38eed0e()>>/${flakePath}";
        exists = pathExists path;
    };
    flake = if etc.local.exists then (dirOf etc.local.path)
            else if userrepo.exists then (dirOf userrepo.path)
            else if etc.root.exists then (dirOf etc.root.path)
            else if yadm.exists then (dirOf yadm.path)
            else if home.exists then (dirOf home.path)
            else (fetchGit {
                url = "https://github.com/<<username>>/<<username>>";
                ref = "main";
            });
in import flake
#+end_src

* etc
** tailscale

#+name: dfabe3af-df4f-498b-94a7-5e8edafa64c8
#+begin_src emacs-lisp :var path=""
(shell-command-to-string (format "pass show %s" path))
#+end_src

*** apikeys
**** jeet.ray

#+begin_src text :tangle (meq/tangle-path) :tangle-mode (identity #o600)
<<dfabe3af-df4f-498b-94a7-5e8edafa64c8(path="keys/api/tailscale/jeet.ray")>>
#+end_src

** apk
*** repositories
:PROPERTIES:
:header-args:text+: :noweb-ref 7d9906c4-9fdb-4804-a0be-8020003d1ff9
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<7d9906c4-9fdb-4804-a0be-8020003d1ff9>>
#+end_src

#+begin_src text
http://postmarketos.brixit.nl/postmarketos/master
https://dl-cdn.alpinelinux.org/alpine/v3.13/main
https://dl-cdn.alpinelinux.org/alpine/v3.13/community
#+end_src

*** keys
**** build.postmarketos.org.rsa.pub
:PROPERTIES:
:header-args:text+: :noweb-ref build.postmarketos.org.rsa.pub
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<build.postmarketos.org.rsa.pub>>
#+end_src

#+begin_src text
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlXE4h6kp8aCzn6BjuOnz
Z1lcFSY+WRZ2vGUb5hEZ+YG75xYZW+yELr8P8+HSUrpBXF/HTQYKH/cNJc5zmOny
EsmcZskIYB0qgZPg02GXBV8VfjL+Es+y166g14IH2YKkdfplqHYVpCmnkmaZXQZu
ZAOEL2hyuzTAYYFhCZWHYYgdWfpnKDDlVcnw1Q3/LhADBlN63CW0UMWc5oJ7MwlY
SKriM60cHvER1YD5bdbGG/JTBFnB4djliLtvRNp+w3emwHmDhFmnYITN2WOHbYpV
P+RIfzq0IP978sKGJmd0RPuwl2ruifBYikm/F79Ko8lT2gVE40B7wqbInIGquTr1
deERIr47jcPRGl+01Svm0SxbXD1/zBNjo4wvMsZEW7Te689mFjxsXHnD7OEUQqh/
D1DhbnKJwpKwClYOi/aVDyGJunqavSR0QYPqN3nP+uXdBC4wuLI9gRS/yXNaxpMy
9AKwlD3uUhKzmJMJIu3L1/TH/vY9M5xZ2lnFduTZmL/X/4sjhyTb1ycFwU9UIY4C
u2CP/YLqiiquokgzpRfYwJyOP4quBVRC46Tejx5PzTCvnhro7LAzDoS756iBv9E/
2oxwC5VafGSChO+N8SyEBy532Gs+rcZDwUE7M9Y1GbQHW3ALMTwxstWqZ3GKWKd1
Cw6JQoywUhR09tFwQrYZao0CAwEAAQ==
-----END PUBLIC KEY-----
#+end_src

** nixos
*** default.nix

Taken from [[https://github.com/edolstra/flake-compat#usage][here]]:

#+begin_src nix :tangle (meq/tangle-path)
(import
  (
    let lock = builtins.fromJSON (builtins.readFile ./flake.lock); in
    fetchTarball {
      url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
      sha256 = lock.nodes.flake-compat.locked.narHash;
    }
  )
  { src = ./.; }
).defaultNix
#+end_src

*** patches
**** BACKPORT-Linux-5.8-compat-__vmalloc.patch

#+begin_src diff :tangle (meq/tangle-path)
From 6cc95288ccea12ad7b67b2b5b3997dfad8e5b5c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20Niew=C3=B6hner?=
 <c0d3z3r0@users.noreply.github.com>
Date: Tue, 9 Jun 2020 01:32:02 +0200
Subject: [PATCH] BACKPORT: Linux 5.8 compat: __vmalloc()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The `pgprot` argument has been removed from `__vmalloc` in Linux 5.8,
being `PAGE_KERNEL` always now [1].

Detect this during configure and define a wrapper for older kernels.

[1] https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/mm/vmalloc.c?h=next-20200605&id=88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Co-authored-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Co-authored-by: Michael Niewöhner <foss@mniewoehner.de>
Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Signed-off-by: Michael Niewöhner <foss@mniewoehner.de>
Closes #10422
---
 config/kernel-kmem.m4       | 26 ++++++++++++++++++++++++++
 config/kernel.m4            |  2 ++
 include/spl/sys/kmem.h      |  9 +++++++++
 module/spl/spl-kmem-cache.c |  4 ++--
 module/spl/spl-kmem.c       |  9 ++++-----
 5 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/config/kernel-kmem.m4 b/config/kernel-kmem.m4
index cc055e530..f1c0d2412 100644
--- a/config/kernel-kmem.m4
+++ b/config/kernel-kmem.m4
@@ -56,3 +56,29 @@ AC_DEFUN([SPL_AC_DEBUG_KMEM_TRACKING], [
    AC_MSG_CHECKING([whether detailed kmem tracking is enabled])
    AC_MSG_RESULT([$enable_debug_kmem_tracking])
 ])
+
+dnl #
+dnl # 5.8 API,
+dnl # __vmalloc PAGE_KERNEL removal
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL], [
+   ZFS_LINUX_TEST_SRC([__vmalloc], [
+       #include <linux/mm.h>
+       #include <linux/vmalloc.h>
+   ],[
+       void *p __attribute__ ((unused));
+
+       p = __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+   ])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL], [
+   AC_MSG_CHECKING([whether __vmalloc(ptr, flags, pageflags) is available])
+   ZFS_LINUX_TEST_RESULT([__vmalloc], [
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_VMALLOC_PAGE_KERNEL, 1, [__vmalloc page flags exists])
+   ],[
+       AC_MSG_RESULT(no)
+   ])
+])
+-
diff --git a/config/kernel.m4 b/config/kernel.m4
index b67fcef8c..23edfdcd8 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -45,6 +45,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
    ZFS_AC_KERNEL_SRC_SCHED
    ZFS_AC_KERNEL_SRC_USLEEP_RANGE
    ZFS_AC_KERNEL_SRC_KMEM_CACHE
+   ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_SRC_WAIT
    ZFS_AC_KERNEL_SRC_INODE_TIMES
    ZFS_AC_KERNEL_SRC_INODE_LOCK
@@ -163,6 +164,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
    ZFS_AC_KERNEL_SCHED
    ZFS_AC_KERNEL_USLEEP_RANGE
    ZFS_AC_KERNEL_KMEM_CACHE
+   ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_WAIT
    ZFS_AC_KERNEL_INODE_TIMES
    ZFS_AC_KERNEL_INODE_LOCK
diff --git a/include/spl/sys/kmem.h b/include/spl/sys/kmem.h
index 72d3a7765..ca15bfe7f 100644
--- a/include/spl/sys/kmem.h
+++ b/include/spl/sys/kmem.h
@@ -169,6 +169,15 @@ extern void *spl_kmem_alloc(size_t sz, int fl, const char *func, int line);
 extern void *spl_kmem_zalloc(size_t sz, int fl, const char *func, int line);
 extern void spl_kmem_free(const void *ptr, size_t sz);
 
+/*
+ * 5.8 API change, pgprot_t argument removed.
+ */
+#ifdef HAVE_VMALLOC_PAGE_KERNEL
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags, PAGE_KERNEL)
+#else
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags)
+#endif
+
 /*
  * The following functions are only available for internal use.
  */
diff --git a/module/spl/spl-kmem-cache.c b/module/spl/spl-kmem-cache.c
index d71b4b348..4866b2993 100644
--- a/module/spl/spl-kmem-cache.c
+++ b/module/spl/spl-kmem-cache.c
@@ -203,7 +203,7 @@ kv_alloc(spl_kmem_cache_t *skc, int size, int flags)
        ASSERT(ISP2(size));
        ptr = (void *)__get_free_pages(lflags, get_order(size));
    } else {
-       ptr = __vmalloc(size, lflags | __GFP_HIGHMEM, PAGE_KERNEL);
+       ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
    }
 
    /* Resulting allocated memory will be page aligned */
@@ -1242,7 +1242,7 @@ spl_cache_grow(spl_kmem_cache_t *skc, int flags, void **obj)
     * allocation.
     *
     * However, this can't be applied to KVM_VMEM due to a bug that
-    * __vmalloc() doesn't honor gfp flags in page table allocation.
+    * spl_vmalloc() doesn't honor gfp flags in page table allocation.
     */
    if (!(skc->skc_flags & KMC_VMEM)) {
        rc = __spl_cache_grow(skc, flags | KM_NOSLEEP);
diff --git a/module/spl/spl-kmem.c b/module/spl/spl-kmem.c
index cee69ad43..ca1fc145f 100644
--- a/module/spl/spl-kmem.c
+++ b/module/spl/spl-kmem.c
@@ -172,16 +172,15 @@ spl_kmem_alloc_impl(size_t size, int flags, int node)
         * kmem_zalloc() callers.
         *
         * For vmem_alloc() and vmem_zalloc() callers it is permissible
-        * to use __vmalloc().  However, in general use of __vmalloc()
-        * is strongly discouraged because a global lock must be
-        * acquired.  Contention on this lock can significantly
+        * to use spl_vmalloc().  However, in general use of
+        * spl_vmalloc() is strongly discouraged because a global lock
+        * must be acquired.  Contention on this lock can significantly
         * impact performance so frequently manipulating the virtual
         * address space is strongly discouraged.
         */
        if ((size > spl_kmem_alloc_max) || use_vmem) {
            if (flags & KM_VMEM) {
-               ptr = __vmalloc(size, lflags | __GFP_HIGHMEM,
-                   PAGE_KERNEL);
+               ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
            } else {
                return (NULL);
            }
-- 
2.25.1
#+end_src

**** export_kernel_fpu_functions_5_3.patch

#+begin_src diff :tangle (meq/tangle-path)
From 1e010beda2896bdf3082fb37a3e49f8ce20e04d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 2 May 2019 05:28:08 +0100
Subject: [PATCH] x86/fpu: Export kernel_fpu_{begin,end}() with
 EXPORT_SYMBOL_GPL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need these symbols in zfs as the fpu implementation breaks userspace:

https://github.com/zfsonlinux/zfs/issues/9346
Signed-off-by: Jörg Thalheim <joerg@thalheim.io>
---
 arch/x86/kernel/fpu/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 12c70840980e..352538b3bb5d 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -102,7 +102,7 @@ void kernel_fpu_begin(void)
    }
    __cpu_invalidate_fpregs_state();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_begin);
+EXPORT_SYMBOL(kernel_fpu_begin);
 
 void kernel_fpu_end(void)
 {
@@ -111,7 +111,7 @@ void kernel_fpu_end(void)
    this_cpu_write(in_kernel_fpu, false);
    preempt_enable();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_end);
+EXPORT_SYMBOL(kernel_fpu_end);
 
 /*
  * Save the FPU state (mark it for reload if necessary):
-- 
2.23.0
#+end_src

**** fetchpypi.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/fetchpypi.nix b/fetchpypi.nix
index e60c9df..df50c0d 100644
--- a/fetchpypi.nix
+++ b/fetchpypi.nix
@@ -24,5 +24,5 @@ in makeOverridable( {format ? "setuptools", sha256 ? "", hash ? "", ... } @attrs
   let
     url = computeUrl (builtins.removeAttrs attrs ["sha256" "hash"]) ;
   in fetchurl {
-    inherit url sha256 hash;
+    inherit url sha256;
   })
#+end_src

**** fetchurl.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/pkgs/build-support/fetchurl/boot.nix
+++ b/pkgs/build-support/fetchurl/boot.nix
@@ -6,7 +6,8 @@ let mirrors = import ./mirrors.nix; in
 , urls ? []
 , sha256
 , name ? baseNameOf (toString url)
-}:
+, ...
+} @ args:
 
 import <nix/fetchurl.nix> {
   inherit system sha256 name;
diff --git a/pkgs/build-support/fetchzip/default.nix b/pkgs/build-support/fetchzip/default.nix
index c61df8ceb00..d973837f0d3 100644
--- a/pkgs/build-support/fetchzip/default.nix
+++ b/pkgs/build-support/fetchzip/default.nix
@@ -14,7 +14,8 @@
 , name ? "source"
 , ... } @ args:
 
-(fetchurl ({
+let
+ x = (fetchurl ({
   inherit name;
 
   recursiveHash = true;
@@ -46,7 +47,11 @@
       mv "$unpackDir" "$out"
     '') #*/
     + extraPostFetch;
-} // removeAttrs args [ "stripRoot" "extraPostFetch" ])).overrideAttrs (x: {
+  } // removeAttrs args [ "stripRoot" "extraPostFetch" ]));
+
+in
+  x // {
+    # .overrideAttrs (x: {
   # Hackety-hack: we actually need unzip hooks, too
   nativeBuildInputs = x.nativeBuildInputs ++ [ unzip ];
-})
+}
#+end_src

**** grub_zfs.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -285,6 +285,7 @@ static const char *spa_feature_names[] = {
   "com.delphix:embedded_data",
   "com.delphix:extensible_dataset",
   "org.open-zfs:large_blocks",
+  "org.zfsonlinux:large_dnode",
   NULL
 };
#+end_src

**** set_power_mgmt.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/net/wireless/nl80211.c    2019-07-08 00:41:56.000000000 +0200
+++ b/net/wireless/nl80211.c    2020-02-05 19:30:26.352718504 +0100
@@ -10517,10 +10520,7 @@
    if (!rdev->ops->set_power_mgmt)
        return -EOPNOTSUPP;
 
-   state = (ps_state == NL80211_PS_ENABLED) ? true : false;
-
-   if (state == wdev->ps)
-       return 0;
+   state = false;
 
    err = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);
    if (!err)
#+end_src

*** users.json

#+name: 33b84622-7a1e-4a87-9c9f-fd10a3c13a8a
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** homes.json

#+name: d0d6dd01-0986-45be-9254-23c5483b54c0
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<userhome>>",
    "secondary": "/home/frost",
    "nightingale": "/home/curtis"
}
#+end_src

*** profiles
**** server.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }: let
    relayNo = if config.variables.relay then "no" else "yes";
    relayYes = if config.variables.relay then "yes" else "no";
in {
    imports = [ ../options.nix ];
    services.openssh = {
        enable = true;
        extraConfig = lib.mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
        '';
        permitRootLogin = "yes";
        openFirewall = config.variables.relay;
    };
    environment.systemPackages = with pkgs; [ inetutils mtr sysstat git ];
    variables.server = true;
}
#+end_src

*** devices
**** linode.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [
        ../profiles/server.nix
        "${(import ../..).inputs.nixos}/modules/profiles/qemu-guest.nix"
    ];
    boot = {
        kernelParams = [ "console=ttyS0,19200n8" ];
        loader.grub.extraConfig = ''
            serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
            terminal_input serial;
            terminal_output serial;
        '';
        initrd.availableKernelModules = [ "virtio_pci" "ahci" "sd_mod" ];
    };
    networking = {
        usePredictableInterfaceNames = false;
        interfaces.eth0.useDHCP = true;
    };
}
#+end_src

**** rpi3.nix

Adapted from [[https://nixos.wiki/wiki/NixOS_on_ARM/Raspberry_Pi_3][here]]:

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports =  [
        ../minimal.nix
        ../profiles/server.nix
    ];
    hardware.enableRedistributableFirmware = true;
    networking.wireless.enable = true;
    sound.enable = true;
    hardware.pulseaudio.enable = mkForce true;
    boot.loader.raspberryPi.firmwareConfig = ''
        dtparam=audio=on
    '';
    boot.kernelParams = [
        "console=ttyS1,115200n8"
    ];
    boot.loader.raspberryPi = {
        enable = true;
        version = 3;
        firmwareConfig = ''
            core_freq=250
        '';
    };
    systemd.services.btattach = {
        before = [ "bluetooth.service" ];
        after = [ "dev-ttyAMA0.device" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
            ExecStart = "${pkgs.bluez}/bin/btattach -B /dev/ttyAMA0 -P bcm -S 3000000";
        };
    };
    boot.loader.raspberryPi.enable = true;
    # Set the version depending on your raspberry pi. 
    boot.loader.raspberryPi.version = 3;
    # We need uboot
    boot.loader.raspberryPi.uboot.enable = true;
    # These two parameters are the important ones to get the
    # camera working. These will be appended to /boot/config.txt.
    boot.loader.raspberryPi.firmwareConfig = ''
        start_x=1
        gpu_mem=256
    '';
    boot.kernelModules = [ "bcm2835-v4l2" ];
    boot.initrd.kernelModules = [ "vc4" "bcm2835_dma" "i2c_bcm2835" ];
}
#+end_src

**** rpi4.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports =  [
        ../minimal.nix
        ../profiles/server.nix
        (import ../.).inputs.hardware.raspberry-pi-4
    ];
    boot.kernelPackages = lib.mkForce pkgs.linuxPackages_rpi4;
}
#+end_src

*** hosts

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

**** bastiodon
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi3.nix ];
    services.tailscale = {
        exitNode.advertise = true;
        acceptDNS = ! config.services.tailscale.exitNode.advertise;
    };
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    variables.relay = true;
}
#+end_src

**** sandshrew
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        (import ../..).inputs.hardware.microsoft-surface
    ];
    variables.encrypted = true;
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
        networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };

    # TODO
    # services.surface-dtx-daemon.detach = mkForce ''
    #     #!/usr/bin/env sh
    #     for usb in $(ls /dev/disk/by-id).split("\n"):
    #         if usb and usb[:4] == "usb-":
    #             for mnt in $(mount).split("\n"):
    #                 if mnt and usb in mnt:
    #                     umount @(mnt.split()[2])
    # '';

}
#+end_src

**** siluam
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        "${(import ../..).inputs.pinebook-pro}/pinebook_pro.nix"
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    swapDevices = [ { device = "/dev/mmcblk2p2"; } ];
}
#+end_src

**** murasame
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../minimal.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** argus
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports = [ ../../devices/linode.nix ../../minimal.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    variables.relay = true;
}
#+end_src

**** yggdrasil
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    variables.zfs = false;
}
#+end_src

**** enterprise
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

*** lib.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref d9031cd2-74a9-4239-b22d-fcc00b37e0f8
:END:

#+begin_src text :tangle (meq/tangle-path)
<<d9031cd2-74a9-4239-b22d-fcc00b37e0f8>>
#+end_src

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+begin_src nix
with builtins; { hello, lib, inputs ? {}, system ? currentSystem, extras ? {} }: with lib; let
    newLib = self: extras // (rec {

        # TODO: Is this necessary?
        mntConvert = dir: let mntDir = "/mnt/" + dir; in if (pathExists mntDir) then mntDir else dir;

        zipToSet = names: values: listToAttrs (
            map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
                if hasAttrs then names else (sort lessThan names)
            ) (
                if hasAttrs then values else (sort lessThan values)
            ))
        );
        foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter isAttrs list);
        foldToSet' = list: foldr (new: old: new // old) {} (filter isAttrs list);
        mif = {
            list = condition: value: optionals condition value;
            list' = condition: value: optional condition value;
            set = condition: value: optionalAttrs condition value;
            num = condition: value: if condition then value else 0;
            null = condition: value: if condition then value else null;
            str = condition: value: optionalString condition value;
            drv = condition: value: if condition then value else hello;
        };
        readDirExists = dir: mif.set (pathExists dir) (readDir dir);
        toCapital = string: concatImapStrings (
            i: v: if (i == 0) then (toUpper v) else v
        ) (stringToCharacters string);
        sequence = list: end: foldr (a: b: deepSeq a b) end list;
        filters = {
            remove = {
                prefix = ignores: list: filter (f: ! any (i: hasPrefix i f) ignores) list;
                suffix = ignores: list: filter (f: ! any (i: hasSuffix i f) ignores) list;
                infix = ignores: list: filter (f: ! any (i: hasInfix i f) ignores) list;
            };
        };
        dirCon = let
            aord = dir: func: attrNames (filterAttrs func (if (isAttrs dir) then dir else (readDirExists dir)));
        in {
            dirs = dir: aord dir (n: v: v == "directory");
            others = dir: aord dir (n: v: v != "directory");
            files = dir: aord dir (n: v: v == "regular");
            sym = dir: aord dir (n: v: v == "symlink");
            unknown = dir: aord dir (n: v: v == "unknown");
        };
        recurseDir = { dir, local ? false, iter ? 0, ignores ? {} }: with lib; let
            stringDir = toString dir;
            recurse = unique (flatten [
                (map (n: "${stringDir}/${n}") (dirCon.others dir))
                (map (dir': recurseDir { dir = "${stringDir}/${dir'}"; inherit local; iter = iter + 1; }) (dirCon.dirs dir))
            ]);
            processed-prefix = map (i: if (local == null) then i else if (local == 0) then "/${i}" else if local then "./${i}" else if (! local) then "${stringDir}/${i}" else i) (ignores.prefix or []);
            process' = recurse': let
                stringDir' = "${stringDir}/";
            in if (local == null) then (map (f: replaceStrings [ stringDir' ] [ "" ] f) recurse') else if (local == 0) then (map (f: replaceStrings [ stringDir' ] [ "/" ] f) recurse') else if local then (map (f: replaceStrings [ stringDir' ] [ "./" ] f) recurse') else recurse';
            process = recurse': with filters.remove; pipe recurse' [ process' (prefix processed-prefix) (suffix (ignores.suffix or [])) (infix (ignores.infix or [])) ];
        in if (iter == 0) then (process recurse) else recurse;
        has = {
            prefix = prefixes: string: any (prefix: hasPrefix prefix string) prefixes;
            suffix = suffixes: string: any (suffix: hasSuffix suffix string) suffixes;
            infix = infixes: string: any (infix: hasInfix infix string) infixes;
        };
        import = let
            args = {
                suffix = "";
                ignores = [];
            };
            name = {
                suffix ? args.suffix,
                noSuffix ? suffix == "",
                file
            }: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));
            # !!! This returns a function
            filterFunc = {
                suffix ? args.suffix,
                noSuffix ? suffix == "",
                ignores ? args.ignores,
                dir,
            }: let
                _ignores = flatten [
                    ignores
                    (let _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix"); in mif.list (pathExists _ignores') (import _ignores'))
                    "default" # triggers infinite recursion if modules are defined here
                    "deprecated"
                    "nix" # niv
                    "shell" # nix-shell
                ];
            in file: value:
                (if noSuffix then (
                    (hasSuffix ".nix" file) || (value == "directory")
                ) else (hasSuffix suffix file)) &&
                (!hasPrefix "_" file) &&
                (!elem (name { inherit suffix file noSuffix; }) _ignores);
            contents = _args@{
                suffix ? args.suffix,
                ignores ? args.ignores,
                dir,
            }: filterAttrs (filterFunc _args) (readDirExists dir);
        in rec {
            inherit name;
            list = _args@{
                suffix ? args.suffix,
                ignores ? args.ignores,
                dir,

                # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
                func ? (n: v: dir + "/${n}"),

            }: let
                __args = removeAttrs _args [ "func" ];
            in mapAttrsToList func (contents __args);
            listNames = {
                suffix ? args.suffix,
                ignores ? args.ignores,
                dir
            }: list {
                inherit suffix ignores dir;
                func = (n: v: name { inherit suffix; file = n; });
            };
            set = _args@{
                call ? null,
                suffix ? args.suffix,
                ignores ? args.ignores,
                dir,
                modules ? {},

                # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
                func ? (n: v: dir + "/" + n),

            }: let
                files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" "call" ]) _args);
            in listToAttrs (map (file: nameValuePair
                (name { inherit suffix file; })
                (if (call != null) then (call.callPackage file modules)
                 else (import file (foldToSet [ modules inputs ])))
            ) files);
#+end_src

Deprecated Set Function:

#+begin_src nix :noweb-ref no
            set = _args@{
                suffix ? args.suffix,
                ignores ? args.ignores,
                dir,
                modules ? {},

                # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
                func ? (n: v: dir + "/" + n),

            }: let
                files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
            in zipToSet
                (map (file: name { inherit suffix file; }) files)
                (map (file: import file (foldToSet [ modules inputs ])) files);
#+end_src

#+begin_src nix
        };
        attrs = rec {
            configs = {
                nixpkgs = {
                    allowUnfree = true;
                    allowBroken = true;
                    allowUnsupportedSystem = true;
                    # preBuild = ''
                    #     makeFlagsArray+=(CFLAGS="-w")
                    #     buildFlagsArray+=(CC=cc)
                    # '';
                    permittedInsecurePackages = [
                        "python2.7-cryptography-2.9.2"
                    ];
                };
                nix = let
                    MG = size: let
                        mg = stringToCharacters size;
                    in toString ((toInt (elemAt mg 0)) * (
                        if (elemAt mg 1 == "M") then 1 else 1024
                    ) * 1024 * 1024);
                in ''
                    <<270d5d30-951e-4171-8c23-67fc45d20578()>>
                    min-free = ${MG "250M"}
                    max-free = ${MG "1G"}
                '';
                services = rec {
                    mkBase = User: {
                        enable = true;
                        serviceConfig = rec {
                            Restart = "on-failure";
                            inherit User;
                            Group = User;
                            Environment = [ "PATH=/run/wrappers/bin:$PATH" ];
                        };
                        wantedBy = [ "multi-user.target" ];
                    };
                    base = mkBase users.primary;
                    mkdir = path: "/run/current-system/sw/bin/mkdir -p ${path} &> /dev/null";
                };
            };
            users = fromJSON (readFile ./users.json);
            usernames = attrValues users;
            designations = attrNames users;

            excludedUsers = { root = "root"; };
            excludedUsernames = attrValues excludedUsers;
            excludedDesignations = attrNames excludedUsers;

            allUsers = recursiveUpdate users excludedUsers;
            allUsernames = attrValues allUsers;
            allDesignations = attrNames allUsers;

            homes = fromJSON (readFile ./homes.json);
            excludedHomes = { root = "/root"; };
            allHomes = recursiveUpdate homes excludedHomes;

            datasets = {
                backup = [
                    "system/persist"
                    "virt"
                    "omniverse"
                    users.primary
                ];
            };
            platforms = {
                arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
                imd = [ "i686-linux" "x86_64-linux" ];
            };
            arms = elem system platforms.arm;
            no-arms = !arms;
            ssh.keys = rec {
                "id_rsa.bak" = "<<652c4828-b716-42a1-b777-b37b99b468a7>>";
                "id_ed25519.bak" = "<<ec2d5c28-4cbc-4f9b-aa60-835fff096273>>";
                jeet_ray_ecdsa = "<<757d7c7f-bbd3-49b3-a47e-84158337318c>>";
                jeet_ray_ed25519 = "<<9d0e196f-1118-43bb-8b2f-0650e49b211a>>";
                jeet_ray_rsa = "<<ec44d933-c4ac-4da5-8086-f1d7b4358139>>";
                shadowrylander_ecdsa = "<<9320021a-a3d7-4bd5-9f80-269073d02a2a>>";
                shadowrylander_ed25519 = "<<12713489-9696-4a9a-8e92-242011772051>>";
                shadowrylander_rsa = "<<3325c6f6-a054-41bf-a941-7dd6ad5f6124>>";
                id_rsa = shadowrylander_rsa;
                id_ed25519 = jeet_ray_ed25519;
                id_ecdsa = jeet_ray_ecdsa;
            };
            fileSystems = {
                base = {
                    fsType = "zfs";
                    options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
                };
                supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"

                    # TODO
                    # "bcachefs"

                ];
            };
            commands = {
                rebuild = "nixos-rebuild --show-trace";
                install = "nixos-install --show-trace";
            };
            versions = {
                python = {
                    two = "7";
                    three = "10";
                };
            };
        };
    });
    extension = makeExtensible newLib;
in with lib; extension.extend (final: prev: extension.foldToSet (attrValues prev))
#+end_src

*** callPackages
**** caddy.nix

Adapted from [[https://github.com/NixOS/nixpkgs/issues/14671#issuecomment-1016376290][here]]; allows me to build ~caddy~ with plugins:

#+begin_src nix :tangle (meq/tangle-path)
{ lib, fetchFromGitHub, buildGoModule }: with lib; let
    imports = flip concatMapStrings [
        "github.com/mholt/caddy-l4@latest"
        "github.com/abiosoft/caddy-yaml@latest"
        "github.com/caddy-dns/cloudflare@latest"
    ] (pkg: "\t\t\t_ \"${pkg}\"\n");
	main = ''
		package main

		import (
			caddycmd "github.com/caddyserver/caddy/v2/cmd"
			_ "github.com/caddyserver/caddy/v2/modules/standard"
			${imports}
		)

		func main() {
			caddycmd.Main()
		}
	'';
in buildGoModule rec {
	pname = "caddy";
	version = "2.5.1";
    runVend = true;
	subPackages = [ "cmd/caddy" ];

	src = fetchFromGitHub {
		owner = "caddyserver";
        repo = pname;
        rev = "v${version}";
		sha256 = "1nlphjg5wh5drpwkm4cczrkxdzbv72ll7hp5x7z6ww8pzz3q10b3";
	};

	vendorSha256 = "sha256-xu3klc9yb4Ws8fvXRV286IDhi/zQVN1PKCiFKb8VJBo=";

	overrideModAttrs = (_: {
		preBuild    = "echo '${main}' > cmd/caddy/main.go";
		postInstall = "cp go.sum go.mod $out/";
	});

	postPatch = ''
		echo '${main}' > cmd/caddy/main.go
	'';

	postConfigure = ''
		cp vendor/go.sum ./
		cp vendor/go.mod ./
	'';

	meta = {
		homepage = https://caddyserver.com;
		description = "Fast, cross-platform HTTP/2 web server with automatic HTTPS";
		license = licenses.asl20;
    	maintainers = with maintainers; [ Br1ght0ne ];
	};
}
#+end_src

**** guix.nix

Adapted from [[https://github.com/pukkamustard/nixpkgs/blob/guix/pkgs/development/guix/guix.nix][here]]:

#+begin_src nix :tangle (meq/tangle-path)
{stdenv, fetchurl, lib}: stdenv.mkDerivation rec {
    name = "guix-${version}";
    version = "1.0.0";

    src = fetchurl {
      url = "https://ftp.gnu.org/gnu/guix/guix-binary-${version}.${stdenv.targetPlatform.system}.tar.xz";
      sha256 = {
        "x86_64-linux" = "11y9nnicd3ah8dhi51mfrjmi8ahxgvx1mhpjvsvdzaz07iq56333";
        "i686-linux" = "14qkz12nsw0cm673jqx0q6ls4m2bsig022iqr0rblpfrgzx20f0i";
        "aarch64-linux" = "0qzlpvdkiwz4w08xvwlqdhz35mjfmf1v3q8mv7fy09bk0y3cwzqs";
        }."${stdenv.targetPlatform.system}";
    };
    sourceRoot = ".";

    outputs = [ "out" "store" "var" ];
    phases = [ "unpackPhase" "installPhase" ];

    installPhase = ''
      # copy the /gnu/store content
      mkdir -p $store
      cp -r gnu $store

      # copy /var content
      mkdir -p $var
      cp -r var $var

      # link guix binaries
      mkdir -p $out/bin
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix $out/bin/guix
      ln -s /var/guix/profiles/per-user/root/current-guix/bin/guix-daemon $out/bin/guix-daemon
    '';

    meta = with lib; {
      description = "The GNU Guix package manager";
      homepage = https://www.gnu.org/software/guix/;
      license = licenses.gpl3Plus;
      maintainers = [ maintainers.johnazoidberg ];
      platforms = [ "aarch64-linux" "i686-linux" "x86_64-linux" ];
    };
}
#+end_src

**** flk.nix

#+begin_src nix :tangle (meq/tangle-path)
{ stdenv, fetchgit, lib }: stdenv.mkDerivation rec {
    pname = "flk";
    version = "1.0.0.0";

    src = fetchgit {
        url = "https://github.com/chr15m/flk.git";
        rev = "46a88bdb461dda336d5aca851c16d938e05304dc";
        sha256 = "sha256-NAhWe0O1K3LOdIwYNOHfkBzkGm+h0wckpsCuY/lY/+8=";
        deepClone = true;
    };

    installPhase = ''
        mkdir --parents $out/bin
        cp ./docs/flk $out/bin/
    '';

    meta = {
        description = "A LISP that runs wherever Bash is";
        homepage = "https://github.com/chr15m/flk";
        license = lib.licenses.mpl20;
    };
}
#+end_src

**** mdsh.nix

#+begin_src nix :tangle (meq/tangle-path)
{ stdenv, fetchFromGitHub, lib }: stdenv.mkDerivation rec {
    pname = "mdsh";
    version = "1.0.0.0";

    src = fetchFromGitHub {
        owner = "bashup";
        repo = pname;
        rev = "7e7af618a341eebd50e7825b062bc192079ad5fc";
        sha256 = "1wg5iy1va2fl843rish2q1kif818cz8mnhwmg88ir5p364fc2kcp";
    };

    installPhase = ''
        mkdir --parents $out/bin
        cp "$src/bin/mdsh" $out/bin/
    '';

    meta = {
        description = "Multi-lingual, Markdown-based Literate Programming... in run-anywhere bash";
        homepage = "https://github.com/bashup/mdsh";
        license = lib.licenses.mit;
    };
}
#+end_src

**** poetry2setup.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, Python
, fetchFromGitHub
, gawk
}:

Python.pkgs.buildPythonApplication rec {
  pname = "poetry2setup";
  version = "1.0.0";
  format = "pyproject";

  src = fetchFromGitHub {
    owner = "abersheeran";
    repo = pname;
    rev = "6d3345f488fda4d0f6eed1bd3438ea6207e55e3a";
    sha256 = "07z776ikj37whhx7pw1f3pwp25w04aw22vwipjjmvi8c642qxni4";
  };

  propagatedBuildInputs = with Python.pkgs; [ poetry-core ];

  buildInputs = with Python.pkgs; [ poetry-core ];

  installPhase = ''
    mkdir --parents $out/bin
    cp $src/${pname}.py $out/bin/${pname}
    chmod +x $out/bin/${pname}
    ${gawk}/bin/awk -i inplace 'BEGINFILE{print "#!/usr/bin/env python3"}{print}' $out/bin/${pname}
  '';

  postFixup = "wrapProgram $out/bin/${pname} $makeWrapperArgs";

  makeWrapperArgs = [ "--prefix PYTHONPATH : ${placeholder "out"}/lib/${Python.pkgs.python.libPrefix}/site-packages" ];

  meta = {
    description = "Convert python-poetry(pyproject.toml) to setup.py.";
    homepage = "https://github.com/abersheeran/${pname}";
    license = lib.licenses.mit;
  };
}
#+end_src

**** settings.nix

#+begin_src nix :tangle (meq/tangle-path)
{ stdenv, fetchFromGitHub }: stdenv.mkDerivation rec {
    pname = "settings";
    version = "1.0.0.0";

    src = fetchFromGitHub {
        owner = "sylvorg";
        repo = pname;
        rev = "7b3fc6e974a5c2927b2282b9cb9842f498d5a9ce";
    	sha256 = "0cq7kfycd66137a6cjgfq0jkxp13jx01v03rrdjcci9d6gz1ysmh";
    };

    phases = [ "installPhase" ];

    installPhase = ''
        mkdir --parents $out
        cp -r $src/bin $out/bin
        chmod +x $out/bin/*
    '';

    meta.mainprogram = "org-tangle";
}
#+end_src

**** tailapi.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, Python
, fetchFromGitHub
}:

Python.pkgs.buildPythonApplication rec {
  pname = "tailapi";
  version = "1.0.0.0";

  src = fetchFromGitHub {
    owner = "syvlorg";
    repo = pname;
    rev = "ada101b9c2919cfbe365c7d5fe71710d95425ca3";
    sha256 = "0bywlkbwxsnf11i1kv36ls2yax0pp30qmgcyfq3gcmzzhcgk2q3k";
  };

  propagatedBuildInputs = with Python.pkgs; [
    oreo
    requests
  ];

  installPhase = ''
    mkdir --parents $out/bin
    cp $src/${pname}.py $out/bin/${pname}
    chmod +x $out/bin/${pname}
  '';

  postFixup = "wrapProgram $out/bin/${pname} $makeWrapperArgs";

  makeWrapperArgs = [
    # "--prefix" "PATH" ":" (lib.makeBinPath [ git ])
    "--prefix PYTHONPATH : ${placeholder "out"}/lib/${Python.pkgs.python.libPrefix}/site-packages"
  ];

  meta.homepage = "https://github.com/syvlorg/${pname}";
}
#+end_src

**** python3
***** autoslot.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchFromGitHub
, pytestCheckHook
, flit
}:

buildPythonPackage rec {
  pname = "autoslot";
  version = "2021.10.1";
  format = "pyproject";

  src = fetchFromGitHub {
    owner = "cjrh";
    repo = pname;
    rev = "a36ea378136bc7dfdc11f3f950186f6ed8bee8c5";
    sha256 = "1dds9dwf5bqxi84s1fzcdykiqgcc1iq3rh6p76wjz6h7cb451h08";
  };

  buildInputs = [ flit ];
  nativeBuildInputs = buildInputs;

  checkInputs = [ pytestCheckHook ];

  pythonImportsCheck = [ "autoslot" ];

  meta = {
    description = "Automatic __slots__ for your Python classes";
    homepage = "https://github.com/cjrh/autoslot";
    license = lib.licenses.asl20;
  };
}
#+end_src

***** oreo.nix

#+begin_src nix :tangle (meq/tangle-path)
{ buildPythonPackage
, fetchFromGitHub
, pythonOlder
, poetry-core
, addict
, autoslot
, click
, coconut
, cytoolz
, hy
, hyrule
, more-itertools
, nixpkgs
, rich
, toolz
}:

buildPythonPackage rec {
  pname = "oreo";
  version = "1.0.0.0";
  format = "pyproject";
  disabled = pythonOlder "3.9";

  src = fetchFromGitHub {
    owner = "syvlorg";
    repo = pname;
    rev = "6cb1453b0d13613ca1d19bd1b419b107b99a2f6d";
    sha256 = "0cizhp6p70sx8a388iyy005q0xm83db052f0rwcwmcaxmqvq74zb";
  };

  buildInputs = [ poetry-core ];
  nativeBuildInputs = buildInputs;

  propagatedBuildInputs = [
      addict
      autoslot
      click
      coconut
      cytoolz
      hy
      hyrule
      more-itertools
      nixpkgs
      rich
      toolz
  ];

  pythonImportsCheck = [ "oreo" ];

  postPatch = ''
    substituteInPlace pyproject.toml --replace "rich = { git = \"https://github.com/syvlorg/rich.git\", branch = \"master\" }" ""
    substituteInPlace setup.py --replace "'rich @ git+https://github.com/syvlorg/rich.git@master'," ""
  '';

  meta = {
    description = "The Stuffing for Other Functions!";
    homepage = "https://github.com/syvlorg/oreo";
  };
}
#+end_src

***** bakery.nix

#+begin_src nix :tangle (meq/tangle-path)
{ buildPythonPackage
, fetchFromGitHub
, pythonOlder
, poetry-core
, oreo
}:

buildPythonPackage rec {
  pname = "bakery";
  version = "2.0.0.0";
  format = "pyproject";
  disabled = pythonOlder "3.9";

  src = fetchFromGitHub {
    owner = "syvlorg";
    repo = pname;
    rev = "45cb6fd6153f60cacd00860c042c4517bfe2681e";
    sha256 = "067d61nn6s766p9icca5zs35429v8rbb6zkww6pab1wf9q084g7i";
  };

  buildInputs = [ poetry-core ];
  nativeBuildInputs = buildInputs;

  propagatedBuildInputs = [ oreo ];

  pythonImportsCheck = [ "bakery" ];

  postPatch = ''
    substituteInPlace pyproject.toml --replace "oreo = { git = \"https://github.com/syvlorg/oreo.git\", branch = \"main\" }" ""
    substituteInPlace setup.py --replace "'oreo @ git+https://github.com/syvlorg/oreo.git@main'" ""
  '';

  meta = {
    homepage = "https://github.com/syvlorg/bakery";
  };
}
#+end_src

***** backtrace.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchFromGitHub
, pytestCheckHook
, colorama
}:

buildPythonPackage rec {
  pname = "backtrace";
  version = "0.2.1";

  src = fetchFromGitHub {
    owner = "nir0s";
    repo = pname;
    rev = "a1f75c956f669a6175088693802d5392e6bd7e51";
    sha256 = "1i3xj04zxz9vi57gbkmnnyh9cypf3bm966ic685s162p1xhnz2qp";
  };

  propagatedBuildInputs = [ colorama ];

  checkInputs = [ pytestCheckHook ];

  pythonImportsCheck = [ "backtrace" ];

  meta = {
    description = "Makes Python tracebacks human friendly";
    homepage = "https://github.com/nir0s/backtrace";
    license = lib.licenses.asl20;
  };
}
#+end_src

***** xontrib-readable-traceback.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchPypi
, colorama
, backtrace
}:

buildPythonPackage rec {
  pname = "xontrib-readable-traceback";
  version = "0.3.2";

  src = fetchPypi {
    inherit pname version;
    sha256 = "sha256-1D/uyiA3A1dn9IPakjighckZT5Iy2WOMroBkLMp/FZM=";
  };

  propagatedBuildInputs = [ colorama backtrace ];

  meta = {
    description = "xonsh readable traceback";
    homepage = "https://github.com/vaaaaanquish/xontrib-readable-traceback";
    license = lib.licenses.mit;
  };
}
#+end_src

***** xonsh-autoxsh.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchPypi
}:

buildPythonPackage rec {
  pname = "xonsh-autoxsh";
  version = "0.3";

  src = fetchPypi {
    inherit pname version;
    sha256 = "sha256-qwXbNbQ5mAwkZ4N+htv0Juw2a3NF6pv0XpolLIQfIe4=";
  };

  meta = {
    description = "Automatically execute scripts for directories in Xonsh Shell.";
    homepage = "https://github.com/Granitosaurus/xonsh-autoxsh";
    license = lib.licenses.mit;
  };
}
#+end_src

***** xonsh-direnv.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchPypi
}:

buildPythonPackage rec {
  pname = "xonsh-direnv";
  version = "1.5.0";

  src = fetchPypi {
    inherit pname version;
    sha256 = "sha256-OLjtGD2lX4Yf3aHrxCWmAbSPZnf8OuVrBu0VFbsna1Y=";
  };

  meta = {
    description = "xonsh extension for using direnv";
    homepage = "https://github.com/Granitosaurus/xonsh-direnv";
    license = lib.licenses.mit;
  };
}
#+end_src

***** xontrib-pipeliner.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchPypi
, six
}:

buildPythonPackage rec {
  pname = "xontrib-pipeliner";
  version = "0.3.4";

  src = fetchPypi {
    inherit pname version;
    sha256 = "sha256-f8tUjPEQYbycq1b3bhXwPU2YF9fkp1URqDDLH2CeNpo=";
  };

  propagatedBuildInputs = [ six ];

  postPatch = ''
    substituteInPlace setup.py --replace "'xonsh', " ""
  '';

  meta = {
    description = "Let your pipe lines flow thru the Python code in xonsh.";
    homepage = "https://github.com/anki-code/xontrib-sh";
    license = lib.licenses.mit;
  };
}
#+end_src

***** xontrib-sh.nix

#+begin_src nix :tangle (meq/tangle-path)
{ lib
, buildPythonPackage
, fetchPypi
}:

buildPythonPackage rec {
  pname = "xontrib-sh";
  version = "0.3.0";

  src = fetchPypi {
    inherit pname version;
    sha256 = "sha256-eV++ZuopnAzNXRuafXXZM7tmcay1NLBIB/U+SVrQV+U=";
  };

  meta = {
    description = "Paste and run commands from bash, zsh, fish, tcsh in xonsh shell.";
    homepage = "https://github.com/anki-code/xontrib-sh";
    license = lib.licenses.mit;
  };
}
#+end_src

*** overlays.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref overlays.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<overlays.nix>>
#+end_src

**** Arguments

#+begin_src nix
args@{ lib, nixpkgs, inputs, pkgs, channel }: with builtins; with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** Update Python Packages

Adapted from [[https://discourse.nixos.org/t/how-to-add-custom-python-package/536/4][here]]:

#+begin_src nix
    updatePython = pv: prev: attrs: { "${pv}" = prev.${pv}.override { packageOverrides = new: old: old // attrs; }; };
#+end_src

#+begin_src nix
    updatePythonPackage = pv: prev: pkg: func: updatePython pv prev { "${pkg}" = prev.${pv}.pkgs.${pkg}.overridePythonAttrs func; };
    updatePythonPackages = pv: final: prev: dir: updatePython pv prev (j.import.set { call = final.${pv}.pkgs; inherit dir; ignores = j.dirCon.dirs dir; });
    pv2 = "python2${j.attrs.versions.python.two}";
    pv3 = "python3${j.attrs.versions.python.three}";
#+end_src

***** End of Let

#+begin_src nix
in flatten [
#+end_src

**** J

#+begin_src nix
(final: prev: { j = { inherit pkgs; };})
#+end_src

**** lib

#+begin_src nix
(final: prev: { inherit lib; })
#+end_src

**** Patched Fetchers

#+begin_src nix :noweb-ref no
(final: prev: {
    fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchurl.patch ];});
    fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchpypi.patch ];});
})
#+end_src

**** Rust

This is used to get all the rust packages in ~nixpkgs~:

#+begin_src shell
nix eval --impure --expr 'with builtins; let pkgs = import (fetchGit { url = "https://github.com/nixos/nixpkgs"; ref = (fromJSON (readFile ./etc/nixos/flake.lock)).nodes.<<channel>>.original.ref; }) {}; in with pkgs; with lib; attrNames (filterAttrs (n: v: all (b: b == true) [ (! elem n [ ]) (tryEval v).success (v ? patchRegistryDeps) ]) pkgs)' 1> ./etc/nixos/rust-packages.nix
#+end_src

#+name: 947c9d7c-a6bc-4ddc-b2a5-38830b0521d2
#+begin_src emacs-lisp
(setq command (concat "nix eval --impure --expr "
                          "'with builtins; let "
                              "pkgs = import (fetchGit { "
                                  "url = \"https://github.com/nixos/nixpkgs\"; "
                                  "ref = (fromJSON (readFile ./etc/nixos/flake.lock)).nodes.<<channel>>.original.ref; "
                              "}) {}; "
                          "in with pkgs; with lib; "
                              "attrNames (filterAttrs (n: v: all (b: b == true) [ "
                                  "(! elem n [ ]) "
                                  "(tryEval v).success "
                                  "(v ? patchRegistryDeps) "
                              "]) pkgs)' "
                      "&> ./etc/nixos/rust-packages.nix"))
;; (message command)
(shell-command command)
"(import ./rust-packages.nix)"
#+end_src

#+begin_src nix
(final: prev: genAttrs <<947c9d7c-a6bc-4ddc-b2a5-38830b0521d2()>> (pkg: final.j.pkgs.${channel}.${pkg}))
#+end_src

**** Python

#+begin_src nix
(final: prev: rec {
    Python2 = final.${pv2};
    Python2Packages = final."${pv2}Packages";
    Python3 = final.${pv3};
    Python3Packages = final."${pv3}Packages";
    Python = Python3;
    PythonPackages = Python3Packages;
})
#+end_src

***** Flit

#+begin_src nix
(final: prev: let newInputs = [ final.git ]; in updatePythonPackage pv3 prev "flit" (old: {
    buildInputs = newInputs ++ (old.buildInputs or []);
    nativeBuildInputs = newInputs ++ (old.nativeBuildInputs or []);
}))
#+end_src

***** Rich

#+begin_src nix
(final: prev: updatePythonPackage pv3 prev "rich" (old: {
    version = "12.0.0";
    src = final.fetchFromGitHub {
        owner = "syvlorg";
        repo = old.pname;
        rev = "a6c20ce10adc7b8cfacfd74e0b025e8c2c8c19eb";
        sha256 = "1ld3ihvssfk56240wignmd6hv7gynid5wmcynl58ng8sbfywm3ly";
    };
    propagatedBuildInputs = (with final.PythonPackages; [ hy ]) ++ old.propagatedBuildInputs;
    meta = {
        description = "Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal";
        homepage = "https://github.com/syvlorg/rich";
        license = lib.licenses.mit;
    };
}))
#+end_src

***** Xonsh

#+begin_src nix
(final: prev: { xonsh = prev.xonsh.overridePythonAttrs (old: { propagatedBuildInputs = (with final.PythonPackages; [ 
    bakery
    xontrib-sh
    xontrib-readable-traceback
    xontrib-pipeliner
    xonsh-autoxsh
    xonsh-direnv
]) ++ old.propagatedBuildInputs; }); })
#+end_src

**** NIX

#+begin_src nix :noweb-ref no
inputs.nix.overlay
#+end_src

**** NUR

#+begin_src nix
(final: prev: { nur = import inputs.nur { nurpkgs = nixpkgs; pkgs = prev; }; })
#+end_src

**** Emacs

#+begin_src nix
inputs.emacs.overlay
#+end_src

**** Systemd
***** Homed

# TODO

#+begin_src nix :noweb-ref no
(final: prev: { systemd = prev.systemd.overrideAttrs (old: { withHomed = true; }); })
#+end_src

**** Mozilla

# TODO

#+begin_src nix :noweb-ref no
(final: prev: inputs.mozilla.overlays)
#+end_src

**** My Packages

#+begin_src nix
(final: prev: let dir = ./callPackages; in j.import.set { call = final; inherit dir; ignores = j.dirCon.dirs dir; })
#+end_src

***** Default

#+begin_src nix
(final: prev: { default = final.settings; })
#+end_src

***** Python2

#+begin_src nix
(final: prev: updatePythonPackages pv2 final prev ./callPackages/python2)
#+end_src

***** Python3

#+begin_src nix
(final: prev: updatePythonPackages pv3 final prev ./callPackages/python3)
#+end_src

**** Overlays in Overlays Directory

#+begin_src nix
(final: prev: let dir = ./overlays; in j.import.set { inherit dir; ignores = j.dirCon.dirs dir; })
#+end_src

**** Overrides from Older Channels

You can use attribute sets to reassign packages from a particular channel, such as ~{ gcc10 = "gcc11" }~ assigned to ~nixos-unstable~ will have ~pkgs.gcc10~ call ~nixos-unstable.gcc11~ instead:

#+begin_src nix
(let pkgsets = {
    # nixos-unstable = [ "gnome-tour" ];
    # nixos-unstable = "gnome-tour";
    # nixos-unstable = { python3 = "python310"; };
};
in mapAttrsToList (
    pkgchannel: pkglist': let
        pkglist = if (isString pkglist') then [ pkglist' ] else pkglist';
    in map (
        pkg': let
            pkgIsAttrs = isAttrs pkg';
            pkg1 = if pkgIsAttrs then (last (attrNames pkg')) else pkg';
            pkg2 = if pkgIsAttrs then (last (attrValues pkg')) else pkg';
            self = (pkgchannel == channel) || (pkgchannel == "self");
        in final: prev: { "${pkg1}" = if self then (if pkgIsAttrs then final.${pkg2} else prev.${pkg2}) else final.j.pkgs.${pkgchannel}.${pkg2}; }
    ) pkglist
) pkgsets)
#+end_src

***** Override Sets from Older Channels

#+begin_src nix
(let pkgsets = {
    # nixos-unstable = [ { python310Packages = "mypy"; } { python310Packages = [ "mypy" ]; } ];
    # nixos-unstable = { python310Packages = "mypy"; };
    # nixos-unstable = { python310Packages = [ "mypy" ]; };
};
in mapAttrsToList (
    pkgchannel: pkglist': let
        pkglist = if (isAttrs pkglist') then [ pkglist' ] else pkglist';
    in map (
        pkg': let
            pkg1 = last (attrNames pkg');
            pkg2Pre = last (attrValues pkg');
            pkg2IsString = isString pkg2Pre;
            self = (pkgchannel == channel) || (pkgchannel == "self");
            pkgFunc = pkg: { "${pkg}" = if self then (if pkgIsAttrs then final.${pkg} else prev.${pkg}) else final.j.pkgs.${pkgchannel}.${pkg1}.${pkg}; };
            pkg2 = if pkg2IsString then (pkgFunc pkg2Pre) else (genAttrs pkg2Pre pkgFunc);
        in final: prev: { "${pkg1}" = pkg2; }
    ) pkglist
) pkgsets)
#+end_src

**** End of overlays.nix

#+begin_src nix
]
#+end_src

*** flake.nix

#+begin_src nix :tangle (meq/tangle-path)
{
    nixConfig = {
        # Adapted From: https://github.com/divnix/digga/blob/main/examples/devos/flake.nix#L4
        <<270d5d30-951e-4171-8c23-67fc45d20578(flake='t)>>
    };

    inputs = rec {
        nixos-unstable.url = github:NixOS/nixpkgs/nixos-unstable;
        nixos-unstable-small.url = github:NixOS/nixpkgs/nixos-unstable-small;
        nixos-22-05.url = github:NixOS/nixpkgs/nixos-22.05;
        nixos-22-05-small.url = github:NixOS/nixpkgs/nixos-22.05-small;
        nixos-21-11.url = github:NixOS/nixpkgs/nixos-21.11;
        nixos-21-11-small.url = github:NixOS/nixpkgs/nixos-21.11-small;
        nixos-master.url = github:NixOS/nixpkgs/master;
        nixpkgs.follows = "<<channel>>";

        hardware.url = github:nixos/nixos-hardware;

        pinebook-pro = {
            url = github:samueldr/wip-pinebook-pro;
            flake = false;
        };

        <<username>> = {
            url = github:<<username>>/<<username>>;
            flake = false;
        };

        flake-compat = {
            url = github:edolstra/flake-compat;
            flake = false;
        };

        home-manager.url = github:nix-community/home-manager;
        impermanence.url = github:nix-community/impermanence;

        nix.url = github:nixos/nix;
        extra-container.url = github:erikarvstedt/extra-container;
        nur.url = github:nix-community/nur;
        emacs.url = github:nix-community/emacs-overlay;
        mozilla.url = github:mozilla/nixpkgs-mozilla;

        flake-utils.url = github:numtide/flake-utils;
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let
        channel = "<<channel>>";
        patch = {
            nixpkgs = let
                patches' = [ ./patches/nixpkgs/bcachefs-module.patch ];
            in {
                default = src: config: nixpkgs // ((import src config).applyPatches {
                    name = "defaultPatches";
                    inherit src;
                    patches = patches';
                });
                extras = src: config: patches: nixpkgs // ((import src config).applyPatches { name = "extraPatches"; inherit src patches; });
                both = src: config: patches: nixpkgs // ((import src config).applyPatches {
                    name = "bothPatches";
                    inherit src;
                    patches = patches' ++ patches;
                });
            };
            pkgs = {
                default = src: config: import (patch.nixpkgs.default src config) config;
                extras = src: config: patches: import (patch.nixpkgs.extras src config patches) config;
            };
        };
        make = {
            base = {
                nixpkgset = {
                    base = system: { inherit system; };
                    default = system: lib: (make.base.nixpkgset.base system) // { config = lib.j.attrs.configs.nixpkgs; };
                    overlayed = overlays: system: lib: (make.base.nixpkgset.default system lib) // { inherit overlays; };
                };
                nixpkgs = {
                    base = system: patch.nixpkgs.default nixpkgs (make.base.nixpkgset.base system);
                    default = system: lib: patch.nixpkgs.default nixpkgs (make.base.nixpkgset.default system lib);
                    overlayed = overlays: system: lib: patch.nixpkgs.default nixpkgs (make.base.nixpkgset.overlayed overlays system lib);
                };
                pkgs = {
                    base = system: patch.pkgs.default nixpkgs (make.base.nixpkgset.base system);
                    default = system: lib: patch.pkgs.default nixpkgs (make.base.nixpkgset.default system lib);
                    overlayed = overlays: system: lib: patch.pkgs.default nixpkgs (make.base.nixpkgset.overlayed overlays system lib);
                };
                lib = system: (make.base.nixpkgs.base system).lib.extend (final: prev: {
                    j = import ./lib.nix {
                        inherit inputs system;
                        inherit (make.base.pkgs.default system final) hello;
                        lib = final;
                        extras = { inherit patch; };
                    };
                    inherit (inputs.home-manager.lib) hm;
                });
                overlays = system: lib: import ./overlays.nix {
                    inherit lib inputs channel;
                    nixpkgs = make.base.nixpkgs system;
                    pkgs = mapAttrs (n: v: patch.pkgs.default v (make.base.nixpkgset.default system lib))
                                    (filterAttrs (n: v: (hasPrefix "nixos-" n) || (hasPrefix "release-" n)) inputs);
                };
                specialArgs = system: rec {
                    inherit inputs;
                    lib = make.base.lib system;
                    nixpkgset = {
                        base = make.base.nixpkgset.base system;
                        default = make.base.nixpkgset.default system lib;
                        overlayed = make.base.nixpkgset.overlayed overlays system lib;
                    };
                    nixpkgs = {
                        base = make.base.nixpkgs.base system;
                        default = make.base.nixpkgs.default system lib;
                        overlayed = make.base.nixpkgs.overlayed overlays system lib;
                    };
                    pkgs = {
                        base = make.base.pkgs.base system;
                        default = make.base.pkgs.default system lib;
                        overlayed = make.base.pkgs.overlayed overlays system lib;
                    };
                    overlays = make.base.overlays system lib;
                };
                app = drv: { type = "app"; program = "${drv}${drv.passthru.exePath or "/bin/${drv.meta.mainprogram or drv.pname or drv.name}"}"; };
            };
            nameless = recursiveUpdate make.base {
                outputs = system: rec {
                    inherit system;
                    specialArgs = make.nameless.specialArgs system;
                    inherit (specialArgs) nixpkgset nixpkgs pkgs overlays lib;
                    overlay = final: prev: { settings = final.callPackage ./callPackages/settings.nix {}; };
                    defaultOverlay = overlay;
                    legacyPackages = pkgs.overlayed;
                    apps = mapAttrs (n: v: make.nameless.app v) pkgs.overlayed;
                    app = apps.default;
                    defaultApp = app;
                    packages = flattenTree { inherit (legacyPackages) settings; };
                    package = packages.settings;
                    defaultPackage = package;
                };
            };
            named = recursiveUpdate make.base {
                specialArgs = name: system: (make.nameless.specialArgs system) // { host = name; };
                config = name: system: nixosSystem rec {
                    specialArgs = make.named.specialArgs name system;
                    modules = with inputs; let
                        j-list = specialArgs.lib.j.import.list;
                    in flatten [
                        "${toString ./.}/hosts/${name}"
                        home-manager.nixosModules.home-manager
                        impermanence.nixosModules.impermanence
                        (j-list { dir = ./modules; })
                        (j-list { dir = ./secrets; })
                    ];
                };

                nixosConfiguration = system: { packages.nixosConfigurations = genAttrs (j.dirCon.dirs ./hosts) (name: make.named.config name system); };

                # nixosConfiguration = system: { packages.nixosConfigurations = listToAttrs (map
                #     (name: nameValuePair name (make.named.config name system))
                #     (j.dirCon.dirs ./hosts)
                # ); };
            };
            both = system: (make.named.nixosConfiguration system) // (make.nameless.outputs system);
        };

    in (eachSystem allSystems make.both) // { inherit make; };
}
#+end_src

*** options.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref ea6bb5f8-9240-40e0-a149-ad89f320c90b
:END:

#+begin_src text :tangle (meq/tangle-path)
<<ea6bb5f8-9240-40e0-a149-ad89f320c90b>>
#+end_src

#+begin_src nix
{ config, options, lib, ... }: with lib;

{
    options = {
#+end_src

Adapted from [[https://discourse.nixos.org/t/variables-for-a-system/2342/6][here]]:

#+begin_src nix
        variables = {
            zfs = mkOption {
                type = types.bool;
                default = true;
            };
            relay = mkOption {
                type = types.bool;
                default = false;
            };
            server = mkOption {
                type = types.bool;
                default = config.variables.relay;
            };
            client = mkOption {
                type = types.bool;
                default = (! config.variables.server) && (! config.variables.relay);
            };
            minimal = mkOption {
                type = types.bool;
                default = false;
            };
            encrypted = mkOption {
                type = types.bool;
                default = false;
            };
        };
#+end_src

#+begin_src nix
        programs = {
            mosh = {
                openFirewall = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Whether to automatically open the specified port in the firewall.";
                };
            };
        };
        services = {
            tailscale = {
                autoconnect = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Automatically run `tailscale up' on boot.";
                };
                openFirewall = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Whether to automatically open the specified port in the firewall.";
                };
                trustInterface = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Whether to automatically trust the specified interface in the firewall.";
                };
                hostName = mkOption {
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "The hostname for this device; defaults to `config.networking.hostName'.";
                };
                useUUID = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Use a new UUID as the hostname on every boot; enables `config.services.tailscale.api.ephemeral' by default.";
                };
                deleteHostBeforeAuth = mkOption {
                    type = types.bool;
                    default = false;
                    description = ''
                        Delete the hostname from the tailnet before authentication, if it exists.
                        Does nothing if already authenticated, as determined by the existence of the path from `config.services.tailscale.authenticationConfirmationFile'.
                    '';
                };
                strictReversePathFiltering = mkOption {
                    type = types.bool;
                    default = true;
                    description = "Whether to enable strict reverse path filtering.";
                };
                authkey = mkOption {
                    type = types.nullOr types.nonEmptyStr;
                    default = null;
                    description = ''
                        Authentication key.

                        Warning: Consider using authfile instead if you do not
                        want to store the key in the world-readable Nix store.
                    '';
                };
                authfile = mkOption {
                    example = "/private/tailscale_auth_key";
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "File with authentication key.";
                };
                api.key = mkOption {
                    type = types.nullOr types.nonEmptyStr;
                    default = null;
                    description = ''
                        API key.

                        Warning: Consider using api.file instead if you do not
                        want to store the key in the world-readable Nix store.
                    '';
                };
                api.file = mkOption {
                    example = "/private/tailscale_api_key";
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "File with API key.";
                };
                api.tags = mkOption {
                    example = [ "relay" "server" ];
                    type = types.listOf types.nonEmptyStr;
                    default = [ ];
                    description = "Tags to be used when creating new auth keys.";
                };
                api.reusable = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Create a reusable auth key.";
                };
                api.ephemeral = mkOption {
                    type = with types; nullOr bool;
                    default = null;
                    description = "Create an ephemeral auth key; is enabled by default by `config.services.tailscale.useUUID'.";
                };
                api.preauthorized = mkOption {
                    type = types.bool;
                    default = true;
                    description = "Create a pre-authorized auth key.";
                };
                api.domain = mkOption {
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "Your tailscale domain.";
                };
                state.text = mkOption {
                    type = types.nullOr types.lines;
                    default = null;
                    description = ''
                        The state of tailscale, written to /var/lib/tailscale/tailscaled.state

                        Warning: Consider using state.{file|dir} instead if you do not
                        want to store the state in the world-readable Nix store.
                    '';
                };
                state.file = mkOption {
                    example = "/private/tailscale/tailscaled.state";
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "File with the state of tailscale.";
                };
                state.dir = mkOption {
                    example = "/private/tailscale";
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "Directory with the state file (tailscaled.state) of tailscale.";
                };
                magicDNS.enable = mkEnableOption "MagicDNS";
                magicDNS.searchDomains = mkOption {
                    type = types.listOf types.nonEmptyStr;
                    default = [ ];
                    description = "MagicDNS search domains.";
                };
                magicDNS.nameservers = mkOption {
                    type = types.listOf types.nonEmptyStr;
                    default = [ ];
                    description = "MagicDNS nameservers.";
                };
                acceptDNS = mkOption {
                    type = types.bool;
                    default = true;
                    description = "Whether this tailscale instance will use the preconfigured DNS servers on the tailscale admin page.";
                };
                routes.accept = mkOption {
                    type = with types; nullOr bool;
                    default = null;
                    description = "Use subnet routers; enabled by default if `config.services.tailscale.routes.advertise' is null.";
                };
                routes.advertise = mkOption {
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "Start tailscale as a subnet router with the specified subnets.";
                };
                exitNode.advertise = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Whether this tailscale instance will used as an exit node.";
                };
                exitNode.ip = mkOption {
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "The exit node, as an ip address, to be used with this device.";
                };
                exitNode.hostName = mkOption {
                    type = with types; nullOr nonEmptyStr;
                    default = null;
                    description = "The exit node, as a hostname, to be used with this device; requires an api key provided via `config.services.tailscale.api.{key|file}'.";
                };
                exitNode.allowLANAccess = mkOption {
                    type = types.bool;
                    default = false;
                    description = "Allow direct access to your local network when traffic is routed via an exit node.";
                };
                extraConfig = mkOption {
                    type = types.attrs;
                    default = { };
                    description = "An attribute set of options and values; if an option is a single character, a single dash will be prepended, otherwise two.";
                };
                authenticationConfirmationFile = mkOption {
                    type = types.nonEmptyStr;
                    example = "/private/tailscale/tailscaled.authenticated";
                    default = "/var/lib/tailscale/tailscale.authenticated";
                    description = "Path to the `tailscale.authenticated' file.";
                };
            };
#+end_src

Adapted from [[https://github.com/pukkamustard/nixpkgs/blob/guix/nixos/modules/services/development/guix.nix][here]]:

#+begin_src nix
            guix = {
                enable = mkEnableOption "GNU Guix package manager";
                package = mkOption {
                    type = types.package;
                    default = pkgs.guix;
                    defaultText = "pkgs.guix";
                    description = "Package that contains the guix binary and initial store.";
                };
            };
#+end_src

#+begin_src nix
        };
    };
    imports = [ ./var ];
    config = mkMerge [
#+end_src

Adapted from [[https://discourse.nixos.org/t/variables-for-a-system/2342/12][here]]:

#+begin_src nix
        { _module.args.variables = config.variables; }
#+end_src

**** Mosh

#+begin_src nix
        (let cfg = config.programs.mosh; in mkIf cfg.enable {
            networking.firewall.allowedUDPPortRanges = optional cfg.openFirewall { from = 60000; to = 61000; };
        })
#+end_src

**** Guix

Adapted from [[https://github.com/pukkamustard/nixpkgs/blob/guix/nixos/modules/services/development/guix.nix][here]]:

#+begin_src nix
        (let cfg = config.services.guix; in mkIf cfg.enable {
            users = {
                extraUsers = lib.fold (a: b: a // b) {} (builtins.map buildGuixUser (lib.range 1 10));
                extraGroups.guixbuild = {name = "guixbuild";};
            };
            systemd.services.guix-daemon = {
                enable = true;
                description = "Build daemon for GNU Guix";
                serviceConfig = {
                    ExecStart="/var/guix/profiles/per-user/root/current-guix/bin/guix-daemon --build-users-group=guixbuild";
                    Environment="GUIX_LOCPATH=/var/guix/profiles/per-user/root/guix-profile/lib/locale";
                    RemainAfterExit="yes";

                    # See <https://lists.gnu.org/archive/html/guix-devel/2016-04/msg00608.html>.
                    # Some package builds (for example, go@1.8.1) may require even more than
                    # 1024 tasks.
                    TasksMax="8192";
                };
                wantedBy = [ "multi-user.target" ];
            };
            system.activationScripts.guix = ''
                # copy initial /gnu/store
                if [ ! -d /gnu/store ]
                then
                    mkdir -p /gnu
                    cp -ra ${cfg.package.store}/gnu/store /gnu/
                fi

                # copy initial /var/guix content
                if [ ! -d /var/guix ]
                then
                    mkdir -p /var
                    cp -ra ${cfg.package.var}/var/guix /var/
                fi

                # root profile
                if [ ! -d ~root/.config/guix ]
                then
                    mkdir -p ~root/.config/guix
                    ln -sf /var/guix/profiles/per-user/root/current-guix \
                    ~root/.config/guix/current
                fi

                # authorize substitutes
                GUIX_PROFILE="`echo ~root`/.config/guix/current"; source $GUIX_PROFILE/etc/profile
                guix archive --authorize < ~root/.config/guix/current/share/guix/ci.guix.info.pub
            '';

            environment.shellInit = ''
                # Make the Guix command available to users
                export PATH="/var/guix/profiles/per-user/root/current-guix/bin:$PATH"

                export GUIX_LOCPATH="$HOME/.guix-profile/lib/locale"
                export PATH="$HOME/.guix-profile/bin:$PATH"
                export INFOPATH="$HOME/.guix-profile/share/info:$INFOPATH"
            '';
        })
#+end_src

**** Tailscale

#+begin_src nix
        (let cfg = config.services.tailscale; in mkIf cfg.enable {
            assertions = flatten [
                (optional ((count (state: state != null) (with cfg.state; [ text file dir ])) > 1)
                          "Sorry; only one of `config.services.tailscale.state.{text|file|dir}' may be set!")
                (optional ((cfg.exitNode.ip != null) && (cfg.exitNode.hostName != null))
                          "Sorry; only one of `config.services.tailscale.exitNode.{ip|hostName}' may be set!")
                (optional ((cfg.exitNode.hostName != null) && (cfg.api.key == null) && (cfg.api.file == null))
                          "Sorry; `config.services.tailscale.api.{key|file}' must be set when using `config.services.tailscale.exitNode.hostName'!")
                (optional ((count (auth: auth != null) (with cfg; [ authkey authfile api.key api.file ])) > 1)
                          "Sorry; only one of `config.services.tailscale.{authkey|authfile|api.key|api.file}' may be set!")
                (optional ((cfg.api.domain == null) && ((cfg.api.key != null) || (cfg.api.file != null)))
                          "Sorry; `config.services.tailscale.api.domain' must be set when using `config.services.tailscale.api.{key|file}'!")
            ];
            warnings = flatten [
                (optional ((cfg.api.key != null) || (cfg.api.file != null))
                          "To users who wipe their root directories: persist your `config.services.tailscale.authenticationConfirmationFile'!")
                (optional (cfg.exitNode.advertise && cfg.acceptDNS)
                          "Advertising this device as an exit node and accepting the preconfigured DNS servers on the tailscale admin page at the same time may result in this device attempting to use itself as a DNS server.")

                # TODO: Why is this causing an infinite recursion error?
                # (optional (((isBool cfg.routes.accept) && cfg.routes.accept) && (cfg.routes.advertise != null))
                #           "Advertising this device as a subnet router and accepting the preconfigured subnet routes on the tailscale admin page at the same time may result in this device #TODO")

            ];
            services.tailscale = {
                api.ephemeral = if (cfg.api.ephemeral == null) then config.services.tailscale.useUUID else cfg.api.ephemeral;
                hostName = if (cfg.hostName == null) then config.networking.hostName else cfg.hostName;
                routes.accept = if (cfg.routes.accept == null) then (cfg.routes.advertise == null) else cfg.routes.accept;
            };
            environment.vars = let
                nullText = cfg.state.text != null;
                nullFile = cfg.state.file != null;
                nullDir = cfg.state.dir != null;
            in optionalAttrs (nullText || nullFile || nullDir) {
                "lib/tailscale/tailscaled.state" = mkIf (nullText || nullFile) {
                    ${if nullText then "text" else "source"} = if (nullText) then cfg.state.text else cfg.state.file;
                };
                "lib/tailscale" = mkIf nullDir { source = cfg.state.dir; };
            };
            networking = {
                nameservers = optionals cfg.magicDNS.enable (flatten [ cfg.magicDNS.nameservers "100.100.100.100" ]);
                search = optionals cfg.magicDNS.enable cfg.magicDNS.searchDomains;
                firewall = {
                    ${if cfg.strictReversePathFiltering then null else "checkReversePath"} = "loose";
                    trustedInterfaces = optional cfg.trustInterface cfg.interfaceName;
                    allowedUDPPorts = optional cfg.openFirewall cfg.port;
                };
            };
            systemd.services.tailscale-autoconnect = let
                api_and_no_authConFile = ((cfg.api.key != null) || (cfg.api.file != null)) && (! pathExists cfg.authenticationConfirmationFile);
            in mkIf cfg.autoconnect {
                description = "Automatic connection to Tailscale";

                # make sure tailscale is running before trying to connect to tailscale
                after = [ "network-pre.target" "tailscale.service" ];
                wants = [ "network-pre.target" "tailscale.service" ];
                wantedBy = [ "multi-user.target" ];

                environment = mkIf api_and_no_authConFile {
                TAILSCALE_APIKEY = if (cfg.api.key != null) then cfg.api.key else (readFile cfg.api.file);
                };

                # set this service as a oneshot job
                serviceConfig = {
                    Type = "oneshot";
                    ExecStart = let
                        extraConfig = mapAttrsToList (opt: val: let
                        value = optionalString (! isBool val) " ${toString val}";
                        in (if ((stringLength opt) == 1) then "-" else "--") + opt + value) cfg.extraConfig;
                    in ''
                        # wait for tailscaled to settle
                        sleep 2

                        # check if we are already authenticated to tailscale
                        echo "Waiting for tailscale.service start completion ..."
                        status="$(${cfg.package}/bin/tailscale status -json | ${pkgs.jq}/bin/jq -r .BackendState)"
                        if [ $status = "Running" ]; then # if so, then do nothing
                            echo "Already authenticated to Tailscale, exiting."
                            exit 0
                        fi

                        # Delete host from tailnet if:
                        # * `config.services.tailscale.deleteHostBeforeAuth' is enabled
                        # * `config.services.tailscale.api.{key|file}' is not null
                        # * path at `config.services.tailscale.authenticationConfirmationFile` does not exist
                        ${optionalString (cfg.deleteHostBeforeAuth && api_and_no_authConFile) ''${pkgs.tailapi}/bin/tailapi --domain ${cfg.api.domain} \
                                                                                                                            --recreate-response \
                                                                                                                            --devices ${cfg.hostName} \
                                                                                                                            delete \
                                                                                                                            --do-not-prompt &> /dev/null''}

                        # otherwise authenticate with tailscale
                        echo "Authenticating with Tailscale ..."
                        ${cfg.package}/bin/tailscale up --hostname ${if cfg.useUUID then "$(${pkgs.util-linux}/bin/uuidgen)" else cfg.hostName} \
                        ${optionalString cfg.acceptDNS "--accept-dns \\"}
                        ${optionalString cfg.routes.accept "--accept-routes \\"}
                        ${optionalString (cfg.routes.advertise != null) "--advertise-routes ${cfg.routes.advertise} \\"}
                        ${optionalString cfg.exitNode.advertise "--advertise-exit-node \\"}
                        ${optionalString (cfg.exitNode.ip != null) "--exit-node ${cfg.exitNode.ip} \\"}
                        ${optionalString (cfg.exitNode.hostName != null) ''--exit-node $(${pkgs.tailapi}/bin/tailapi --domain ${cfg.api.domain} \
                                                                           --recreate-response \
                                                                           --devices ${cfg.exitNode.hostName} \
                                                                           ip -f4) \''}
                        ${optionalString (((cfg.exitNode.ip != null) || (cfg.exitNode.hostName != null)) && cfg.exitNode.allowLANAccess)
                                         "--exit-node-allow-lan-access \\"}

                        ${concatStringsSep " " (mapAttrsToList (n: v: let
                            opt = (if ((stringLength n) == 1) then "-" else "--") + n;
                        in "${opt} ${v}") extraConfig)} \

                        ${optionalString (cfg.authkey != null) "--authkey ${cfg.authkey} \\"}
                        ${optionalString (cfg.authfile != null) "--authkey ${readFile cfg.authfile} \\"}
                        ${optionalString api_and_no_authConFile ''--authkey $(${pkgs.tailapi}/bin/tailapi --domain ${cfg.api.domain} \
                                                                                                          --recreate-response \
                                                                                                          create \
                                                                                                          ${optionalString cfg.api.reusable "--reusable \\"}
                                                                                                          ${optionalString cfg.api.ephemeral "--ephemeral \\"}
                                                                                                          ${optionalString cfg.api.reusable "--preauthorized \\"}
                                                                                                          ${optionalString (cfg.api.tags != null)
                                                                                                                           (concatStringsSep " " cfg.api.tags)} \
                                                                                                          --just-key)''}

                        ${optionalString ((cfg.state.file != null) && (! pathExists cfg.state.file)) "cp /var/lib/tailscale/tailscaled.state ${cfg.state.file}"}
                        ${optionalString ((cfg.state.dir != null) && ((! pathExists cfg.state.dir) || ((length (attrNames (readDir cfg.state.dir))) == 0)))
                                         "${pkgs.rsync}/bin/rsync -avvczz /var/lib/tailscale/ ${cfg.state.dir}/"}

                        touch ${cfg.authenticationConfirmationFile}
                    '';
                };
            };
        })
#+end_src

**** End of options.nix

#+begin_src nix
    ];
}
#+end_src

*** var
**** default.nix

Adapted from [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/etc-activation.nix][here]]:

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: {
    imports = [ ./var.nix ];
    config.system.activationScripts.vars = lib.stringAfter [ "users" "groups" ] config.system.build.varActivationCommands;
}
#+end_src

**** var.nix

Adapted from [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/etc.nix][here]]:

#+begin_src nix :tangle (meq/tangle-path)
# Management of static files in /var.

{ config, lib, pkgs, ... }:

with lib;

let

  var' = filter (f: f.enable) (attrValues config.environment.vars);

  var = pkgs.runCommandLocal "var" {
    # This is needed for the systemd module
    passthru.targets = map (x: x.target) var';
  } /* sh */ ''
    set -euo pipefail

    makevarEntry() {
      src="$1"
      target="$2"
      mode="$3"
      user="$4"
      group="$5"

      if [[ "$src" = *'*'* ]]; then
        # If the source name contains '*', perform globbing.
        mkdir -p "$out/var/$target"
        for fn in $src; do
            ln -s "$fn" "$out/var/$target/"
        done
      else

        mkdir -p "$out/var/$(dirname "$target")"
        if ! [ -e "$out/var/$target" ]; then
          ln -s "$src" "$out/var/$target"
        else
          echo "duplicate entry $target -> $src"
          if [ "$(readlink "$out/var/$target")" != "$src" ]; then
            echo "mismatched duplicate entry $(readlink "$out/var/$target") <-> $src"
            ret=1

            continue
          fi
        fi

        if [ "$mode" != symlink ]; then
          echo "$mode" > "$out/var/$target.mode"
          echo "$user" > "$out/var/$target.uid"
          echo "$group" > "$out/var/$target.gid"
        fi
      fi
    }

    mkdir -p "$out/var"
    ${concatMapStringsSep "\n" (varEntry: escapeShellArgs [
      "makevarEntry"
      # Force local source paths to be added to the store
      "${varEntry.source}"
      varEntry.target
      varEntry.mode
      varEntry.user
      varEntry.group
    ]) var'}
  '';

in

{

  ###### interface

  options = {

    environment.vars = mkOption {
      default = {};
      example = literalExpression ''
        { example-configuration-file =
            { source = "/nix/store/.../var/dir/file.conf.example";
              mode = "0440";
            };
          "default/useradd".text = "GROUP=100 ...";
        }
      '';
      description = ''
        Set of files that have to be linked in <filename>/var</filename>.
      '';

      type = with types; attrsOf (submodule (
        { name, config, options, ... }:
        { options = {

            enable = mkOption {
              type = types.bool;
              default = true;
              description = ''
                Whether this /var file should be generated.  This
                option allows specific /var files to be disabled.
              '';
            };

            target = mkOption {
              type = types.str;
              description = ''
                Name of symlink (relative to
                <filename>/var</filename>).  Defaults to the attribute
                name.
              '';
            };

            text = mkOption {
              default = null;
              type = types.nullOr types.lines;
              description = "Text of the file.";
            };

            source = mkOption {
              type = types.path;
              description = "Path of the source file.";
            };

            mode = mkOption {
              type = types.str;
              default = "symlink";
              example = "0600";
              description = ''
                If set to something else than <literal>symlink</literal>,
                the file is copied instead of symlinked, with the given
                file mode.
              '';
            };

            uid = mkOption {
              default = 0;
              type = types.int;
              description = ''
                UID of created file. Only takes effect when the file is
                copied (that is, the mode is not 'symlink').
                '';
            };

            gid = mkOption {
              default = 0;
              type = types.int;
              description = ''
                GID of created file. Only takes effect when the file is
                copied (that is, the mode is not 'symlink').
              '';
            };

            user = mkOption {
              default = "+${toString config.uid}";
              type = types.str;
              description = ''
                User name of created file.
                Only takes effect when the file is copied (that is, the mode is not 'symlink').
                Changing this option takes precedence over <literal>uid</literal>.
              '';
            };

            group = mkOption {
              default = "+${toString config.gid}";
              type = types.str;
              description = ''
                Group name of created file.
                Only takes effect when the file is copied (that is, the mode is not 'symlink').
                Changing this option takes precedence over <literal>gid</literal>.
              '';
            };

          };

          config = {
            target = mkDefault name;
            source = mkIf (config.text != null) (
              let name' = "var-" + baseNameOf name;
              in mkDerivedConfig options.text (pkgs.writeText name')
            );
          };

        }));

    };

  };


  ###### implementation

  config = {

    system.build.var = var;
    system.build.varActivationCommands =
      ''
        # Set up the statically computed bits of /var.
        echo "setting up /var..."
        ${pkgs.perl.withPackages (p: [ p.FileSlurp ])}/bin/perl ${./setup-var.pl} ${var}/var
      '';
  };

}
#+end_src

**** setup-var.pl

Adapted from [[https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/setup-etc.pl][here]]:

#+begin_src perl :tangle (meq/tangle-path)
use strict;
use File::Find;
use File::Copy;
use File::Path;
use File::Basename;
use File::Slurp;

my $var = $ARGV[0] or die;
my $static = "/var/static";

sub atomicSymlink {
    my ($source, $target) = @_;
    my $tmp = "$target.tmp";
    unlink $tmp;
    symlink $source, $tmp or return 0;
    rename $tmp, $target or return 0;
    return 1;
}


# Atomically update /var/static to point at the var files of the
# current configuration.
atomicSymlink $var, $static or die;

# Returns 1 if the argument points to the files in /var/static.  That
# means either argument is a symlink to a file in /var/static or a
# directory with all children being static.
sub isStatic {
    my $path = shift;

    if (-l $path) {
        my $target = readlink $path;
        return substr($target, 0, length "/var/static/") eq "/var/static/";
    }

    if (-d $path) {
        opendir DIR, "$path" or return 0;
        my @names = readdir DIR or die;
        closedir DIR;

        foreach my $name (@names) {
            next if $name eq "." || $name eq "..";
            unless (isStatic("$path/$name")) {
                return 0;
            }
        }
        return 1;
    }

    return 0;
}

# Remove dangling symlinks that point to /var/static.  These are
# configuration files that existed in a previous configuration but not
# in the current one.  For efficiency, don't look under /var/nixos
# (where all the NixOS sources live).
sub cleanup {
    if ($File::Find::name eq "/var/nixos") {
        $File::Find::prune = 1;
        return;
    }
    if (-l $_) {
        my $target = readlink $_;
        if (substr($target, 0, length $static) eq $static) {
            my $x = "/var/static/" . substr($File::Find::name, length "/var/");
            unless (-l $x) {
                print STDERR "removing obsolete symlink ‘$File::Find::name’...\n";
                unlink "$_";
            }
        }
    }
}

find(\&cleanup, "/var");


# Use /var/.clean to keep track of copied files.
my @oldCopied = read_file("/var/.clean", chomp => 1, err_mode => 'quiet');
open CLEAN, ">>/var/.clean";


# For every file in the var tree, create a corresponding symlink in
# /var to /var/static.  The indirection through /var/static is to make
# switching to a new configuration somewhat more atomic.
my %created;
my @copied;

sub link {
    my $fn = substr $File::Find::name, length($var) + 1 or next;
    my $target = "/var/$fn";
    File::Path::make_path(dirname $target);
    $created{$fn} = 1;

    # Rename doesn't work if target is directory.
    if (-l $_ && -d $target) {
        if (isStatic $target) {
            rmtree $target or warn;
        } else {
            warn "$target directory contains user files. Symlinking may fail.";
        }
    }

    if (-e "$_.mode") {
        my $mode = read_file("$_.mode"); chomp $mode;
        if ($mode eq "direct-symlink") {
            atomicSymlink readlink("$static/$fn"), $target or warn;
        } else {
            my $uid = read_file("$_.uid"); chomp $uid;
            my $gid = read_file("$_.gid"); chomp $gid;
            copy "$static/$fn", "$target.tmp" or warn;
            $uid = getpwnam $uid unless $uid =~ /^\+/;
            $gid = getgrnam $gid unless $gid =~ /^\+/;
            chown int($uid), int($gid), "$target.tmp" or warn;
            chmod oct($mode), "$target.tmp" or warn;
            rename "$target.tmp", $target or warn;
        }
        push @copied, $fn;
        print CLEAN "$fn\n";
    } elsif (-l "$_") {
        atomicSymlink "$static/$fn", $target or warn;
    }
}

find(\&link, $var);


# Delete files that were copied in a previous version but not in the
# current.
foreach my $fn (@oldCopied) {
    if (!defined $created{$fn}) {
        $fn = "/var/$fn";
        print STDERR "removing obsolete file ‘$fn’...\n";
        unlink "$fn";
    }
}


# Rewrite /var/.clean.
close CLEAN;
write_file("/var/.clean", map { "$_\n" } @copied);

# Create /var/NIXOS tag if not exists.
# When /var is not on a persistent filesystem, it will be wiped after reboot,
# so we need to check and re-create it during activation.
open TAG, ">>/var/NIXOS";
close TAG;
#+end_src

*** boot.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref 7aee3b93-7060-4dfc-9bf5-6593e10af352
:END:

#+begin_src text :tangle (meq/tangle-path)
<<7aee3b93-7060-4dfc-9bf5-6593e10af352>>
#+end_src

#+begin_src nix
with builtins; args@{ config, ... }: let
    flake = import ./.;
    system = args.system or currentSystem;
    host = args.host or config.networking.hostName;
    inheritanceSet = if (args ? inputs) then args else (flake.make.named.specialArgs host system);
    inherit (inheritanceSet) lib;
    pkgs = inheritanceSet.pkgs.overlayed;
in with lib; {
    boot = {
        supportedFilesystems = j.attrs.fileSystems.supported;
        initrd = {
            inherit (config.boot) supportedFilesystems;
            compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
        };
        kernelPackages = mkDefault pkgs.linuxPackages_xanmod;
        # kernelPackages = mkDefault pkgs.linuxPackages_lqx;
        # kernelPackages = mkDefault pkgs.linuxPackages_zen;
        kernelPatches = flatten [

            # TODO
            # (optionals (elem "bcachefs" config.boot.supportedFilesystems) (filter (set: hasInfix "bcachefs" set.name) pkgs.linuxKernel.kernels.linux_testing_bcachefs.kernelPatches))
#+end_src

# TODO: Apparently doesn't work with bcachefs

#+begin_src nix :noweb-ref no
            {
                name = "Enable ZSTD Compression";
                patch = null;
                extraConfig = ''
                    RD_ZSTD y
                    KERNEL_ZSTD y
                    KERNEL_XZ n
                '';
            }
#+end_src

#+begin_src nix
        ];
    };
}
#+end_src

*** minimal.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref 7c145c63-c2e7-4ead-b74c-a8f48b93fd80
:END:

#+begin_src text :tangle (meq/tangle-path)
<<7c145c63-c2e7-4ead-b74c-a8f48b93fd80>>
#+end_src

**** Arguments

#+begin_src nix
with builtins; args@{ config, ... }: let
    flake = import ./.;
    system = args.system or currentSystem;
    host = args.host or config.networking.hostName;
    fromFlake = args ? inputs;
    inheritanceSet = if fromFlake then args else (flake.make.named.specialArgs host system);
    inherit (inheritanceSet) lib;
    pkgs = inheritanceSet.pkgs.overlayed;

    dir = "<<userrepo>>";
    dirExists = pathExists dir;
    repo = if dirExists then (fetchGit { url = "file://${dir}"; ref = "main"; }) else flake.inputs.${lib.j.attrs.users.primary};

    nixos = "${(args.nixpkgs or inheritanceSet.nixpkgs).overlayed}/nixos";
    nixos-configuration = configuration: import nixos { configuration = import configuration (lib.recursiveUpdate args inheritanceSet); inherit system; };
    nixos-configurations = {
        server = nixos-configuration ./profiles/server.nix;
        configuration = nixos-configuration ./configuration.nix;
        hardware-configuration = import nixos { inherit system; configuration.imports = [
            ./hardware-configuration.nix
            ./boot.nix
            ({config, ... }: { networking.hostId = substring 0 8 (readFile "/etc/machine-id"); boot.loader.grub.devices = [ "nodev" ]; })
        ]; };
    };
    datasets = import ./datasets.nix host;
in with lib; {
    imports = with flake.inputs; flatten [
        ./cachix.nix
        (optionals (! fromFlake) [ home-manager.nixosModules.home-manager impermanence.nixosModules.impermanence ])
        ./options.nix
        ./boot.nix
    ];
    config = mkMerge [
        # (removeAttrs nixos-configurations.hardware-configuration.config [ "fileSystems" "nesting" "jobs" "fonts" "meta" "documentation" ])
        (filterAttrs (n: v: elem n [ "powerManagement" ]) nixos-configurations.hardware-configuration.config)
#+end_src

***** ZFS

#+begin_src nix
( mkIf config.variables.zfs {
    boot = {
        extraModulePackages = with config.boot.kernelPackages; [ zfsUnstable ];
        kernelModules = [ "zfs" ];
        kernelParams = [ "nohibernate" ];
        loader.grub.zfsSupport = true;
        initrd = {
            postDeviceCommands = mkAfter (concatMapStrings (d: "zfs rollback -r ${d}@blank\n") (filter (d: (j.has.prefix [
                "${host}/system/home"
            ] d) || (elem d [
                "${host}/system/root"
                # "${host}/system/tmp"
            ])) (attrNames datasets)));
            kernelModules = [ "zfs" "r8169" ];
            availableKernelModules = config.boot.initrd.kernelModules;
        };
        zfs = {
            requestEncryptionCredentials = true;
            enableUnstable = true;
            devNodes = "/dev/";
        };
    };
    environment = {
        persistence = let
            reallyUnique = list: let
                attrs = remove null (map (item: if (isAttr item) then (item.file or item.directory) else null) list);
            in unique (filter (item: ! elem item list) list);
            mergePersisted = set: list: reallyUnique (map (item: if (isString item) then (recursiveUpdate { inherit item; } set) else (recursiveUpdate set item)) (flatten list));
        in {
            "/persist/root" = let
                rootDirSet = {
                    user = "root";
                    group = "root";
                };
                rootFileSet.parentDirectory = rootDirSet;
                etc-prefixes = [ "nixos" "containers" "NetworkManager/system-connections" "tailscale" ];
            in {
                hideMounts = true;
                files = mergePersisted rootFileSet [
                    "/etc/host"
                    "/etc/machine-id"
                    (map (directory: j.recurseDir { dir = "${repo}/${directory}"; local = 0; ignores.prefix = (map (d: d + "/") etc-prefixes); }) [
                        "etc"
                        "var"
                    ])
                ];
                directories = mergePersisted rootDirSet [
                    (map (d: "/etc/" + d) etc-prefixes)

                    "/bin"

                    # TODO: Prevents `sshd_config' itself from being created
                    # "/etc/ssh"

                    "/sbin"
                    "/snap"
                    "/usr"
                    "/var/lib/acme"
                    "/var/lib/bluetooth"
                    "/var/lib/systemd/coredump"
                    "/var/log"

                    # Managed by the `var' module
                    # "/var/lib/tailscale"

                    config.services.tailscale.authenticationConfirmationFile
                ];
            };
            "/persist" = let
                redRepoFiles = flatten [
                    (j.dirCon.others repo)
                ];
                redRepoDirectories = flatten [
                    (j.dirCon.dirs repo)
                ];
            in {
                users = mapAttrs' (designation: user: let
                    home = j.attrs.allHomes.${designation};
                    pHome = "/persist/${home}";
                    userDirSet = {
                        inherit user;
                        group = user;
                    };
                    userFileSet.parentDirectory = userDirSet;
                    predRepoFiles = flatten [
                        (j.dirCon.others pHome)
                    ];
                    predRepoDirectories = flatten [
                        (j.dirCon.dirs pHome)
                    ];
                in nameValuePair user {
                    inherit home;
                    files = mergePersisted userFileSet [
                        ".bash_history"
                        ".emacs-profile"
                        ".fasd"
                        ".gitignore"
                        ".globalignore"
                        ".nix-channels"
                        ".python-history"
                        ".screenrc"
                        ".viminfo"
                        ".zsh_history"
                        config.services.caddy.dataDir
                        redRepoFiles
                        predRepoFiles
                    ];
                    directories = mergePersisted userDirSet [
                        ".atom"
                        ".byobu"
                        ".cache"
                        ".config"
                        ".linuxbrew"
                        ".local"
                        ".mozilla"
                        ".peru"
                        ".pki"
                        ".repos"
                        ".user"
                        ".vim_runtime"
                        ".virtualenvs"
                        ".vscode-oss"
                        ".vscode"
                        ".yubico"
                        ".z"
                        "Documents"
                        "Downloads"
                        "keybase"
                        "Music"
                        "nix-plugins"
                        "Pictures"
                        "Public"
                        "Templates"
                        "tests"
                        "Videos"
                        "VirtualBox VMs"
                        { directory = ".gnupg"; mode = "0700"; }
                        { directory = ".nixops"; mode = "0700"; }
                        { directory = ".ssh"; mode = "0700"; }
                        { directory = ".gnupgk"; mode = "0700"; }
                        redRepoDirectories
                        predRepoDirectories
                    ];}) j.attrs.allUsers;
            };
        };
    };
    fileSystems = with lib; let
        forceMountpoint = dataset: mountpoint: mkForce (recursiveUpdate j.attrs.fileSystems.base { device = dataset; ${
            j.mif.null ((j.has.infix [
                j.attrs.users.primary
                "persist"
                "home"
            ] dataset) || (elem dataset [ ])) "neededForBoot"
        } = true; });
        regularDatasets = filterAttrs (n: v: ! isList v) datasets;
        filteredDatasets = filterAttrs (n: v: isList v) datasets;
        listedDatasets = listToAttrs (flatten (mapAttrsToList (dataset: mountlist: map (mountpoint: nameValuePair dataset mountpoint) mountlist) filteredDatasets));
    in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (forceMountpoint dataset mountpoint)) (recursiveUpdate regularDatasets listedDatasets);
    services = {
        sanoid = let
            sanoidBase = {
                useTemplate = [ "base" ];
                recursive = true;
            };
            disabled = { processChildrenOnly = true; };
        in {
            enable = true;
            templates."base" = {
                autoprune = true;
                autosnap = true;
                interval = "30s";

                # 6 snapshots an hour
                daily = 144;

                # 2 snapshots a minute
                hourly = 120;

                # 6 snapshots a day for 28 days
                monthly = 168;

                # Twice the weeks in a year
                yearly = 104;
            };

            datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) (flatten [
                j.attrs.datasets.backup
                host
            ]));
        };
        syncoid = let
            syncoidBase = mkMerge [{
                recursive = true;
                commonArgs = [
                    "--compress zstd-slow"
                    "--no-stream"
                    "--no-sync-snap"
                    "--create-bookmark"
                ];
                }
                (mkIf vars.encrypted {
                    sendOptions = "vvwRI";
                    recvOptions = "vvFs";
                })
                (mkIf (!vars.encrypted) {
                    recvOptions = "vvFds";
                    sendOptions = "vvRI";
                })
            ];
        in {
            enable = false;
            sshKey = "/root/.ssh/id_ed25519";
            commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (recursiveUpdate syncoidBase { target = ""; })) (flatten [
                j.attrs.datasets.backup
                host
            ]));
        };
        udev.extraRules = ''
            ACTION=="add|change", KERNEL=="sd[a-z]*[0-9]*|mmcblk[0-9]*p[0-9]*|nvme[0-9]*n[0-9]*p[0-9]*", ENV{ID_FS_TYPE}=="zfs_member", ATTR{../queue/scheduler}="none"
        ''; # zfs already has its own scheduler. without this my(@Artturin) computer froze for a second when i nix build something.
        zfs = {
            trim.enable = true;
            autoScrub.enable = true;

            # Managed by Sanoid
            autoSnapshot.enable = false;
        };
    };
#+end_src

Adapted from [[https://www.reddit.com/r/NixOS/comments/ut8j10/nixos_zfs_podman_backing_file_system_is/?utm_medium=android_app&utm_source=share][here]]:

#+begin_src nix
    virtualisation = {
        containers.storage.settings.storage.driver = "zfs";
        lxd.zfsSupport = true;
        podman.extraPackages = [ pkgs.zfs ];
        docker.storageDriver = "zfs";
    };
#+end_src

#+begin_src nix
})
#+end_src

***** Boot

#+begin_src nix
{
    boot = {
        initrd = {
            inherit (nixos-configurations.hardware-configuration.config.boot.initrd) availableKernelModules kernelModules;
            network.ssh.enable = true;
        };
        inherit (nixos-configurations.hardware-configuration.config.boot) kernelModules extraModulePackages;
        extraModprobeConfig = '' options kvm_intel_nested=1 '';
        loader = {
            generic-extlinux-compatible.enable = mkForce false;
            systemd-boot = {
                configurationLimit = 25;
                editor = mkForce false;
                # enable = mkForce false;
                enable = mkForce true;
            };
            grub = {
                # enable = mkForce true;
                enable = mkForce false;
                efiSupport = true;
                efiInstallAsRemovable = mkForce false;
                # efiInstallAsRemovable = mkForce true;
                # devices = [ "nodev" ];
                # device = "nodev";
                device = if config.boot.loader.grub.efiSupport then config.boot.loader.efi.efiSysMountPoint else "/boot";
                version = 2;
                useOSProber = true;

                # TODO: Get more options
                extraEntries = ''
                    menuentry "Reboot" { reboot }
                    menuentry "Poweroff" { halt }
                '';
            };
            efi = {
                canTouchEfiVariables = mkForce true;
                # canTouchEfiVariables = mkForce false;
                efiSysMountPoint = "/boot/efi";
            };
            timeout = 10;

            # Used for Bedrock Linux
            # Also causing EFI stuff not to be installed
            # initScript.enable = mkForce true;

        };
    };
}
#+end_src

***** Console

#+begin_src nix
{
    console = {
        # Select internationalisation properties.
        # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
        font = "Cartograph CF Extra Bold Italic";
        keyMap = "us";
    };
}
#+end_src

***** Environment

#+begin_src nix
{
    environment = {
        etc."nix/nix.conf".text = mkForce j.attrs.configs.nix;
        systemPackages = with pkgs; flatten [
            (pass.withExtensions (ext: with ext; [pass-tomb pass-genphrase]))
            (Python.withPackages (ppkgs: with ppkgs; [ bakery nixpkgs ]))
            assh
            cached-nix-shell
            cachix
            direnv
            exa
            fasd
            fd
            fzf
            git
            git-crypt
            gnupg
            gopass
            hub
            mosh
            sqlite
            starship
            tailscale
            tailapi
            yadm
            zoxide
        ];
    };
}
#+end_src

***** Memory

#+begin_src nix
{
    zramSwap = {
        enable = true;
        algorithm = "zstd";
    };
}
#+end_src

***** Filesystems

#+begin_src nix
{
    fileSystems = let
        inherit (j.attrs.fileSystems) base;
    in if config.variables.zfs then (filterAttrs (n: v: elem n [ "/boot" "/boot/efi" ]) nixos-configurations.hardware-configuration.config.fileSystems) else nixos-configurations.hardware-configuration.config.fileSystems;
}
#+end_src

***** Hardware

#+begin_src nix
{
    hardware = {
        inherit (nixos-configurations.hardware-configuration.config.hardware) cpu;
        enableRedistributableFirmware = lib.mkDefault true;
        # Enable sound
        pulseaudio.enable = mkForce true;
    };
    sound.enable = true;
}
#+end_src

***** Home-Manager

#+begin_src nix
{
    home-manager = {
        useGlobalPkgs = true;
        users = mapAttrs' (designation: user: nameValuePair user {
            home = {
                stateVersion = head (splitString "p" (args.nixpkgs or inheritanceSet.nixpkgs).overlayed.lib.version);
                activation.setup-yubikey-sudo = lib.hm.dag.entryAfter [ "writeBoundary" ] "ykpamcfg -2 -v";
                homeDirectory = j.attrs.allHomes.${designation};
            };
        }) j.attrs.allUsers;
    };
}
#+end_src

***** Networking

#+begin_src nix
{
    networking = {
        networkmanager.enable = mkForce true;
        interfaces = mkIf fromFlake (mapAttrs (n: v: recursiveUpdate v {
            useDHCP = mkForce (! config.networking.networkmanager.enable);
            wakeOnLan.enable = true;
        }) (filterAttrs (n: v: !elem n [ "wg0" ]) nixos-configurations.configuration.config.networking.interfaces));

        # The global useDHCP flag is deprecated, therefore explicitly set to false here.
        # Per-interface useDHCP will be mandatory in the future, so this generated config
        # replicates the default behaviour.
        useDHCP = false;

        # Configure network proxy if necessary
        # proxy = {
        # default = "http://user:password@proxy:port/";
        # noProxy = "127.0.0.1,localhost,internal.domain";
        # };

        wireguard.interfaces.wg0 = {
            generatePrivateKeyFile = true;
            privateKeyFile = "/persist/etc/wireguard/wg0";
        };

        firewall = recursiveUpdate {
            enable = true;
        } (if config.variables.relay then {
            allowedTCPPorts = [ 80 222 443 2022 8080 9418 ];
        } else if config.variables.server then {
            allowedTCPPorts = [ ];
        } else {
            allowedTCPPorts = [ ];
        });
    };
}
#+end_src

***** Nix

#+begin_src nix
{
    nix = rec {
        registry = {
            "${j.attrs.users.primary}" = {
                from = {
                    id = j.attrs.users.primary;
                    type = "indirect";
                };
                to = {
                    type = "github";
                    owner = j.attrs.users.primary;
                    repo = j.attrs.users.primary;
                };
            };
        };
        package = pkgs.nixUnstable;
        gc = mkMerge [
            { automatic = true; }
            { dates = "monthly"; }
            # {
            #   dates = "monthly";
            #   options = "-d";
            # }
            # {
            #   dates = "daily";
            #   options = "--delete-older-than 30d";
            # }
        ];
        optimise = {
            automatic = true;
            dates = [ "05:00" ];
        };
        extraOptions = j.attrs.configs.nix;
        settings = {
            auto-optimise-store = true;
            sandbox = true;
        };
        # sandboxPaths = [];
    };
}
#+end_src

***** Nixpkgs

#+begin_src nix
{ nixpkgs = inheritanceSet.nixpkgset.overlayed; }
#+end_src

***** Power

#+begin_src nix
{
    services.logind.lidSwitch = "hybrid-sleep";
    powerManagement = {
        enable = true;
        cpuFreqGovernor = mkForce "ondemand";
    };
}
#+end_src

***** Programs

#+begin_src nix
{
    programs = {
        xonsh.enable = true;
        fish.enable = true;
        zsh.enable = true;
        tmux.enable = true;
        fuse.userAllowOther = true;
        mosh = {
            enable = true;
            openFirewall = true;
        };
    };
}
#+end_src

***** Services

#+begin_src nix
{
    services = {
        tailscale.enable = true;
        openssh = mkForce nixos-configurations.server.config.services.openssh;
        xserver = {
            enable = true;
            layout = "us";
            # xkbOptions = "eurosign:e";
            # Enable touchpad support.
            libinput = {
                enable = true;
                touchpad = {
                    naturalScrolling = true;
                    middleEmulation = true;
                    tapping = true;
                };
            };
            # synaptics.enable = true;
            desktopManager.gnome.enable = true;
            displayManager = {
                startx.enable = true;
                lightdm.enable = mkForce false;
            };
            autorun = false;
        };
    };
}
#+end_src

***** Users

#+begin_src nix
{
    users = with j.attrs.users; let
        base = {
            hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
            isNormalUser = true;
            createHome = true;
            extraGroups = [
                "wheel"
                "networkmanager"
                "persist"
                "libvirtd"
                "docker"
                "adbusers"
            ];
            openssh.authorizedKeys.keys = unique (flatten [
                (attrValues j.attrs.ssh.keys)
            ]);
        };
    in rec {
        users = mkMerge [
            (genAttrs j.attrs.allUsernames (user: base))
            {
                "${primary}" = {
                    uid = 4362;
                    home = j.attrs.homes.primary;
                    description = "Jeet Ray";
                    group = primary;
                    extraGroups = [ secondary ];
                    # shell = pkgs.xonsh;
                    shell = pkgs.zsh;
                };
                "${secondary}" = {
                    uid = 1111;
                    home = j.attrs.homes.secondary;
                    description = "Alicia Summers";
                    group = secondary;
                    extraGroups = [ primary ];
                    shell = pkgs.fish;
                };
                "${nightingale}" = {
                    uid = 8888;
                    home = j.attrs.homes.nightingale;
                    description = "Curtis Nightingale";
                    group = "root";
                    extraGroups = [ primary secondary ];
                    shell = pkgs.zsh;
                };
                root = {
                    shell = mkForce pkgs.zsh;
                    home = j.attrs.allHomes.root;
                    isNormalUser = mkForce false;
                    isSystemUser = mkForce true;
                };
            }
        ];

        mutableUsers = false;

        groups = {
            "${primary}" = {
                gid = config.users.users.${primary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${secondary}" = {
                gid = config.users.users.${secondary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${nightingale}" = {
                gid = config.users.users.${nightingale}.uid;
                members = [ nightingale ];
            };
        };
    };
}
#+end_src

***** Security

#+begin_src nix
{
    environment = {
        shellInit = ''
            export GPG_TTY="$(tty)"
            gpg-connect-agent /bye
            export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
            echo UPDATESTARTUPTTY | gpg-connect-agent
        '';
        systemPackages = with pkgs; [
            pinentry-curses
        ];
    };
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = true;
            pinentryFlavor = "curses";
        };
        ssh.startAgent = ! config.programs.gnupg.agent.enableSSHSupport;
    };
    security.pam.enableSSHAgentAuth = true;
}
#+end_src

***** Yubikey

#+begin_src nix
( mkIf config.variables.client {
    # For Yubikey SSH-GPG Authentication
    environment = {
        systemPackages = with pkgs; [
            pcsctools
            yubico-pam yubico-piv-tool yubikey-manager yubikey-agent yubikey-personalization yubioath-desktop
            yubikey-manager-qt yubikey-personalization-gui
        ];
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
    };
    services = {
        udev.packages = with pkgs; [
            libu2f-host
            libyubikey
            yubikey-personalization
        ];
        pcscd.enable = true;
    };
})
#+end_src

***** End of minimal.nix

#+begin_src nix
]; }
#+end_src

*** modules
**** boot.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    boot = {
        binfmt.emulatedSystems = [
            "armv7l-linux"
            "aarch64-linux"
        ];
        extraModulePackages = with config.boot.kernelPackages; [
            # anbox
            # wireguard
        ];
        kernelPatches = let
            genCK = ignores: map (name: {
                inherit name;
                patch = "${toString ck}/${name}";
            }) (pipe flake.inputs.ck [
                readDir
                attrNames
                (filter (p: !elem p (flatten [
                    "series"
                    "0016-Add-ck1-version.patch"
                    ignores
                ])))
            ]);
            versionhas.infix = infix: j.has.infix (if (isList infix) then infix else [ infix ]) config.boot.kernelPackages.version;

        # TODO: Doesn't work with the surface kernel; causes it to overheat during suspend
        in unique (flatten [
            # (j.mif.list (versionhas.infix [ "xanmod" "zen" "lqx"]) (genCK [
            #     "0001-MultiQueue-Skiplist-Scheduler-v0.210.patch"
            #     "0002-Unmask-ondemand-and-conservative-and-allow-schedutil.patch"
            #     "0003-Make-preemptible-kernel-default.patch"
            #     "0007-Replace-all-schedule-timeout-1-with-schedule_min_hrt.patch"
            #     "0011-Make-hrtimer-granularity-and-minimum-hrtimeout-confi.patch"
            #     "0012-Make-threaded-IRQs-optionally-the-default-which-can-.patch"
            #     "0015-Make-nohz_full-not-be-picked-up-as-a-default-config-.patch"
            # ]))
            # (j.mif.list (versionhas.infix "xanmod") (genCK [
            #     "0013-Reinstate-default-Hz-of-100-in-combination-with-MuQS.patch"
            #     "0014-Swap-sucks.patch"
            # ]))
            # (genCK [
            #     # "0004-Create-highres-timeout-variants-of-schedule_timeout-.patch"
            #     # "0005-Special-case-calls-of-schedule_timeout-1-to-use-the-.patch"
            #     # "0006-Convert-msleep-to-use-hrtimers-when-active.patch"
            #     # "0008-Replace-all-calls-to-schedule_timeout_interruptible-.patch"
            #     # "0009-Replace-all-calls-to-schedule_timeout_uninterruptibl.patch"
            #     # "0010-Don-t-use-hrtimer-overlay-when-pm_freezing-since-som.patch"
            # ])
        ]);

    };
}
#+end_src

**** environment.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    environment = {
        pathsToLink = [ "/share/nix-direnv" ];
        systemPackages = [
            # ddar
            # extra-container
            # haskellPackages.hocker
            acpilight
            alacritty
            asdf-vm
            atom
            autojump
            autossh
            bat
            bc
            btrfs-progs
            byobu
            cascadia-code
            cmake
            copyq
            coreutils
            ctop
            curl
            darling-dmg
            direnv
            diskus
            distrobox
            dos2unix
            duf
            elvish
            emacs
            entr
            exa
            exfat
            fasd
            fd
            fd
            fff
            ffmpeg
            figlet
            filet
            firefox
            fzf
            gcc
            git
            git-filter-repo
            git-fire
            git-lfs
            gitoxide
            glances
            gnumake
            google-chrome google-chrome-beta google-chrome-dev
            gotop
            gparted
            gptfdisk
            inetutils
            jupyter
            keybase-gui kitty
            libffi
            libguestfs
            libsForQt5.qtstyleplugin-kvantum
            libtool
            lolcat
            lorri
            man
            meld
            micro
            mkpasswd
            monkeysphere
            mtr
            neo-cowsay
            neovim
            nickel
            niv
            nix-direnv
            nnn
            nodePackages.prettier
            nox
            ntfs3g nixos-shell
            pandoc
            par2cmdline
            parted pmutils
            peru
            pfetch
            pypy
            Python
            ranger
            refind
            ripgrep
            rsync
            sd
            settings
            shadowfox
            shellcheck
            silver-searcher
            snapper
            spacevim
            sqlite
            starship
            sysstat
            thefuck
            thermald
            tmux
            tmuxp
            tree
            udftools
            ulauncher
            uutils-coreutils
            vagrant
            vim
            vivaldi vivaldi-ffmpeg-codecs vivaldi-widevine
            vlc
            vscode vscodium
            wget
            win-qemu
            woeusb
            wstunnel
            wtf
            xclip
            xclip
            xfce.thunar
            xz
            zenith
            zoxide
        ] ++ (map (pkg: pkgs.gnome."gnome-${pkg}") [
            "boxes"
            "characters"
            "session"
            "tweaks"
        ]) ++ (map (pkg: pkgs."nix-prefetch-${pkg}") [
            "docker"
            "github"
            "scripts"
        ]) ++ (with pkgs.gnome; [
            dconf-editor
        ]) ++ (with pkgs.gitAndTools; [
            gh
            git-extras
            git-hub
            gitflow
            hub
            lab
        ]) ++ (with pkgs.PythonPackages; [
            black
            black-macchiato
            jupyterlab
            poetry
            pipx
        ]);
    };
}
#+end_src

**** miscellaneous.nix

#+begin_quote
Help is available in the configuration.nix(5) man page and in the NixOS manual (accessible by running 'nixos-help').
#+end_quote

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, system, inputs, ... }: with lib;

{
    xdg.portal = {
        enable = mkForce j.attrs.no-arms;
        extraPortals = map (portal: pkgs."xdg-desktop-portal-${portal}") [ "gtk" "kde" ];
    };
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        inherit (nixos-configurations.configuration.config.system) stateVersion;
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            flake = "https://github.com/nixos/nixpkgs/archive/${inputs.nixpkgs.rev}.tar.gz";
        };
    };
}
#+end_src

**** programs.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    programs = {
        extra-container.enable = true;
    };
}
#+end_src

**** home-manager.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with lib;

{
    home-manager = {
        users = mapAttrs' (designation: user: nameValuePair user {}) j.attrs.allUsers;
    };
}
#+end_src

**** tailscale.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
  services.tailscale = {
    apifile = "/etc/tailscale/apikeys/jeet.ray";
    autoconnet = true;
    deleteHostBeforeAuth = true;
    # exitNode = mkIf (! config.services.tailscale.exitNode.advertise) {
    #     device = "bastiodon";
    #     allowLANAccess = true;
    # };
    magicDns = {
        enable = true;
        searchDomains = [
            # "<<username>>.github.beta.tailscale.net"
            "sylvorg.github.beta.tailscale.net"
        ];
        nameservers = [
            # Cloudflare
            # "1.1.1.1"
            # "1.0.0.1"

            # Google
            # "8.8.8.8"
            # "8.8.4.4"

            # Quad9
            # "9.9.9.9"
            # "149.112.112.112"

            # Adguard
            "94.140.14.14"
            "94.140.15.15"
        ];
    };
    openFirewall = true;
    state.file = "/etc/tailscale/states/${config.networking.hostName}/tailscaled.state";
    trustInterface = true;
  };
}
#+end_src

**** services.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref services.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
{ config, lib, pkgs, system, host, ... }: with lib;

{
    services = {
        emacs = {
            package = pkgs.emacsGcc;
            enable = true;
            defaultEditor = true;
        };
        # flatpak.enable = j.attrs.no-arms;
        flatpak.enable = true;
        guix.enable = true;
        printing.enable = true;
    };
}
#+end_src

**** caddy.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with builtins; with lib;

{
    services.caddy = mkIf config.variables.relay {
        enable = true;
        ca = null;
        config = readFile "/etc/caddy/files/${config.networking.hostName}";
        adapter = "yaml";
    };
}
#+end_src

**** systemd.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref 31997f56-591e-4f45-bcce-bfb6b5333cc6
:END:

#+begin_src text :tangle (meq/tangle-path)
<<31997f56-591e-4f45-bcce-bfb6b5333cc6>>
#+end_src

#+begin_src nix
{ config, lib, pkgs, host, ... }: with lib;

{
    systemd = let
        replaceBorgmatic = n: replaceStrings [ "borgmatic-" ] [ "" ] n;
        replaceRclone = n: replaceStrings [ "rclone-" ] [ "" ] n;
        mkBaseWants = list: unique ([ "network.target" "network-online.target" ] ++ list);
    in {
        # packages = with pkgs; [ runit ];
        services = let
            mkBaseBorgmaticWants = list: mkBaseWants ([ "rclone-backblazeB2.service" ] ++ list);
            mkBaseBorgmatic = n: rec {
                description = "Borgmatic ${(j.toCapital n)} Backup";
                unitConfig.ConditionACPower = "true";
                serviceConfig = {
                    Type = "oneshot";
                    MemoryDenyWriteExecute = "no";
                    LockPersonality = "true";
                    MemoryDenyWriteExecute=no
                    NoNewPrivileges = "yes";
                    PrivateDevices = "yes";
                    PrivateTmp = "yes";
                    ProtectClock = "yes";
                    ProtectControlGroups = "yes";
                    ProtectHostname = "yes";
                    ProtectKernelLogs = "yes";
                    ProtectKernelModules = "yes";
                    ProtectKernelTunables = "yes";
                    RestrictAddressFamilies = "AF_UNIX AF_INET AF_INET6 AF_NETLINK";
                    RestrictNamespaces = "yes";
                    RestrictRealtime = "yes";
                    RestrictSUIDSGID = "yes";
                    SystemCallArchitectures = "native";
                    SystemCallFilter = "@system-service";
                    SystemCallErrorNumber = "EPERM";
                    ProtectSystem = "strict";
                    ProtectHome = "tmpfs";
                    Nice = "19";
                    CPUSchedulingPolicy = "batch";
                    IOSchedulingClass = "best-effort";
                    IOSchedulingPriority = "7";
                    IOWeight = "100";
                    Restart = "no";
                    LogRateLimitIntervalSec = "0";
                    ExecStartPre = "${pkgs.coreutils}/bin/sleep 10m";
                    ExecStart = ''
                        ${pkgs.systemd}/bin/systemd-inhibit --who=\"${description}\" \
                                                            --why=\"Prevent interrupting scheduled backup for `${description}'\" \
                                                            ${pkgs.borgmatic}/bin/borgmatic \
                                                                --verbosity -1 \
                                                                --syslog-verbosity 1 \
                                                                --config /etc/borgmatic/${n}.yaml
                    '';
                };
            };
            mkBaseRclone = n: let
                mountdir = "/mnts/rclone/${n}";
            in rec {
                description = "Rclone ${j.toCapital n} Mount";
                wants = mkBaseWants [  ];
                after = wants;
                serviceConfig = {
                    ExecStartPre = "/run/current-system/sw/bin/mkdir -p ${mountdir}";
                    ExecStop = "/run/wrappers/bin/fusermount -u ${mountdir}";
                    RestartSec = "10s";
                    Type = "notify";
                };
            };
#+end_src

Adapted from [[https://discourse.nixos.org/t/fusermount-systemd-service-in-home-manager/5157][here]], [[https://gist.github.com/kabili207/2cd2d637e5c7617411a666d8d7e97101?permalink_comment_id=4087768#gistcomment-4087768][here]], and [[https://gist.github.com/shadowrylander/2b993d10c98a84e12284833acf164ab1][here]]:

#+begin_src nix
            mkBaseExecStartRclone = mount: let
                dir-cache-time = "96h";
                buffer-size = "512M";
            in ''
                ${pkgs.rclone}/bin/rclone mount \
                                          ${mount} \
                                          /mnts/rclone/${head (splitString ":" mount)} \
                                          --config ${j.attrs.homes.primary}/rclone.conf \
                                          --cache-dir /var/rclone \
                                          --dir-cache-time ${dir-cache-time} \
                                          --vfs-cache-mode full \
                                          --vfs-cache-max-age ${dir-cache-time} \
                                          --vfs-read-chunk-size 128M \
                                          --vfs-read-chunk-size-limit ${buffer-size} \
                                          --buffer-size ${buffer-size} \
                                          --umask 022 \
                                          --allow-other \
                                          --allow-root
            '';
#+end_src

#+begin_src nix
        in mkMerge [
            (mapAttrs (n: v: recursiveUpdate (recursiveUpdate j.attrs.configs.services.base (mkBaseBorgmatic (replaceBorgmatic n))) v) {
                borgmatic-oreo = rec {
                    wants = mkBaseBorgmaticWants [ "chimchar-oreo.mount" "oreo.mount" ];
                    after = wants;
                    serviceConfig = {
                        ReadWritePaths = "-/oreo";
                        ReadOnlyPaths = "-/chimchar/oreo";
                    };
                };
                borgmatic-oreo-rsync = rec {
                    wants = mkBaseBorgmaticWants [ "chimchar-oreo.mount" ];
                    after = wants;
                    serviceConfig.ReadOnlyPaths = "-/chimchar/oreo";
                };
                borgmatic-chimchar = rec {
                    wants = mkBaseBorgmaticWants [ "chimchar.mount" "infernape.mount" ];
                    after = wants;
                    serviceConfig = {
                        ReadWritePaths = "-/infernape";
                        ReadOnlyPaths = "-/chimchar";
                    };
                };
                borgmatic-user = rec {
                    wants = mkBaseBorgmaticWants [ "${replaceStrings [ "/" ] [ "-" ] (removeSuffix "/" (removePrefix "/" j.attrs.homes.primary))}.mount" ];
                    after = wants;
                    serviceConfig = {
                        BindPaths = "-<<userrepo>> -${j.attrs.homes.primary}/.user";
                    };
                };
            })
            (mapAttrs (n: v: recursiveUpdate (recursiveUpdate j.attrs.configs.services.base (mkBaseRclone (replaceRclone n))) v) {
                rclone-backblazeB2.serviceConfig.ExecStart = mkBaseExecStartRclone "backblazeB2:borgbackups-53f2bd74-148c-4fe7-bdb5-701d325645a6";
            })
            {
                # wstunnel-http = mkIf config.variables.relay (recursiveUpdate (j.attrs.configs.services.mkBase "root") {
                #     serviceConfig = {
                #         ExecStart = "${pkgs.wstunnel}/bin/wstunnel --server ws://0.0.0.0:80 -r 127.0.0.1:880";
                #     };
                # });
                # iodine = mkIf config.variables.relay (recursiveUpdate (j.attrs.configs.services.mkBase "root") {

                # });
                # wstunnel-tls = mkIf config.variables.relay (recursiveUpdate (j.attrs.configs.services.mkBase "root") {
                wstunnel = mkIf config.variables.relay (recursiveUpdate (j.attrs.configs.services.mkBase "root") {
                    serviceConfig = {
                        ExecStart = "${pkgs.wstunnel}/bin/wstunnel wss://0.0.0.0:443 -r 127.0.0.1:32443";
                    };
                });
            }
        ];
        timers = let
            mkBase = n: {
                description = "Borgmatic ${toCapital n} Backup Timer";
                wantedBy = [ "timers.target" ];
                timeConfig = {
                    OnCalender = "*-*-* */6:00:00";
                    Persistent = "true";
                    RandomizedDelaySec = "3h";
                };
            };
        in mapAttrs (n: v: recursiveUpdate (mkBase (replaceBorgmatic n)) v) {
            borgmatic-oreo = {  };
            borgmatic-oreo-rsync = {  };
            borgmatic-chimchar = {  };
            borgmatic-user = {
                timeConfig = {
                    OnCalender = "*-*-* */3:00:00";
                    RandomizedDelaySec = "90min";
                };
            };
        };
    };
}
#+end_src

**** virtualisation.nix

Adapted from [[https://www.reddit.com/r/NixOS/comments/ut8j10/nixos_zfs_podman_backing_file_system_is/?utm_medium=android_app&utm_source=share][here]]:

#+begin_src nix
{ config, pkgs, ... }:

{
    virtualisation = {
        containers.storage.settings.storage = {
            graphroot = "/var/lib/containers/storage";
            runroot = "/run/containers/storage";
        };
        xen.enable = false;
        podman = {
            enable = true;
            dockerCompat = true;
        };
        oci-containers.backend = "podman";
        docker = {
            enable = true;
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

** borgmatic

#+name: 3ba5dd6d-4e89-4053-a2c8-89bb213a2d5b
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "storage:
    encryption_passcommand: pass show backup/borg/%r
    archive_name_format: \"borgmatic-%r-{now:%%Y%%m%%dT%%H%%M%%S%%f}\"

retention:
    prefix: \"borgmatic-%r-\"

consistency:
    prefix: \"borgmatic-%r-\"" `((?r . ,repo)))
#+end_src

*** shared.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref 8ef18fc2-ee65-4dfc-8977-69f14efd8064
:END:

#+begin_src text :tangle (meq/tangle-path)
<<8ef18fc2-ee65-4dfc-8977-69f14efd8064>>
#+end_src

#+begin_src yaml
location:
    one_file_system: false
    numeric_owner: false
    atime: true
    ctime: true
    birthtime: true
    read_special: true
    bsd_flags: true
    files_cache: ctime,size,inode
    local_path: borg
    remote_path: borg
    exclude_caches: true
    exclude_nodump: true
    exclude_patterns:
        - .zfs/snapshot

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

storage:
    checkpoint_interval: 300
    compression: auto,zstd,22
    ssh_command: assh wrapper ssh --
    relocated_repo_access_is_ok: true
    unknown_unencrypted_repo_access_is_ok: true

retention:
    keep_within: 6H
    keep_secondly: 60
    keep_minutely: 60
    keep_hourly: 24
    keep_daily: 7
    keep_weekly: 4
    keep_monthly: 6
    keep_yearly: 4

consistency:
    checks:
        - repository
        - data
        - extract

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
hooks:
    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

*** borgmatic-shell.nix

#+begin_src nix :tangle (meq/tangle-path)
with builtins; with (import (fetchGit {
    url = "https://github.com/<<username>>/<<username>>";
    ref = "main";
})).legacyPackages.${currentSystem}; mkShell { buildInputs = with PythonPackages; [ bakery ]; }
#+end_src

*** mountable-mounted.hy
:PROPERTIES:
:header-args:hy+: :noweb-ref 755d259c-5582-4cd7-bd51-70b33598f264
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#! /usr/bin/env nix-shell"
<<755d259c-5582-4cd7-bd51-70b33598f264>>
#+end_src

#+begin_src hy
#[9debb8f7-e891-48e9-8bd9-3b5b40d0ebbb[
#! nix-shell borgmatic-shell.nix
#! nix-shell -i hy
]9debb8f7-e891-48e9-8bd9-3b5b40d0ebbb]
#+end_src

#+begin_src hy
(import bakery [zfs])
(import sys [argv exit])
(for [pool (cut argv 1 None)]
     (for [dataset (.list zfs :H True :r True :o "mountpoint,mounted" pool)]
          (let [ dataset-split (.split dataset) ]
               (if (and (!= (get dataset-split 0) "none") (= (get dataset-split 1) "no"))
                   (exit 75)))))
#+end_src

*** oreo.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref 5f309ef6-fa82-4235-9a2a-4ffdbf2cf1f1
:END:

#+begin_src text :tangle (meq/tangle-path)
<<5f309ef6-fa82-4235-9a2a-4ffdbf2cf1f1>>
#+end_src

#+begin_src yaml
<<: !include /etc/borgmatic/shared.yaml

location:
    source_directories:
        - /chimchar/oreo
    repositories:
        - /oreo
    hooks:
        before_backup:
            - pass show backup/borg/oreo &> /dev/null || exit 75
            - findmnt /chimchar/oreo > /dev/null || exit 75
            - findmnt /oreo > /dev/null || exit 75
        # Healthchecks ping URL or UUID to notify when a backup
        # begins, ends, or errors. Create an account at
        # https://healthchecks.io if you'd like to use this service.
        # See borgmatic monitoring documentation for details.
        healthchecks: https://hc-ping.com/9660799a-0aba-44d7-a29f-3887a0ce82bd
<<3ba5dd6d-4e89-4053-a2c8-89bb213a2d5b(repo="oreo")>>
#+end_src

*** oreo-rsync.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref 10dc9db1-b913-4d17-abea-206297082e84
:END:

#+begin_src text :tangle (meq/tangle-path)
<<10dc9db1-b913-4d17-abea-206297082e84>>
#+end_src

#+begin_src yaml
<<: !include /etc/borgmatic/shared.yaml

location:
    source_directories:
        - /chimchar/oreo
    repositories:
        - 9237@usw-s009.rsync.net/./oreo-rsync
    remote_path: borg1
    hooks:
        before_backup:
            - pass show backup/borg/oreo &> /dev/null || exit 75
            - findmnt /chimchar/oreo > /dev/null || exit 75
            - ping -qc 1 usw-s009.rsync.net || exit 75
        # Healthchecks ping URL or UUID to notify when a backup
        # begins, ends, or errors. Create an account at
        # https://healthchecks.io if you'd like to use this service.
        # See borgmatic monitoring documentation for details.
        healthchecks: https://hc-ping.com/e6d79f19-8c5b-429a-99d0-0247fdb251ea
<<3ba5dd6d-4e89-4053-a2c8-89bb213a2d5b(repo="oreo-rsync")>>
#+end_src

*** infernape.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref 8c3fd1cd-ab81-4e13-a520-ce067e07df54
:END:

#+begin_src text :tangle (meq/tangle-path)
<<8c3fd1cd-ab81-4e13-a520-ce067e07df54>>
#+end_src

#+begin_src yaml
<<: !include /etc/borgmatic/shared.yaml

location:
    source_directories:
        - /chimchar
    repositories:
        - /infernape
    hooks:
        before_backup:
            - pass show backup/borg/syvlorg &> /dev/null || exit 75
            - chmod +x /etc/borgmatic/mountable-mounted.hy && /etc/borgmatic/mountable-mounted.hy chimchar
            - findmnt /infernape > /dev/null || exit 75
        # Healthchecks ping URL or UUID to notify when a backup
        # begins, ends, or errors. Create an account at
        # https://healthchecks.io if you'd like to use this service.
        # See borgmatic monitoring documentation for details.
        healthchecks: https://hc-ping.com/aa90aa9a-d507-4c8e-92c9-a037cd42e585
<<3ba5dd6d-4e89-4053-a2c8-89bb213a2d5b(repo="infernape")>>
#+end_src

*** user.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref 09c26e15-e863-4127-9e5e-b8a768a63b8c
:END:

#+begin_src text :tangle (meq/tangle-path)
<<09c26e15-e863-4127-9e5e-b8a768a63b8c>>
#+end_src

#+begin_src yaml
<<: !include /etc/borgmatic/shared.yaml

location:
    source_directories:
        - <<userrepo>>
    repositories:
        - <<userhome>>/.user
        - hpvlk40u@hpvlk40u.repo.borgbase.com/./repo
    hooks:
        before_backup:
            - git -C <<userrepo>> pull --all || :
            - git -C <<userrepo>> submodule update --init --recursive || :
            - pass show backup/borg/user &> /dev/null || exit 75
            - ping -qc 1 hpvlk40u.repo.borgbase.com || exit 75
        # Healthchecks ping URL or UUID to notify when a backup
        # begins, ends, or errors. Create an account at
        # https://healthchecks.io if you'd like to use this service.
        # See borgmatic monitoring documentation for details.
        healthchecks: https://hc-ping.com/1ed0af6c-aa1d-4930-aa1e-3d1af89c9251
<<3ba5dd6d-4e89-4053-a2c8-89bb213a2d5b(repo="user")>>
#+end_src

** nix
*** nix.conf

Adapted from [[https://github.com/divnix/digga/blob/main/examples/devos/flake.nix#L4][here]]:

#+name: 270d5d30-951e-4171-8c23-67fc45d20578
#+begin_src emacs-lisp :var delim="" comment="" quoted='nil flake='nil
(format-spec "# extra-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/%q%d
trusted-substituters = %qhttps://cache.nixos.org/%q%d
# extra-trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=%q%d
trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY=%q%d
%ckeep-derivations = true%d
%ckeep-outputs = true%d
extra-experimental-features = %qnix-command flakes%q%d
%callow-unsafe-native-code-during-evaluation = true%d
%cmin-free = 262144000%d
%cmax-free = 1073741824%d" `((?d . ,(if flake ";" delim)) (?c . ,(if flake "# " comment)) (?q . ,(if (or flake quoted) "\"" ""))))
#+end_src

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** zsh
*** keephack

#+call: hash() :exports none

#+RESULTS:
: 20210601185403002625400

#+name: 20210601185403002625400
#+begin_src emacs-lisp
(concat
    (let
        ((file "~/resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+begin_src sh :tangle (meq/tangle-path)
<<20210601185403002625400()>>
#+end_src

** sv

I just keeping these here for reference.

*** caddy
**** log
***** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
exec svlogd -tt /etc/sv/caddy/log
#+end_src

**** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
for port in 22 80 222 443 2022 8080 9418 60000:61000/udp; do
    ufw allow $port &> /dev/null
done
chmod +x /etc/sv/caddy/{finish,log/run}
exec /usr/bin/caddy run --config /.config/caddy/files/<<hostname>> --adapter yaml 2>&1
#+end_src

**** finish

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
killall caddy
#+end_src

* .gnupgk
** jeet_ray_rsa.pub

#+begin_src text :tangle (meq/tangle-path)
-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGJq3x0BEADVv97yaZ2dvNvJhmPWi8MSVpjLa5C1LgOEYU+d2icQgPa+znPq
3975Tjh0tN64DpLpRCAOTt8nj+IzohQXrkDJ1VVzcK01HwWgTjYYDGhq7ziUd9yH
38wCeiA/uUjXS/l27CZxiQnuUMj0PozLF5YungNtZcUaoXRw2bj/Evkbz3tc+QID
FYCv6PPqQDmEZUw/UH6O0CKCtJMvEPbyT9S519Vo1AJ4mCO0HDQduwUiJOmcl3Jl
3UrwiIc5jlyjVJr+VNS/DIuXZFXrJE+Xhqj9bHkS7nXgoPGnZVoW9yl7yevoywX4
4R7stWEBEkpwpNpBfYvSb4N0zQ4OkbJzK+y6OH2VO7TiqdrtK8c1V8JndRO0Z6Y7
eqQ6KgzKoxeW5lCQHBeyDTpk5JkW70Mkkame9KHpNh3ZryMpj5vWanfQ2w9SDusQ
ybwJx9rmRtY8oykhpqPkj7orn+MV8r0GjWTVaQ8PuylzjDpj8WG7CUwkO+/wsMpb
XwjLFlnHx3zq0q6hPeSk3Oc8e/iaL4QWXgxy6XbMEGcaiamN7+oWtaWS3lmscjHN
0/+EYEJc3QYG7nHih3od0KdNxpb8IqM9JMQ7WExXk1n6VnvWNVApqA1Rx2APuIGg
TkWlEdNI0ZI0nAZF/idazRZhfqfVotV2BA51T0mGx4VvCm7yNyQnVYKwJQARAQAB
tCdKZWV0IFJheSAoamVldC5yYXkpIDxqZWV0LnJheUBzeXZsLm9yZz6JAk4EEwEI
ADgWIQTarbDFXR7q9CL8fheMELh2VDUU+AUCYmrfHQIbAwULCQgHAgYVCgkICwIE
FgIDAQIeAQIXgAAKCRCMELh2VDUU+MuwD/sF8ubYahmk7Lcqj7JnKwxHWWan7EJa
5tQwwGDMRy8w6c/2wHxK2tq4icCisZk5E+quPrp4qFzo8gZVD7ZOM6CsXMBGpr9r
eRHXqN+Sw/cc94hlGysjyR9MAW/Mw3p9eMoXvpiF/CV7roN1mASOJi8EIb3b7zNd
uVfkjvPkDa6sVoPiQjOQzgCKEjYVvWJT3ffd6YAfNpxtmEACjNXCUOz6SpDyur0k
tnwCIrLnhh2m8Rje+R9xoeXrXDvk1S7TK4GuNQrb3BuTYL4ctqRewpjgIwR2HjA7
8/JN67TV2dekEiePQ/xShV6OjzuOBAF7pd4djdvxSgIQ49Ye/EaHkK5b7Mgn7UkO
LWYiV+A3fP+M/KEyKi9wm2LvKpIBDQbP0tpkU9cBQZ5ZlNvv3FyIB3QfpTR2T79F
B3rIWF9gYSDANxYuRNQfyDWb1Cx4UdyME22nqNSD0GW6KbWrABDnrgxg6cbeTdPK
v9a3M5dZg2+NMvQt9wiidRYmCUYyqR99xCPMuhS9aqGOxoK89kkVKxmn69yAwmdw
FsIPssL8Hu2cJx1LJR3efnoiOWBNkEfGPd6E2jKZicvoSZIp+URulgSCCo6ycVQt
iysKuRxH0TOsnINAGl6S6Qo1FEwfbTp1Sle/YxeK83HhSzCvK08nxS9xJlMvwAVj
EOPbF8Spb+Hbz7kCDQRiat8dARAAyYTWH54fFr/dvWvC6wpKYEhIoaV+PuSAukOi
2FmomwiMPq4WjGL2qc/+/KK/kNL/CUgZxW5jySy5jRo4FWrtTKruOpWyCcW3vSb9
TX9vWCP/jc+P/3lU3WJVfRpKuppwpB7Zji7ybfYnEP9ekT2YjgLT3wF9wFtbrkfU
YyeI4jOgtL9BRA/3MNCfpdtEowWWF71avzzSg05zI3/2NT6N98oAqAZ1vGEbk836
qZGrNm73bXQ5BWjwgN7A1NsR9Lycls8b+zsz5S70jyQmkN3dzpkCLgplDAgk3H7i
n5+V3Vs7+6urk/1so17Ev76LhrEhejOr9YlVISHZ5keoPdxW+JZJXtAjeC5DjiOx
UcmvKG8hkGE8miv3lVGoeWPCkyDO1pCXveRD4R/a13A3SagdmsJUOc61PQVgfE2l
EAOOzDWIs9DD71Bw4UccetAnqracAIxfepx2L/L5JQvLi0ToUdp3PhGfwILnEPaQ
RJZG24vXeK3zSsxg8BE1jyToidti0grxFI08Pq/e+G4v9Cawhx1KMQ2w4OMmVzjt
v2kFOdo/qYQyJ235ps33iUiyaVP3v24T2CIKCMzWhtZ3BC3RnX7iZKVcjIYvPdo1
1ruEHQ1TMHKe8zPWQzMBToBqllEE/RxlrLsqlNKmain/IKC0QkBHPUOS2lfCyzi7
1NiupycAEQEAAYkCNgQYAQgAIBYhBNqtsMVdHur0Ivx+F4wQuHZUNRT4BQJiat8d
AhsMAAoJEIwQuHZUNRT447QP/1cT14s9kjlIVDkags0ZyiJZachQ1TkRuH0S5lgj
j5vFEnII0T1XbmAqbHW4lj8kmwk/vvTfy8LkvcBmxuY+/fi+uTdNVJ9czrFxzqW7
KXEeJgXVt4MH3YwPqJVZk2GK7qcqiHxEMP6Pw842rLQ4rN+VtiFXoIQ8hah+hEef
Z9WX+NvZ1wH+vo7aB1gEqQfvtxCvmce+G78ef5cKJeGu3abunD94s8EJ5xoXaG4J
GStBoK/7QcVVWaJn9liHOstVupiU3isMY0sfjQVOod5s3l/kS8ziI3JF86YOCsM2
2PFQaKQHfqskwEqoO/4T40xsq/OjZIH3SdqklKwp9NQe5GmMQFFTEssNaOagxK/q
7KT196j+fNyeN+2nJFyJs/kaSYzKYUuTlwpM0Xi/kGNDbSY+E7XDc6TgLBRppz2n
bTPU9wd40DZGZWEsad8Bevn7Q6Amv9ZEVhrrhDBOB1eYBtjWTJxGo8BRfREl2WQb
nkT/csNLcJRujJoOaRzHEn9RRcTXc5dIWOeZTNZHVqjgQ1LckdUutnkpNy1+MBHQ
ktKcDhm1DIqBm5URPGkj3TIgOJfLfGcQRLVO1KSaQG80AogbeaytfL+6qM/CyRGI
/jbxRRSQms+WuKZxKmvN3wL0fshSJCtHh33oijjs26VEvUCqsk3YfNThbqf477+w
GfJDuQINBGJq6OoBEADO6WDqVwcWWH5DyiktpnFze6GzdBtHXiV/nlyim1J6kXXG
fJCfqtYY3TB1nkyoXDoXYe/1ywLf0ezIXqrHH0I9XRqo3ThK/SUJViFDoc2qgtYc
B/Bkg3QvZuN2q+1lBrVSyO/C2Pklad4RKWsewOS5BO/BPFFdMu2d4XTpIXxfWztZ
TnWs+rp6a1N8TzXEKIzm/QvKXGAIrZ5hHeefgYvTisFfowyLfI4Lm4A4Ofrrskaq
8XdlSXaOVNrr5d1FGiv2Hos+/aoojtJX+V+uIlIhMo93broRBTt13u19exKmQF3J
A1SKNiJ8RYqU3B3Ri0CJp0bT8aRakxJwp0HhBj8m+mWQY/QYOe3qbWFkG9ccZIsv
9Ezg2oQcrLvECDnRWSUN/iICFH4cblAKnubup0A6GF4WyOEXhwl4jJ/GnqfiKdSl
8KM4it7LtB6m6P0Vt53FImBzcK4TmsdgEyDq8rPUR0PL10vQRyNKkJz2cqpablq+
VX5xucZbPu6w8vG6oRTBrRE+Q9wIoCrySF9qJE/tgImCKEWDWseGLkd4oHYfVhgg
oTnMumhUtEN6LMXhusqdyhL5rAHJ3YMSTSrNc2zE+We/it3WFhlc68Daw6Kc/HYw
qI8jhQ0OMS3CXNF2RXuxN1FlTZHS06h+2C9nBmbJO1WJ0Xllyi/cn9ISy/bM5QAR
AQABiQI2BBgBCAAgFiEE2q2wxV0e6vQi/H4XjBC4dlQ1FPgFAmJq6OoCGyAACgkQ
jBC4dlQ1FPgVMRAAu2nfCGDSI6vfXy9lvX9IUffTmV/aDidnamYYqLTLBRVcMe5T
SKOVqk3I4e4HOPMAmm+WmIJLFPqx3GDnmx6hvG0Edwcx+FkfpidrC8qU5aWhyRAS
MXMdfPs4mgRzQezvU+i4QqeS7k37OcPOobwqzLIjkq+0/ELFiaoCBLKscAE+juqq
EmrBh3lFKHsWUF3YQSZ8PqjDGywFRO9dm+zc+ZE7AAqr7niGipjxNCoPG7bOX+Rd
uv1Ko845+5idlDkpi4bsQbFpOLlEIkQcbnQHGPVlRRukApd9Wo+uUJxmUHNcL6ys
qkXs7535ZPeCLdRQ2IS8OsoaeUnkJJl0XC6Old52bOkUtE+nUkFv6eyg+2KXAWKA
4pDZD9n2YNc+MQnJTt31yotBNUEZoCBPjT9a3/2vsBRakyd992jxDJC300DwGJrE
KX/7WGPbVeSnC29yBaZgsiXz9v6S3UF1RMOe7PkKPPY4EQiijNdmzchZRbVMI//a
EyyJlCOTMkPId7Dctes5Yp6KROzhPFyTyOEeYM5tfm46cRGNkETkBgw+/5tMLA5Z
qtvXo3WfQFAUHv6DI90XKhaB3+FeXsosBW5LmWJuy+tLnypiJR7nY0RHmYVI2ZXn
MibZQg+ZAwmehn7ytlU3FiHPx4fYZd6gSsIUPZJ1twx4/5sW6nUv+iK6V0S5Ag0E
YmrpVgEQAL/PWZUr+WRg7LHYK1Uz1x8Wa0rkNIjU3fGvYBcElg63hrGnCPCp4N4J
nYwWZuNn4FJ1qDBm7merwUz5jCY2MRojEEHyMpluOy48Z+zVixOyDz6acD5LQzQE
2pLx72Gry+dxpOqbC6iLytY465SYMOYHT1tt+fbBUuo+eLsMP+0y6TIEYldHffKB
NZQDTf0FvWrTqn599zpG/3cHmAJ0LO3Hr1lG0d6bnXyYzoKyJUwu/kxhZ6Ypy0bZ
m/TyzG80K6vWmaEmi6avyMx4EqfMxFxw0hkUiwtXw3HyStlUbGSL+/cnhWv1wRFZ
TSj8EANHw3awDSoJK5+TIFWzbkyJ9fVRabX6X59eZ96zlhXEggX7Rct2aCLpnlcw
vYjySxZ5lReulTXsZUsHMjHzCkaweoRtBqKVYGmeYIqId3CbMfLx87X2z/++T9jP
3hIKaJg0VHSDCSEtsunWazPnlNAOMkk3GKUUQ+/f8nlQcm0G0iJr0Cf+M2U6fU2u
mmc9Mwbt6wj3xslsWjS5oPIdHHN/Iv3qamGCOtuSCEaGC25uc4d3WEy17RhhwTa9
AWPc5pSOoL6tlKXy0sQnyFCegkwehvoieLrIUgjWg/0cdUmziYxhXECXOwWPyhCm
i8Om2l8yzrv9JGRDhyKyhMQQf8JvbKcuBZagqq756yu29AHSQqJ9ABEBAAGJBGwE
GAEIACAWIQTarbDFXR7q9CL8fheMELh2VDUU+AUCYmrpVgIbAgJACRCMELh2VDUU
+MF0IAQZAQgAHRYhBEdm0dTZAEMb9fn06yCVykzJwQUsBQJiaulWAAoJECCVykzJ
wQUswQUQAIa5SxgY0cHz1aP/CUDF41SQuq1+nAqUmwXndNJ42iTAH/vGOVNBiXEH
Q55CQO8mOHw0F0omhEg5cDdhh+YyP2pSHxyWqTGwY+RqVdLIkl4pAopOaAyGRoyD
N333wJoRw+lVnqACPDe5pdXCWWrllfuiZvQfsKs4t7qGYIAn+TY4Uw+lHbMknYb/
uDEPg03uSintuyu2l/yIGArMa0Ij3sh0jyfiFTaiylPafWBM/NfLnoCVSTbMURp5
7nGM3BVp0yKYMhey20KrY+GFoDCeVhFn6E0cqh5NRmL853nG59JrT5nHBl2AaVIr
+Vgwwsv1ltbCA2Jrb7V84Y7TjG90LHgRMVVsadzX1o4PMN2AoJ2plTj6tFTCDZDk
KBm8DmaV6Rygt0rZhAztPW7jg/X5lkx2biiNJLFyPzYBxfGnd6/JCzhakHYETAmH
srl0prUHrrcAH0pd7IZPandCE05bM9hOb7d4VtA7IT00TWeKn2M3Tf3QmE0hbcxb
k/c+1ZRIxrx8HyQDkGFRVu4GwjTmSU5uRGu0Q9FvclRsxaAm7TMVUAZ/Q3ZLNta6
b8TwGdbXHQOcG3DEO/awY0DhkWhuQrgnk7d+MtoV3xONbGb9H7kQtEadubd1EcNU
M6I0oTdwvoHg/mcos9UWzTjY3kLa5bwNMeAKHcQfukio+giKuwFp6RkQAMIM3Hoh
WQZPQqpU7/GsEt++onMP3G4RUKevUKH5meecmcgeu9NC9A+vT2GrrUVFh0juLIBE
pT0FEuiduMj1zp+ByH1ywl0EnrtUPuJNjtqZLlWjfyVCz318Fo9LTB0yWUGQUU+L
UM6qXWd1W2hGk4x4SNi2C5gnJ04fyPkP0dyxKbnQqTYQlltLC5pbgVRxq/0CmtCC
uIMShTQ9CaX0w3VvMbra6fJgkZuRk8SOwFmA3YZ+a+CaYvo6PL9FQjxPIJ4PuBKL
zUdJw4IOIHJi+n9KuwINwhvlJqvxFMY5vjLieI8moNezhVcGEwbGa/XT0mvZG6xP
t0Wp/LtH8vM4pSxv+ftmmpiQhm0vL+17tlX3NDTp3HIySF5J1q5nEn3JpjmKIsGS
FeHd85EM5NcVGyFSF11Q3XJciLz08H+xcJw1C7C/vV9dNX/icJRtW45+4lkBjBan
7EtMyTfkQ9wahN8O7T32OoWrhl6QZe46CsKc9FEK2SdlAKyy0bG9MPZJ1kHxN/1c
nkHgXg25cecCCN8Is/mEFQ650057Rqyz3zNtH+EVZwFNJGVgFMzrLQ0Q6QY+9A7J
UFeHy12N2RGsGJpoJFoF1f0TrPinYU7TivvUJeWulGWKGr3CZHY//3NAji74iUsr
REgsM22cpS836D7wEX0rtEYHPj9YAkfj53yI
=LhpQ
-----END PGP PUBLIC KEY BLOCK-----
#+end_src

* .ssh
** id_rsa.pub.bak

#+name: 652c4828-b716-42a1-b777-b37b99b468a7
#+begin_src text :tangle (meq/tangle-path)
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com
#+end_src

** id_ed25519.pub.bak

#+name: ec2d5c28-4cbc-4f9b-aa60-835fff096273
#+begin_src text :tangle (meq/tangle-path)
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO8NzKV52dRBAir8ARoFJX/xQDVCNup6xe1ddX1YVXSO sylvorg@syvl.org
#+end_src

** jeet_ray_ecdsa.pub

#+name: 757d7c7f-bbd3-49b3-a47e-84158337318c
#+begin_src text :tangle (meq/tangle-path)
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGsRy6rLDzmLNISdWahFLGDo+ZZLbndj6k8Q8MUQum/mPAzy8lsAQz/0XiicJz7LlM74tWGDYSJG1Ay2Iyc/ew4= jeet.ray@syvl.org
#+end_src

** jeet_ray_ed25519.pub

#+name: 9d0e196f-1118-43bb-8b2f-0650e49b211a
#+begin_src text :tangle (meq/tangle-path)
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICor+WXoAypnk5rkgTljAN6kk8olvKWqtnmGWVuQu8z9 jeet.ray@syvl.org
#+end_src

** jeet_ray_rsa.pub

#+name: ec44d933-c4ac-4da5-8086-f1d7b4358139
#+begin_src text :tangle (meq/tangle-path)
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCs4zqEt/Fkjw0LVQTwJXlovmnqqGWC4UOVPvoLDvo0JD6WeVBDi4cFPX2mpNJYmYJsBLDXeUq5XrQ1ST3BkfVdspsragnD7O92tTEf3/VHfIC1L165pnB08FXQrtIjyLL7Ry4dloUGBYKLnHOtnXlpefKMQzRYUacc7Tr1o2wv+XRoDW9h+qDqJz1O61N68JFLgJWD3/nUkm8siTg1OLvqO9ATp+UgP/Lb08E6HfqYOiD8H+1ZJjz78mo5oZatknvgy8uJJPqEX7/aRM61YA9TG+tw/sf6wlrDtUQUik8Y4k1DLmkhE15wcgq/HF2Rqka/acA9GxA5smNGyjs6CS+H jeet.ray@syvl.org
#+end_src

** shadowrylander_ecdsa.pub

#+name: 9320021a-a3d7-4bd5-9f80-269073d02a2a
#+begin_src text :tangle (meq/tangle-path)
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNlVuY9reRuMloYvecJHHsOYkAPDyQwELOI3kfibslIKI5hY+o1jx5yVyAUomHynP6wulm5aziNc5kWdsRE9BE8= shadowrylander@syvl.org
#+end_src

** shadowrylander_ed25519.pub

#+name: 12713489-9696-4a9a-8e92-242011772051
#+begin_src text :tangle (meq/tangle-path)
ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINZ2FCMbnetAnDZ63Wzct+O3MYhtO9+BedATbtiHI9BT shadowrylander@syvl.org
#+end_src

** shadowrylander_rsa.pub

#+name: 3325c6f6-a054-41bf-a941-7dd6ad5f6124
#+begin_src text :tangle (meq/tangle-path)
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDP8ifT/3d6L2MzZPoTh0bUjQUXuPKfPP8Tp03E5En2x+iKhv+J/U0z0xk7IdPZ4qEO+ZWI5xWbwVkDdnRnJ/5HgA0/ZwmO5Zpj3llSr4dJMUVSSyO23fFIL2WqOpHyQDeexJWMxbU5SmIi+c855VwewCbGDcPnmDo0XgR/u4LRF2pwYGNGFtJ2/GICEIob/2w0ICwi7TMUEkDbUFcP5web81OzsNu80M60VaNl870uT1rwBeKuW7CXFtImYytZ0mOc5LC6d7ugkFS1zAbLOWjt3PJ8Op2MH9ncBj5jCsIlA/OqI72jKwEPOl8evYqWeEOzlVxA7/AkRj7haQqFE8r/ shadowrylander@syvl.org
#+end_src

** id_rsa.pub

#+name: 643209da-424e-4027-a77c-54ac4e661013
#+begin_src text :tangle (meq/tangle-path)
<<3325c6f6-a054-41bf-a941-7dd6ad5f6124>>
#+end_src

** id_ed25519.pub

#+name: 1483d99f-3b9c-4bf8-8139-1bd917e5fe47
#+begin_src text :tangle (meq/tangle-path)
<<9d0e196f-1118-43bb-8b2f-0650e49b211a>>
#+end_src

** id_ecdsa.pub

#+name: e9088d86-c5ba-4aca-b7e3-80edd943e12c
#+begin_src text :tangle (meq/tangle-path)
<<757d7c7f-bbd3-49b3-a47e-84158337318c>>
#+end_src

* .gitattributes
:PROPERTIES:
:header-args:gitattributes+: :noweb-ref 964e6c9e-f4f8-4def-8bab-6e13f95759a5
:END:

#+begin_src text :tangle (meq/tangle-path)
<<964e6c9e-f4f8-4def-8bab-6e13f95759a5>>
#+end_src

Adapted from [[https://rehansaeed.com/gitattributes-best-practices/#final-form][here]]:

#+begin_src gitattributes
####################
# Git Line Endings #
####################

# Set default behaviour to automatically normalize line endings.
,* text=auto

# Force batch scripts to always use CRLF line endings so that if a repo is accessed
# in Windows via a file share from Linux, the scripts will work.
*.{cmd,[cC][mM][dD]} text eol=crlf
*.{bat,[bB][aA][tT]} text eol=crlf

# Force bash scripts to always use LF line endings so that if a repo is accessed
# in Unix via a file share from Windows, the scripts will work.
*.sh text eol=lf
#+end_src

** Largefiles

The LFS filter are from both
[[https://raw.githubusercontent.com/sindresorhus/binary-extensions/main/binary-extensions.json][here]] and
[[https://rehansaeed.com/gitattributes-best-practices/#final-form][here]]:

#+begin_src gitattributes
*.3dm filter=lfs diff=lfs merge=lfs -text
*.3ds filter=lfs diff=lfs merge=lfs -text
*.3g2 filter=lfs diff=lfs merge=lfs -text
*.3gp filter=lfs diff=lfs merge=lfs -text
*.7z filter=lfs diff=lfs merge=lfs -text
*.a filter=lfs diff=lfs merge=lfs -text
*.aac filter=lfs diff=lfs merge=lfs -text
*.aax filter=lfs diff=lfs merge=lfs -text
*.adp filter=lfs diff=lfs merge=lfs -text
*.ai filter=lfs diff=lfs merge=lfs -text
*.aif filter=lfs diff=lfs merge=lfs -text
*.aiff filter=lfs diff=lfs merge=lfs -text
*.alz filter=lfs diff=lfs merge=lfs -text
*.ape filter=lfs diff=lfs merge=lfs -text
*.apk filter=lfs diff=lfs merge=lfs -text
*.appimage filter=lfs diff=lfs merge=lfs -text
*.ar filter=lfs diff=lfs merge=lfs -text
*.arj filter=lfs diff=lfs merge=lfs -text
*.asf filter=lfs diff=lfs merge=lfs -text
*.au filter=lfs diff=lfs merge=lfs -text
*.avi filter=lfs diff=lfs merge=lfs -text
*.baml filter=lfs diff=lfs merge=lfs -text
*.bh filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text
*.bk filter=lfs diff=lfs merge=lfs -text
*.bmp filter=lfs diff=lfs merge=lfs -text
*.br filter=lfs diff=lfs merge=lfs -text
*.btif filter=lfs diff=lfs merge=lfs -text
*.bz2 filter=lfs diff=lfs merge=lfs -text
*.bzip2 filter=lfs diff=lfs merge=lfs -text
*.cab filter=lfs diff=lfs merge=lfs -text
*.caf filter=lfs diff=lfs merge=lfs -text
*.cgm filter=lfs diff=lfs merge=lfs -text
*.class filter=lfs diff=lfs merge=lfs -text
*.cmx filter=lfs diff=lfs merge=lfs -text
*.cpio filter=lfs diff=lfs merge=lfs -text
*.cr2 filter=lfs diff=lfs merge=lfs -text
*.cur filter=lfs diff=lfs merge=lfs -text
*.dat filter=lfs diff=lfs merge=lfs -text
*.dcm filter=lfs diff=lfs merge=lfs -text
*.deb filter=lfs diff=lfs merge=lfs -text
*.dex filter=lfs diff=lfs merge=lfs -text
*.djvu filter=lfs diff=lfs merge=lfs -text
*.dll filter=lfs diff=lfs merge=lfs -text
*.dmg filter=lfs diff=lfs merge=lfs -text
*.dng filter=lfs diff=lfs merge=lfs -text
*.doc filter=lfs diff=lfs merge=lfs -text
*.docm filter=lfs diff=lfs merge=lfs -text
*.docx filter=lfs diff=lfs merge=lfs -text
*.dot filter=lfs diff=lfs merge=lfs -text
*.dotm filter=lfs diff=lfs merge=lfs -text
*.dra filter=lfs diff=lfs merge=lfs -text
*.DS_Store filter=lfs diff=lfs merge=lfs -text
*.dsk filter=lfs diff=lfs merge=lfs -text
*.dts filter=lfs diff=lfs merge=lfs -text
*.dtshd filter=lfs diff=lfs merge=lfs -text
*.dvb filter=lfs diff=lfs merge=lfs -text
*.dwg filter=lfs diff=lfs merge=lfs -text
*.dxf filter=lfs diff=lfs merge=lfs -text
*.ecelp4800 filter=lfs diff=lfs merge=lfs -text
*.ecelp7470 filter=lfs diff=lfs merge=lfs -text
*.ecelp9600 filter=lfs diff=lfs merge=lfs -text
*.egg filter=lfs diff=lfs merge=lfs -text
*.eol filter=lfs diff=lfs merge=lfs -text
*.eot filter=lfs diff=lfs merge=lfs -text
*.epub filter=lfs diff=lfs merge=lfs -text
*.exe filter=lfs diff=lfs merge=lfs -text
*.f4v filter=lfs diff=lfs merge=lfs -text
*.fbs filter=lfs diff=lfs merge=lfs -text
*.fh filter=lfs diff=lfs merge=lfs -text
*.fla filter=lfs diff=lfs merge=lfs -text
*.flac filter=lfs diff=lfs merge=lfs -text
*.flatpak filter=lfs diff=lfs merge=lfs -text
*.fli filter=lfs diff=lfs merge=lfs -text
*.flv filter=lfs diff=lfs merge=lfs -text
*.fpx filter=lfs diff=lfs merge=lfs -text
*.fst filter=lfs diff=lfs merge=lfs -text
*.fvt filter=lfs diff=lfs merge=lfs -text
*.g3 filter=lfs diff=lfs merge=lfs -text
*.gh filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.graffle filter=lfs diff=lfs merge=lfs -text
*.gz filter=lfs diff=lfs merge=lfs -text
*.gzip filter=lfs diff=lfs merge=lfs -text
*.h261 filter=lfs diff=lfs merge=lfs -text
*.h263 filter=lfs diff=lfs merge=lfs -text
*.h264 filter=lfs diff=lfs merge=lfs -text
*.icns filter=lfs diff=lfs merge=lfs -text
*.ico filter=lfs diff=lfs merge=lfs -text
*.ief filter=lfs diff=lfs merge=lfs -text
*.img filter=lfs diff=lfs merge=lfs -text
*.ipa filter=lfs diff=lfs merge=lfs -text
*.iso filter=lfs diff=lfs merge=lfs -text
*.jar filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpgv filter=lfs diff=lfs merge=lfs -text
*.jpm filter=lfs diff=lfs merge=lfs -text
*.jxr filter=lfs diff=lfs merge=lfs -text
*.key filter=lfs diff=lfs merge=lfs -text
*.ktx filter=lfs diff=lfs merge=lfs -text
*.lha filter=lfs diff=lfs merge=lfs -text
*.lib filter=lfs diff=lfs merge=lfs -text
*.lvp filter=lfs diff=lfs merge=lfs -text
*.lz filter=lfs diff=lfs merge=lfs -text
*.lzh filter=lfs diff=lfs merge=lfs -text
*.lzma filter=lfs diff=lfs merge=lfs -text
*.lzo filter=lfs diff=lfs merge=lfs -text
*.m3u filter=lfs diff=lfs merge=lfs -text
*.m4a filter=lfs diff=lfs merge=lfs -text
*.m4v filter=lfs diff=lfs merge=lfs -text
*.mar filter=lfs diff=lfs merge=lfs -text
*.mdi filter=lfs diff=lfs merge=lfs -text
*.mht filter=lfs diff=lfs merge=lfs -text
*.mid filter=lfs diff=lfs merge=lfs -text
*.midi filter=lfs diff=lfs merge=lfs -text
*.mj2 filter=lfs diff=lfs merge=lfs -text
*.mka filter=lfs diff=lfs merge=lfs -text
*.mkv filter=lfs diff=lfs merge=lfs -text
*.mmr filter=lfs diff=lfs merge=lfs -text
*.mng filter=lfs diff=lfs merge=lfs -text
*.mobi filter=lfs diff=lfs merge=lfs -text
*.mov filter=lfs diff=lfs merge=lfs -text
*.movie filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.mp4a filter=lfs diff=lfs merge=lfs -text
*.mpeg filter=lfs diff=lfs merge=lfs -text
*.mpg filter=lfs diff=lfs merge=lfs -text
*.mpga filter=lfs diff=lfs merge=lfs -text
*.mxu filter=lfs diff=lfs merge=lfs -text
*.nef filter=lfs diff=lfs merge=lfs -text
*.npx filter=lfs diff=lfs merge=lfs -text
*.numbers filter=lfs diff=lfs merge=lfs -text
*.nupkg filter=lfs diff=lfs merge=lfs -text
*.o filter=lfs diff=lfs merge=lfs -text
*.odp filter=lfs diff=lfs merge=lfs -text
*.ods filter=lfs diff=lfs merge=lfs -text
*.odt filter=lfs diff=lfs merge=lfs -text
*.oga filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text
*.ogv filter=lfs diff=lfs merge=lfs -text
*.otf filter=lfs diff=lfs merge=lfs -text
*.ott filter=lfs diff=lfs merge=lfs -text
*.pages filter=lfs diff=lfs merge=lfs -text
*.pbm filter=lfs diff=lfs merge=lfs -text
*.pcx filter=lfs diff=lfs merge=lfs -text
*.pdb filter=lfs diff=lfs merge=lfs -text
*.pdf filter=lfs diff=lfs merge=lfs -text
*.pea filter=lfs diff=lfs merge=lfs -text
*.pgm filter=lfs diff=lfs merge=lfs -text
*.pic filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.pnm filter=lfs diff=lfs merge=lfs -text
*.pot filter=lfs diff=lfs merge=lfs -text
*.potm filter=lfs diff=lfs merge=lfs -text
*.potx filter=lfs diff=lfs merge=lfs -text
*.ppa filter=lfs diff=lfs merge=lfs -text
*.ppam filter=lfs diff=lfs merge=lfs -text
*.ppm filter=lfs diff=lfs merge=lfs -text
*.pps filter=lfs diff=lfs merge=lfs -text
*.ppsm filter=lfs diff=lfs merge=lfs -text
*.ppsx filter=lfs diff=lfs merge=lfs -text
*.ppt filter=lfs diff=lfs merge=lfs -text
*.pptm filter=lfs diff=lfs merge=lfs -text
*.pptx filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text
*.pya filter=lfs diff=lfs merge=lfs -text
*.pyc filter=lfs diff=lfs merge=lfs -text
*.pyo filter=lfs diff=lfs merge=lfs -text
*.pyv filter=lfs diff=lfs merge=lfs -text
*.qt filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.ras filter=lfs diff=lfs merge=lfs -text
*.raw filter=lfs diff=lfs merge=lfs -text
*.resources filter=lfs diff=lfs merge=lfs -text
*.rgb filter=lfs diff=lfs merge=lfs -text
*.rip filter=lfs diff=lfs merge=lfs -text
*.rlc filter=lfs diff=lfs merge=lfs -text
*.rmf filter=lfs diff=lfs merge=lfs -text
*.rmvb filter=lfs diff=lfs merge=lfs -text
*.rpm filter=lfs diff=lfs merge=lfs -text
*.rtf filter=lfs diff=lfs merge=lfs -text
*.rz filter=lfs diff=lfs merge=lfs -text
*.s3m filter=lfs diff=lfs merge=lfs -text
*.s7z filter=lfs diff=lfs merge=lfs -text
*.scpt filter=lfs diff=lfs merge=lfs -text
*.sgi filter=lfs diff=lfs merge=lfs -text
*.shar filter=lfs diff=lfs merge=lfs -text
*.snap filter=lfs diff=lfs merge=lfs -text
*.sil filter=lfs diff=lfs merge=lfs -text
*.sketch filter=lfs diff=lfs merge=lfs -text
*.slk filter=lfs diff=lfs merge=lfs -text
*.smv filter=lfs diff=lfs merge=lfs -text
*.snk filter=lfs diff=lfs merge=lfs -text
*.so filter=lfs diff=lfs merge=lfs -text
*.stl filter=lfs diff=lfs merge=lfs -text
*.suo filter=lfs diff=lfs merge=lfs -text
*.sub filter=lfs diff=lfs merge=lfs -text
*.swf filter=lfs diff=lfs merge=lfs -text
*.tar filter=lfs diff=lfs merge=lfs -text
*.tbz filter=lfs diff=lfs merge=lfs -text
*.tbz2 filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tgz filter=lfs diff=lfs merge=lfs -text
*.thmx filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.tlz filter=lfs diff=lfs merge=lfs -text
*.ttc filter=lfs diff=lfs merge=lfs -text
*.ttf filter=lfs diff=lfs merge=lfs -text
*.txz filter=lfs diff=lfs merge=lfs -text
*.udf filter=lfs diff=lfs merge=lfs -text
*.uvh filter=lfs diff=lfs merge=lfs -text
*.uvi filter=lfs diff=lfs merge=lfs -text
*.uvm filter=lfs diff=lfs merge=lfs -text
*.uvp filter=lfs diff=lfs merge=lfs -text
*.uvs filter=lfs diff=lfs merge=lfs -text
*.uvu filter=lfs diff=lfs merge=lfs -text
*.viv filter=lfs diff=lfs merge=lfs -text
*.vob filter=lfs diff=lfs merge=lfs -text
*.war filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.wax filter=lfs diff=lfs merge=lfs -text
*.wbmp filter=lfs diff=lfs merge=lfs -text
*.wdp filter=lfs diff=lfs merge=lfs -text
*.weba filter=lfs diff=lfs merge=lfs -text
*.webm filter=lfs diff=lfs merge=lfs -text
*.webp filter=lfs diff=lfs merge=lfs -text
*.whl filter=lfs diff=lfs merge=lfs -text
*.wim filter=lfs diff=lfs merge=lfs -text
*.wm filter=lfs diff=lfs merge=lfs -text
*.wma filter=lfs diff=lfs merge=lfs -text
*.wmv filter=lfs diff=lfs merge=lfs -text
*.wmx filter=lfs diff=lfs merge=lfs -text
*.woff filter=lfs diff=lfs merge=lfs -text
*.woff2 filter=lfs diff=lfs merge=lfs -text
*.wrm filter=lfs diff=lfs merge=lfs -text
*.wvx filter=lfs diff=lfs merge=lfs -text
*.xbm filter=lfs diff=lfs merge=lfs -text
*.xif filter=lfs diff=lfs merge=lfs -text
*.xla filter=lfs diff=lfs merge=lfs -text
*.xlam filter=lfs diff=lfs merge=lfs -text
*.xls filter=lfs diff=lfs merge=lfs -text
*.xlsb filter=lfs diff=lfs merge=lfs -text
*.xlsm filter=lfs diff=lfs merge=lfs -text
*.xlsx filter=lfs diff=lfs merge=lfs -text
*.xlt filter=lfs diff=lfs merge=lfs -text
*.xltm filter=lfs diff=lfs merge=lfs -text
*.xltx filter=lfs diff=lfs merge=lfs -text
*.xm filter=lfs diff=lfs merge=lfs -text
*.xmind filter=lfs diff=lfs merge=lfs -text
*.xpi filter=lfs diff=lfs merge=lfs -text
*.xpm filter=lfs diff=lfs merge=lfs -text
*.xwd filter=lfs diff=lfs merge=lfs -text
*.xz filter=lfs diff=lfs merge=lfs -text
*.z filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.zipx filter=lfs diff=lfs merge=lfs -text
#+end_src

** git-crypt

Note that ~git-crypt~ must come after all other ~.gitattributes~ as doing otherwise will overwrite the ~git-crypt~ filter and diffs.

#+begin_src gitattributes
black.aiern.org filter=git-crypt diff=git-crypt

etc/nixos/secrets/**/* filter=git-crypt diff=git-crypt
etc/caddy/**/* filter=git-crypt diff=git-crypt
etc/tailscale/**/* filter=git-crypt diff=git-crypt

.termux/font.ttf filter=git-crypt diff=git-crypt

.ssh/**/* filter=git-crypt diff=git-crypt
.ssh/**/*.pub* -filter -diff
.ssh/**/assh.yml -filter -diff

.gnupgk/**/* filter=git-crypt diff=git-crypt
.gnupgk/**/*.pub* -filter -diff

.fonts/cartographcf-* filter=git-crypt diff=git-crypt

.config/borg/keys/**/* filter=git-crypt diff=git-crypt
.config/rclone/rclone.conf filter=git-crypt diff=git-crypt

**/.password.tomb.key filter=git-crypt diff=git-crypt
#+end_src

* .xonshrc
:PROPERTIES:
:header-args:xonsh+: :noweb-ref .xonshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xonshrc>>
#+end_src

** imports

#+begin_src xonsh
import sys, os
from pathlib import Path
#+end_src

** environment

#+begin_src xonsh
$AUTO_CD = True
$AUTO_PUSHD = True
$AUTO_SUGGEST = True
$AUTO_SUGGEST_IN_COMPLETIONS = True
$BASH_COMPLETIONS += [ f"{Path.home()}/resources/bashCompletions" ]
$COMPLETION_IN_THREAD = True
$COMPLETIONS_CONFIRM = True
$DOTGLOB = True
$FUZZY_PATH_COMPLETION = True
$HISTCONTROL = { "ignoreboth", "erasedups", "ignoreerr" }
$MOUSE_SUPPORT = True
$PRETTY_PRINT_RESULTS = True
$PROMPT_TOOLKIT_COLOR_DEPTH = "DEPTH_24_BIT"
$SHELL_TYPE = "prompt_toolkit"
$UPDATE_COMPLETIONS_ON_KEYPRESS = True
$UPDATE_OS_ENVIRON = True
$VI_MODE = True
$XONSH_AUTOPAIR = True
$XONSH_CACHE_EVERYTHING = True
$XONSH_HISTORY_BACKEND = "sqlite"
$XONSH_STORE_STDOUT = True

# This enumerates all history files when set to true
$XONSH_DEBUG = False

$XONSH_SHOW_TRACEBACK = True

# Xonsh Prompt
$PROMPT_FIELDS["prompt_end"] = "Wheee! 😹 "
# $PROMPT = "{BOLD_#E5004D}{env_name} {BOLD_#FF4081}{prompt_end}"
# $PROMPT = lambda: $(starship prompt)
execx($(starship init xonsh))
$RIGHT_PROMPT = "{BOLD_#E5004D} {prompt_end}{BOLD_#FC9F71} || {BOLD_#E5004D} {user}@{hostname} "
# $BOTTOM_TOOLBAR = $RIGHT_PROMPT

# Path
sys.path.insert(0, "")
<<profile-paths(shell="xonsh")>>

# Shell
# $EDITOR = "emacsclient -c"
# $VISUAL = "emacsclient -c"

# Etc
$LESSOPEN = "| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
$LESS = " -R "
#+end_src

** functions

#+begin_src xonsh
def _mdg(args, stdin=None):
    mkdir -p @(args) && cd @(args[0])

def _direnv_allow(args, stdin=None):
    if args:
        for argument in args:
            direnv allow @(argument)
    else:
        direnv allow

def _get_fzfdf_output(*args):
    if args:
        return $(fd @((".", *args) if os.path.exists(args[0]) else args) | fzf-tmux).strip("\n")
    else:
        return $(fd | fzf-tmux).strip("\n")

def _cdi(args, stdin=None):
    cd @(_get_fzfdf_output(*args, "-t", "d"))

def _cdr(args, stdin=None):
    cd @($(zoxide query -l | fzf-tmux).strip("\n"))

def _cdf(args, stdin=None):
    cd @($(fasd -ld | fzf-tmux).strip("\n"))

def _rc(args, stdin=None):
    hist = $(history show @(args))
    command = $(echo @(hist) | fzf-tmux).strip("\n").split()
    if command:
        $(@(command))

def _run(args, stdin=None):
    args = list(args)
    args[0] = Path(args[0]).absolute()
    chmod +x @(args[0]) && @(args)

def _Run(args, stdin=None):
    curl --create-dirs -fsSLo @(args[1]) @(args[0])
    _run(args[1:])
#+end_src

** xontribs

#+begin_src xonsh
# xontrib load coreutils
# xontrib load docker_tabcomplete
# xontrib load schedule
# xontrib load ssh_agent
# xontrib load vox_tabcomplete

xontrib load abbrevs
xontrib load autoxsh
xontrib load bashisms
xontrib load direnv
xontrib load pipeliner
xontrib load readable-traceback
xontrib load sh
xontrib load vox
xontrib load whole_word_jumping

# Jedi was what was causing the python function completions
# instead of the path completions
# xontrib load jedi
#+end_src

** base

#+begin_src xonsh
execx($(zoxide init xonsh), 'exec', __xonsh__.ctx, filename='zoxide')

aliases["-"] = "pushd"
aliases[".."] = "cd .."
aliases["."] = "exa -la"
aliases["c"] = "clear"
aliases["cdf"] = _cdf
aliases["cdi"] = _cdi
aliases["cdr"] = _cdr
aliases["da"] = _direnv_allow
aliases["emd"] = "systemctl --user start emacs.service"
aliases["git"] = lambda args, stdin=None: $(hub @(args))
aliases["kemd"] = "systemctl --user stop emacs.service"
aliases["la"] = lambda args, stdin=None: $(exa -la --octal-permissions @(args))
aliases["md"] = lambda args, stdin=None: $(mkdir -p @(args))
aliases["mdg"] = _mdg
aliases["mosh"] = lambda args, stdin=None: $(mosh --experimental-remote-ip=remote @(args))
aliases["n"] = "exit"
aliases["rc"] = _rc
aliases["remd"] = "systemctl --user restart emacs.service"
aliases["Run"] = _Run
aliases["run"] = _run
aliases["s"] = "source ~/.xonshrc"
aliases["semd"] = "systemctl status emacs"
aliases["ssh"] = lambda args, stdin=None: $(assh wrapper ssh -- @(args))
aliases["ve"] = lambda args, stdin=None: $(vox enter @(args)) if args else $(vox exit)
aliases["vim"] = lambda args, stdin=None: $(emacsclient -c @(args))

# fasd aliases
aliases["o"] = lambda args, stdin=None: $(fasd -ae xdg-open @(args)) # quick opening files with xdg-open

# quick opening files with emacs
aliases["e"] = lambda args, stdin=None: $(fasd -fe 'emacsclient -c' @(args))
#+end_src

* .ssh
** assh.yml
:PROPERTIES:
:header-args:yml+: :noweb-ref 0b99b52d-bb22-4396-a739-f6c11199f59a
:END:

#+begin_src text :tangle (meq/tangle-path)
<<0b99b52d-bb22-4396-a739-f6c11199f59a>>
#+end_src

#+name: efee5a24-3aac-44d1-a94b-713c35480acd
#+begin_src emacs-lisp :var host=""
(substring (shell-command-to-string (format "tailapi -rD sylvorg.github --api-key $(pass show keys/api/tailscale/jeet.ray) -d %s ip -f4" host)) 0 -1)
#+end_src

#+name: b6cf933e-ecd4-442a-b326-4d5203f59dd6
#+begin_src emacs-lisp :var host="" :var ip=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "    %h:
        HostName: %i
        Gateways:
            - %h.magic
            - %h.tailscale.4
            - %h.tailscale.6
            - %h.tailapi.4
            - %h.tailapi.6
            - %h.dns
            - direct
            - %h.local.hostname
            - argus" `((?h . ,host) (?i . ,ip)))
#+end_src

#+begin_src yml
hosts:
#+end_src

Adapted from [[https://askubuntu.com/users/201083/kervin][kervin's]] answer [[https://askubuntu.com/a/520109/1058868][here]]:

#+begin_src yml
    "*.magic":
        ResolveCommand: /usr/bin/env sh -c "echo %h | cut -d '.' -f 1"
#+end_src

Adapted from [[https://stackoverflow.com/users/2554537/zedfoxus][zedfoxus's]] answer [[https://stackoverflow.com/a/22727211/10827766][here]]:

#+begin_src yml
    "*.tailscale.*":
        ResolveCommand: /usr/bin/env sh -c "tailscale ip -$(echo %h | rev | cut -d '.' -f 1) $(echo %h | cut -d '.' -f 1)"
#+end_src

#+begin_src yml
    "*.tailapi.*":
        ResolveCommand: /usr/bin/env sh -c "tailapi -rD sylvorg.github --api-key $(pass show keys/api/tailscale/jeet.ray) -d $(echo %h | cut -d '.' -f 1) ip -f$(echo %h | rev | cut -d '.' -f 1)"
#+end_src

#+begin_src yml
    "*.dns":
        ResolveCommand: /usr/bin/env sh -c "echo $(echo %h | cut -d '.' -f 1).syvl.org"
#+end_src

Adapted from [[https://stackoverflow.com/users/807131/ddoxey][ddoxey's]] question [[https://stackoverflow.com/questions/13552881/can-i-determine-the-current-ip-from-a-known-mac-address][here]]:

#+begin_src yml
    "*.local.hostname":
        ResolveCommand: /usr/bin/env sh -c "ping -c 1 $(echo %h | cut -d '.' -f 1) | head -1 | awk '{print $3}' | sed 's/[()]//g'"
#+end_src

Adapted from [[https://stackoverflow.com/users/1291650/hanoo][hanoo's]] answer [[https://stackoverflow.com/a/36366894/10827766][here]]:

#+begin_src yml
    "*.local.mac":
        ResolveCommand: /usr/bin/env sh -c "ip neighbor | grep -i $(echo %h | cut -d '.' -f 1) | cut -d ' ' -f 1"
#+end_src

#+begin_src yml
    "argus.wstunnel.tls.magic":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(echo %h | cut -d '.' -f 1):443"
    "argus.wstunnel.tls.tailscale":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(tailscale ip -$(echo %h | rev | cut -d '.' -f 1) $(echo %h | cut -d '.' -f 1)):443"
    "argus.wstunnel.tls.tailapi":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(tailapi -rD sylvorg.github --api-key $(pass show keys/api/tailscale/jeet.ray) -d $(echo %h | cut -d '.' -f 1) ip -f$(echo %h | rev | cut -d '.' -f 1)):443"
    "argus.wstunnel.tls.dns":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://io.syvl.org:443"
    "argus.wstunnel.tls.public":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://<<9c0c8ca0-8731-4d1f-94bf-7a076bc698c0>>:443"

    "argus.wstunnel.http.magic":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(echo %h | cut -d '.' -f 1):80"
    "argus.wstunnel.http.tailscale":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(tailscale ip -$(echo %h | rev | cut -d '.' -f 1) $(echo %h | cut -d '.' -f 1)):80"
    "argus.wstunnel.http.tailapi":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://$(tailapi -rD sylvorg.github --api-key $(pass show keys/api/tailscale/jeet.ray) -d $(echo %h | cut -d '.' -f 1) ip -f$(echo %h | rev | cut -d '.' -f 1)):80"
    "argus.wstunnel.http.dns":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://io.syvl.org:80"
    "argus.wstunnel.http.public":
        ProxyCommand: /usr/bin/env sh -c "wstunnel -L stdio:%h:%p wss://<<9c0c8ca0-8731-4d1f-94bf-7a076bc698c0>>:80"

    "argus.iodine.magic":
        ProxyCommand: /usr/bin/env sh -c ""
    "argus.iodine.tailscale":
        ProxyCommand: /usr/bin/env sh -c ""
    "argus.iodine.tailapi":
        ProxyCommand: /usr/bin/env sh -c ""
    "argus.iodine.dns":
        ProxyCommand: /usr/bin/env sh -c ""
    "argus.iodine.public":
        ProxyCommand: /usr/bin/env sh -c ""

    "argus":
        HostName: io.syvl.org
        Gateways:
            - argus.magic
            - argus.tailscale.4
            - argus.tailscale.6
            - argus.tailapi.4
            - argus.tailapi.6
            - argus.dns
            - direct
            # - argus.wstunnel.tls.magic
            # - argus.wstunnel.tls.tailscale
            # - argus.wstunnel.tls.tailapi
            # - argus.wstunnel.tls.dns
            # - argus.wstunnel.tls.public
            # - argus.wstunnel.http.magic
            # - argus.wstunnel.http.tailscale
            # - argus.wstunnel.http.tailapi
            # - argus.wstunnel.http.dns
            # - argus.wstunnel.http.public
            # - argus.wstunnel.io.magic
            # - argus.wstunnel.io.tailscale
            # - argus.wstunnel.io.tailapi
            # - argus.wstunnel.io.dns
            # - argus.wstunnel.io.public

    <<b6cf933e-ecd4-442a-b326-4d5203f59dd6(host="sandshrew", ip=efee5a24-3aac-44d1-a94b-713c35480acd(host="sandshrew"))>>

    <<b6cf933e-ecd4-442a-b326-4d5203f59dd6(host="murasame")>>
#+end_src

* .config
** nix
*** nix.conf

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** systemd
*** user
**** emacs.service
:PROPERTIES:
:header-args:systemd+: :noweb-ref c5890943-2514-4794-a0cb-7a0c9ab32aca
:END:

#+begin_src text :tangle (meq/tangle-path)
<<c5890943-2514-4794-a0cb-7a0c9ab32aca>>
#+end_src

#+begin_src
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --bg-daemon=damascus --update
ExecStop=/usr/bin/emacsclient -s damascus -e "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure
TimeoutSec=900

[Install]
WantedBy=default.target
#+end_src

** yadm
*** bootstrap
:PROPERTIES:
:header-args:shell+: :noweb-ref 879a83d3-17ad-446f-8ad2-9945ac588f07
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#! /usr/bin/env sh"
<<879a83d3-17ad-446f-8ad2-9945ac588f07>>
#+end_src

#+begin_src shell
set -eo pipefail
[ -z "$1" ] && worktree="$HOME" || worktree="$1"
chmod 700 "$worktree/.ssh" "$worktree/.gnupgk" "$worktree/.config/borg/keys"
chmod 600 "$worktree/.ssh/*" "$worktree/.gnupgk/*" "$worktree/.config/borg/keys/*"
#+end_src

*** config

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

** direnv
*** .direnvrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src zsh
use_flake() {
    watch_file flake.nix
    watch_file flake.lock
    eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
}
#+end_src

** kitty
*** kitty.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref kitty.conf
:END:

#+begin_src text :tangle (meq/tangle-path)
<<kitty.conf>>
#+end_src

#+begin_src conf
include ~/resources/kittyThemes/themes/Monokai_Pro_(Filter_Ristretto).conf
#+end_src

** ion
*** initrc
:PROPERTIES:
:header-args:ion+: :noweb-ref initrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<initrc>>
#+end_src

#+begin_src ion
eval $(starship init ion)
#+end_src

** git
*** config
:PROPERTIES:
:header-args:conf+: :noweb-ref ee416303-b507-49b2-9e6b-8dc71a97c171
:END:

#+name: c635d49e-5f0e-4245-bc91-81e9f8de0a12
#+begin_src text :tangle (meq/tangle-path)
<<ee416303-b507-49b2-9e6b-8dc71a97c171>>
#+end_src

#+begin_src conf
[core]
    excludesfile = ~/.globalignore
    attributesfile = ~/.gitattributes
    fileMode = false
    hookPath = ~/.config/git/hooks

[user]
    email = jeet.ray@syvl.org
    name = Jeet Ray

[alias]
    cnm = commit --allow-empty-message -am ""
    chRun = !chmod +x $1 &&
    user = !git -C "$HOME/<<reponame>>"
    commit-user = user cnm
    push-user = user push
    super-user = !git commit-user && git push-user
    settings = !git -C "$(git rev-parse --show-toplevel)/settings"
    update-settings = !git settings pull origin main && git add "$(git rev-parse --show-toplevel)/settings" && git commit -m "Updated settings repo"
    usp = !git us && git push
    sub = submodule update --init --recursive --remote
    submerge = sub --merge
    crossmerge = !GIT_DISCOVERY_ACROSS_FILESYSTEM=1 git submerge
    damerge = !GIT_SSL_NO_VERIFY=1 git crossmerge
    subinit = sub --force
    crossinit = !GIT_DISCOVERY_ACROSS_FILESYSTEM=1 git subinit
    daminit = !GIT_SSL_NO_VERIFY=1 git crossinit
#+end_src

Adapted from [[https://unix.stackexchange.com/users/48083/graeme][Graeme's]] answer [[https://unix.stackexchange.com/a/136798/270053][here]]:

#+begin_src conf
    encrypted = !git crypt status -e | sed 's/.*: //'
    decrypted = !git crypt status -u | sed 's/.*: //'
#+end_src

#+begin_src conf
    dekey = chRun "$HOME/.config/git/scripts/dekey"
    rekey = chRun "$HOME/.config/git/scripts/rekey"

[protocol "keybase"]
	allow = always

[protocol "restic"]
	allow = always

[pull]
    rebase = false

[filter "git"]
	clean = cat
	smudge = cat

[diff "git"]
	command = git diff
#+end_src

*** scripts
**** git-shell.nix

#+begin_src nix :tangle (meq/tangle-path)
with builtins; with (import (fetchGit {
    url = "https://github.com/<<username>>/<<username>>";
    ref = "main";
})).legacyPackages.${currentSystem}; mkShell { buildInputs = [ git-crypt git-filter-repo rsync realpath ]; }
#+end_src

**** dekey
:PROPERTIES:
:header-args:shell+: :noweb-ref d4fe01d0-adf7-42b4-886c-fd6c22b4065f
:END:

#+begin_src text :tangle (meq/tangle-path)
<<d4fe01d0-adf7-42b4-886c-fd6c22b4065f>>
#+end_src

#+begin_src shell :tangle (meq/tangle-path) :shebang "#! /usr/bin/env nix-shell"
#! nix-shell git-shell.nix
#! nix-shell -i sh
set -eo pipefail
root=$(git rev-parse --show-toplevel)
for gpgID in $@; do
#+end_src

Adapted from [[https://stackoverflow.com/users/15168/jonathan-leffler][Jonathan Leffler's]] answer [[https://stackoverflow.com/a/1429628/10827766][here]], and [[https://stackoverflow.com/users/1114966/squiguy][squiguy's]] answer [[https://stackoverflow.com/a/13662036/10827766][here]]:

#+begin_src shell
    rm "$root/.git-crypt/keys/default/0/$(gpg --fingerprint $gpgID | sed -n 2p | tr -d ' ').gpg"
#+end_src

#+begin_src shell
done
#+end_src

**** rekey
:PROPERTIES:
:header-args:shell+: :noweb-ref 34bb592d-cf90-4f98-8aa1-0c14ed7027e1
:END:

#+begin_src text :tangle (meq/tangle-path)
<<34bb592d-cf90-4f98-8aa1-0c14ed7027e1>>
#+end_src

#+begin_src shell :tangle (meq/tangle-path) :shebang "#! /usr/bin/env nix-shell"
#! nix-shell git-shell.nix
#! nix-shell -i sh
set -eo pipefail
root=$(git rev-parse --show-toplevel)
#+end_src

Adapted from [[https://unix.stackexchange.com/users/52727/chaos][chaos']] answer [[https://unix.stackexchange.com/a/181939/270053][here]]:

#+begin_src shell
tmpf=$(mktemp)
tmpd=$(mktemp -d)
tmpCrypt=$(mktemp -d)
#+end_src

Adapted from [[https://unix.stackexchange.com/users/83831/wurtel][wurtel's]] comment [[https://unix.stackexchange.com/questions/181937/how-create-a-temporary-file-in-shell-script#comment302878_181939][here]],
and [[https://unix.stackexchange.com/users/20482/ijoseph][ijoseph's]] comment [[https://unix.stackexchange.com/questions/181937/how-create-a-temporary-file-in-shell-script#comment1096615_181939][here]], stating:

#+begin_quote
For those wondering, the trailing integers in trap "rm -f $temp_file" 0 2 3 15 are the /signals/ [[https://www.shellscript.sh/trap.html][upon which to run the first argument]]. 0: exit shell, 2: Interrupt, 3: Quit, 15: Terminate.
#+end_quote

#+begin_src shell
trap "rm -rf $tmpf $tmpd $tmpCrypt" 0 2 3 15
#+end_src

Adapted from [[https://stackoverflow.com/users/2075062/epere4][epere4's]] answer [[https://stackoverflow.com/a/14892459/10827766][here]]:

#+begin_src shell
if [ -f "$root/.git" ]; then
    gitCrypt=$(realpath $(cat "$root/.git" | sed 's/.*: //'))
else
    gitCrypt="$root/.git/git-crypt"
fi
#+end_src

#+begin_src shell
git crypt unlock
git encrypted > $tmpf
#+end_src

Adapted from [[https://stackoverflow.com/users/100208/atp][atp's]] answer [[https://stackoverflow.com/a/30176688/10827766][here]]:

#+begin_src shell
rsync -avvczz --files-from $tmpf "$root" $tmpd
#+end_src

#+begin_src shell
rsync -avvczz "$root/.git-crypt/" $tmpCrypt/
rm -rf "$gitCrypt" "$root/.git-crypt"
git -C "$root" filter-repo --paths-from-file $tmpf --invert-paths --force
rsync -avvczz $tmpd/ "$root"/
git crypt init
for key in $(ls $tmpCrypt/keys/default/0/*gpg); do
    git crypt add-gpg-user $(basename $key .gpg)
done
[ -n "$1" ] && git crypt add-gpg-user $@ || :
#+end_src

** powershell
*** Microsoft.PowerShell_profile.ps1
:PROPERTIES:
:header-args:powershell+: :noweb-ref Microsoft.PowerShell_profile.ps1
:END:

#+begin_src text :tangle (meq/tangle-path)
<<Microsoft.PowerShell_profile.ps1>>
#+end_src

#+begin_src powershell
# For zoxide v0.8.0+
Invoke-Expression (& {
    $hook = if ($PSVersionTable.PSVersion.Major -lt 6) { 'prompt' } else { 'pwd' }
    (zoxide init --hook $hook powershell | Out-String)
})
Invoke-Expression (&starship init powershell)
#+end_src

** fish
*** config.fish
:PROPERTIES:
:header-args:fish+: :noweb-ref config.fish
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.fish>>
#+end_src

#+begin_src fish
source ~/resources/nix-env.fish/conf.d/nix-env.fish
cd ~/resources/bass
make install &>/dev/null
cd -
<<20211028011434584909200>>
<<profile-paths(shell="fish")>>
alias s=source ~/.config/fish/config.fish
direnv hook fish | source
zoxide init fish | source
starship init fish | source
#+end_src

** qtile
*** config.py
:PROPERTIES:
:header-args:python+: :noweb-ref config.py
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.py>>
#+end_src

This config is taken from [[http://gegenokitaro.github.io/tuts/2015/05/14/qtile-ricchan/][here]]:

#+begin_src python
# Copyright (c) 2010 Aldo Cortesi
# Copyright (c) 2010, 2014 dequis
# Copyright (c) 2012 Randall Ma
# Copyright (c) 2012-2014 Tycho Andersen
# Copyright (c) 2012 Craig Barnes
# Copyright (c) 2013 horsik
# Copyright (c) 2013 Tao Sauvage
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libqtile.config import Key, Screen, Group, Drag, Click, Match
from libqtile.command import lazy
from libqtile import layout, bar, widget
from libqtile.dgroups import simple_key_binder

mod = "mod4"

keys = [
    # Switch between windows in current stack pane
    Key(
        [mod], "j",
        lazy.layout.down()
    ),
    Key(
        [mod], "k",
        lazy.layout.up()
    ),

    # Move windows up or down in current stack
    Key(
        [mod, "control"], "j",
        lazy.layout.shuffle_down()
    ),
    Key(
        [mod, "control"], "k",
        lazy.layout.shuffle_up()
    ),

    # Switch window focus to other pane(s) of stack
    Key(
        [mod], "space",
        lazy.layout.next()
    ),

    Key(
        [mod], "Left",
        lazy.screen.prevgroup()
    ),

    Key(
        [mod], "Right",
        lazy.screen.nextgroup()
    ),

    # Swap panes of split stack
    Key(
        [mod, "shift"], "space",
        lazy.layout.rotate()
    ),

    # Toggle between split and unsplit sides of stack.
    # Split = all windows displayed
    # Unsplit = 1 window displayed, like Max layout, but still with
    # multiple stack panes
    Key(
        [mod, "shift"], "Return",
        lazy.layout.toggle_split()
    ),
    Key([mod], "Return", lazy.spawn("urxvt")),

    # Toggle between different layouts as defined below
    Key([mod], "Tab", lazy.nextlayout()),
    Key([mod], "w", lazy.window.kill()),

    Key([mod, "control"], "r", lazy.restart()),
    Key([mod, "control"], "q", lazy.shutdown()),
    Key([mod], "r", lazy.spawncmd()),
]

groups = [
    Group(" urxvt "),
    Group(" web ", matches=[Match(wm_class=["Firefox"])]),
    Group(" blender "),
    Group(" inkscape "),
    Group(" gimp "),
    Group(" doc "),
]

dgroups_key_binder = simple_key_binder("mod4")


layouts = [
    layout.TreeTab(
            font='Cartograph CF Light Italic',
            name="tree tab",
            bg_color="#222222",
            inactive_bg="#AB5DEE",
            panel_width=150,
            margin_left=0,
            margin_y=0,
            sections=['TreeTab'],
            section_left=0,
            padding_x=4,
            active_bg="#FFB86C",
            rounded=False,
        ),
    layout.MonadTall(
            name="xmonad tall",
            ratio=0.5,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Stack(
            num_stacks=2,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        )
]

floating_layout = layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#69B2B8",
            border_normal="#335260",
        )

widget_defaults = dict(
    font='Cartograph CF Light Italic',
    fontsize=12,
    background="#222222",
    markup=True,
)

screens = [
    Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(
                        borderwidth=0,
                        margin=0,
                        padding=6,
                        active="FFFFFF",
                        inactive="FFB86C",
                        highlight_method="block",
                        this_current_screen_border="#AB5DEE",
                        invert_mouse_wheel=True,
                        rounded=False,
                    ),
                widget.Prompt(),
                widget.CurrentLayout(
                        background="#E11B22",
                    ),
                widget.Spacer(),
                #widget.WindowName(),
                widget.TextBox("testing", name="default"),
                widget.Systray(),
                widget.Clock(format=' %I:%M %p '),
            ],
            24,
            background="#335260",
        ),
    ),
]

# Drag floating layouts.
mouse = [
    Drag([mod], "Button1", lazy.window.set_position_floating(),
        start=lazy.window.get_position()),
    Drag([mod], "Button3", lazy.window.set_size_floating(),
        start=lazy.window.get_size()),
    Click([mod], "Button2", lazy.window.bring_to_front())
]

dgroups_app_rules = []
main = None
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
auto_fullscreen = True

# XXX: Gasp! We're lying here. In fact, nobody really uses or cares about this
# string besides java UI toolkits; you can see several discussions on the
# mailing lists, github issues, and other WM documentation that suggest setting
# this string if your java app doesn't work correctly. We may as well just lie
# and say that we're a working one by default.
#
# We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in
# java that happens to be on java's whitelist.
wmname = "LG3D"
#+end_src

* .SpaceVim.d
** init.toml
:PROPERTIES:
:header-args:conf+: :noweb-ref init.toml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<init.toml>>
#+end_src

#+begin_src conf
#=============================================================================
# dark_powered.toml --- dark powered configuration example for SpaceVim
# Copyright (c) 2016-2020 Wang Shidong & Contributors
# Author: Wang Shidong < wsdjeg at 163.com >
# URL: https://spacevim.org
# License: GPLv3
#=============================================================================

# All SpaceVim option below [option] section
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    colorscheme = "gruvbox"
    colorscheme_bg = "dark"
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = "arrow"
    statusline_iseparator = "arrow"
    buffer_index_type = 4
    enable_tabline_filetype_icon = true
    enable_statusline_mode = false
    bootstrap_before = 'vimrc#before'
    bootstrap_after = 'vimrc#after'
    escape_key_binding = ""
#+end_src

*** layers

#+begin_src conf
# Enable autocomplete layer
[[layers]]
name = 'autocomplete'
auto_completion_return_key_behavior = "complete"
auto_completion_tab_key_behavior = "smart"

[[layers]]
name = 'shell'
default_position = 'top'
default_height = 30

[[layers]]
name = "lang#nix"
#+end_src

*** plugins

#+begin_src conf
[[custom_plugins]]
    repo = "tssm/fairyfloss.vim"
    merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/mountaineer.vim"
#     merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/gunmetal.vim"
#     merged = true

[[custom_plugins]]
    repo = "megantiu/true.vim"
    merged = true

# From:
# Answer: https://vi.stackexchange.com/questions/678/how-do-i-save-a-file-in-a-directory-that-does-not-yet-exist/679#679
# User: https://vi.stackexchange.com/users/51/martin-tournoij
[[custom_plugins]]
    repo = "arp242/auto_mkdir2.vim"
    merged = true

[[custom_plugins]]
    repo = "tpope/vim-eunuch"
    merged = true

# [[custom_plugins]]
#     repo = "johannesthyssen/vim-signit"
#     merged = true

[[custom_plugins]]
    repo = "jupyter-vim/jupyter-vim"
    merged = true

[[custom_plugins]]
    repo = "haya14busa/dein-command.vim"
    merged = true

[[custom_plugins]]
    repo = "andrep/vimacs"
    merged = true

[[custom_plugins]]
    repo = "shougo/denite.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/defx.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/deoplete.nvim"
    merged = true
#+end_src

** autoload
*** vimrc.vim

#+begin_src vimrc :tangle (meq/tangle-path)
function! vimrc#before() abort
endfunction

function! vimrc#after() abort
    syntax on
    filetype plugin indent on

    " enable 24bit true color
    if (has("termguicolors"))
    set termguicolors
    endif

    " enable the theme
    syntax enable
    colorscheme fairyfloss

    let g:true_airline = 1
    let g:airline_theme='true'

    " for kitty
    let &t_ut=""

    " disables border on left side
    set foldcolumn=0

    " Spaces & Tabs
    set tabstop=4       " number of visual spaces per TAB
    set softtabstop=4   " number of spaces in tab when editing
    set shiftwidth=4    " number of spaces to use for autoindent
    set expandtab       " tabs are space
    set autoindent
    set copyindent      " copy indent from the previous line

    " set number relativenumber

    " Insert Toggle
    imap ;; <ESC>
    map ;; i <BACKSPACE>

    " Change two spaces to four
    map \\ :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>
    imap \\ <ESC> :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>

    " Change movement keys to <space>wasd
    noremap <Space-a> h
    noremap <Space-s> j
    noremap <Space-w> k
    noremap <Space-d> l

    " Set Paste
    command SMP :set paste <CR>

    " Set NoPaste
    command SNP :set nopaste <CR>

    " Tab to insert
    map <TAB> i <TAB>

    " Vim Signit
    let g:signit_initials = "JR"
    let g:signit_name = "Jeet Ray"
    " let g:signit_extra_1
    " let g:signit_extra_2
    " let g:signit_position
    let g:signit_ascii_font = "isometric1.flf"
    " let g:signit_ascii_spacing

    if has('nvim')
        call dein#add('iron-e/nvim-libmodal')
        call dein#add('shougo/deol.nvim')
        call dein#add('shougo/deoppet.nvim')
        call dein#add('shougo/deorise.nvim')
    else
        call dein#add('iron-e/vim-libmodal')
        call dein#add('roxma/nvim-yarp')
        call dein#add('roxma/vim-hug-neovim-rpc')
    endif

    let g:deoplete#enable_at_startup = 1
endfunction
#+end_src

* .byobu
** .tmux.conf

#+begin_src conf :tangle (meq/tangle-path)
<<20211018140524183223400>>
#+end_src

* .tmux.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref .tmux.conf
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211018140524183223400

#+name: 20211018140524183223400
#+begin_src text :tangle (meq/tangle-path)
<<20210601214303404504400()>>
<<.tmux.conf>>
#+end_src

** aleclearmind active-row replacement

#+call: hash() :exports none

#+RESULTS:
: 20210601214303404504400

#+name: 20210601214303404504400
#+begin_src emacs-lisp :noweb-ref no
(replace-regexp-in-string
    "set -g prefix C-a"
    "set -g prefix C-Space"
    (replace-regexp-in-string
        "unbind C-b"
        "# unbind C-b"
        (let ((file "./resources/aleclearmind/active-row.conf"))
            (if (file-directory-p file)
                (insert-file-contents file)
                ""))))
#+end_src

** powerline

#+begin_src conf
# source ./resources/powerline/powerline/bindings/tmux/powerline-base.conf
source ./resources/powerline/powerline/bindings/tmux/powerline.conf
# source ./resources/powerline/powerline/bindings/tmux/powerline_tmux_2.1_plus.conf
#+end_src

** oh-my-tmux

#+begin_src conf
source ./resources/oh-my-tmux/.tmux.conf
source ./resources/oh-my-tmux/.tmux.conf.local
#+end_src

** keybindings

From: https://man7.org/linux/man-pages/man1/tmux.1.html#KEY_BINDINGS

*** unbindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214314440746200

#+name: 20210601214314440746200
#+begin_src text :noweb-ref no
C-b
C-x
C-z
#+end_src

#+begin_src conf
unbind <<20210601214314440746200>>
#+end_src

*** bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214317258641300

#+name: 20210601214317258641300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key <<20210601214317258641300>>
#+end_src

*** root bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214320148298300

#+name: 20210601214320148298300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -n <<20210601214320148298300>>
#+end_src

*** root repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214322950137300

#+name: 20210601214322950137300
#+begin_src text :noweb-ref no
M-s send-prefix
C-S-F5 send-keys M-F5
C-S-Left send-keys M-Left
C-S-Right send-keys M-Right
#+end_src

#+begin_src conf
bind-key -nr <<20210601214322950137300>>
#+end_src

*** repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214325764323500

#+name: 20210601214325764323500
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -r <<20210601214325764323500>>
#+end_src

*** prefix table bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214331744518200

#+name: 20210601214331744518200
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -T prefix <<20210601214331744518200>>
#+end_src

** base

#+begin_src conf
set -g prefix2 S-Space

# Mouse support - set to on if you want to use the mouse
# setw -g mode-mouse on
# set -g mouse-select-pane on
# set -g mouse-resize-pane on
# set -g mouse-select-window on

# enable activity alerts
setw -g monitor-activity off
set -g visual-activity off

# Center the window list
set -g status-justify centre

# VI Mode
set -g status-keys vi

# utf8 is on
# set -g utf8 on
# set -g status-utf8 on

run-shell "powerline-daemon -q"

set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Spacemacs Settings:
set -gs escape-time 10

# address vim mode switching delay (http://superuser.com/a/252717/65504)
set -s escape-time 0

# increase scrollback buffer size
set -g history-limit 50000

# tmux messages are displayed for 1.25 seconds
set -g display-time 1250

# refresh 'status-left' and 'status-right' more often
# set -g status-interval 1

# focus events enabled for terminals that support them
set -g focus-events on

# border thickness
set-option -g pane-active-border-style "bg=default"
set-option -ag pane-active-border-style "fg=colour208"
set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Adapted From: https://www.reddit.com/r/tmux/comments/einuqy/make_tmux_modal/
set-option -g prefix None
bind-key -n C-Space {
  set-option key-table prefix
  set-option status-bg yellow
}
bind-key -T prefix C-Space {
  set-option key-table root
  set-option status-bg green
}

setw -g aggressive-resize on
#+end_src

** plugins

#+call: hash() :exports none

#+RESULTS:
: 20210601214334528396400

#+name: 20210601214334528396400
#+begin_src text :noweb-ref no
tmux-plugins/tpm
tmux-plugins/tmux-battery
tmux-plugins/tmux-cpu
tmux-plugins/tmux-fpp
tmux-plugins/tmux-logging
tmux-plugins/tmux-online-status
tmux-plugins/tmux-open
tmux-plugins/tmux-pain-control
tmux-plugins/tmux-prefix-highlight
tmux-plugins/tmux-sessionist
tmux-plugins/tmux-sidebar
tmux-plugins/vim-tmux-focus-events
tmux-plugins/tmux-yank
tmux-plugins/tmux-continuum
tmux-plugins/tmux-resurrect
christoomey/vim-tmux-navigator
sainnhe/tmux-fzf
samoshkin/tmux-plugin-sysstat
wfxr/tmux-fzf-url
schasse/tmux-jump
eraserhd/tmux-ctrlw
jlipps/tmux-safekill
fcsonline/tmux-thumbs
addisonlynch/tmux-sidebar-plus
#+end_src

#+begin_src conf
set -g @plugin <<20210601214334528396400>>
set -g @continuum-boot 'on'
set -g @continuum-save-interval '10'
set -g @continuum-restore 'on'
set -g @resurrect-save-bash-history 'on'
set -g @resurrect-dir '~/.byobu/tmux_resurrect'
set -g @resurrect-processes '"mc --nocolor" "tail -f" bat docker elvish emacs fish glances gotop htop ipython irssi jupyter-lab jupyter-notebook less man more mosh mutt nvim ssh syncthing tail top vi vim weechat wtf xonsh xsh zsh'
set -g @resurrect-capture-pane-contents 'on'
set -g @resurrect-strategy-vim 'session'
set -g @resurrect-strategy-nvim 'session'
run "./resources/tpm/tpm"
#+end_src

* .tmuxp
** default.yaml
:PROPERTIES:
:header-args:conf+: :noweb-ref default.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<default.yaml>>
#+end_src

#+begin_src conf
session_name: default
#+end_src

* .profile
:PROPERTIES:
:header-args:shell+: :noweb-ref .profile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.profile>>
#+end_src

#+name: profile-sources
#+begin_src shell
# source $HOME/.nix-profile/etc/profile.d/nix.sh
eval "$(fasd --init auto)"
#+end_src

#+name: cd-home-and-profile-aliases
#+begin_src shell
# Adapted From:
# Answer: https://askubuntu.com/a/146034/1058868
# User: https://askubuntu.com/users/1059/gilles-so-stop-being-evil
alias -- -="pushd"

alias ..="cd .."
alias .="exa -la --octal-permissions"
alias c="clear"
alias cdf='cdf'
alias cdi='cdi'
alias cdr='cdr'
alias da='direnvAllow'
alias emd="systemctl --user start emacs.service"
alias git="hub"
alias kemd="systemctl --user stop emacs.service"
alias la='exa -la --octal-permissions'
alias md="mkdir -p"
alias mdg='mdg'
alias mosh="mosh --experimental-remote-ip=remote"
alias n="exit"
alias rc="rc"
alias remd="systemctl --user restart emacs.service"
alias Run="Run"
alias run="run"
alias semd="systemctl status emacs"
alias ssh="assh wrapper ssh --"
alias vi="emacsclient -c"
alias vim="emacsclient -c"

# fasd
alias o="fasd -ae xdg-open"

# quick opening files with emacs
alias e="fasd -fe 'emacsclient -t'"
#+end_src

#+name: profile-functions
#+begin_src shell
cdf () { cd $(fasd -ld | fzf-tmux); }
cdi () { cd $(getFzfdfOutput "$@" "-t" "d"); }
cdr () { cd $(zoxide query -l | fzf-tmux); }
direnvAllow () {
    if [ -z "$1" ]; then
        direnv allow
    else
        for d in "$@"; do
            direnv allow "$d"
        done
    fi
}
getFzfdfOutput () {
    if [ -z "$1" ]; then
        echo $(fd | fzf-tmux)
    else
        if [ -d "$1" ]; then
            echo $(fd "." "$@" | fzf-tmux)
        else
            echo $(fd "$@" | fzf-tmux)
        fi
    fi
}
mdg () { mkdir -p "$@" && cd "$1"; }

Run () { curl --create-dirs -fsSLo "$2" "$1" && shift && run "$@"; }
run () { chmod +x "$1" && "$@"; }
#+end_src

#+name: profile-exports
#+begin_src shell
# export EDITOR='emacsclient -c'
# export VISUAL='emacsclient -c'
export HISTCONTROL='ignoreboth:erasedups'
export LESSOPEN='| /usr/share/source-highlight/src-hilite-lesspipe.sh %s'
export LESS=' -R '
#+end_src

#+name: profile-paths
#+begin_src emacs-lisp :noweb-ref no :var shell=""
(let* ((path '("$HOME/.local/bin"
            "$HOME/.nimble/bin"
            "/home/linuxbrew/.linuxbrew/bin"
            "/home/linuxbrew/.linuxbrew/sbin"
            "$HOME/.nix-profile/bin"
            "$HOME/.guix-profile/bin"
            "$HOME/go/bin"
            "/usr/local/sbin"
            "/usr/local/bin"
            "/usr/sbin"
            "/usr/bin"
            "/sbin"
            "/bin"
            "/usr/games"
            "/usr/local/games"
            "/snap/bin"
            "/usr/local/go/bin"
            "/usr/lib/node_modules")))
    (pcase shell
        ("fish" (concat "set -gx PATH $PATH" (string-join path " ")))
        ("xonsh" (concat "$PATH += [ \"" (string-join path "\",\n\t\"") "\" ]"))
        (t (concat "export PATH=\"$PATH:" (string-join path ":") "\""))))
#+end_src

#+name: profile-all-together
#+begin_src text
<<profile-sources>>
<<profile-functions>>
<<profile-exports>>
<<cd-home-and-profile-aliases>>
<<profile-paths()>>
#+end_src

#+begin_src shell
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

alias s="source $HOME/.profile"
#+end_src

* .bashrc
:PROPERTIES:
:header-args:bash+: :noweb-ref .bashrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.bashrc>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20211027212836251792500

#+name: 20211027212836251792500
#+begin_src bash
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.bashrc"
eval "$(direnv hook bash)"
eval "$(zoxide init bash)"
eval "$(starship init bash)"
set -o vi
#+end_src

* .elvish
** lib
*** direnv.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref direnv.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<direnv.elv>>
#+end_src

#+begin_src elvish
direnv hook elvish
#+end_src

* rc.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref rc.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<rc.elv>>
#+end_src

#+begin_src elvish
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
use direnv
eval (zoxide init elvish | slurp)
eval (starship init elvish)
#+end_src

* .xinitrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .xinitrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xinitrc>>
#+end_src

#+begin_src shell
# exec emacs
exec emacsclient -a "" -c
#+end_src

* .direnvrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src shell
source ~/resources/nix-direnv/direnvrc
source ~/.config/direnv/direnvrc

if [[ -f /run/current-system/sw/share/nix-direnv/direnvrc ]]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

* .globalignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .globalignore
:END:

#+call: hash() :exports none

#+RESULTS:
: 20210601185925524999600

#+name: 20210601185925524999600
#+begin_src text :tangle (meq/tangle-path)
<<.globalignore>>
#+end_src

#+begin_src gitignore
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
/_gsdata_
/.boar
/.git
/.hg
**/.zfs/snapshot
/test*.*
temp
/etc/nixos/configuration.nix
/etc/nixos/hardware-configuration.nix
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

* .gitignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .gitignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.gitignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .hgignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .hgignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.hgignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .zshrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshrc>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshrc

# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history 0 | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.zshrc"
eval "$(direnv hook zsh)"
eval "$(zoxide init zsh)"
prompt off
eval "$(starship init zsh)"

bindkey -v

# From: https://leetschau.github.io/remove-duplicate-zsh-history.html
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_SAVE_NO_DUPS

source ~/resources/zsh-autosuggestions/zsh-autosuggestions.zsh
# source ~/resources/zsh-autocomplete/zsh-autocomplete.plugin.zsh

# Adapted From: https://github.com/zsh-users/zsh-history-substring-search#usage
source ~/resources/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/resources/zsh-history-substring-search/zsh-history-substring-search.zsh
#+end_src

* .zshenv
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshenv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshenv>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshenv
skip_global_compinit=1
#+end_src

* .zprofile
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zprofile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zprofile>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zprofile
#+end_src

* .zlogout
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogout
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogout>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogout
eval "$(direnv hook zsh)"
#+end_src

* .zlogin
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogin
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogin>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogin
eval "$(direnv hook zsh)"
#+end_src

* .stow-global-ignore
:PROPERTIES:
:header-args:conf+: :noweb-ref .stow-global-ignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.stow-global-ignore>>
#+end_src

#+begin_src conf
\.git
#+end_src

* .termux
** termux.properties
:PROPERTIES:
:header-args:conf+: :noweb-ref termux.properties
:END:

#+begin_src text :tangle (meq/tangle-path)
<<termux.properties>>
#+end_src

#+begin_src conf
### After making changes and saving you need to run `termux-reload-settings`
### to update the terminal.  All information here can also be found on the
### wiki: https://wiki.termux.com/wiki/Terminal_Settings

###############
# Extra keys
###############

### Settings for choosing which set of symbols to use for illustrating keys.
### Choose between default, arrows-only, arrows-all, all and none
# extra-keys-style = default

### Default extra-key configuration
# extra-keys = [[ESC, TAB, CTRL, ALT, {key: '-', popup: '|'}, DOWN, UP]]

### Two rows with more keys
# extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'], \
#               ['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]

### Configuration with additional popup keys (swipe up from an extra key)
# extra-keys = [[ \
#   {key: ESC, popup: {macro: "CTRL f d", display: "tmux exit"}}, \
#   {key: CTRL, popup: {macro: "CTRL f BKSP", display: "tmux ←"}}, \
#   {key: ALT, popup: {macro: "CTRL f TAB", display: "tmux →"}}, \
#   {key: TAB, popup: {macro: "ALT a", display: A-a}}, \
#   {key: LEFT, popup: HOME}, \
#   {key: DOWN, popup: PGDN}, \
#   {key: UP, popup: PGUP}, \
#   {key: RIGHT, popup: END}, \
#   {macro: "ALT j", display: A-j, popup: {macro: "ALT g", display: A-g}}, \
#   {key: KEYBOARD, popup: {macro: "CTRL d", display: exit}} \
# ]]

###############
# Colors/themes
###############

### Force black colors for drawer and dialogs
# use-black-ui = true

###############
# Keyboard shortcuts
###############

### Open a new terminal with ctrl + t (volume down + t)
# shortcut.create-session = ctrl + t

### Go one session down with (for example) ctrl + 2
# shortcut.next-session = ctrl + 2

### Go one session up with (for example) ctrl + 1
# shortcut.previous-session = ctrl + 1

### Rename a session with (for example) ctrl + n
# shortcut.rename-session = ctrl + n

###############
# Bell key
###############

### Vibrate device (default).
# bell-character = vibrate

### Beep with a sound.
# bell-character = beep

### Ignore bell character.
# bell-character = ignore

###############
# Back key
###############

### Send the Escape key.
# back-key=escape

### Hide keyboard or leave app (default).
# back-key=back

###############
# Keyboard issue workarounds
###############

### Letters might not appear until enter is pressed on Samsung devices
# enforce-char-based-input = true

### ctrl+space (for marking text in emacs) does not work on some devices
# ctrl-space-workaround = true

allow-external-apps = true
#+end_src
