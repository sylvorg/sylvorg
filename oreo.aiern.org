#+setupfile: ./settings/README.org
#+include: ./settings/README.org

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* shell.nix

#+begin_src nix :tangle (meq/tangle-path)
let
    name = "nichtstrap";
    pkgs = import <nixpkgs> {};
in (pkgs.buildFHSUserEnv {
    inherit name;
    targetPkgs = pkgs: with pkgs; [ python310 sd gcc rsync ];
    runScript = ''
        pip install --upgrade pip
        pip install https://github.com/<<username>>/bakery/archive/main.tar.gz \
                    coconut \
                    cytoolz \
                    xonsh || :
        chmod +x ${builtins.toString ./.}/nichtstrap 2> /dev/null || chmod +x ${builtins.toString ./.}/nichtstrap.py
        exec xonsh
    '';
}).env
#+end_src

* nichtstrap.py

#+begin_src py :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3"
import hy, os
from addict import Dict
from nanite import module_installed
nichtstrap = module_installed(os.path.dirname(os.path.realpath(__file__)) + "/nichtstrap.hy").nichtstrap
if __name__ == "__main__":
    nichtstrap(obj=Dict(dict()))
#+end_src

* nichtstrap.hy
:PROPERTIES:
:header-args:hy+: :noweb-ref nwr20220129201318455450756
:END:

#+begin_src hy :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env hy"
<<nwr20220129201318455450756>>
#+end_src

** Imports

#+begin_src hy
(import click)
(import json)
(import os)
#+end_src

*** From

#+begin_src hy
(import addict [Dict :as D])
(import bakery [ getconf
                 mkswap
                 mount :as Mount
                 nixos-generate-config
                 nixos-install
                 nixos-rebuild
                 rsync
                 sd
                 swapon
                 umount
                 zfs
                 zpool ])
(import functools [partial])
(import pathlib [Path])
(import sys [argv])
#+end_src

*** Coconut

[[https://coconut.readthedocs.io/en/latest/index.html][Coconut]]:

#+begin_src hy
(try (import coconut *)
     (except [ImportError] None))
#+end_src

*** Toolz

[[https://github.com/pytoolz/toolz][Toolz]] and [[https://github.com/pytoolz/cytoolz/][CyToolz]]:

#+begin_src hy
(try (import cytoolz [last])
     (except [ImportError]
             (import toolz [last])))
#+end_src

** Requires

#+begin_src hy
(require hyrule [-> assoc])
#+end_src

** Set Resources Directory

#+begin_src hy
(setv resources (+ (.dirname os.path (.realpath os.path __file__)) "/etc/nixos/"))
#+end_src

** Datasets

#+call: hash() :exports none

#+RESULTS:
: 20220205031620372930929

#+name: 20220205031620372930929
#+begin_src text
dross
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601190015343762700

#+name: 20210601190015343762700
#+begin_src json
{
    "base": {  },
    "omniverse": {  },
    "reserved": {  },
    "<<username>>": { "datasets": {
            "oreo": { "mountpoint": "/home/<<username>>/oreo", "options": [ "snapdir=visible" ] },
            "sylveon": { "mountpoint": "/home/<<username>>/sylveon", "options": [ "snapdir=visible" ] },
            "sylvorg": { "mountpoint": "/home/<<username>>/sylvorg", "options": [ "snapdir=visible" ] },
            "syvlorg": { "mountpoint": "/home/<<username>>/syvlorg", "options": [ "snapdir=visible" ] },
            "<<20220205031620372930929>>": { "mountpoint": "/home/<<username>>/<<20220205031620372930929>>", "options": [ "snapdir=visible" ] },
            "uru": { "mountpoint": "/home/<<username>>/uru", "options": [ "snapdir=visible" ] }},
        "options": [ "mountpoint=legacy" ]},
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": {  },
            "root": {  },
            "tmp": { "datasets": { "nix": {  }}, "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

** Update Datasets

#+begin_src hy
(defn update-datasets [host [swap 0] [encrypted False] [deduplicated False] [pool False]]
      (setv snap-dir     [ "snapdir=visible" ]
            extra-copies (+ snap-dir [ "copies=3" ])
            cache        [ "sync=disabled" ]
            ml           "mountpoint=legacy"
            d            "datasets"
            s            "system"
            datasets     (D (.loads json (.strip #[[
                                <<20210601190015343762700>>
                         ]])))
            users        (D (.loads json (.strip #[[
                                <<20210601185359809444000>>
                         ]]))))
      (assoc datasets host (D { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                                "options" [ ml ]}))
      (for [user (.values users)]
           (assoc (. datasets [s] [d] home [d]) user (dict))
           (assoc (. datasets virt [d] podman [d]) user (dict)))
      (with [dnix (open (+ resources "/datasets.nix") "w")]
            (.write dnix "{\n")
            (defn recurse [ddict dname droot [mountpoint ""]]
                  (setv recurse/dataset (+ droot "/" dname)
                        cloning         (and (!= dname "base")
                                             (and encrypted deduplicated))
                        prefixes        (, "system"
                                           "system/root"
                                           "swap"
                                           "base"
                                           "hold"
                                           "omniverse"
                                           "reserved" ))
                  (if cloning
                      (setv clone-or-create  "clone"
                            snapshot-or-none (+ host "/base@root"))
                      (setv clone-or-create  "create"
                            snapshot-or-none ""))
                  (if (not (in recurse/dataset (lfor dataset prefixes (+ host "/" dataset))))
                      (do (if (setx recurse/mountpoint (.get ddict "mountpoint" ""))
                              (setv mountpoint recurse/mountpoint)
                              (if mountpoint
                                  (setv mountpoint (+ mountpoint "/" dname)
                                        recurse/mountpoint mountpoint)
                                  (do (setv recurse/mountpoint (.removeprefix recurse/dataset (+ host "/")))
                                      (for [prefix prefixes]
                                           (setv recurse/mountpoint (.removeprefix recurse/mountpoint (+ prefix "/"))))
                                      (setv recurse/mountpoint (+ "/" recurse/mountpoint)))))
                          (.write dnix (+ "\t\""
                                          recurse/dataset
                                          "\" = \""
                                          recurse/mountpoint
                                          "\";\n"))))
                  (if pool
                      (do (zfs :m/subcommand clone-or-create
                               :o { "repeat-with-values" (.get ddict "options" []) }
                               snapshot-or-none
                               recurse/dataset)
                          (.snapshot zfs :r True (+ recurse/dataset "@root"))))
                  (for [[key value] (.items (.get ddict d (D {  })))]
                       (recurse value key recurse/dataset mountpoint)))
            (for [[key value] (.items datasets)]
                 (recurse value key host))
            (.write dnix "}"))
      (if pool
          (let [pool-size-plus-metric (get (.get zpool :H True "size" host :m/list True :m/split True) 2)
                pool-size             (-> pool-size-plus-metric
                                          (cut 0 -1)
                                          (float)
                                          (round 2))
                pool-metric           (last pool-size-plus-metric)]
               (defn pool-percentage-value [percentage]
                     (-> percentage
                         (float)
                         (/ 100)
                         (round 2)
                         (str)
                         (+ pool-metric)
                         (return)))
               (.set zfs
                     (+ "refreservation=" (pool-percentage-value 15))
                     (+ host "/reserved"))

               ;; Apparently, if python internal keywords exist in the argument, such as "set", etc.
               ;; the command errors out; perhaps something to raise an issue of.
               ;; This seems to work as an alternative.
               ;; run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/reserved", shell = True)

               (if swap
                   (let [swoptions [ "com.sun:auto-snapshot=false"
                                     "compression=zle"
                                     "logbias=throughput"
                                     "primarycache=metadata"
                                     "secondarycache=none"
                                     "sync=standard" ]
                         page-size (getconf "PAGESIZE" :m/str True)]
                        (.create zfs
                                 :V (+ (str swap) "G")
                                 :b page-size
                                 :o { "repeat-with-values" swoptions }
                                 (+ host "/swap"))
                        (mkswap (+ "/dev/zvol" host "/swap")))))))
#+end_src

** Click

#+begin_src hy
(setv no-host-error-message "Sorry! The host needs to be set; do this with the main command while running the subcommand!")
#@((.group click :no-args-is-help True)
   (.option click "-d" "--dazzle" :is-flag True)
   (.option click "-H" "--host")
   (.option click "-i" "--inspect" :is-flag True)
   (.option click "-p" "--print-run" :is-flag True)
   click.pass-context
   (defn nichtstrap [ ctx dazzle host inspect print-run ]
         (.ensure-object ctx dict)
         (setv ctx.obj.host host)
         (if print-run (.bake-all- getconf :m/print-command-and-run True))
         (if inspect (.bake-all- getconf :m/debug True))))
#+end_src

*** Main

#+begin_src hy
#@((.command nichtstrap :no-args-is-help True
                        :context-settings { "ignore_unknown_options" True
                                            "allow_extra_args"       True })
   (.argument click "program-arguments" :nargs -1)
   (.option click "-a" "--all" :is-flag True)
   (.option click "-c" "--copy" :is-flag True)
   (.option click "-g" "--generate" :is-flag True)
   (.option click "-i" "--install" :is-flag True)
   (.option click "-r" "--replace" :is-flag True)
#+end_src

This can't use a default value, as that would trigger a rebuild all the time.

#+begin_src hy
   (.option click "-R" "--rebuild")
#+end_src

#+begin_src hy
   click.pass-context
   (defn main [ ctx all copy generate install program-arguments rebuild replace ]
         (.bake-all- getconf :m/sudo True)
         (setv copy-partial (partial rsync :m/run True :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } f"{resources}/"))
         (if rebuild
             (do (if copy
                     (copy-partial "/etc/nixos/"))
                 (nixos-rebuild rebuild #* ctx.args :show-trace True))
             (do (if (or copy all)
                     (do (update-datasets ctx.obj.host)
                         (copy-partial "/mnt/etc/nixos/")))
                 (if (or generate all)
                     (nixos-generate-config :m/run True :root "/mnt" :m/dazzle True))
                 (if (or replace all)
                     (if ctx.obj.host
                         (sd :m/run True
                             "./hardware-configuration.nix"
                             (+ "./configs/" ctx.obj.host)
                             "/mnt/etc/nixos/configuration.nix")
                         (raise (NameError no-host-error-message))))
                 (if (or install all)
                     (nixos-install #* ctx.args
                                    :m/run True
                                    :show-trace True
#+end_src

From [[https://github.com/NixOS/nix/issues/2293#issuecomment-405339738][here]], and documented [[https://nixos.org/manual/nix/stable/expressions/builtins.html#:~:text=The%20fetched%20tarball%20is%20cached%20for%20a%20certain%20amount%20of%20time%20(1%20hour%20by%20default)%20in%20~/.cache/nix/tarballs/.%20You%20can%20change%20the%20cache%20timeout%20either%20on%20the%20command%20line%20with%20%2D%2Dtarball%2Dttl%20number%2Dof%2Dseconds%20or%20in%20the%20Nix%20configuration%20file%20by%20adding%20the%20line%20tarball%2Dttl%20%3D%20number%2Dof%2Dseconds.][here]]:

#+begin_quote
The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/.
You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds
or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds.
#+end_quote

#+begin_src hy :noweb-ref no
                                    :option "tarball-ttl 0"
#+end_src

#+begin_src hy
))))))
#+end_src

*** Create

#+begin_src hy
#@((.command nichtstrap :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-s" "--swap" :type int :default 0)
   (.option click "-z" "--zfs-device" :required True)
   click.pass-context
   (defn create [ ctx deduplicated encrypted swap zfs-device ]
         (if ctx.obj.host
             (try (if (= (input "THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN 'ZFS CREATE'!\n\t") "ZFS CREATE")
                      (let [options (D { "xattr"      "sa"
                                         "acltype"    "posixacl"
                                         "mountpoint"  "none"
                                         "compression" "zstd-19"
                                         "checksum"    "edonr"
                                         "atime"       "off"
                                         "relatime"    "off" })
                            command (partial zpool.create
                                             :f True
                                             :o { "repeat-with-values" (, "autotrim=on" "altroot=/mnt" "autoexpand=on") })]
                           (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                                (if (in ctx.obj.host dataset)
                                    (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
                           (if encrypted
                               (setv options.encryption "aes-256-gcm"
                                     options.keyformat  "passphrase"))
                           (if deduplicated
                               (setv options.dedup "edonr,verify"))
                           (if (.ismount os.path "/mnt")
                               (umount :R True "/mnt"))
                           (.export zpool :f True ctx.obj.host :m/ignore-stderr True)
                           (command :O { "repeat-with-values" (gfor [k v] (.items options) f"{k}={v}") } ctx.obj.host zfs-device)
                           (update-datasets ctx.obj.host swap encrypted deduplicated :pool True))
                      (print "Sorry; not continuing!\n\n"))
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

*** Mount

#+begin_src hy
#@((.command nichtstrap :no-args-is-help True)
   (.option click "-b" "--boot-device")
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :is-flag True)
   click.pass-context
   (defn mount [ ctx boot-device deduplicated encrypted root-device swap ]
         (if ctx.obj.host
             (do (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                      (if (in ctx.obj.host dataset)
                          (break))
                      (else (.import zpool :f True ctx.obj.host)))
                 (if encrypted
                     (.load-key zfs ctx.obj.host))
                 (try (.mkdir (Path "/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt")
                                  (umount :R True "/mnt"))))
                 (if root-device
                     (Mount root-device "/mnt")
                     (Mount :t "zfs" (+ ctx.obj.host "/system/root") "/mnt"))
                 (with [datasets (open (+ resources "/datasets.nix"))]
                       (setv dataset-dict (dfor dm
                                                (cut (.readlines datasets) 1 -1)
                                                :setv [k v] (.split dm "=")
                                                [(.strip k)
#+end_src

Because the mount already has a double-quote on the right side, we strip the quotes on the left side,
then re-add them to the final mountpoint with ~"/mnt~.

#+begin_src hy
                                                 (+ "\"/mnt"
                                                    (-> v
                                                        (.strip)
                                                        (.rstrip ";")
                                                        (.lstrip "\"")))])
#+end_src

#+begin_src hy
                             ordered-dataset-dict (-> dataset-dict
                                                      (.items)
                                                      (sorted :key (fn [item] (get item 1)))
                                                      (dict)))
                       (for [[k v] (.items ordered-dataset-dict)]
                            (-> v (.strip "\"") (Path) (.mkdir :parents True :exist-ok True))
                            (Mount :t "zfs" k v)))
                 (.mkdir (Path "/mnt/etc/nixos") :parents True :exist-ok True)
                 (if boot-device
                     (let [boot "/mnt/boot/efi"]
                          (.mkdir (Path boot) :parents True :exist-ok True)
                          (Mount boot-device boot)))
                 (if swap
                     (swapon (+ "/dev/zvol/" ctx.obj.host "/swap")))

                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp") "/tmp")
                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/tmp/nix")
                 ;; (rsync :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } :delete True "/nix/" "/tmp/nix/")
                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/nix")
         
                 )
             (raise (NameError no-host-error-message)))))
#+end_src

*** Update

#+begin_src hy
#@((.command nichtstrap :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-f" "--files" :is-flag True :help "Update datasets.nix with any new datasets; the default")
   (.option click "-p" "--pool" :is-flag True :help "Update the pool and datasets.nix with any new datasets")
   (.option click "-s" "--swap" :type int :default 0)
   click.pass-context
   (defn update [ ctx deduplicated encrypted files pool swap ]
         (if ctx.obj.host
             (try (setv ud (partial update-datasets ctx.obj.host swap encrypted deduplicated))
                  (cond [files (ud)]
                        [pool (ud :pool True)]
                        [True (ud)])
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

** End of nichtstrap

#+begin_src hy :noweb-ref no
(if (= __name__ "__main__")
    (nichtstrap :obj (D {})))
#+end_src

* etc
** apk
*** repositories
:PROPERTIES:
:header-args:text+: :noweb-ref repositories
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<repositories>>
#+end_src

#+begin_src text
http://postmarketos.brixit.nl/postmarketos/master
https://dl-cdn.alpinelinux.org/alpine/v3.13/main
https://dl-cdn.alpinelinux.org/alpine/v3.13/community
#+end_src

*** keys
**** build.postmarketos.org.rsa.pub
:PROPERTIES:
:header-args:text+: :noweb-ref build.postmarketos.org.rsa.pub
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<build.postmarketos.org.rsa.pub>>
#+end_src

#+begin_src text
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlXE4h6kp8aCzn6BjuOnz
Z1lcFSY+WRZ2vGUb5hEZ+YG75xYZW+yELr8P8+HSUrpBXF/HTQYKH/cNJc5zmOny
EsmcZskIYB0qgZPg02GXBV8VfjL+Es+y166g14IH2YKkdfplqHYVpCmnkmaZXQZu
ZAOEL2hyuzTAYYFhCZWHYYgdWfpnKDDlVcnw1Q3/LhADBlN63CW0UMWc5oJ7MwlY
SKriM60cHvER1YD5bdbGG/JTBFnB4djliLtvRNp+w3emwHmDhFmnYITN2WOHbYpV
P+RIfzq0IP978sKGJmd0RPuwl2ruifBYikm/F79Ko8lT2gVE40B7wqbInIGquTr1
deERIr47jcPRGl+01Svm0SxbXD1/zBNjo4wvMsZEW7Te689mFjxsXHnD7OEUQqh/
D1DhbnKJwpKwClYOi/aVDyGJunqavSR0QYPqN3nP+uXdBC4wuLI9gRS/yXNaxpMy
9AKwlD3uUhKzmJMJIu3L1/TH/vY9M5xZ2lnFduTZmL/X/4sjhyTb1ycFwU9UIY4C
u2CP/YLqiiquokgzpRfYwJyOP4quBVRC46Tejx5PzTCvnhro7LAzDoS756iBv9E/
2oxwC5VafGSChO+N8SyEBy532Gs+rcZDwUE7M9Y1GbQHW3ALMTwxstWqZ3GKWKd1
Cw6JQoywUhR09tFwQrYZao0CAwEAAQ==
-----END PUBLIC KEY-----
#+end_src

** nixos
*** patches
**** BACKPORT-Linux-5.8-compat-__vmalloc.patch

#+begin_src diff :tangle (meq/tangle-path)
From 6cc95288ccea12ad7b67b2b5b3997dfad8e5b5c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20Niew=C3=B6hner?=
 <c0d3z3r0@users.noreply.github.com>
Date: Tue, 9 Jun 2020 01:32:02 +0200
Subject: [PATCH] BACKPORT: Linux 5.8 compat: __vmalloc()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The `pgprot` argument has been removed from `__vmalloc` in Linux 5.8,
being `PAGE_KERNEL` always now [1].

Detect this during configure and define a wrapper for older kernels.

[1] https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/mm/vmalloc.c?h=next-20200605&id=88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Co-authored-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Co-authored-by: Michael Niewöhner <foss@mniewoehner.de>
Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Signed-off-by: Michael Niewöhner <foss@mniewoehner.de>
Closes #10422
---
 config/kernel-kmem.m4       | 26 ++++++++++++++++++++++++++
 config/kernel.m4            |  2 ++
 include/spl/sys/kmem.h      |  9 +++++++++
 module/spl/spl-kmem-cache.c |  4 ++--
 module/spl/spl-kmem.c       |  9 ++++-----
 5 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/config/kernel-kmem.m4 b/config/kernel-kmem.m4
index cc055e530..f1c0d2412 100644
--- a/config/kernel-kmem.m4
+++ b/config/kernel-kmem.m4
@@ -56,3 +56,29 @@ AC_DEFUN([SPL_AC_DEBUG_KMEM_TRACKING], [
    AC_MSG_CHECKING([whether detailed kmem tracking is enabled])
    AC_MSG_RESULT([$enable_debug_kmem_tracking])
 ])
+
+dnl #
+dnl # 5.8 API,
+dnl # __vmalloc PAGE_KERNEL removal
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL], [
+   ZFS_LINUX_TEST_SRC([__vmalloc], [
+       #include <linux/mm.h>
+       #include <linux/vmalloc.h>
+   ],[
+       void *p __attribute__ ((unused));
+
+       p = __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+   ])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL], [
+   AC_MSG_CHECKING([whether __vmalloc(ptr, flags, pageflags) is available])
+   ZFS_LINUX_TEST_RESULT([__vmalloc], [
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_VMALLOC_PAGE_KERNEL, 1, [__vmalloc page flags exists])
+   ],[
+       AC_MSG_RESULT(no)
+   ])
+])
+-
diff --git a/config/kernel.m4 b/config/kernel.m4
index b67fcef8c..23edfdcd8 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -45,6 +45,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
    ZFS_AC_KERNEL_SRC_SCHED
    ZFS_AC_KERNEL_SRC_USLEEP_RANGE
    ZFS_AC_KERNEL_SRC_KMEM_CACHE
+   ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_SRC_WAIT
    ZFS_AC_KERNEL_SRC_INODE_TIMES
    ZFS_AC_KERNEL_SRC_INODE_LOCK
@@ -163,6 +164,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
    ZFS_AC_KERNEL_SCHED
    ZFS_AC_KERNEL_USLEEP_RANGE
    ZFS_AC_KERNEL_KMEM_CACHE
+   ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_WAIT
    ZFS_AC_KERNEL_INODE_TIMES
    ZFS_AC_KERNEL_INODE_LOCK
diff --git a/include/spl/sys/kmem.h b/include/spl/sys/kmem.h
index 72d3a7765..ca15bfe7f 100644
--- a/include/spl/sys/kmem.h
+++ b/include/spl/sys/kmem.h
@@ -169,6 +169,15 @@ extern void *spl_kmem_alloc(size_t sz, int fl, const char *func, int line);
 extern void *spl_kmem_zalloc(size_t sz, int fl, const char *func, int line);
 extern void spl_kmem_free(const void *ptr, size_t sz);
 
+/*
+ * 5.8 API change, pgprot_t argument removed.
+ */
+#ifdef HAVE_VMALLOC_PAGE_KERNEL
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags, PAGE_KERNEL)
+#else
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags)
+#endif
+
 /*
  * The following functions are only available for internal use.
  */
diff --git a/module/spl/spl-kmem-cache.c b/module/spl/spl-kmem-cache.c
index d71b4b348..4866b2993 100644
--- a/module/spl/spl-kmem-cache.c
+++ b/module/spl/spl-kmem-cache.c
@@ -203,7 +203,7 @@ kv_alloc(spl_kmem_cache_t *skc, int size, int flags)
        ASSERT(ISP2(size));
        ptr = (void *)__get_free_pages(lflags, get_order(size));
    } else {
-       ptr = __vmalloc(size, lflags | __GFP_HIGHMEM, PAGE_KERNEL);
+       ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
    }
 
    /* Resulting allocated memory will be page aligned */
@@ -1242,7 +1242,7 @@ spl_cache_grow(spl_kmem_cache_t *skc, int flags, void **obj)
     * allocation.
     *
     * However, this can't be applied to KVM_VMEM due to a bug that
-    * __vmalloc() doesn't honor gfp flags in page table allocation.
+    * spl_vmalloc() doesn't honor gfp flags in page table allocation.
     */
    if (!(skc->skc_flags & KMC_VMEM)) {
        rc = __spl_cache_grow(skc, flags | KM_NOSLEEP);
diff --git a/module/spl/spl-kmem.c b/module/spl/spl-kmem.c
index cee69ad43..ca1fc145f 100644
--- a/module/spl/spl-kmem.c
+++ b/module/spl/spl-kmem.c
@@ -172,16 +172,15 @@ spl_kmem_alloc_impl(size_t size, int flags, int node)
         * kmem_zalloc() callers.
         *
         * For vmem_alloc() and vmem_zalloc() callers it is permissible
-        * to use __vmalloc().  However, in general use of __vmalloc()
-        * is strongly discouraged because a global lock must be
-        * acquired.  Contention on this lock can significantly
+        * to use spl_vmalloc().  However, in general use of
+        * spl_vmalloc() is strongly discouraged because a global lock
+        * must be acquired.  Contention on this lock can significantly
         * impact performance so frequently manipulating the virtual
         * address space is strongly discouraged.
         */
        if ((size > spl_kmem_alloc_max) || use_vmem) {
            if (flags & KM_VMEM) {
-               ptr = __vmalloc(size, lflags | __GFP_HIGHMEM,
-                   PAGE_KERNEL);
+               ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
            } else {
                return (NULL);
            }
-- 
2.25.1
#+end_src

**** 0110-initialize-ata-before-graphics.patch

#+begin_src diff :tangle (meq/tangle-path)
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Arjan van de Ven <arjan@linux.intel.com>
Date: Thu, 2 Jun 2016 23:36:32 -0500
Subject: [PATCH] initialize ata before graphics

ATA init is the long pole in the boot process, and its asynchronous.
move the graphics init after it so that ata and graphics initialize
in parallel
---
 drivers/Makefile | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/drivers/Makefile b/drivers/Makefile
index c0cd1b9..af1e2fb 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -59,15 +59,8 @@ obj-y                += char/
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-y              += iommu/
 
-# gpu/ comes after char for AGP vs DRM startup and after iommu
-obj-y              += gpu/
-
 obj-$(CONFIG_CONNECTOR)        += connector/
 
-# i810fb and intelfb depend on char/agp/
-obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
-obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
-
 obj-$(CONFIG_PARPORT)      += parport/
 obj-$(CONFIG_NVM)      += lightnvm/
 obj-y              += base/ block/ misc/ mfd/ nfc/
@@ -80,6 +73,14 @@ obj-$(CONFIG_IDE)        += ide/
 obj-y              += scsi/
 obj-y              += nvme/
 obj-$(CONFIG_ATA)      += ata/
+
+# gpu/ comes after char for AGP vs DRM startup and after iommu
+obj-y              += gpu/
+
+# i810fb and intelfb depend on char/agp/
+obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
+obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
+
 obj-$(CONFIG_TARGET_CORE)  += target/
 obj-$(CONFIG_MTD)      += mtd/
 obj-$(CONFIG_SPI)      += spi/
-- 
https://clearlinux.org
#+end_src

**** export_kernel_fpu_functions_5_3.patch

#+begin_src diff :tangle (meq/tangle-path)
From 1e010beda2896bdf3082fb37a3e49f8ce20e04d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 2 May 2019 05:28:08 +0100
Subject: [PATCH] x86/fpu: Export kernel_fpu_{begin,end}() with
 EXPORT_SYMBOL_GPL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need these symbols in zfs as the fpu implementation breaks userspace:

https://github.com/zfsonlinux/zfs/issues/9346
Signed-off-by: Jörg Thalheim <joerg@thalheim.io>
---
 arch/x86/kernel/fpu/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 12c70840980e..352538b3bb5d 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -102,7 +102,7 @@ void kernel_fpu_begin(void)
    }
    __cpu_invalidate_fpregs_state();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_begin);
+EXPORT_SYMBOL(kernel_fpu_begin);
 
 void kernel_fpu_end(void)
 {
@@ -111,7 +111,7 @@ void kernel_fpu_end(void)
    this_cpu_write(in_kernel_fpu, false);
    preempt_enable();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_end);
+EXPORT_SYMBOL(kernel_fpu_end);
 
 /*
  * Save the FPU state (mark it for reload if necessary):
-- 
2.23.0
#+end_src

**** fetchpypi.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/fetchpypi.nix b/fetchpypi.nix
index e60c9df..df50c0d 100644
--- a/fetchpypi.nix
+++ b/fetchpypi.nix
@@ -24,5 +24,5 @@ in makeOverridable( {format ? "setuptools", sha256 ? "", hash ? "", ... } @attrs
   let
     url = computeUrl (builtins.removeAttrs attrs ["sha256" "hash"]) ;
   in fetchurl {
-    inherit url sha256 hash;
+    inherit url sha256;
   })
#+end_src

**** fetchurl.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/pkgs/build-support/fetchurl/boot.nix
+++ b/pkgs/build-support/fetchurl/boot.nix
@@ -6,7 +6,8 @@ let mirrors = import ./mirrors.nix; in
 , urls ? []
 , sha256
 , name ? baseNameOf (toString url)
-}:
+, ...
+} @ args:
 
 import <nix/fetchurl.nix> {
   inherit system sha256 name;
diff --git a/pkgs/build-support/fetchzip/default.nix b/pkgs/build-support/fetchzip/default.nix
index c61df8ceb00..d973837f0d3 100644
--- a/pkgs/build-support/fetchzip/default.nix
+++ b/pkgs/build-support/fetchzip/default.nix
@@ -14,7 +14,8 @@
 , name ? "source"
 , ... } @ args:
 
-(fetchurl ({
+let
+ x = (fetchurl ({
   inherit name;
 
   recursiveHash = true;
@@ -46,7 +47,11 @@
       mv "$unpackDir" "$out"
     '') #*/
     + extraPostFetch;
-} // removeAttrs args [ "stripRoot" "extraPostFetch" ])).overrideAttrs (x: {
+  } // removeAttrs args [ "stripRoot" "extraPostFetch" ]));
+
+in
+  x // {
+    # .overrideAttrs (x: {
   # Hackety-hack: we actually need unzip hooks, too
   nativeBuildInputs = x.nativeBuildInputs ++ [ unzip ];
-})
+}
#+end_src

**** grub_zfs.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -285,6 +285,7 @@ static const char *spa_feature_names[] = {
   "com.delphix:embedded_data",
   "com.delphix:extensible_dataset",
   "org.open-zfs:large_blocks",
+  "org.zfsonlinux:large_dnode",
   NULL
 };
#+end_src

**** set_power_mgmt.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/net/wireless/nl80211.c    2019-07-08 00:41:56.000000000 +0200
+++ b/net/wireless/nl80211.c    2020-02-05 19:30:26.352718504 +0100
@@ -10517,10 +10520,7 @@
    if (!rdev->ops->set_power_mgmt)
        return -EOPNOTSUPP;
 
-   state = (ps_state == NL80211_PS_ENABLED) ? true : false;
-
-   if (state == wdev->ps)
-       return 0;
+   state = false;
 
    err = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);
    if (!err)
#+end_src

*** users.json

#+call: hash() :exports none

#+RESULTS:
: 20210601185359809444000

#+name: 20210601185359809444000
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** configs

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

**** sandshrew
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [
        ../../super.nix
        "${builtins.fetchGit { url = "https://github.com/nixos/nixos-hardware.git"; }}/microsoft/surface"
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
        networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env sh
        for usb in $(ls /dev/disk/by-id).split("\n"):
            if usb and usb[:4] == "usb-":
                for mnt in $(mount).split("\n"):
                    if mnt and usb in mnt:
                        umount @(mnt.split()[2])
    '';
}
#+end_src

**** murasame
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [
        ../../super.nix
        ../../bcachefs.nix
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** argus
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [
        ../../super.nix
        ../../bcachefs.nix
    ];
    boot = {
        kernelParams = [ "console=ttyS0,19200n8" ];
        loader.grub.extraConfig = ''
            serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
            terminal_input serial;
            terminal_output serial;
        '';
    };
    networking = {
        usePredictableInterfaceNames = false;
        interfaces.eth0.useDHCP = true;
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

*** bcachefs.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    boot = {
        supportedFilesystems = [ "bcachefs" ];
        initrd.supportedFilesystems = config.boot.supportedFilesystems;
    };
}
#+end_src

*** lib.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref lib.nix
:END:

#+begin_src nix :noweb-ref no :tangle (meq/tangle-path)
<<lib.nix>>
#+end_src

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

**** Arguments

#+begin_src nix
pkgs: lib: host: with lib; with builtins;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** New Lib

#+begin_src nix
newLib = self: rec {
#+end_src

****** Functions

#+begin_src nix
functions = rec {
#+end_src

******* Convert Path To Mount

#+begin_src nix
mntConvert = dir: let mntDir = "/mnt/" + dir; in if (pathExists mntDir) then mntDir else dir;
#+end_src

******* Zip To Set

#+begin_src nix
zipToSet = names: values: listToAttrs (
    map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
        if hasAttrs then names else (sort lessThan names)
    ) (
        if hasAttrs then values else (sort lessThan values)
    ))
);
#+end_src

******* Fold To Set

#+begin_src nix
# TODO: Why is the filter necessary?
foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);
#+end_src

******* My Conditionals

#+begin_src nix
myIf = {
    list = condition: value: optionals condition value;
    singleton = condition: value: optional condition value;
    set = condition: value: if condition then value else {};
    num = condition: value: if condition then value else 0;
    knull = condition: value: if condition then value else null;
    empty = condition: value: if condition then value else "";
    drv = condition: value: if condition then value else pkgs.hello;
};
#+end_src

******* To Capital

#+begin_src nix
toCapital = string: concatImapStrings (
    i: v: if (i == 0) then (toUpper v) else v
) (stringToCharacters string);
#+end_src

******* Sequence

#+begin_src nix
sequence = list: end: foldr (a: b: deepSeq a b) end list;
#+end_src

******* Import Stuff

#+begin_src nix
args = {
    suffix = "";
    ignores = [];
};

baseNameNoSuffix = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    file
}: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

# !!! This returns a function
filterFunc = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    ignores ? args.ignores,
    dir,
}: let
    _ignores = flatten [
        ignores
        (let
            _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
        in if (pathExists _ignores') then (import _ignores') else [])
        [ "default" "deprecated" ]
    ];
in file: value:
    (if noSuffix then (
        (hasSuffix ".nix" file) || (value == "directory")
    ) else (hasSuffix suffix file)) &&
    (!hasPrefix "_" file) &&
    (!elem (baseNameNoSuffix { inherit suffix file noSuffix; }) _ignores);

contents = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
}: filterAttrs (filterFunc _args) (readDir dir);

list = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/${n}"),

}: let
    __args = removeAttrs _args [ "func" ];
in mapAttrsToList func (contents __args);

listNames = {
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir
}: list {
    inherit suffix ignores dir;
    func = (n: v: baseNameNoSuffix { inherit suffix; file = n; });
};

set = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
    modules ? {},

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/" + n),

}: let
    files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
in zipToSet
    (map (file: name { inherit suffix file; }) files)
    (map (file: import file (foldToSet [ modules inputs ])) files);
#+end_src

******* End of Functions

#+begin_src nix
};
#+end_src

****** Attrs

#+call: hash() :exports none

#+RESULTS:
: 20210601184948158342800

#+name: 20210601184948158342800
#+begin_src conf
keep-derivations = true
keep-outputs = true
experimental-features = nix-command flakes
allow-unsafe-native-code-during-evaluation = true
#+end_src

#+begin_src nix
attrs = rec {
#+end_src

******* Relay Machines

#+begin_src nix
relays = [ <<relays>> ];
#+end_src

******* Configs

#+begin_src nix
configs = {
    nixpkgs = {
        allowUnfree = true;
        allowBroken = true;
        allowUnsupportedSystem = true;
        # preBuild = ''
        #     makeFlagsArray+=(CFLAGS="-w")
        #     buildFlagsArray+=(CC=cc)
        # '';
        permittedInsecurePackages = [
            "python2.7-cryptography-2.9.2"
        ];
    };
    nix = let
        MG = size: let
            mg = stringToCharacters size;
        in toString ((toInt (elemAt mg 0)) * (
            if (elemAt mg 1 == "M") then 1 else 1024
        ) * 1024 * 1024);
    in ''
        <<20210601184948158342800>>
        min-free = ${MG "250M"}
        max-free = ${MG "1G"}
    '';
    services = rec {
        mkBase = User: {
            enable = true;
            serviceConfig = rec {
                Restart = "on-failure";
                inherit User;
                Group = User;
            };
            wantedBy = [ "multi-user.target" ];
        };
        base = mkBase users.primary;
        mkdir = path: "mkdir -p /persist/${path} &> /dev/null";
    };
};
#+end_src

******* Users

#+begin_src nix
users = fromJSON (readFile ./users.json);
excludedUsers = [ "root" ];
mainUsers = attrValues users;
allUsers = mainUsers ++ excludedUsers;
#+end_src

******** Homes

#+begin_src nix
homes = listToAttrs (map (
    user: nameValuePair user "/home/${user}"
) mainUsers);
allHomes = homes // { root = "/root"; };
#+end_src

******* Datasets

#+begin_src nix
datasets = {
    fileSystems = import ./datasets.nix;
    backup = [
        "system/persist"
        "virt"
        "omniverse"
        users.primary
    ];
};
#+end_src

******* Platforms

#+begin_src nix
platforms = {
    arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
    imd = [ "i686-linux" "x86_64-linux" ];
};
#+end_src

******* SSH

#+begin_src nix
ssh.keys = {
    master = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
};
#+end_src

******* Filesystems

#+begin_src nix
fileSystems = {
    base = {
        fsType = "zfs";
        options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
    };
    supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
};
#+end_src

******* Commands

#+begin_src nix
commands = {
    rebuild = "nixos-rebuild --impure";
    install = "nixos-install --impure --show-trace";
};
#+end_src

******* Versions

#+begin_src nix
versions = {
    python = "310";
    emacs = "28";
};
#+end_src

******* End of Attrs

#+begin_src nix
};
#+end_src

****** Paths

#+begin_src nix
paths = rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches.base = "${nixos}/patches";
};
#+end_src

****** End of New Lib

#+begin_src nix
};
#+end_src

***** Extension

#+begin_src nix
extension = makeExtensible newLib;
#+end_src

**** Extend

#+begin_src nix
in with lib; extension.extend (final: prev: foldr (new: old: recursiveUpdate new old) {} (attrValues prev))
#+end_src

*** callPackages
**** caddy.nix

Taken from [[https://github.com/NixOS/nixpkgs/issues/14671#issuecomment-1016376290][here]]; allows me to build caddy with plugins:

#+begin_src nix :tangle (meq/tangle-path)
{ lib, fetchFromGitHub, buildGoModule, plugins ? [], vendorSha256 ? "" }:

with lib;

let imports = flip concatMapStrings plugins (pkg: "\t\t\t_ \"${pkg}\"\n");

	main = ''
		package main

		import (
			caddycmd "github.com/caddyserver/caddy/v2/cmd"

			_ "github.com/caddyserver/caddy/v2/modules/standard"
${imports}
		)

		func main() {
			caddycmd.Main()
		}
	'';


in buildGoModule rec {
	pname = "caddy";
	version = "2.4.6";
  runVend = true;
	subPackages = [ "cmd/caddy" ];

  src = fetchFromGitHub {
    owner = "caddyserver";
    repo = "caddy";
    rev = "v${version}";
    sha256 = "sha256-xNCxzoNpXkj8WF9+kYJfO18ux8/OhxygkGjA49+Q4vY=";
  };

	inherit vendorSha256;

	overrideModAttrs = (_: {
		preBuild    = "echo '${main}' > cmd/caddy/main.go";
		postInstall = "cp go.sum go.mod $out/ && ls $out/";
	});

	postPatch = ''
		echo '${main}' > cmd/caddy/main.go
		cat cmd/caddy/main.go
	'';

	postConfigure = ''
		cp vendor/go.sum ./
		cp vendor/go.mod ./
	'';

	meta = {
		homepage = https://caddyserver.com;
		description = "Fast, cross-platform HTTP/2 web server with automatic HTTPS";
		license = licenses.asl20;
    maintainers = with maintainers; [ Br1ght0ne ];
	};
}
#+end_src

*** overlays.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref overlays.nix
:END:

#+begin_src nix :noweb-ref no :tangle (meq/tangle-path)
<<overlays.nix>>
#+end_src

**** Arguments

#+begin_src nix
lib: nixpkgs: pkgs: channel: with builtins; with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** Otherpkgs

#+begin_src nix
channels = (map (d: "nixos-" + d) (
    "unstable"
    "unstable-small"
    "21.11"
    "21.11-small"
)) + (map (d: "release-" + d) (
    "21.11"
)) + (
    "master"
);
othernixpkgs = listToAttrs (map (ref: nameValuePair
    ref
    (fetchGit { url = "https://github.com/nixos/nixpkgs"; inherit ref; })
) channels);
otherpkgs = mapAttrs (n: v: import v j.attrs.configs.nixpkgs) othernixpkgs;
#+end_src

***** End of Let

#+begin_src nix
in flatten [
#+end_src

**** J

#+begin_src nix
[(final: prev: { j = {
    nixpkgs = othernixpkgs;
    pkgs = otherpkgs;
    inherit channels;
};})]
#+end_src

**** Patched Fetchers

#+begin_src nix :noweb-ref no
[(
    final: prev: {
        fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchurl.patch ];}); }
)]
[(
    final: prev: {
        fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchpypi.patch ];}); }
)]
#+end_src

**** NIX

# TODO

#+begin_src nix :noweb-ref no
[( final: prev: { nix = import (fetchGit { url = "https://github.com/nixos/nix"; }); })]
#+end_src

**** NUR

#+begin_src nix
[( final: prev: { nur = import (fetchGit { url = "https://github.com/nix-community/nur"; }) { nurpkgs = nixpkgs; pkgs = prev; }; })]
#+end_src

**** Emacs

#+begin_src nix
[
    (import (fetchGit { url = "https://github.com/nix-community/emacs-overlay"; }))
]
#+end_src

**** Systemd
***** Homed

# TODO

#+begin_src nix :noweb-ref no
[( final: prev: { systemd = prev.systemd.overrideAttrs (old: { withHomed = true; }); })]
#+end_src

**** Containers
***** Extra-Containers

#+begin_src nix
[
    (final: prev: {
        extra-container = let
            pkgSrc = fetchGit { url = "https://github.com/erikarvstedt/extra-container"; };
        in pkgs.callPackage pkgSrc { inherit pkgSrc; };
    })
]
#+end_src

**** Caddy With Plugins

#+begin_src nix
[
    (final: prev: { caddy = pkgs.callPackage ./callPackages/caddy.nix {
        plugins = [
            "github.com/mholt/caddy-l4@latest"
            "github.com/abiosoft/caddy-yaml@latest"
            "github.com/caddy-dns/cloudflare@latest"
        ];
    }; })
]
#+end_src

**** Mozilla

#+begin_src nix
(let
    mozilla = fetchGit { url = "https://github.com/mozilla/nixpkgs-mozilla"; };
    mozilla-overlays = import "${mozilla}/overlays.nix";
in (map import mozilla-overlays))
#+end_src

**** Overlays in Overlays Directory

#+begin_src nix
(flatten (map (file:
    [(final: prev: {
        "${j.functions.name { inherit file; }}" = import file {
            inherit sources pkgs lib;
        };
    })]
) (j.functions.list { dir = ./overlays; ignores = [ "nix" ]; })))
#+end_src

**** Overrides from Older Channels

#+begin_src nix
(let pkgsets = {
    unstable = [  ];
};
in flatten (mapAttrsToList (
    pkgchannel: pkglist: map (
        pkg: [(final: prev: {
            "${pkg}" = if (pkgchannel == channel) then prev.${pkg} else final.j.pkgs.${pkgchannel}.${pkg};
        })]
    ) pkglist
) pkgsets))
#+end_src

**** Guix

#+begin_src nix
[(final: prev: { guix = final.callPackage "${fetchGit { url = "https://github.com/${j.attrs.users.primary}/nixpkgs"; ref = "guix"; }}/pkgs/development/guix/guix.nix" {  }; })]
#+end_src

**** End of overlays.nix

#+begin_src nix
]
#+end_src

*** super.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref super.nix
:END:

#+begin_src nix :noweb-ref no :tangle (meq/tangle-path)
<<super.nix>>
#+end_src

**** Arguments

#+begin_src nix
{ config, ... }: with builtins;
#+end_src

**** Config Let

#+begin_src nix
let
#+end_src

***** Nixpkgs

#+begin_src nix
ref = "master";
nixpkgs = fetchGit { url = "https://github.com/nixos/nixpkgs"; inherit ref; };
#+end_src

***** Lib

#+begin_src nix
prepkgs = import nixpkgs {  };
lib = prepkgs.lib.extend (final: prev: { j = import ./lib.nix prepkgs final config.networking.hostName; });
#+end_src

***** Overlays

#+begin_src nix
overlays = import ./overlays.nix lib nixpkgs pkgs ref;
#+end_src

***** Pkgs

#+begin_src nix
pkgs = import nixpkgs { inherit overlays; };
#+end_src

***** Config Repo

#+begin_src nix
dir = "${lib.j.attrs.homes.${lib.j.attrs.users.primary}}/.local/share/yadm/repo.git";
dirExists = pathExists dir;
repo = with lib; j.functions.mntConvert (fetchGit {
    url = if dirExists then "file://${dir}" else "https://github.com/${j.attrs.users.primary}/${j.attrs.users.primary}";
});
#+end_src

**** Config

#+begin_src nix
in with lib; {
#+end_src

***** Imports

#+begin_src nix
imports = [
    ./hardware-configuration.nix
    "${fetchGit { url = "https://github.com/nix-community/home-manager"; }}/nixos"
    "${fetchGit { url = "https://github.com/nix-community/impermanence"; }}/nixos.nix"
    "${fetchGit { url = "https://github.com/${j.attrs.users.primary}/nixpkgs"; ref = "guix"; }}/nixos/modules/services/development/guix.nix"
];
#+end_src

***** Boot

#+begin_src nix
boot = {
#+end_src

****** Supported Filesystems

#+begin_src nix
supportedFilesystems = j.attrs.fileSystems.supported;
#+end_src

****** Initrd

#+begin_src nix
initrd = {
    inherit (config.boot) supportedFilesystems;
    compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
    network.ssh.enable = true;
};
#+end_src

****** Extra Modprobe Config

#+begin_src nix
extraModprobeConfig = '' options kvm_intel_nested=1 '';
#+end_src

****** Loader

#+begin_src nix
loader = {
    systemd-boot = {
        configurationLimit = 25;
        editor = mkForce false;
        # enable = mkForce false;
        enable = mkForce true;
    };
    grub = {
        # enable = mkForce true;
        enable = mkForce false;
        efiSupport = true;
        efiInstallAsRemovable = mkForce false;
        # devices = [ "nodev" ];
        device = "nodev";
        version = 2;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';

    };
    efi = {
        canTouchEfiVariables = mkForce true;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    # Also causing EFI stuff not to be installed
    # initScript.enable = mkForce true;

};
#+end_src

****** Kernel

#+begin_src nix
# kernelPackages = mkDefault pkgs.linuxPackages_xanmod;
# kernelPackages = mkDefaultpkgs.linuxPackages_lqx;
# kernelPackages = mkDefaultpkgs.linuxPackages_zen;
#+end_src

******* Patches

#+begin_src nix
kernelPatches = [
#+end_src

******** Clear Linux

# TODO

#+begin_src nix :noweb-ref no
{ name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
#+end_src

******** ZSTD Kernel Compression

# TODO

#+begin_src nix :noweb-ref no
{
    name = "Enable ZSTD Compression";
    patch = null;
    extraConfig = ''
        RD_ZSTD y
        KERNEL_ZSTD y
        KERNEL_XZ n
    '';
}
#+end_src

******** End of Kernel Patches

#+begin_src nix
];
#+end_src

******* Extra Module Packages

#+begin_src nix
extraModulePackages = with config.boot.kernelPackages; [
    # anbox
    # wireguard
    zfsUnstable
];
#+end_src

******* Emulated Systems

#+begin_src nix
binfmt.emulatedSystems = [
    "armv7l-linux"
    "aarch64-linux"
];
#+end_src

******* ZFS

#+begin_src nix
kernelModules = [ "zfs" ];
kernelParams = [ "nohibernate" ];
# loader.grub.zfsSupport = true;
initrd = {
    postDeviceCommands = mkAfter ''
        zfs rollback -r ${config.networking.hostName}/system/root@blank
        zfs rollback -r ${config.networking.hostName}/system/home@blank
        zfs rollback -r ${config.networking.hostName}/system/tmp@blank
    '';
    kernelModules = [ "zfs" ];
    availableKernelModules = [ "zfs" ];
};
zfs = {
    requestEncryptionCredentials = true;
    enableUnstable = true;
    devNodes = "/dev/";
};
#+end_src

****** End of Boot

#+begin_src nix
};
#+end_src

***** Console

#+begin_src nix
console = {
    # Select internationalisation properties.
    # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
    font = "Cartograph CF Extra Bold Italic";
    keyMap = "us";
};
#+end_src

***** Environment

#+begin_src nix
environment = {
#+end_src

****** Etc

#+begin_src nix
etc."nix/nix.conf".text = mkForce j.attrs.configs.nix;
#+end_src

****** Paths to Link

#+begin_src nix
pathsToLink = [ "/share/nix-direnv" ];
#+end_src

****** System Packages

#+begin_src nix
systemPackages = with pkgs; [
    #   vim # Do not forget to add an editor to edit configuration.nix! The Nano editor is also installed by default.
] ++ (map (pkg: pkgs.gnome."gnome-${pkg}") [
    # "boxes"
    # "characters"
    # "tweaks"
    "session"
]) ++ (with pkgs.gnome; [
    # dconf-editor
]);
#+end_src

****** ZFS

#+begin_src nix
persistence = let
    rootDirSet = {
        user = "root";
        group = "root";
    };
    rootFileSet.parentDirectory = rootDirSet;
in {
    # "/root" = {
    #     directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // rootDirSet) else (rootDirSet // directory)) (flatten [
    #         [
    #             "/etc/nix"
    #             "/etc/nixos"
    #             "/etc/zsh"
    #         ]
    #     ]));
    # };
    "/persist" = let
        redRepo = readDir repo;
        redRepoFiles = flatten [
            (attrNames (filterAttrs (n: v: v != "directory") redRepo))
            [ "configuration.nix" "hardware-configuration.nix" "datasets.nix" ]
        ];
        redRepoDirectories = flatten [
            (attrNames (filterAttrs (n: v: v == "directory") redRepo))
        ];
    in {
        hideMounts = true;
        # files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // rootFileSet) else (rootFileSet // file)) (flatten [
        #     [
        #         "/etc/host"
        #         "/etc/machine-id"
        #     ]
        # ]));
        directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // rootDirSet) else (rootDirSet // directory)) (flatten [
            [
                "/bin"
                "/etc/containers"
                "/etc/NetworkManager/system-connections"
                "/etc/ssh"
                "/etc/wireguard"
                "/sbin"
                "/snap"
                "/usr"
                "/var/lib/acme"
                "/var/lib/bluetooth"
                "/var/lib/systemd/coredump"
                "/var/log"
            ]
        ]));
        users = listToAttrs (map (user: let
            userDirSet = {
                inherit user;
                group = user;
            };
            userFileSet.parentDirectory = userDirSet;
        in nameValuePair user {
            home = j.attrs.allHomes.${user};

            # TODO
            # files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // userFileSet) else (userFileSet // file)) (flatten [
            #     [
            #         ".bash-history"
            #         ".emacs-profile"
            #         ".gitignore"
            #         ".globalignore"
            #         ".nix-channels"
            #         ".python-history"
            #         ".viminfo"
            #         ".zsh-history"
            #         ".screenrc"
            #     ]

            #     # TODO
            #     # redRepoFiles

            # ]));

            directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // userDirSet) else (userDirSet // directory)) (flatten [
                [
                    ".atom"
                    ".byobu"
                    ".cache"
                    ".caddy"
                    ".config"
                    ".linuxbrew"
                    ".local"
                    ".mozilla"
                    ".peru"
                    ".pki"
                    ".vim_runtime"
                    ".virtualenvs"
                    ".vscode-oss"
                    ".vscode"
                    ".yubico"
                    ".z"
                    "Documents"
                    "Downloads"
                    "keybase"
                    "Music"
                    "nix-plugins"
                    "Pictures"
                    "Public"
                    "Templates"
                    "tests"
                    "Videos"
                    "VirtualBox VMs"
                    { directory = ".gnupg"; mode = "0700"; }
                    { directory = ".nixops"; mode = "0700"; }
                    { directory = ".ssh"; mode = "0700"; }
                ]
                redRepoDirectories
            ]));}) j.attrs.allUsers);
    };
};
#+end_src

****** End of Environment

#+begin_src nix
};
#+end_src

***** Filesystems

#+begin_src nix
fileSystems = let
    inherit (j.attrs.fileSystems) base;
    fileSystems' = j.attrs.datasets.fileSystems;
in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
    mkForce (base // { device = dataset; ${
        j.functions.myIf.knull ((hasInfix j.attrs.users.primary dataset) || (hasInfix "persist" dataset)) "neededForBoot"
    } = true; })
)) fileSystems';
#+end_src

***** Hardware

#+begin_src nix
hardware = {
    enableRedistributableFirmware = lib.mkDefault true;
    # Enable sound
    pulseaudio.enable = true;
};
sound.enable = true;
#+end_src

***** Home-Manager

#+begin_src nix
home-manager.users = j.functions.foldToSet [
    listToAttrs (user: nameValuePair user {
        home.file.<<20220205031620372930929>> = {
            source = repo;
            recursive = true;
        };
    }) allUsers
];
#+end_src

***** Memory

#+begin_src nix
zramSwap = {
    enable = true;
    algorithm = "zstd";
};
#+end_src

***** Miscellaneous

#+begin_quote
Help is available in the configuration.nix(5) man page and in the NixOS manual (accessible by running 'nixos-help').
#+end_quote

****** Flatpak

#+begin_src nix
xdg.portal.enable = mkForce (!elem currentSystem [ "aarch64-linux" ]);
#+end_src

****** Miscellaneous

#+begin_src nix
i18n = {
    # Select internationalisation properties.
    defaultLocale = "en_US.UTF-8";
};
time.timeZone = "America/Toronto";
system = {
    # This value determines the NixOS release from which the default
    # settings for stateful data, like file locations and database versions
    # on your system were taken. It's perfectly fine and recommended to leave
    # this value at the release version of the first install of this system.
    # Before changing this value read the documentation for this option
    # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
    # stateVersion = "20.09"; # Did you read the comment?
    autoUpgrade = {
        enable = true;
        allowReboot = false;
        flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
    };
};
#+end_src

***** Networking

#+begin_src nix
networking = let
    wofie = "4876d858001ae2b6b27f7517f36045a09836fb877cbafef3b101e5c995af7a71";
in {
    # interfaces = map (interface:
    #     { inherit interface; method = "magicpacket"; }
    # ) (attrNames config.networking.interfaces);
    wireless = {
        # enable = true; # Enables wireless support via wpa_supplicant.
        enable = false; # Enables wireless support via wpa_supplicant.
        networks = {
            "Wofie" = {
                pskRaw = wofie;
                priority = 0;
            };
        };
    };
    networkmanager.enable = mkForce true;

    # The global useDHCP flag is deprecated, therefore explicitly set to false here.
    # Per-interface useDHCP will be mandatory in the future, so this generated config
    # replicates the default behaviour.
    useDHCP = false;

    # Configure network proxy if necessary
    # proxy = {
    # default = "http://user:password@proxy:port/";
    # noProxy = "127.0.0.1,localhost,internal.domain";
    # };

    # Or disable the firewall altogether.
    # enable = false;
    # };

    wireguard.interfaces.wg0 = {
        generatePrivateKeyFile = true;
        privateKeyFile = "/persist/etc/wireguard/wg0";
    };

    # hostId = substring 0 8 (readFile "/etc/machine-id");

    firewall = mkIf (elem config.networking.hostName j.attrs.relays) {
        allowedTCPPorts = [ 22 80 222 443 2022 8080 9418 ];
        allowedUDPPortRanges = [
            {
                from = 60000;
                to = 61000;
            }
        ];
    };
};
#+end_src

***** Nix

#+begin_src nix
nix = rec {
    gc = j.functions.foldToSet [
        { automatic = true; }
        { dates = "monthly"; }
        # {
        #   dates = "monthly";
        #   options = "-d";
        # }
        # {
        #   dates = "daily";
        #   options = "--delete-older-than 30d";
        # }
    ];
    optimise = {
        automatic = true;
        dates = [ "05:00" ];
    };
    autoOptimiseStore = true;
    extraOptions = j.attrs.configs.nix;
    useSandbox = true;
    # sandboxPaths = [];
};
#+end_src

***** Nixpkgs

#+begin_src nix
nixpkgs = { inherit overlays; };
#+end_src

***** Power

#+begin_src nix
services.logind.lidSwitch = "hybrid-sleep";
powerManagement = {
    enable = true;
    cpuFreqGovernor = mkForce "ondemand";
};
#+end_src

***** Programs

#+begin_src nix
programs = {
    xonsh.enable = true;
    fish.enable = true;
    zsh.enable = true;
};
#+end_src

***** Security

This is mostly for Yubikey Authentication:

#+begin_src nix
# For Yubikey SSH-GPG Authentication
environment.shellInit = ''
    export GPG_TTY="$(tty)"
    gpg-connect-agent /bye
    export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
    echo UPDATESTARTUPTTY | gpg-connect-agent
'';
programs = {
    # Some programs need SUID wrappers, can be configured further or are
    # started in user sessions.
    # mtr.enable = true;
    gnupg.agent = {
        enable = true;
        enableSSHSupport = false;
        pinentryFlavor = "curses";
    };

    # For use with Yubikey SSH-GPG Authentication, set to false
    ssh.startAgent = true;
};
security.pam = {
    yubico = {
        enable = true;
        debug = true;
        mode = "challenge-response";
    };
    enableSSHAgentAuth = true;
};
#+end_src

***** Services

#+begin_src nix
services = {
#+end_src

****** Emacs

#+begin_src nix
emacs = {
    package = pkgs.emacs;
    enable = true;
    defaultEditor = true;
};
#+end_src

****** Flatpak

#+begin_src nix
flatpak.enable = !elem currentSystem [ "aarch64-linux" ];
#+end_src

****** Guix

#+begin_src nix
guix.enable = true;
#+end_src

****** Printing

#+begin_src nix
printing.enable = true;
#+end_src

****** SSH

#+begin_src nix
openssh = {
    enable = true;
    extraConfig = mkOrder 0 ''
        TCPKeepAlive yes
        ClientAliveCountMax 480
        ClientAliveInterval 3m
    '';
    permitRootLogin = "yes";
};
#+end_src

****** UDEV

#+begin_src nix
udev.extraRules = ''
    ACTION=="add|change", KERNEL=="sd[a-z]*[0-9]*|mmcblk[0-9]*p[0-9]*|nvme[0-9]*n[0-9]*p[0-9]*", ENV{ID_FS_TYPE}=="zfs_member", ATTR{../queue/scheduler}="none"
''; # zfs already has its own scheduler. without this my(@Artturin) computer froze for a second when i nix build something.
#+end_src

****** XServer

#+begin_src nix
xserver = {
    enable = true;
    layout = "us";
    # xkbOptions = "eurosign:e";
    # Enable touchpad support.
    libinput = {
        enable = true;
        touchpad = {
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
        };
    };
    # synaptics.enable = true;
    desktopManager.gnome.enable = true;
    displayManager = {
        startx.enable = true;
        lightdm.enable = mkForce false;
    };
    autorun = false;
};
#+end_src

****** Yubikey

#+begin_src nix
udev.packages = with pkgs; [
    yubikey-personalization
    libu2f-host
];
pcscd.enable = true;
#+end_src

****** ZFS

#+begin_src nix
zfs = {
    trim.enable = true;
    autoScrub.enable = true;

    # Managed by Sanoid
    autoSnapshot.enable = false;
};
#+end_src

******* Sanoid

#+begin_src nix
sanoid = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${config.networking.hostName}/${dataset}" sanoidBase) (flatten [
        j.attrs.datasets.backup
        [ config.networking.hostName ]
    ]));
};
#+end_src

******* Syncoid

#+begin_src nix
syncoid = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        # (mkIf vars.encrypted {
        #     sendOptions = "vvwRI";
        #     recvOptions = "vvFs";
        # })
        # (mkIf (!vars.encrypted) {
        #     recvOptions = "vvFds";
        #     sendOptions = "vvRI";
        # })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) (flatten [
        j.attrs.datasets.backup
        [ config.networking.hostName ]
    ]));
};
#+end_src

****** End of Services

#+begin_src nix
};
#+end_src

***** Systemd

#+begin_src nix
systemd = {
    # packages = with pkgs; [ runit ];
    services = {
        # runit.enable = true;
        caddy = mkIf (elem config.networking.hostName j.attrs.relays) (j.attrs.configs.services.base // {
            serviceConfig = {
                ExecStart = ''
                    ${pkgs.caddy}/bin/caddy run --config ${j.attrs.homes.${j.attrs.users.primary}}/.config/caddy/files/${config.networking.hostName} --adapter yaml 2>&1
                '';
                ExecStop = ''
                    pkill caddy
                '';
            };
        });
    };
};
#+end_src

***** Users

#+begin_src nix
users = with j.attrs.users; let
    base = {
        hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
        isNormalUser = true;
        createHome = true;
        extraGroups = [
            "wheel"
            "networkmanager"
            "persist"
            "libvirtd"
            "docker"
        ];
        openssh.authorizedKeys.keys = [
            j.attrs.ssh.keys.master
        ];
    };
in rec {
    users = mkMerge [
        (genAttrs j.attrs.allUsers (user: base))
        {
            "${primary}" = {
                uid = 4362;
                home = j.attrs.homes.${primary};
                description = "Jeet Ray";
                group = primary;
                extraGroups = [ secondary ];
                shell = pkgs.zsh;
            };
            "${secondary}" = {
                uid = 1111;
                home = j.attrs.homes.${secondary};
                description = "Alicia Summers";
                group = secondary;
                extraGroups = [ primary ];
                shell = if (!elem currentSystem [ "aarch64-linux" ]) then pkgs.fish else pkgs.zsh;
            };
            "${nightingale}" = {
                uid = 8888;
                home = j.attrs.homes.${nightingale};
                description = "Curtis Nightingale";
                group = "root";
                extraGroups = [ primary secondary ];
                shell = pkgs.zsh;
            };
            root = {
                shell = mkForce pkgs.zsh;
                home = j.attrs.allHomes.root;
                isNormalUser = mkForce false;
                isSystemUser = mkForce true;
            };
        }
    ];

    mutableUsers = false;

    groups = {
        "${primary}" = {
            gid = config.users.users.${primary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${secondary}" = {
            gid = config.users.users.${secondary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${nightingale}" = {
            gid = config.users.users.${nightingale}.uid;
            members = [ nightingale ];
        };
    };
};
#+end_src

***** Virtualisation

#+begin_src nix
virtualisation = {
    xen.enable = false;
    lxd.zfsSupport = true;
    podman.enable = true;
    docker = {
        enable = true;
        storageDriver = "zfs";
        package = pkgs.docker;
        enableOnBoot = true;
    };
    libvirtd.enable = true;
};
#+end_src

***** End of super.nix

#+begin_src nix
}
#+end_src

** nix
*** nix.conf

#+call: hash() :exports none

#+RESULTS:
: 20211023232853007053400

#+name: 20211023232853007053400
#+begin_src conf :tangle (meq/tangle-path)
<<20210601184948158342800>>
min-free = 262144000
max-free = 1073741824
#+end_src

** zsh
*** keephack

#+call: hash() :exports none

#+RESULTS:
: 20210601185403002625400

#+name: 20210601185403002625400
#+begin_src emacs-lisp
(concat
    (let
        ((file "~/resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+begin_src sh :tangle (meq/tangle-path)
<<20210601185403002625400()>>
#+end_src

** sv

I just keeping these here for reference.

*** caddy
**** log
***** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
exec svlogd -tt /etc/sv/caddy/log
#+end_src

**** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
for port in 22 80 222 443 2022 8080 9418 60000:61000/udp; do
    ufw allow $port &> /dev/null
done
chmod +x /etc/sv/caddy/{finish,log/run}
exec /usr/bin/caddy run --config /.config/caddy/files/<<hostname>> --adapter yaml 2>&1
#+end_src

**** finish

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
killall caddy
#+end_src

* resources
** functions

#+begin_src sh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
getSecret() {
    # Adapted From: https://stackoverflow.com/a/3980713/10827766
    set +o history
    stty -echo
    printf "$1: "
    shift
    read secret
    stty echo
    printf "\n"
    echo $secret | $@
    set -o history
}

# Adapted From: https://askubuntu.com/a/15856/1058868
inRoot() { [[ $EUID -eq 0 ]] && $1 || : }
notInRoot() { [[ $EUID -ne 0 ]] && $1 || : }

inAndroid() { [[ $(uname -a) == *Android* ]] && $1 || : }
notInAndroid() { [[ $(uname -a) != *Android* ]] && $1 || : }
inUbuntu() { [[ $(uname -a) == *Ubuntu* ]] && $1 || : }
notInUbuntu() { [[ $(uname -a) != *Ubuntu* ]] && $1 || : }
inNixOS() { [[ $(uname -a) == *NixOS* ]] && $1 || : }
notInNixOS() { [[ $(uname -a) != *NixOS* ]] && $1 || : }
#+end_src

* .gitattributes

The LFS filter are from both
[[https://raw.githubusercontent.com/sindresorhus/binary-extensions/main/binary-extensions.json][here]] and
[[https://rehansaeed.com/gitattributes-best-practices/#final-form][here]]:

#+begin_src gitattributes :tangle (meq/tangle-path)
*.sec filter=git-crypt diff=git-crypt
id_* filter=git-crypt diff=git-crypt
.gnupg/** filter=git-crypt diff=git-crypt

*.3dm filter=lfs diff=lfs merge=lfs -text
*.3ds filter=lfs diff=lfs merge=lfs -text
*.3g2 filter=lfs diff=lfs merge=lfs -text
*.3gp filter=lfs diff=lfs merge=lfs -text
*.7z filter=lfs diff=lfs merge=lfs -text
*.a filter=lfs diff=lfs merge=lfs -text
*.aac filter=lfs diff=lfs merge=lfs -text
*.aax filter=lfs diff=lfs merge=lfs -text
*.adp filter=lfs diff=lfs merge=lfs -text
*.ai filter=lfs diff=lfs merge=lfs -text
*.aif filter=lfs diff=lfs merge=lfs -text
*.aiff filter=lfs diff=lfs merge=lfs -text
*.alz filter=lfs diff=lfs merge=lfs -text
*.ape filter=lfs diff=lfs merge=lfs -text
*.apk filter=lfs diff=lfs merge=lfs -text
*.appimage filter=lfs diff=lfs merge=lfs -text
*.ar filter=lfs diff=lfs merge=lfs -text
*.arj filter=lfs diff=lfs merge=lfs -text
*.asf filter=lfs diff=lfs merge=lfs -text
*.au filter=lfs diff=lfs merge=lfs -text
*.avi filter=lfs diff=lfs merge=lfs -text
*.bak filter=lfs diff=lfs merge=lfs -text
*.baml filter=lfs diff=lfs merge=lfs -text
*.bh filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text
*.bk filter=lfs diff=lfs merge=lfs -text
*.bmp filter=lfs diff=lfs merge=lfs -text
*.br filter=lfs diff=lfs merge=lfs -text
*.btif filter=lfs diff=lfs merge=lfs -text
*.bz2 filter=lfs diff=lfs merge=lfs -text
*.bzip2 filter=lfs diff=lfs merge=lfs -text
*.cab filter=lfs diff=lfs merge=lfs -text
*.caf filter=lfs diff=lfs merge=lfs -text
*.cgm filter=lfs diff=lfs merge=lfs -text
*.class filter=lfs diff=lfs merge=lfs -text
*.cmx filter=lfs diff=lfs merge=lfs -text
*.cpio filter=lfs diff=lfs merge=lfs -text
*.cr2 filter=lfs diff=lfs merge=lfs -text
*.cur filter=lfs diff=lfs merge=lfs -text
*.dat filter=lfs diff=lfs merge=lfs -text
*.dcm filter=lfs diff=lfs merge=lfs -text
*.deb filter=lfs diff=lfs merge=lfs -text
*.dex filter=lfs diff=lfs merge=lfs -text
*.djvu filter=lfs diff=lfs merge=lfs -text
*.dll filter=lfs diff=lfs merge=lfs -text
*.dmg filter=lfs diff=lfs merge=lfs -text
*.dng filter=lfs diff=lfs merge=lfs -text
*.doc filter=lfs diff=lfs merge=lfs -text
*.docm filter=lfs diff=lfs merge=lfs -text
*.docx filter=lfs diff=lfs merge=lfs -text
*.dot filter=lfs diff=lfs merge=lfs -text
*.dotm filter=lfs diff=lfs merge=lfs -text
*.dra filter=lfs diff=lfs merge=lfs -text
*.DS_Store filter=lfs diff=lfs merge=lfs -text
*.dsk filter=lfs diff=lfs merge=lfs -text
*.dts filter=lfs diff=lfs merge=lfs -text
*.dtshd filter=lfs diff=lfs merge=lfs -text
*.dvb filter=lfs diff=lfs merge=lfs -text
*.dwg filter=lfs diff=lfs merge=lfs -text
*.dxf filter=lfs diff=lfs merge=lfs -text
*.ecelp4800 filter=lfs diff=lfs merge=lfs -text
*.ecelp7470 filter=lfs diff=lfs merge=lfs -text
*.ecelp9600 filter=lfs diff=lfs merge=lfs -text
*.egg filter=lfs diff=lfs merge=lfs -text
*.eol filter=lfs diff=lfs merge=lfs -text
*.eot filter=lfs diff=lfs merge=lfs -text
*.epub filter=lfs diff=lfs merge=lfs -text
*.exe filter=lfs diff=lfs merge=lfs -text
*.f4v filter=lfs diff=lfs merge=lfs -text
*.fbs filter=lfs diff=lfs merge=lfs -text
*.fh filter=lfs diff=lfs merge=lfs -text
*.fla filter=lfs diff=lfs merge=lfs -text
*.flac filter=lfs diff=lfs merge=lfs -text
*.flatpak filter=lfs diff=lfs merge=lfs -text
*.fli filter=lfs diff=lfs merge=lfs -text
*.flv filter=lfs diff=lfs merge=lfs -text
*.fpx filter=lfs diff=lfs merge=lfs -text
*.fst filter=lfs diff=lfs merge=lfs -text
*.fvt filter=lfs diff=lfs merge=lfs -text
*.g3 filter=lfs diff=lfs merge=lfs -text
*.gh filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.graffle filter=lfs diff=lfs merge=lfs -text
*.gz filter=lfs diff=lfs merge=lfs -text
*.gzip filter=lfs diff=lfs merge=lfs -text
*.h261 filter=lfs diff=lfs merge=lfs -text
*.h263 filter=lfs diff=lfs merge=lfs -text
*.h264 filter=lfs diff=lfs merge=lfs -text
*.icns filter=lfs diff=lfs merge=lfs -text
*.ico filter=lfs diff=lfs merge=lfs -text
*.ief filter=lfs diff=lfs merge=lfs -text
*.img filter=lfs diff=lfs merge=lfs -text
*.ipa filter=lfs diff=lfs merge=lfs -text
*.iso filter=lfs diff=lfs merge=lfs -text
*.jar filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpgv filter=lfs diff=lfs merge=lfs -text
*.jpm filter=lfs diff=lfs merge=lfs -text
*.jxr filter=lfs diff=lfs merge=lfs -text
*.key filter=lfs diff=lfs merge=lfs -text
*.ktx filter=lfs diff=lfs merge=lfs -text
*.lha filter=lfs diff=lfs merge=lfs -text
*.lib filter=lfs diff=lfs merge=lfs -text
*.lvp filter=lfs diff=lfs merge=lfs -text
*.lz filter=lfs diff=lfs merge=lfs -text
*.lzh filter=lfs diff=lfs merge=lfs -text
*.lzma filter=lfs diff=lfs merge=lfs -text
*.lzo filter=lfs diff=lfs merge=lfs -text
*.m3u filter=lfs diff=lfs merge=lfs -text
*.m4a filter=lfs diff=lfs merge=lfs -text
*.m4v filter=lfs diff=lfs merge=lfs -text
*.mar filter=lfs diff=lfs merge=lfs -text
*.mdi filter=lfs diff=lfs merge=lfs -text
*.mht filter=lfs diff=lfs merge=lfs -text
*.mid filter=lfs diff=lfs merge=lfs -text
*.midi filter=lfs diff=lfs merge=lfs -text
*.mj2 filter=lfs diff=lfs merge=lfs -text
*.mka filter=lfs diff=lfs merge=lfs -text
*.mkv filter=lfs diff=lfs merge=lfs -text
*.mmr filter=lfs diff=lfs merge=lfs -text
*.mng filter=lfs diff=lfs merge=lfs -text
*.mobi filter=lfs diff=lfs merge=lfs -text
*.mov filter=lfs diff=lfs merge=lfs -text
*.movie filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.mp4a filter=lfs diff=lfs merge=lfs -text
*.mpeg filter=lfs diff=lfs merge=lfs -text
*.mpg filter=lfs diff=lfs merge=lfs -text
*.mpga filter=lfs diff=lfs merge=lfs -text
*.mxu filter=lfs diff=lfs merge=lfs -text
*.nef filter=lfs diff=lfs merge=lfs -text
*.npx filter=lfs diff=lfs merge=lfs -text
*.numbers filter=lfs diff=lfs merge=lfs -text
*.nupkg filter=lfs diff=lfs merge=lfs -text
*.o filter=lfs diff=lfs merge=lfs -text
*.odp filter=lfs diff=lfs merge=lfs -text
*.ods filter=lfs diff=lfs merge=lfs -text
*.odt filter=lfs diff=lfs merge=lfs -text
*.oga filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text
*.ogv filter=lfs diff=lfs merge=lfs -text
*.otf filter=lfs diff=lfs merge=lfs -text
*.ott filter=lfs diff=lfs merge=lfs -text
*.pages filter=lfs diff=lfs merge=lfs -text
*.pbm filter=lfs diff=lfs merge=lfs -text
*.pcx filter=lfs diff=lfs merge=lfs -text
*.pdb filter=lfs diff=lfs merge=lfs -text
*.pdf filter=lfs diff=lfs merge=lfs -text
*.pea filter=lfs diff=lfs merge=lfs -text
*.pgm filter=lfs diff=lfs merge=lfs -text
*.pic filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.pnm filter=lfs diff=lfs merge=lfs -text
*.pot filter=lfs diff=lfs merge=lfs -text
*.potm filter=lfs diff=lfs merge=lfs -text
*.potx filter=lfs diff=lfs merge=lfs -text
*.ppa filter=lfs diff=lfs merge=lfs -text
*.ppam filter=lfs diff=lfs merge=lfs -text
*.ppm filter=lfs diff=lfs merge=lfs -text
*.pps filter=lfs diff=lfs merge=lfs -text
*.ppsm filter=lfs diff=lfs merge=lfs -text
*.ppsx filter=lfs diff=lfs merge=lfs -text
*.ppt filter=lfs diff=lfs merge=lfs -text
*.pptm filter=lfs diff=lfs merge=lfs -text
*.pptx filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text
*.pya filter=lfs diff=lfs merge=lfs -text
*.pyc filter=lfs diff=lfs merge=lfs -text
*.pyo filter=lfs diff=lfs merge=lfs -text
*.pyv filter=lfs diff=lfs merge=lfs -text
*.qt filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.ras filter=lfs diff=lfs merge=lfs -text
*.raw filter=lfs diff=lfs merge=lfs -text
*.resources filter=lfs diff=lfs merge=lfs -text
*.rgb filter=lfs diff=lfs merge=lfs -text
*.rip filter=lfs diff=lfs merge=lfs -text
*.rlc filter=lfs diff=lfs merge=lfs -text
*.rmf filter=lfs diff=lfs merge=lfs -text
*.rmvb filter=lfs diff=lfs merge=lfs -text
*.rpm filter=lfs diff=lfs merge=lfs -text
*.rtf filter=lfs diff=lfs merge=lfs -text
*.rz filter=lfs diff=lfs merge=lfs -text
*.s3m filter=lfs diff=lfs merge=lfs -text
*.s7z filter=lfs diff=lfs merge=lfs -text
*.scpt filter=lfs diff=lfs merge=lfs -text
*.sgi filter=lfs diff=lfs merge=lfs -text
*.shar filter=lfs diff=lfs merge=lfs -text
*.snap filter=lfs diff=lfs merge=lfs -text
*.sil filter=lfs diff=lfs merge=lfs -text
*.sketch filter=lfs diff=lfs merge=lfs -text
*.slk filter=lfs diff=lfs merge=lfs -text
*.smv filter=lfs diff=lfs merge=lfs -text
*.snk filter=lfs diff=lfs merge=lfs -text
*.so filter=lfs diff=lfs merge=lfs -text
*.stl filter=lfs diff=lfs merge=lfs -text
*.suo filter=lfs diff=lfs merge=lfs -text
*.sub filter=lfs diff=lfs merge=lfs -text
*.swf filter=lfs diff=lfs merge=lfs -text
*.tar filter=lfs diff=lfs merge=lfs -text
*.tbz filter=lfs diff=lfs merge=lfs -text
*.tbz2 filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tgz filter=lfs diff=lfs merge=lfs -text
*.thmx filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.tlz filter=lfs diff=lfs merge=lfs -text
*.ttc filter=lfs diff=lfs merge=lfs -text
*.ttf filter=lfs diff=lfs merge=lfs -text
*.txz filter=lfs diff=lfs merge=lfs -text
*.udf filter=lfs diff=lfs merge=lfs -text
*.uvh filter=lfs diff=lfs merge=lfs -text
*.uvi filter=lfs diff=lfs merge=lfs -text
*.uvm filter=lfs diff=lfs merge=lfs -text
*.uvp filter=lfs diff=lfs merge=lfs -text
*.uvs filter=lfs diff=lfs merge=lfs -text
*.uvu filter=lfs diff=lfs merge=lfs -text
*.viv filter=lfs diff=lfs merge=lfs -text
*.vob filter=lfs diff=lfs merge=lfs -text
*.war filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.wax filter=lfs diff=lfs merge=lfs -text
*.wbmp filter=lfs diff=lfs merge=lfs -text
*.wdp filter=lfs diff=lfs merge=lfs -text
*.weba filter=lfs diff=lfs merge=lfs -text
*.webm filter=lfs diff=lfs merge=lfs -text
*.webp filter=lfs diff=lfs merge=lfs -text
*.whl filter=lfs diff=lfs merge=lfs -text
*.wim filter=lfs diff=lfs merge=lfs -text
*.wm filter=lfs diff=lfs merge=lfs -text
*.wma filter=lfs diff=lfs merge=lfs -text
*.wmv filter=lfs diff=lfs merge=lfs -text
*.wmx filter=lfs diff=lfs merge=lfs -text
*.woff filter=lfs diff=lfs merge=lfs -text
*.woff2 filter=lfs diff=lfs merge=lfs -text
*.wrm filter=lfs diff=lfs merge=lfs -text
*.wvx filter=lfs diff=lfs merge=lfs -text
*.xbm filter=lfs diff=lfs merge=lfs -text
*.xif filter=lfs diff=lfs merge=lfs -text
*.xla filter=lfs diff=lfs merge=lfs -text
*.xlam filter=lfs diff=lfs merge=lfs -text
*.xls filter=lfs diff=lfs merge=lfs -text
*.xlsb filter=lfs diff=lfs merge=lfs -text
*.xlsm filter=lfs diff=lfs merge=lfs -text
*.xlsx filter=lfs diff=lfs merge=lfs -text
*.xlt filter=lfs diff=lfs merge=lfs -text
*.xltm filter=lfs diff=lfs merge=lfs -text
*.xltx filter=lfs diff=lfs merge=lfs -text
*.xm filter=lfs diff=lfs merge=lfs -text
*.xmind filter=lfs diff=lfs merge=lfs -text
*.xpi filter=lfs diff=lfs merge=lfs -text
*.xpm filter=lfs diff=lfs merge=lfs -text
*.xwd filter=lfs diff=lfs merge=lfs -text
*.xz filter=lfs diff=lfs merge=lfs -text
*.z filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.zipx filter=lfs diff=lfs merge=lfs -text
#+end_src

* .xonsh.d
** fzfdf.sh

#+begin_src zsh :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
if [ -z "$1" ]; then echo $(fd | fzf-tmux) || echo $(fd . "$1" | fzf-tmux); fi
#+end_src

* .xonshrc
:PROPERTIES:
:header-args:xonsh+: :noweb-ref .xonshrc
:END:

#+begin_src xonsh :noweb-ref no :tangle (meq/tangle-path)
<<.xonshrc>>
#+end_src

** imports

#+begin_src xonsh
from sys import path as sys_path
from datetime import datetime
from nanite import fullpath as fp
from os import path as os_path, sep as os_sep, getcwd
from inspect import getsourcefile
#+end_src

** setup

#+begin_src xonsh
# Note that type hints cannot be used

tmux attach 2> /dev/null
# pfetch

python_ver = "3.9"
home = fp("~")
xeroFigletFonts = fp("~/resources/xeroFigletFonts")

# figlet -d @(xeroFigletFonts) -f smisome1.flf "Hello!" | lolcat
#+end_src

** environment

#+begin_src xonsh
$AUTO_CD = True
$AUTO_PUSHD = True
$AUTO_SUGGEST = True
$AUTO_SUGGEST_IN_COMPLETIONS = True
$BASH_COMPLETIONS += [ fp("~/resources/bashCompletions") ]
$COMPLETION_IN_THREAD = True
$COMPLETIONS_CONFIRM = True
$DOTGLOB = True
$FUZZY_PATH_COMPLETION = True
$MOUSE_SUPPORT = True
$PRETTY_PRINT_RESULTS = True
$PROMPT_TOOLKIT_COLOR_DEPTH = "DEPTH_24_BIT"
$SHELL_TYPE = "prompt_toolkit"
$UPDATE_COMPLETIONS_ON_KEYPRESS = True
$UPDATE_OS_ENVIRON = True
$VI_MODE = True
$XONSH_AUTOPAIR = True
$XONSH_CACHE_EVERYTHING = True

# This enumerates all history files when set to true
$XONSH_DEBUG = False

$XONSH_SHOW_TRACEBACK = True

# Xonsh Prompt
$PROMPT_FIELDS["prompt_end"] = "Wheee! 😹 "
# $PROMPT = "{BOLD_#E5004D}{env_name} {BOLD_#FF4081}{prompt_end}"
# $PROMPT = lambda: $(starship prompt)
execx($(starship init xonsh))
$RIGHT_PROMPT = "{BOLD_#E5004D} {prompt_end}{BOLD_#FC9F71} || {BOLD_#E5004D} {user}@{hostname} "
# $BOTTOM_TOOLBAR = $RIGHT_PROMPT

# Path
sys_path.insert(0, "")
<<profile-paths(shell="xonsh")>>

# Shell
# $EDITOR = "emacsclient --socket-name=spacemacsd -t"
$EDITOR = "vim"
$TERM = "xterm-kitty"
$GPG_TTY=$(tty)

# Etc
# $DIRENV_WARN_TIMEOUT = "100y"
$LESSOPEN = "| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
$LESS = " -R "

# Linuxbrew
# $LINUXBREWHOME = "/home/linuxbrew/.linuxbrew"
# $PATH.append("$LINUXBREWHOME/bin")
# $MANPATH = ["$LINUXBREWHOME/man"]
# $PKG_CONFIG_PATH = ["$LINUXBREWHOME/lib64/pkgconfig", "$LINUXBREWHOME/lib/pkgconfig"]
# $LD_LIBRARY_PATH = ["$LINUXBREWHOME/lib64", "$LINUXBREWHOME/lib"]
#+end_src

** functions

#+begin_src xonsh
def _mdg(args, stdin=None):
    mkdir -p @(args)
    cd @(args[0])

def hgsetup(args, stdin=None):
    hg bookmark master
    hg checkout master
    hg add .hgignore
    hg ci -m .hgignore
    hg ci -Am @(args)
    hg push

def _alacritty_change_themes(args, stdin=None):
    _alc = "alacritty"
    _alc_theme = fullpath(
        config_dir,
        _alc,
        "themes",
        args[0]+".yaml"
    )
    _alc_config = fullpath(
        "~",
        ".config",
        _alc,
        _alc+".yml"
    )
    rsync @(_alc_theme) @(_alc_config)

def _compile(args, stdin=None):
    clear
    name = args.pop(0)
    g++ @(name + ".cpp")
    ./a.out @(name) @(args)

def _compile_only(args, stdin=None):
    g++ @(args[0] + ".cpp")

def _compile_header(args, stdin=None):
    g++ @(args[0] + ".h")

def _compile_link(args, stdin=None):
    for arg in args:
        g++ @(arg + ".cpp") -c
    args = [arg + ".o" for arg in args]
    g++ @(args) -o a.out

def _direnv_allow(args, stdin=None):
    if args:
        for argument in args:
            direnv allow @(argument)
    else:
        direnv allow

def _la(args, stdin=None):
    if "-t" in args:
        args = list(args)
        args.remove("-t")
        exa -laT @(args)
    else:
        exa -la @(args)

def _cdi(args, stdin=None):
    output = $(zsh @(fzfdf) @(args))
    cd @(output.strip("\n"))
#+end_src

** xontribs

#+begin_src xonsh
# xontrib load autojump
# xontrib load coreutils
# xontrib load docker_tabcomplete
# xontrib load schedule
# xontrib load ssh_agent
# xontrib load vox_tabcomplete

xontrib load abbrevs
xontrib load autoxsh
xontrib load bashisms
xontrib load direnv
xontrib load fzf-widgets
xontrib load kitty
xontrib load pipeliner
xontrib load readable-traceback
xontrib load sh
xontrib load vox
xontrib load whole_word_jumping
xontrib load xlsd
xontrib load zoxide

# Jedi was what was causing the python function completions
# instead of the path completions
# xontrib load jedi
#+end_src

** base

#+begin_src xonsh
# byobu attach -t <<username>> &> /dev/null

if getcwd() == "/":
    cd ~

xtras = fp(home, ".xonsh.d")
fzfdf = fp(xtras, "fzfdf.sh")

# source @(fp(xtras, "passwords.xsh"))
source-zsh $(fasd --init auto)
source-zsh $HOME/.asdf/asdf.sh

# vox create base -p $(which @(f"python{python_ver}")) 2> /dev/null
# vox enter base 2> /dev/null

# aliases["act"] = _alacritty_change_themes
aliases["evim"] = lambda args, stdin=None: $($(which -s emacsclient) --socket-name=damascus -t @(args))
# aliases["hgsetup"] = hgsetup
aliases["-"] = "pushd"
aliases[".."] = "cd .."
aliases["."] = "la ."
aliases["ba"] = "byobu attach"
aliases["bd"] = "byobu detach"
aliases["bda"] = "byobu detach-client -a"
aliases["c"] = "clear"
aliases["compile-header"] = _compile_header
aliases["compile-link"] = _compile_link
aliases["compile-only"] = _compile_only
aliases["compile"] = _compile
aliases["da"] = _direnv_allow
aliases["emd"] = "emacs --bg-daemon=damascus"
aliases["kemd"] = "emacsclient --socket-name=damascus -e '(kill-emacs)'"
aliases["la"] = _la
aliases["md"] = lambda args, stdin=None: $(mkdir -p @(args))
aliases["mdg"] = _mdg
aliases["mosh"] = lambda args, stdin=None: $($(which -s mosh) --experimental-remote-ip=remote @(args))
aliases["n"] = "exit"
aliases["remd"] = "emacsclient --socket-name=damascus -e '(kill-emacs)' && emacs --bg-daemon=damascus"
aliases["ssh"] = lambda args, stdin=None: $($(which -s assh) wrapper ssh @(args))
aliases["ve"] = lambda args, stdin=None: $(vox enter @(args)) if args else $(vox exit)
aliases["git"] = lambda args, stdin=None: $($(which -s hub) @(args))
aliases["xpip"] = lambda args, stdin=None: $(pipx inject --force --include-deps xonsh @(args))
aliases["s"] = "source ~/.xonshrc"
aliases["cdi"] = _cdi

# fasd aliases
aliases["o"] = lambda args, stdin=None: $(fasd -ae xdg-open @(args)) # quick opening files with xdg-open

# quick opening files with vim
aliases["v"] = lambda args, stdin=None: $($(which -s fasd) -fe $(which -s vim) @(args))

# quick opening files with emacs
aliases["e"] = lambda args, stdin=None: $($(which -s fasd) -fe '$(which -s emacsclient) --socket-name=damascus -t' @(args))

_fzf_df_alias = "..."
def _fzf(args, stdin=True):
    args = list(args)
    dir_file = $(zsh @(fzfdf) @(fp(args.pop(0)))).rstrip()
    if args[0] == _fzf_df_alias:
        _fzf([dir_file] + args[1::])
    else:
        @(args) @(dir_file)
aliases[_fzf_df_alias] = _fzf
#+end_src

* .config
** nix
*** nix.conf

#+begin_src conf :tangle (meq/tangle-path)
<<20211023232853007053400>>
#+end_src

** borgmatic

#+name: borgmatic-ls
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "    one_file_system: false
    numeric_owner: false
    atime: true
    ctime: true
    birthtime: true
    read_special: true
    bsd_flags: true
    files_cache: ctime,size,inode
    local_path: borg
    remote_path: borg1
    exclude_caches: true
    exclude_nodump: true

storage:
    checkpoint_interval: 300
    compression: zstd,22
    ssh_command: assh wrapper ssh --
    archive_name_format: \"borgmatic-%r-{now:%%Y%%m%%dT%%H%%M%%S%%f}\"
    relocated_repo_access_is_ok: true
    unknown_unencrypted_repo_access_is_ok: true" `((?r . ,repo)))
#+end_src

#+name: borgmatic-rc
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "retention:
    keep_within: 6H
    keep_secondly: 60
    keep_minutely: 60
    keep_hourly: 24
    keep_daily: 7
    keep_weekly: 4
    keep_monthly: 6
    keep_yearly: 4
    prefix: \"borgmatic-%r-\"

consistency:
    checks:
        - repository
        - data
        - extract
    prefix: \"borgmatic-%r-\"" `((?r . ,repo)))
#+end_src

*** sylvorg.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref sylvorg.yaml
:END:

#+begin_src yaml :noweb-ref no :tangle (meq/tangle-path)
<<sylvorg.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/sylvorg
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-sylvorg
<<borgmatic-ls(repo="sylvorg")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="sylvorg")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

*** oreo.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref oreo.yaml
:END:

#+begin_src yaml :noweb-ref no :tangle (meq/tangle-path)
<<oreo.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/oreo
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-oreo
<<borgmatic-ls(repo="oreo")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="oreo")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

** systemd
*** user
**** emacs.service
:PROPERTIES:
:header-args:systemd+: :noweb-ref emacs.service
:END:

#+begin_src systemd :noweb-ref no :tangle (meq/tangle-path)
<<emacs.service>>
#+end_src

#+begin_src
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --bg-daemon=damascus --update
ExecStop=/usr/bin/emacsclient -s damascus -e "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure
TimeoutSec=900

[Install]
WantedBy=default.target
#+end_src

** yadm
*** bootstrap
:PROPERTIES:
:header-args:zsh+: :noweb-ref nwr20220129201347246148721
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<nwr20220129201347246148721>>
#+end_src

#+begin_src zsh
set -eo pipefail

# Adapted From: https://askubuntu.com/a/15856/1058868
if [[ $EUID -ne 0 ]]; then
    root="~"
    ylv="$root/ylv/ylv"
else
    root=""
    ylv="$root/ylv/ylv su"
fi

chmod +x $ylv

source $root/resources/functions

inAndroid {
    termux-setup-storage
    pkg install emacs make fd cmake sqlite libtool man
}

GIT_SSL_NO_VERIFY=1 $ylv submodule update --init --depth 1 --recursive --remote --force
git clone --recurse-submodule git@github.com:<<username>>/<<username>>.git $root/<<20220205031620372930929>>
$ylv remote set-url --push origin git@github.com:<<username>>/<<username>>.git
$ylv config include.path "$root/.gitconfig"

inRoot git chRun /installers/guix/etc/guix-install.sh

# Adapted From: https://askubuntu.com/a/15856/1058868
if [[ $(uname -a) != *Android* ]] && [[ $EUID -ne 0 ]]; then
    hash nix 2>/dev/null && {
#+end_src

This was adapted from [[https://askubuntu.com/a/1336274][this answer]] by [[https://askubuntu.com/users/682525/rainabba][rainabba]], as well as [[https://askubuntu.com/questions/889344/command-to-perform-a-recursive-chmod-to-make-all-sh-files-within-a-directory-ex#comment2280854_1336274][this comment]] by [[https://askubuntu.com/users/158442/muru][muru]]; however, I don't use it any more:

#+begin_src zsh :noweb-ref no
shopt -s globstar && chmod -R +x ~/installers/**/*.sh ~/installers/**/*.in
#+end_src

#+begin_src zsh
        git chRun ~/installers/brew/install.sh
        git chRun ~/installers/nix/scripts/install.in --daemon
        . ~/.nix-profile/etc/profile.d/nix.sh
    } || :
    nix-channel --add https://github.com/nixos/nixpkgs/archive/master.tar.gz master
    nix-channel --update
    nix-env -iA master.nixUnstable
    nix-env -iA master.{emacs,gnumake,fd,cmake,sqlite,libtool,man}
fi

git tangle $root/{oreo.aiern,README}.org

notInRoot { make -f ~/.emacs.d/makefile ylv-init && git bootstrap }

# ln -s $(which xonsh) $PREFIX/usr/bin/xonsh
chsh -s $(which zsh)

. $root/.asdf/asdf.sh
asdf plugin add golang https://github.com/kennyp/asdf-golang.git
asdf install golang latest
asdf global golang latest

asdf plugin add nodejs https://github.com/asdf-vm/asdf-nodejs.git
asdf install nodejs latest
asdf global nodejs latest

go install github.com/CGamesPlay/git-remote-restic@latest
git config --global --add protocol.restic.allow always

go install github.com/charmbracelet/soft-serve/cmd/soft@latest

if [[ $(uname -a) == *Android* ]]; then
    termux-reload-settings
else
    inRoot {
        go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest
        xcaddy build --with github.com/mholt/caddy-l4@latest \
                     --with github.com/abiosoft/caddy-yaml@latest \
                     --with github.com/caddy-dns/cloudflare@latest
        mv {.,/usr/bin}/caddy

        npm install -g wstunnel

        inUbuntu chRun /resources/rolling-rhino/rolling-rhino

        git chRun /etc/sv/stow-runit/run --bootstrap

        for prog in ufw runit et ddclient; do
            sudo systemctl enable --now $prog
        done
    }
fi
#+end_src

** direnv
*** .direnvrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .direnvrc
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src zsh
use_flake() {
    watch_file flake.nix
    watch_file flake.lock
    eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
}
#+end_src

** kitty
*** kitty.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref kitty.conf
:END:

#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<kitty.conf>>
#+end_src

#+begin_src conf
include ~/resources/kittyThemes/themes/Monokai_Pro_(Filter_Ristretto).conf
#+end_src

** ion
*** initrc
:PROPERTIES:
:header-args:ion+: :noweb-ref initrc
:END:

#+begin_src ion :noweb-ref no :tangle (meq/tangle-path)
<<initrc>>
#+end_src

#+begin_src ion
eval $(starship init ion)
#+end_src

** git
*** config
:PROPERTIES:
:header-args:conf+: :noweb-ref config
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211018183420833239200

#+name: 20211018183420833239200
#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<config>>
#+end_src

#+begin_src conf
[core]
    excludesfile = ~/.globalignore
    attributesfile = ~/.gitattributes
    fileMode = false
    hookPath = ~/.config/git/hooks

[user]
    email = aiern@protonmail.com
    name = <<username>>

[alias]
    cnm = commit --allow-empty-message -am ""
    chRun = !chmod +x $1 &&
    curlRun = !curl --create-dirs -fsSLo $2 $1 && shift && git chRun
    sudoRun = !sudo chRun
    sudoCurl = !sudo curlRun
    subinit = chRun ~/.config/git/scripts/subinit
    noggin = !git push origin HEAD:$(git remote show origin | grep "HEAD branch" | sed 's/.*: //')
    make = !make -f ~/makefile
    emake = !make -f home/.emacs.d/makefile $@ || make -f ~/.emacs.d/makefile
    stow = make stow
    mangle = make tangle
    tangle = chRun ~/.config/git/scripts/tangle
    super = chRun ~/.config/git/scripts/super
    wtt = chRun ~/.config/git/scripts/wtt
    sunc = chRun ~/.config/git/scripts/sunc
    senc = chRun ~/.config/git/scripts/senc
    keybase = chRun ~/run_keybase
    sylveon = !git -C ~/sylveon subinit
    bootstrap = emake bootstrap
    su = !sudo yadm -C / $@ || sudo yadm -w /
    se = chRun ~/.config/git/scripts/se
    clone-init = !mv .git/hooks/post-update.sample .git/hooks/post-update && chmod a+x .git/hooks/post-update && git update-server-info
    exa = !exa -la --octal-permissions -I .git
    exat = exa -T
    brew = chRun ~/.config/git/scripts/brew
    nix = chRun ~/.config/git/scripts/nix
    guix = chRun ~/.config/git/scripts/guix
    asdf = chRun ~/.config/git/scripts/asdf
    pacapt = chRun ~/.config/git/scripts/pacapt
    boom = chRun ~/.config/git/scripts/boom

[protocol "keybase"]
	allow = always

[protocol "restic"]
	allow = always
#+end_src

*** hooks
**** pre-commit
:PROPERTIES:
:header-args:zsh+: :noweb-ref pre-commit
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<pre-commit>>
#+end_src

#+begin_src zsh
make -f ~/makefile tangle
#+end_src

**** pre-pull
:PROPERTIES:
:header-args:zsh+: :noweb-ref pre-pull
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<pre-pull>>
#+end_src

#+begin_src zsh
make -f ~/makefile subinit
#+end_src

**** post-pull
:PROPERTIES:
:header-args:zsh+: :noweb-ref post-pull
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<post-pull>>
#+end_src

#+begin_src zsh
make -f ~/makefile tangle
#+end_src

*** scripts
**** tangle
:PROPERTIES:
:header-args:zsh+: :noweb-ref tangle
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<tangle>>
#+end_src

#+begin_src zsh
run="yes yes | git chRun"
$run settings/org-tangle.sh $@ || \
$run home/.emacs.d/settings/org-tangle.sh $@ || \
$run ~/settings/org-tangle.sh $@ || \
$run ~/.emacs.d/settings/org-tangle.sh $@ || \
$run /settings/org-tangle.sh $@
#+end_src

**** super
:PROPERTIES:
:header-args:zsh+: :noweb-ref super
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<super>>
#+end_src

#+begin_src zsh
if [[ -n "$1" ]]; then
    if [[ -n "$2" ]]; then
        ($1 cnm && $1 $2) || $1 $2
    else
        ($1 cnm && $1 push) || $1 push
    fi
else
    (git cnm && git push) || git push || (git cnm && git noggin) || git noggin || (yadm cnm && yadm push) || yadm push
fi
#+end_src

**** subinit
:PROPERTIES:
:header-args:xonsh+: :noweb-ref subinit
:END:

#+begin_src xonsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env xonsh"
<<subinit>>
#+end_src

#+begin_src xonsh
import os, sys
from addict import Dict
currentDir = os.getcwd()
for line in $(yadm --help).split("\n"):
    if "yadm's Git repository" in line:
        yadmRepoDir = os.path.expandvars(line.split()[0].strip())

# Adapted From:
# Answer: https://stackoverflow.com/a/957978/10827766
# User: https://stackoverflow.com/users/10738/baudtack
yadmRootDir = $(git -C @(yadmRepoDir) rev-parse --show-toplevel).strip()

if len(sys.argv) > 1:
    command = sys.argv[1]
    repoDir = yadmRepoDir if command == "yadm" else currentDir
else:
    if yadmRootDir == currentDir:
        repoDir = yadmRepoDir
        command = "yadm"
    else:
        repoDir = currentDir
        command = f"git -C {repoDir}".split()

# Adapted From:
# Answer: https://stackoverflow.com/a/12142066/10827766
# User: https://stackoverflow.com/users/1426193/jistanidiot
currentBranch = $(@(command) rev-parse --abbrev-ref HEAD).strip()
mainBranch = "main" if currentBranch == "HEAD" else currentBranch
masterBranch = "master" if currentBranch == "HEAD" else currentBranch
git pull origin @(mainBranch) || git pull origin @(masterBranch)

_submodules = [line.strip() for line in $(cat .gitmodules).split("\n") if line]
submodule = None
submodules = Dict()
for line in _submodules:
    if '[submodule "' in line:
        submodule = line.split('"')[1]
        submodules[submodule] = Dict()
    elif not submodule:
        pass
    else:
        splitLine = line.split(" = ")
        submodules[submodule][splitLine[0]] = splitLine[1]

for submodule, subdict in submodules.items():
    subpath = os.path.join(currentDir, subdict.path)
    
    # Adapted From:
    # Answer: https://stackoverflow.com/a/66481406/10827766
    # User: https://stackoverflow.com/users/1434495/flair
    if (os.path.exists(subpath) and (not any(os.scandir(subpath)))) or (not os.path.exists(subpath)):

        rm -rf @(subpath)
        @(command) submodule add --force --depth 1 @(subdict.url) @(subdict.path)
#+end_src

**** wtt
:PROPERTIES:
:header-args:zsh+: :noweb-ref wtt
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<wtt>>
#+end_src

#+begin_src zsh
[[ -n "$1" ]] && ext=".$1.sh" || ext=".sh"
git chRun ~/.emacs.d/wtt/wtt$ext
#+end_src

**** sunc
:PROPERTIES:
:header-args:zsh+: :noweb-ref sunc
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<sunc>>
#+end_src

#+begin_src zsh
yadm su remote add user $HOME/<<yadm-dir>>/repo.git
yadm su sync user main
yadm remote add root /root/<<yadm-dir>>/repo.git
yadm sync root main
#+end_src

**** senc
:PROPERTIES:
:header-args:zsh+: :noweb-ref senc
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<senc>>
#+end_src

#+begin_src zsh
yadm su se remote add user $HOME/<<yadm-dir>>-sec/repo.git
yadm su se sync user main
yadm se remote add root /root/<<yadm-dir>>-sec/repo.git
yadm se sync root main
#+end_src

**** se
:PROPERTIES:
:header-args:zsh+: :noweb-ref se
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<se>>
#+end_src

#+begin_src zsh
# Adapted From: https://askubuntu.com/a/15856/1058868
if [[ $EUID -ne 0 ]]; then
    root="~"
    ylv="$root/ylv/ylv"
else
    root="/root"
    ylv="/ylv/ylv su"
fi

$ylv -Y $root/.config/yadm-sec --yadm-dir $root/<<yadm-dir>>-sec
#+end_src

**** brew
:PROPERTIES:
:header-args:zsh+: :noweb-ref brew
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<brew>>
#+end_src

#+begin_src zsh
/home/linuxbrew/.linuxbrew/bin/brew $@ || \
/home/linuxbrew/.linuxbrew/bin/$@ || \
/home/linuxbrew/.linuxbrew/sbin/$@
#+end_src

**** nix
:PROPERTIES:
:header-args:zsh+: :noweb-ref nix
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<nix>>
#+end_src

#+begin_src zsh
/nix/var/nix/profiles/default/bin/nix-env $@ || /nix/var/nix/profiles/default/bin/$@
#+end_src

**** guix
:PROPERTIES:
:header-args:zsh+: :noweb-ref guix
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<guix>>
#+end_src

#+begin_src zsh
/usr/local/bin/guix $@ || /home/linuxbrew/.guix-profile/bin/$@
#+end_src

**** asdf
:PROPERTIES:
:header-args:zsh+: :noweb-ref asdf
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<asdf>>
#+end_src

#+begin_src zsh
/home/linuxbrew/.linuxbrew/opt/asdf/bin/asdf $@ || \
/home/linuxbrew/.linuxbrew/opt/asdf/bin/$@
#+end_src

**** pacapt
:PROPERTIES:
:header-args:zsh+: :noweb-ref pacapt
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<pacapt>>
#+end_src

#+begin_src zsh
git sudoRun /resources/pacapt/pacapt $@
#+end_src

**** boom
:PROPERTIES:
:header-args:zsh+: :noweb-ref boom
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<boom>>
#+end_src

#+begin_src zsh
for pm in brew asdf nix guix pacapt; do git $pm $@ && break; done
#+end_src

** powershell
*** Microsoft.PowerShell_profile.ps1
:PROPERTIES:
:header-args:powershell+: :noweb-ref Microsoft.PowerShell_profile.ps1
:END:

#+begin_src powershell :noweb-ref no :tangle (meq/tangle-path)
<<Microsoft.PowerShell_profile.ps1>>
#+end_src

#+begin_src powershell
Invoke-Expression (&starship init powershell)
#+end_src

** fish
*** config.fish
:PROPERTIES:
:header-args:fish+: :noweb-ref config.fish
:END:

#+begin_src fish :noweb-ref no :tangle (meq/tangle-path)
<<config.fish>>
#+end_src

#+begin_src fish
source ~/resources/nix-env.fish/conf.d/nix-env.fish
source ~/.asdf/asdf.fish
cd ~/resources/bass
make install &>/dev/null
cd -
<<20211028011434584909200>>
<<profile-paths(shell="fish")>>
alias s=source ~/.config/fish/config.fish
direnv hook fish | source
starship init fish | source
#+end_src

** qtile
*** config.py
:PROPERTIES:
:header-args:python+: :noweb-ref config.py
:END:

#+begin_src python :noweb-ref no :tangle (meq/tangle-path)
<<config.py>>
#+end_src

This config is taken from [[http://gegenokitaro.github.io/tuts/2015/05/14/qtile-ricchan/][here]]:

#+begin_src python
# Copyright (c) 2010 Aldo Cortesi
# Copyright (c) 2010, 2014 dequis
# Copyright (c) 2012 Randall Ma
# Copyright (c) 2012-2014 Tycho Andersen
# Copyright (c) 2012 Craig Barnes
# Copyright (c) 2013 horsik
# Copyright (c) 2013 Tao Sauvage
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libqtile.config import Key, Screen, Group, Drag, Click, Match
from libqtile.command import lazy
from libqtile import layout, bar, widget
from libqtile.dgroups import simple_key_binder

mod = "mod4"

keys = [
    # Switch between windows in current stack pane
    Key(
        [mod], "j",
        lazy.layout.down()
    ),
    Key(
        [mod], "k",
        lazy.layout.up()
    ),

    # Move windows up or down in current stack
    Key(
        [mod, "control"], "j",
        lazy.layout.shuffle_down()
    ),
    Key(
        [mod, "control"], "k",
        lazy.layout.shuffle_up()
    ),

    # Switch window focus to other pane(s) of stack
    Key(
        [mod], "space",
        lazy.layout.next()
    ),

    Key(
        [mod], "Left",
        lazy.screen.prevgroup()
    ),

    Key(
        [mod], "Right",
        lazy.screen.nextgroup()
    ),

    # Swap panes of split stack
    Key(
        [mod, "shift"], "space",
        lazy.layout.rotate()
    ),

    # Toggle between split and unsplit sides of stack.
    # Split = all windows displayed
    # Unsplit = 1 window displayed, like Max layout, but still with
    # multiple stack panes
    Key(
        [mod, "shift"], "Return",
        lazy.layout.toggle_split()
    ),
    Key([mod], "Return", lazy.spawn("urxvt")),

    # Toggle between different layouts as defined below
    Key([mod], "Tab", lazy.nextlayout()),
    Key([mod], "w", lazy.window.kill()),

    Key([mod, "control"], "r", lazy.restart()),
    Key([mod, "control"], "q", lazy.shutdown()),
    Key([mod], "r", lazy.spawncmd()),
]

groups = [
    Group(" urxvt "),
    Group(" web ", matches=[Match(wm_class=["Firefox"])]),
    Group(" blender "),
    Group(" inkscape "),
    Group(" gimp "),
    Group(" doc "),
]

dgroups_key_binder = simple_key_binder("mod4")


layouts = [
    layout.TreeTab(
            font='Cartograph CF Light Italic',
            name="tree tab",
            bg_color="#222222",
            inactive_bg="#AB5DEE",
            panel_width=150,
            margin_left=0,
            margin_y=0,
            sections=['TreeTab'],
            section_left=0,
            padding_x=4,
            active_bg="#FFB86C",
            rounded=False,
        ),
    layout.MonadTall(
            name="xmonad tall",
            ratio=0.5,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Stack(
            num_stacks=2,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        )
]

floating_layout = layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#69B2B8",
            border_normal="#335260",
        )

widget_defaults = dict(
    font='Cartograph CF Light Italic',
    fontsize=12,
    background="#222222",
    markup=True,
)

screens = [
    Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(
                        borderwidth=0,
                        margin=0,
                        padding=6,
                        active="FFFFFF",
                        inactive="FFB86C",
                        highlight_method="block",
                        this_current_screen_border="#AB5DEE",
                        invert_mouse_wheel=True,
                        rounded=False,
                    ),
                widget.Prompt(),
                widget.CurrentLayout(
                        background="#E11B22",
                    ),
                widget.Spacer(),
                #widget.WindowName(),
                widget.TextBox("testing", name="default"),
                widget.Systray(),
                widget.Clock(format=' %I:%M %p '),
            ],
            24,
            background="#335260",
        ),
    ),
]

# Drag floating layouts.
mouse = [
    Drag([mod], "Button1", lazy.window.set_position_floating(),
        start=lazy.window.get_position()),
    Drag([mod], "Button3", lazy.window.set_size_floating(),
        start=lazy.window.get_size()),
    Click([mod], "Button2", lazy.window.bring_to_front())
]

dgroups_app_rules = []
main = None
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
auto_fullscreen = True

# XXX: Gasp! We're lying here. In fact, nobody really uses or cares about this
# string besides java UI toolkits; you can see several discussions on the
# mailing lists, github issues, and other WM documentation that suggest setting
# this string if your java app doesn't work correctly. We may as well just lie
# and say that we're a working one by default.
#
# We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in
# java that happens to be on java's whitelist.
wmname = "LG3D"
#+end_src

* .SpaceVim.d
** init.toml
:PROPERTIES:
:header-args:conf+: :noweb-ref init.toml
:END:

#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<init.toml>>
#+end_src

#+begin_src conf
#=============================================================================
# dark_powered.toml --- dark powered configuration example for SpaceVim
# Copyright (c) 2016-2020 Wang Shidong & Contributors
# Author: Wang Shidong < wsdjeg at 163.com >
# URL: https://spacevim.org
# License: GPLv3
#=============================================================================

# All SpaceVim option below [option] section
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    colorscheme = "gruvbox"
    colorscheme_bg = "dark"
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = "arrow"
    statusline_iseparator = "arrow"
    buffer_index_type = 4
    enable_tabline_filetype_icon = true
    enable_statusline_mode = false
    bootstrap_before = 'vimrc#before'
    bootstrap_after = 'vimrc#after'
    escape_key_binding = ""
#+end_src

*** layers

#+begin_src conf
# Enable autocomplete layer
[[layers]]
name = 'autocomplete'
auto_completion_return_key_behavior = "complete"
auto_completion_tab_key_behavior = "smart"

[[layers]]
name = 'shell'
default_position = 'top'
default_height = 30

[[layers]]
name = "lang#nix"
#+end_src

*** plugins

#+begin_src conf
[[custom_plugins]]
    repo = "tssm/fairyfloss.vim"
    merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/mountaineer.vim"
#     merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/gunmetal.vim"
#     merged = true

[[custom_plugins]]
    repo = "megantiu/true.vim"
    merged = true

# From:
# Answer: https://vi.stackexchange.com/questions/678/how-do-i-save-a-file-in-a-directory-that-does-not-yet-exist/679#679
# User: https://vi.stackexchange.com/users/51/martin-tournoij
[[custom_plugins]]
    repo = "arp242/auto_mkdir2.vim"
    merged = true

[[custom_plugins]]
    repo = "tpope/vim-eunuch"
    merged = true

# [[custom_plugins]]
#     repo = "johannesthyssen/vim-signit"
#     merged = true

[[custom_plugins]]
    repo = "jupyter-vim/jupyter-vim"
    merged = true

[[custom_plugins]]
    repo = "haya14busa/dein-command.vim"
    merged = true

[[custom_plugins]]
    repo = "andrep/vimacs"
    merged = true

[[custom_plugins]]
    repo = "shougo/denite.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/defx.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/deoplete.nvim"
    merged = true
#+end_src

** autoload
*** vimrc.vim

#+begin_src vimrc :tangle (meq/tangle-path)
function! vimrc#before() abort
endfunction

function! vimrc#after() abort
    syntax on
    filetype plugin indent on

    " enable 24bit true color
    if (has("termguicolors"))
    set termguicolors
    endif

    " enable the theme
    syntax enable
    colorscheme fairyfloss

    let g:true_airline = 1
    let g:airline_theme='true'

    " for kitty
    let &t_ut=""

    " disables border on left side
    set foldcolumn=0

    " Spaces & Tabs
    set tabstop=4       " number of visual spaces per TAB
    set softtabstop=4   " number of spaces in tab when editing
    set shiftwidth=4    " number of spaces to use for autoindent
    set expandtab       " tabs are space
    set autoindent
    set copyindent      " copy indent from the previous line

    " set number relativenumber

    " Insert Toggle
    imap ;; <ESC>
    map ;; i <BACKSPACE>

    " Change two spaces to four
    map \\ :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>
    imap \\ <ESC> :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>

    " Change movement keys to <space>wasd
    noremap <Space-a> h
    noremap <Space-s> j
    noremap <Space-w> k
    noremap <Space-d> l

    " Set Paste
    command SMP :set paste <CR>

    " Set NoPaste
    command SNP :set nopaste <CR>

    " Tab to insert
    map <TAB> i <TAB>

    " Vim Signit
    let g:signit_initials = "JR"
    let g:signit_name = "Jeet Ray"
    " let g:signit_extra_1
    " let g:signit_extra_2
    " let g:signit_position
    let g:signit_ascii_font = "isometric1.flf"
    " let g:signit_ascii_spacing

    if has('nvim')
        call dein#add('iron-e/nvim-libmodal')
        call dein#add('shougo/deol.nvim')
        call dein#add('shougo/deoppet.nvim')
        call dein#add('shougo/deorise.nvim')
    else
        call dein#add('iron-e/vim-libmodal')
        call dein#add('roxma/nvim-yarp')
        call dein#add('roxma/vim-hug-neovim-rpc')
    endif

    let g:deoplete#enable_at_startup = 1
endfunction
#+end_src

* .byobu
** .tmux.conf

#+begin_src conf :tangle (meq/tangle-path)
<<20211018140524183223400>>
#+end_src

* .tmux.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref .tmux.conf
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211018140524183223400

#+name: 20211018140524183223400
#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<20210601214303404504400()>>
<<.tmux.conf>>
#+end_src

** aleclearmind active-row replacement

#+call: hash() :exports none

#+RESULTS:
: 20210601214303404504400

#+name: 20210601214303404504400
#+begin_src emacs-lisp :noweb-ref no
(replace-regexp-in-string
    "set -g prefix C-a"
    "# set -g prefix C-a"
    (replace-regexp-in-string
        "unbind C-b"
        "# unbind C-b"
        (let
            ((file "./resources/aleclearmind/active-row.conf"))
            (if
                (file-directory-p file)
                (insert-file-contents file)
                ""))))
#+end_src

** powerline

#+begin_src conf
# source ./resources/powerline/powerline/bindings/tmux/powerline-base.conf
source ./resources/powerline/powerline/bindings/tmux/powerline.conf
# source ./resources/powerline/powerline/bindings/tmux/powerline_tmux_2.1_plus.conf
#+end_src

** oh-my-tmux

#+begin_src conf
source ./resources/oh-my-tmux/.tmux.conf
source ./resources/oh-my-tmux/.tmux.conf.local
#+end_src

** keybindings

From: https://man7.org/linux/man-pages/man1/tmux.1.html#KEY_BINDINGS

*** unbindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214314440746200

#+name: 20210601214314440746200
#+begin_src text :noweb-ref no
C-b
C-x
C-z
#+end_src

#+begin_src conf
unbind <<20210601214314440746200>>
#+end_src

*** bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214317258641300

#+name: 20210601214317258641300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key <<20210601214317258641300>>
#+end_src

*** root bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214320148298300

#+name: 20210601214320148298300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -n <<20210601214320148298300>>
#+end_src

*** root repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214322950137300

#+name: 20210601214322950137300
#+begin_src text :noweb-ref no
M-s send-prefix
C-S-F5 send-keys M-F5
C-S-Left send-keys M-Left
C-S-Right send-keys M-Right
#+end_src

#+begin_src conf
bind-key -nr <<20210601214322950137300>>
#+end_src

*** repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214325764323500

#+name: 20210601214325764323500
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -r <<20210601214325764323500>>
#+end_src

*** prefix table bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214331744518200

#+name: 20210601214331744518200
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -T prefix <<20210601214331744518200>>
#+end_src

** base

#+begin_src conf
# set -g prefix2 S-Space

# Mouse support - set to on if you want to use the mouse
# setw -g mode-mouse on
# set -g mouse-select-pane on
# set -g mouse-resize-pane on
# set -g mouse-select-window on

# enable activity alerts
setw -g monitor-activity off
set -g visual-activity off

# Center the window list
set -g status-justify centre

# VI Mode
set -g status-keys vi

# utf8 is on
# set -g utf8 on
# set -g status-utf8 on

run-shell "powerline-daemon -q"

set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Spacemacs Settings:
set -gs escape-time 10

# address vim mode switching delay (http://superuser.com/a/252717/65504)
set -s escape-time 0

# increase scrollback buffer size
set -g history-limit 50000

# tmux messages are displayed for 1.25 seconds
set -g display-time 1250

# refresh 'status-left' and 'status-right' more often
# set -g status-interval 1

# focus events enabled for terminals that support them
set -g focus-events on

# border thickness
set-option -g pane-active-border-style "bg=default"
set-option -ag pane-active-border-style "fg=colour208"
set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Adapted From: https://www.reddit.com/r/tmux/comments/einuqy/make_tmux_modal/
set-option -g prefix None
bind-key -n C-Space {
  set-option key-table prefix
  set-option status-bg yellow
}
bind-key -T prefix C-Space {
  set-option key-table root
  set-option status-bg green
}

setw -g aggressive-resize on
#+end_src

** plugins

#+call: hash() :exports none

#+RESULTS:
: 20210601214334528396400

#+name: 20210601214334528396400
#+begin_src text :noweb-ref no
tmux-plugins/tpm
tmux-plugins/tmux-battery
tmux-plugins/tmux-cpu
tmux-plugins/tmux-fpp
tmux-plugins/tmux-logging
tmux-plugins/tmux-online-status
tmux-plugins/tmux-open
tmux-plugins/tmux-pain-control
tmux-plugins/tmux-prefix-highlight
tmux-plugins/tmux-sessionist
tmux-plugins/tmux-sidebar
tmux-plugins/vim-tmux-focus-events
tmux-plugins/tmux-yank
tmux-plugins/tmux-continuum
tmux-plugins/tmux-resurrect
christoomey/vim-tmux-navigator
sainnhe/tmux-fzf
samoshkin/tmux-plugin-sysstat
wfxr/tmux-fzf-url
schasse/tmux-jump
eraserhd/tmux-ctrlw
jlipps/tmux-safekill
fcsonline/tmux-thumbs
addisonlynch/tmux-sidebar-plus
#+end_src

#+begin_src conf
set -g @plugin <<20210601214334528396400>>
set -g @continuum-boot 'on'
set -g @continuum-save-interval '10'
set -g @continuum-restore 'on'
set -g @resurrect-save-bash-history 'on'
set -g @resurrect-dir '~/.byobu/tmux_resurrect'
set -g @resurrect-processes '"mc --nocolor" "tail -f" bat docker elvish emacs fish glances gotop htop ipython irssi jupyter-lab jupyter-notebook less man more mosh mutt nvim ssh syncthing tail top vi vim weechat wtf xonsh xsh zsh'
set -g @resurrect-capture-pane-contents 'on'
set -g @resurrect-strategy-vim 'session'
set -g @resurrect-strategy-nvim 'session'
run "./resources/tpm/tpm"
#+end_src

* .tmuxp
** default.yaml
:PROPERTIES:
:header-args:conf+: :noweb-ref default.yaml
:END:

#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<default.yaml>>
#+end_src

#+begin_src conf
session_name: default
#+end_src

* .profile
:PROPERTIES:
:header-args:sh+: :noweb-ref .profile
:END:

#+begin_src sh :noweb-ref no :tangle (meq/tangle-path)
<<.profile>>
#+end_src

#+name: profile-sources
#+begin_src sh
. $HOME/.nix-profile/etc/profile.d/nix.sh
. $HOME/.asdf/asdf.sh
. $(fasd --init auto)
. $HOME/resources/functions
#+end_src

#+name: cd-home-and-profile-aliases
#+begin_src sh
cd $HOME
alias c="clear"
alias n="exit"
alias ssh="assh wrapper ssh --"
alias vi='ec'
alias vim='ec'
alias e='ec'
alias f='ec -t'
alias r='systemctl --user restart emacs && ec'
alias s='systemctl --user restart emacs && ec -t'
alias p='emactl'
alias ep='emacs-push'
alias phy='PYTHONPATH="$HOME/.local/syvl/python/hy:$HOME/.local/syvl/python/bakery:$PYTHONPATH" ~/.local/syvl/python/hy/bin/hy'
#+end_src

#+name: profile-functions
#+begin_src sh
ec() { { [ -z "$1" ] || [ "$1" != -* ]; } && emacsclient -s damascus -c $@ || emacsclient -s damascus $@; }
emactl() { systemctl --user $1 emacs.service; }
emacs-push() { make -f ~/.emacs.d/lib/$1/settings/makefile; }
#+end_src

#+name: profile-exports
#+begin_src sh
export EDITOR='ec'
export VISUAL='ec'
#+end_src

#+name: profile-paths
#+begin_src emacs-lisp :noweb-ref no :var shell=""
(let* ((path '("$HOME/.local/bin"
            "$HOME/.nimble/bin"
            "/home/linuxbrew/.linuxbrew/bin"
            "/home/linuxbrew/.linuxbrew/sbin"
            "$HOME/.nix-profile/bin"
            "$HOME/.guix-profile/bin"
            "$HOME/go/bin"
            "/usr/local/sbin"
            "/usr/local/bin"
            "/usr/sbin"
            "/usr/bin"
            "/sbin"
            "/bin"
            "/usr/games"
            "/usr/local/games"
            "/snap/bin"
            "/usr/local/go/bin"
            "/usr/lib/node_modules")))
    (pcase shell
        ("fish" (concat "set -gx PATH $PATH" (string-join path " ")))
        ("xonsh" (concat "$PATH += [ \"" (string-join path "\",\n\t\"") "\" ]"))
        (t (concat "PATH=\"$PATH:" (string-join path ":") "\""))))
#+end_src

#+name: profile-all-together
#+begin_src sh :noweb-ref no
<<profile-sources>>
<<profile-functions>>
<<profile-exports>>
<<cd-home-and-profile-aliases>>
<<profile-paths()>>
#+end_src

#+begin_src sh
alias s="source $HOME/.profile"
#+end_src

* .bashrc
:PROPERTIES:
:header-args:bash+: :noweb-ref .bashrc
:END:

#+begin_src bash :noweb-ref no :tangle (meq/tangle-path)
<<.bashrc>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20211027212836251792500

#+name: 20211027212836251792500
#+begin_src bash
<<profile-all-together>>
alias s="source ~/.bashrc"
eval "$(direnv hook bash)"
eval "$(starship init bash)"
#+end_src

* .elvish
** lib
*** direnv.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref direnv.elv
:END:

#+begin_src elvish :noweb-ref no :tangle (meq/tangle-path)
<<direnv.elv>>
#+end_src

#+begin_src elvish
direnv hook elvish
#+end_src

* rc.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref rc.elv
:END:

#+begin_src elvish :noweb-ref no :tangle (meq/tangle-path)
<<rc.elv>>
#+end_src

#+begin_src elvish
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
use direnv
eval (starship init elvish)
#+end_src

* .xinitrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .xinitrc
:END:

#+begin_src shell :noweb-ref no :tangle (meq/tangle-path)
<<.xinitrc>>
#+end_src

#+begin_src shell
exec emacs
#+end_src

* .direnvrc
:PROPERTIES:
:header-args:sh+: :noweb-ref .direnvrc
:END:

#+begin_src sh :noweb-ref no :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src sh
source ~/resources/nix-direnv/direnvrc
source ~/.config/direnv/direnvrc

if [[ -f /run/current-system/sw/share/nix-direnv/direnvrc ]]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

* .globalignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .globalignore
:END:

#+call: hash() :exports none

#+RESULTS:
: 20210601185925524999600

#+name: 20210601185925524999600
#+begin_src gitignore :noweb-ref no :tangle (meq/tangle-path)
<<.globalignore>>
#+end_src

#+begin_src gitignore
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
<<20211018183420833239200>>
#+end_src

* .gitignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .gitignore
:END:

#+begin_src gitignore :noweb-ref no :tangle (meq/tangle-path)
<<.gitignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .hgignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .hgignore
:END:

#+begin_src gitignore :noweb-ref no :tangle (meq/tangle-path)
<<.hgignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .zshrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshrc
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.zshrc>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshrc
<<profile-all-together>>
alias s="source ~/.zshrc"
eval "$(direnv hook zsh)"
prompt off
eval "$(starship init zsh)"
#+end_src

* .zshenv
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshenv
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.zshenv>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshenv
#+end_src

* .zprofile
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zprofile
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.zprofile>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zprofile
#+end_src

* .zlogout
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogout
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.zlogout>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogout
eval "$(direnv hook zsh)"
#+end_src

* .zlogin
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogin
:END:

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path)
<<.zlogin>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogin
eval "$(direnv hook zsh)"
#+end_src

* .stow-global-ignore
:PROPERTIES:
:header-args:conf+: :noweb-ref .stow-global-ignore
:END:

#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<.stow-global-ignore>>
#+end_src

#+begin_src conf
\.git
#+end_src

* .termux
** termux.properties
:PROPERTIES:
:header-args:conf+: :noweb-ref termux.properties
:END:

#+begin_src conf :noweb-ref no :tangle (meq/tangle-path)
<<termux.properties>>
#+end_src

#+begin_src conf
### After making changes and saving you need to run `termux-reload-settings`
### to update the terminal.  All information here can also be found on the
### wiki: https://wiki.termux.com/wiki/Terminal_Settings

###############
# Extra keys
###############

### Settings for choosing which set of symbols to use for illustrating keys.
### Choose between default, arrows-only, arrows-all, all and none
# extra-keys-style = default

### Default extra-key configuration
# extra-keys = [[ESC, TAB, CTRL, ALT, {key: '-', popup: '|'}, DOWN, UP]]

### Two rows with more keys
# extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'], \
#               ['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]

### Configuration with additional popup keys (swipe up from an extra key)
# extra-keys = [[ \
#   {key: ESC, popup: {macro: "CTRL f d", display: "tmux exit"}}, \
#   {key: CTRL, popup: {macro: "CTRL f BKSP", display: "tmux ←"}}, \
#   {key: ALT, popup: {macro: "CTRL f TAB", display: "tmux →"}}, \
#   {key: TAB, popup: {macro: "ALT a", display: A-a}}, \
#   {key: LEFT, popup: HOME}, \
#   {key: DOWN, popup: PGDN}, \
#   {key: UP, popup: PGUP}, \
#   {key: RIGHT, popup: END}, \
#   {macro: "ALT j", display: A-j, popup: {macro: "ALT g", display: A-g}}, \
#   {key: KEYBOARD, popup: {macro: "CTRL d", display: exit}} \
# ]]

###############
# Colors/themes
###############

### Force black colors for drawer and dialogs
# use-black-ui = true

###############
# Keyboard shortcuts
###############

### Open a new terminal with ctrl + t (volume down + t)
# shortcut.create-session = ctrl + t

### Go one session down with (for example) ctrl + 2
# shortcut.next-session = ctrl + 2

### Go one session up with (for example) ctrl + 1
# shortcut.previous-session = ctrl + 1

### Rename a session with (for example) ctrl + n
# shortcut.rename-session = ctrl + n

###############
# Bell key
###############

### Vibrate device (default).
# bell-character = vibrate

### Beep with a sound.
# bell-character = beep

### Ignore bell character.
# bell-character = ignore

###############
# Back key
###############

### Send the Escape key.
# back-key=escape

### Hide keyboard or leave app (default).
# back-key=back

###############
# Keyboard issue workarounds
###############

### Letters might not appear until enter is pressed on Samsung devices
# enforce-char-based-input = true

### ctrl+space (for marking text in emacs) does not work on some devices
# ctrl-space-workaround = true

allow-external-apps = true
#+end_src

* run_keybase
:PROPERTIES:
:header-args:zsh+: :noweb-ref run_keybase
:END:

Adapted From: https://github.com/keybase/client/blob/master/packaging/linux/run_keybase

#+begin_src zsh :noweb-ref no :tangle (meq/tangle-path) :shebang "#!/usr/bin/env zsh"
<<run_keybase>>
#+end_src

#+begin_src zsh
set -e -u -o pipefail

# This is the script responsible for launching keybase on boot on Linux. A
# .desktop file will be created by the service on first launch in
# ~/.config/autostart/ to invoke this script.

systemd_stop_if_active() {
    service="$1";
    if command -v systemctl &> /dev/null && systemctl --user is-active -q "$service"; then
        systemctl --user stop "$service"
    fi
}

# This works no matter how the services were started, because our
# Restart=on-failure systemd unit configuration won't restart after SIGTERM.
kill_all() {
  # systemd will restart services if they failed to stop cleanly, so do this explicitly
  # first to make the rest of a function a no-op.
  if [ "$KEYBASE_KILL" = "1" ]; then
      systemd_stop_if_active "keybase"
      systemd_stop_if_active "kbfs"
      systemd_stop_if_active "keybase.gui"
      systemd_stop_if_active "keybase-redirector"
  fi

  # Only stop main Electron process; others have additional flags after the process name
  # Child Electron processes will be stopped by main process' handler
  if main_electron_pids="$(pgrep 'Keybase$')"; then
      # intentionally splitting pids
      # shellcheck disable=SC2046
      kill $(echo "$main_electron_pids" | xargs) &> /dev/null && echo Shutting down Keybase GUI...
  fi

  # mountdir may be empty on the initial install, so don't try to unmount in that case.
  if mountdir="$(keybase config get --direct --bare mountdir 2> /dev/null)" && [ -n "$mountdir" ]; then
	  # Redundant in newer kbfsfuses, which catches SIGTERM and unmounts before exiting.
	  fusermount -uz "$mountdir" &> /dev/null && echo Unmounting "$mountdir"...
  fi

  killall kbfsfuse &> /dev/null && echo Unmounting and shutting down kbfsfuse...
  killall keybase &> /dev/null && echo Shutting down keybase service...

  # Only shut down redirector when stopping, but not for restarts.
  if [ "$KEYBASE_KILL" = "1" ]; then
      pkill -f keybase-redirector &> /dev/null && echo Shutting down keybase redirector...
  fi
}

start_systemd() {
  echo Starting via systemd...

  # Reload possibly-updated unit files.
  # This occurs in post-install, but only if it's actually packaged
  # and the user was already running Keybase.
  systemd_errmsg="Failed to load systemd units. If systemd is not supported, please 'export KEYBASE_SYSTEMD=0' before running this command."
  systemctl --user daemon-reload || echo "$systemd_errmsg"

  # We don't want to persist this, so don't store it in the env file.
  # This is unset right after start in the unit file so subsequent direct
  # systemctl calls don't have it set.
  systemctl --user set-environment "KEYBASE_AUTOSTART=$KEYBASE_AUTOSTART"

  # The keybase.gui.service unit has keybase.service as dependencies, so we
  # don't have to list them here. But including them lets us report an error if
  # they fail to start. Also prefer `restart` to `start` so that we don't race
  # against the service shutting down.  kbfs.service will attempt to start the
  # redirector, but it isn't an error if it fails to start, which happens if it
  # is disabled.
  systemctl --user restart keybase.service

  [ "$KEYBASE_NO_KBFS" == "1" ] || systemctl --user restart kbfs.service
  gui_fail_help="Failed to launch GUI. Pass -g to prevent startup if on a machine without a graphical display."
  [ "$KEYBASE_NO_GUI" == "1" ] || systemctl --user restart keybase.gui.service || echo "$gui_fail_help"
}

run_redirector_in_background() {
  if ! keybase --use-root-config-file config get --direct --assert-false --assert-ok-on-nil disable-root-redirector &> /dev/null; then
    return 0
  fi
  redirector_log="$logdir/keybase.redirector.log"
  # An older version of post_install.sh could have made a redirector log
  # here that's owned by root.  If we can't write to it, then just nuke it
  # and overwrite.
  if [ -e "$redirector_log" ] && [ ! -w "$redirector_log" ]; then
    rm -f "$redirector_log"
  fi
  echo Starting the redirector...
  # We need nohup so the redirector doesn't terminate on shell exit,
  # but it isn't necessary for keybase/kbfs/gui which autofork.
  nohup keybase-redirector /keybase >> "$redirector_log" 2>&1 &
}

start_background() {
  echo Launching keybase service...

  # We set the --auto-forked flag here so that updated clients that try to
  # restart this service will know to re-fork it themselves. That's all it does.
  keybase --debug --use-default-log-file service --auto-forked &>> "$logdir/keybase.start.log" &

  if [ "$KEYBASE_NO_KBFS" != "1" ]; then
      run_redirector_in_background
      echo Starting KBFS...

      # The only time kbfsfuse -log-to-file prints to stdout is if the mount
      # fails. So, if it does fail, because the directory does not exist, or
      # has invalid permissions, the user will be notified on the command line
      # after running `run_keybase`, but otherwise stdout will not be cluttered
      # with other various log messages.
      ( kbfsfuse -debug -log-to-file | tee "$logdir/keybase.start.log" ) &
  fi

  if [ "$KEYBASE_NO_GUI" != "1" ]; then
      # For system tray icon due to an upstream Electron issue:
      # https://github.com/electron/electron/issues/10887.
      # Also exported in systemd keybase.gui unit explicitly.
      export XDG_CURRENT_DESKTOP=Unity
      export KEYBASE_AUTOSTART="$KEYBASE_AUTOSTART"

      echo Launching Keybase GUI...
      gui_log="$logdir/Keybase.app.log"
      "$KEYBASE" &>> "$gui_log" &
  fi
}

# Warn if the keybase binary path is unexpected, possibly due to a conflicting
# binary from the Node client. Can silence with KEYBASE_PATH_WARNING=0.
warn_if_weird_path() {
    if [ "${KEYBASE_PATH_WARNING:-}" = "0" ] ; then
        return
    fi
    if [ "$(command -v keybase)" != "/usr/bin/keybase" ] ; then
        echo "WARNING: Expected the keybase executable to be /usr/bin/keybase, but it's"
        echo "         $(command -v keybase) instead. Do you have multiple versions installed?"
        echo "         Export KEYBASE_PATH_WARNING=0 to silence this warning."
    fi
}

show_cryptosquirrel() {
  if n_colors="$(tput colors 2> /dev/null)" && [ "$n_colors" -gt 2 ]; then
      [ "${KEYBASE_NO_SQUIRREL:-}" != "1" ] && cat /opt/keybase/crypto_squirrel.txt
  fi
}

warn_if_exists_and_unwritable() {
  if ! [ -e "$1" ] || [ -w "$1" ]; then
      return
  fi
  echo "WARNING: Cannot write to $1. Did you previously run 'run_keybase' with sudo?"
  echo "         Keybase does not need root privileges to run."
  echo "         Permissions can be restored by running 'sudo chown -R $(whoami):$(whoami) $1',"
  echo "         after which 'run_keybase' can be run again."
}

init() {
  logdir="${XDG_CACHE_HOME:-$HOME/.cache}/keybase"
  runtime_dir="${XDG_RUNTIME_DIR:-$HOME/.config}/keybase"

  warn_if_exists_and_unwritable "$logdir"
  warn_if_exists_and_unwritable "$runtime_dir"
  warn_if_exists_and_unwritable "$HOME/.config"
  warn_if_exists_and_unwritable "$HOME/.local/share/keybase/keybase.leveldb"
  warn_if_exists_and_unwritable "$HOME/.config/keybase"
  warn_if_exists_and_unwritable "$HOME/.config/keybase/gui_config.json"
  warn_if_exists_and_unwritable "$HOME/.cache/keybase"

  # Cannot do in go due to background processes being piped to log in zsh
  mkdir -p "$logdir"

  # Cannot do in go due to flock using a file in this directory
  mkdir -p "$runtime_dir"

  keybase ctl init

  # Remove legacy envfiles; now stored in config directory by ctl init
  rm -f "$runtime_dir/keybase.env" "$runtime_dir/keybase.kbfs.env" "$runtime_dir/keybase.gui.env"

  # Allow distributions to change the location of the gui as long as it's in PATH.
  if command -v Keybase &> /dev/null; then
      KEYBASE=Keybase
  else
      KEYBASE=/opt/keybase/Keybase
  fi
}

check_for_url_scheme_or_saltpack_file_launch() {
  # We set a URL scheme handler on our .desktop file, and since that file
  # points to this script, that's what gets called with URL links. We can
  # differentiate between a normal run_keybase invocation and a URL launch
  # by checking argv.
  #
  # We also have a .saltpack MIME type registration, so double clicking on
  # a saltpack file will also cause run_keybase to receive a $1 argument
  # of a filename to open.

  # If Keybase is already running, then pass it the link and exit.
  if [[ $# -eq 1 && "$1" =~ ^(/|web\+|keybase).* ]]; then
      if pgrep -u "$USER" -f 'Keybase$' &> /dev/null; then
          "$KEYBASE" "$1" &
          exit
      fi
  fi

  # Since we didn't exit, fall through to a normal startup.
}

startup_all() {
  # There is a race condition where if we try to start the keybase service before
  # the previous process has died, we might fail to lock the pid file and error
  # out. Avoid this by waiting for the lock file to be free, on systems with flock
  # installed.
  lockfile="$runtime_dir/keybased.pid"
  if command -v flock &> /dev/null && [ -e "$lockfile" ] ; then
    flock "$lockfile" true
  fi

  warn_if_weird_path

  if keybase ctl wants-systemd &> /dev/null; then
      start_systemd
  else
      start_background
  fi

  echo 'run_keybase: Success!'

  show_cryptosquirrel
}

usage() {
  echo "Usage: run_keybase [-afghk]"
  echo "Starts the Keybase service, KBFS, and the GUI."
  echo "If services are already running, they will be restarted."
  echo ""
  echo "Options can also be controlled by setting related environment variables to 1"
  echo "  -a  keep the GUI minimized in system tray after startup (env KEYBASE_AUTOSTART=1)"
  echo "  -f  do not start KBFS (env KEYBASE_NO_KBFS=1)"
  echo "  -g  do not start the gui (env KEYBASE_NO_GUI=1)"
  echo "  -h  print this help text"
  echo "  -k  shut down all Keybase services (env KEYBASE_KILL=1)"
}

KEYBASE_NO_GUI="${KEYBASE_NO_GUI:-0}"
KEYBASE_NO_KBFS="${KEYBASE_NO_KBFS:-0}"
KEYBASE_AUTOSTART="${KEYBASE_AUTOSTART:-0}"
KEYBASE_KILL="${KEYBASE_KILL:-0}"

# NOTE: Make sure to update the Linux User Guide doc if you change this!
#   http://keybase.io/docs/linux-user-guide
while getopts "afghk" flag; do
    case $flag in
        a) KEYBASE_AUTOSTART=1;;
        f) KEYBASE_NO_KBFS=1;;
        g) KEYBASE_NO_GUI=1;;
        h) usage; exit 0;;
        k) KEYBASE_KILL=1;;
        ?) usage; exit 1;;
    esac
done

init

# Exit early if run caused by a URL scheme invocation and Keybase is already
# running; otherwise fall through to start Keybase.
check_for_url_scheme_or_saltpack_file_launch "$@"

# Always stop any running services. With systemd, we could've decided to just
# `start` services and no-op if they're already running, however:
# 1) We still need to handle the case where services started outside systemd
#    are currently running, and making that totally reliable is tricky.
# 2) Users have come to expect that run_keybase will restart everything, and
#    we tell them to do it after updates.
kill_all
if [ "$KEYBASE_KILL" = "0" ]; then
    startup_all
fi
#+end_src