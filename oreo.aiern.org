#+setupfile: ./settings/README.org

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* shell.nix

#+begin_src nix :tangle (meq/tangle-path)
with builtins; let flake = import ./etc/nixos;
in with import flake.inputs.nixpkgs (flake.make.specialArgs null currentSystem).nixpkgset; let
    strapper = stdenv.mkDerivation rec {
        pname = "strapper";
        version = "1.0.0.0";

        src = ./strapper;

        buildInputs = [ python310 sd gcc rsync xonsh ] ++ (with python310Packages; [ bakery ]);
        nativeBuildInputs = buildInputs;

        phases = [ "installPhase" ];

        installPhase = ''
            mkdir --parents $out
            cp -r $src $out/bin
            chmod +x $out/bin/strapper
        '';
    };
in mkShell rec {
    buildInputs = [ strapper ] ++ strapper.buildInputs;
    nativeBuildInputs = buildInputs;
    shellHook = ''
        exec xonsh
    '';
}
#+end_src

* strapper
** strapper

#+begin_src py :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3"
import hy, os
from addict import Dict
from oreo import module_installed
strapper = module_installed(os.path.dirname(os.path.realpath(__file__)) + "/strapper.hy").strapper
if __name__ == "__main__":
    strapper(obj=Dict(dict()))
#+end_src

** strapper.hy
:PROPERTIES:
:header-args:hy+: :noweb-ref nwr20220129201318455450756
:END:

#+begin_src text :tangle (meq/tangle-path)
<<nwr20220129201318455450756>>
#+end_src

*** Imports

#+begin_src hy
(import click)
(import json)
(import oreo)
(import os)
#+end_src

**** From

#+begin_src hy
(import addict [Dict :as D])
(import bakery [ getconf
                 mkswap
                 mount :as Mount
                 nixos-generate-config
                 nixos-install
                 nixos-rebuild
                 rsync
                 sd
                 swapon
                 umount
                 zfs
                 zpool ])
(import functools [partial])
(import pathlib [Path])
(import sys [argv])
#+end_src

**** Coconut

[[https://coconut.readthedocs.io/en/latest/index.html][Coconut]]:

#+begin_src hy
(try (import coconut *)
     (except [ImportError] None))
#+end_src

**** Toolz

[[https://github.com/pytoolz/toolz][Toolz]] and [[https://github.com/pytoolz/cytoolz/][CyToolz]]:

#+begin_src hy
(try (import cytoolz [last])
     (except [ImportError]
             (import toolz [last])))
#+end_src

*** Requires

#+begin_src hy
(require hyrule [-> assoc])
#+end_src

*** Set Resources Directory

#+begin_src hy
;; (setv resources (+ (.dirname os.path (.realpath os.path __file__)) "/etc/nixos/"))
(setv resources (+ (.getcwd os) "/etc/nixos/"))
#+end_src

*** Datasets

#+call: hash() :exports none

#+RESULTS:
: 20220205031620372930929

#+name: 20220205031620372930929
#+begin_src text
dross
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601190015343762700

#+name: 20210601190015343762700
#+begin_src json
{
    "base": {  },
    "omniverse": {  },
    "reserved": {  },
    "<<username>>": { "datasets": {
            "oreo": { "mountpoint": "/home/<<username>>/oreo" },
            "sylveon": { "mountpoint": "/home/<<username>>/sylveon" },
            "sylvorg": { "mountpoint": "/home/<<username>>/sylvorg" },
            "syvlorg": { "mountpoint": "/home/<<username>>/syvlorg" },
            "<<20220205031620372930929>>": { "mountpoint": "/home/<<username>>/<<20220205031620372930929>>" },
            "uru": { "mountpoint": "/home/<<username>>/uru" }},
        "options": [ "mountpoint=legacy" ]},
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": { "datasets": { "root": { "mountpoint": "/persist/root" }}},
            "root": {  },
            "tmp": { "datasets": { "nix": {  }}, "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

*** Update Datasets

#+begin_src hy
(defn update-datasets [host [swap 0] [encrypted False] [deduplicated False] [pool False] [root-device None]]
      (setv snap-dir     [ "snapdir=visible" ]
            extra-copies (+ snap-dir [ "copies=3" ])
            cache        [ "sync=disabled" ]
            ml           "mountpoint=legacy"
            d            "datasets"
            s            "system"
            datasets     (D (.loads json (.strip #[[
                                <<20210601190015343762700>>
                         ]])))
            users        (D (.loads json (.strip #[[
                                <<20210601185359809444000>>
                         ]]))))
      (assoc datasets "${host}" (D { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                                     "options" [ ml ]}))
      (for [user (.values users)]
           (assoc (. datasets [s] [d] home [d]) user (dict))
           (assoc (. datasets [s] [d] persist [d]) user (dict))
           (assoc (. datasets virt [d] podman [d]) user (dict)))
      (with [dnix (open (+ resources "/datasets.nix") "w")]
            (.write dnix (+ "host: { \n\t\""
                            (or root-device "${host}/system/root")
                            "\" = \"/\";"
                            "\n"))
            (defn recurse [ddict dname droot [mountpoint ""]]
                  (setv recurse/datasets     (.list zfs :r True :o "name" :m/list True :m/ignore-stderr True)
                        recurse/datasets     (cut recurse/datasets 2 (len recurse/datasets))
                        recurse/dataset      (+ droot "/" dname)
                        recurse/real-dataset (.replace recurse/dataset "${host}" host)
                        cloning              (and (!= dname "base")
                                                  (and encrypted deduplicated))
                        prefixes             (, "system"
                                                "system/root"
                                                "swap"
                                                "base"
                                                "hold"
                                                "omniverse"
                                                "reserved" ))
                  (if cloning
                      (setv clone-or-create  "clone"
                            snapshot-or-none (+ host "/base@root"))
                      (setv clone-or-create  "create"
                            snapshot-or-none ""))
                  (if (not (in recurse/real-dataset (lfor prefix prefixes (+ host "/" prefix))))
                      (do (if (setx recurse/mountpoint (.get ddict "mountpoint" ""))
                              (setv mountpoint recurse/mountpoint)
                              (if mountpoint
                                  (setv mountpoint (+ mountpoint "/" dname)
                                        recurse/mountpoint mountpoint)
                                  (do (setv recurse/mountpoint (.removeprefix recurse/dataset "${host}/"))
                                      (for [prefix prefixes]
                                           (setv recurse/mountpoint (.removeprefix recurse/mountpoint (+ prefix "/"))))
                                      (setv recurse/mountpoint (+ "/" recurse/mountpoint)))))
                          (.write dnix (+ "\t\""
                                          recurse/dataset
                                          "\" = \""
                                          recurse/mountpoint
                                          "\";\n"))))
                  (if (and pool (not (in recurse/real-dataset recurse/datasets)))
                      (do (zfs :m/subcommand clone-or-create
                               :o { "repeat-with-values" (.get ddict "options" []) }
                               snapshot-or-none
                               recurse/real-dataset)
                          (.snapshot zfs :r True (+ recurse/real-dataset "@blank"))))
                  (for [[key value] (.items (.get ddict d (D {  })))]
                       (recurse value key recurse/dataset mountpoint)))
            (for [[key value] (.items datasets)]
                 (recurse value key "${host}"))
            (.write dnix "}"))
      (if pool
          (let [pool-size-plus-metric (get (.get zpool :H True "size" host :m/list True :m/split True) 2)
                pool-size             (-> pool-size-plus-metric
                                          (cut 0 -1)
                                          (float)
                                          (round 2))
                pool-metric           (last pool-size-plus-metric)]
               (defn pool-percentage-value [percentage]
                     (-> percentage
                         (float)
                         (/ 100)
                         (round 2)
                         (str)
                         (+ pool-metric)
                         (return)))
               (.set zfs
                     (+ "refreservation=" (pool-percentage-value 15))
                     (+ host "/reserved"))

               ;; Apparently, if python internal keywords exist in the argument, such as "set", etc.
               ;; the command errors out; perhaps something to raise an issue of.
               ;; This seems to work as an alternative.
               ;; run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/reserved", shell = True)

               (if swap
                   (let [swoptions [ "com.sun:auto-snapshot=false"
                                     "compression=zle"
                                     "logbias=throughput"
                                     "primarycache=metadata"
                                     "secondarycache=none"
                                     "sync=standard" ]
                         page-size (getconf "PAGESIZE" :m/str True)]
                        (.create zfs
                                 :V (+ (str swap) "G")
                                 :b page-size
                                 :o { "repeat-with-values" swoptions }
                                 (+ host "/swap"))
                        (mkswap (+ "/dev/zvol" host "/swap")))))))
#+end_src

*** Click

#+begin_src hy
(setv no-host-error-message "Sorry! The host needs to be set; do this with the main command while running the subcommand!")
#@((.group click :no-args-is-help True)
   (.option click "-d" "--dazzle" :is-flag True)
   (.option click "-H" "--host")
   (.option click "-i" "--inspect" :is-flag True)
   (.option click "-p" "--print-run" :is-flag True)
   click.pass-context
   (defn strapper [ ctx dazzle host inspect print-run ]
         (.ensure-object ctx dict)
         (setv ctx.obj.host host)
         (if print-run (.bake-all- getconf :m/print-command-and-run True))
         (if inspect (.bake-all- getconf :m/debug True))))
#+end_src

**** Main

#+begin_src hy
#@((.command strapper :no-args-is-help True
                        :context-settings { "ignore_unknown_options" True
                                            "allow_extra_args"       True })
   (.argument click "program-arguments" :nargs -1)
   (.option click "-a" "--all" :is-flag True)
   (.option click "-c" "--copy" :is-flag True)
   (.option click "-g" "--generate" :is-flag True)
   (.option click "-i" "--install" :is-flag True)
   (.option click "-r" "--replace" :is-flag True)
#+end_src

This can't use a default value, as that would trigger a rebuild all the time.

#+begin_src hy
   (.option click "-R" "--rebuild")
#+end_src

#+begin_src hy
   click.pass-context
   (defn main [ ctx all copy generate install program-arguments rebuild replace ]
         (.bake-all- getconf :m/sudo True)
         (setv copy-partial (partial rsync :m/run True :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } f"{resources}/"))
         (if rebuild
             (do (if copy
                     (copy-partial "/etc/nixos/"))
                 (nixos-rebuild rebuild #* ctx.args :show-trace True))
             (do (if (or copy all)
                     (do (update-datasets ctx.obj.host)
                         (copy-partial "/mnt/etc/nixos/")))
                 (if (or generate all)
                     (nixos-generate-config :m/run True :root "/mnt"))
                 (if (or replace all)
                     (if ctx.obj.host
                         (do (sd :m/run True
                                 "./hardware-configuration.nix"
                                 (+ "./hosts/" ctx.obj.host)
                                 "/mnt/etc/nixos/configuration.nix")
                             (sd :m/run True
                                 "'device = \"\"'"
                                 "'device = \"!\"'"
                                 "/mnt/etc/nixos/hardware-configuration.nix"))
                         (raise (NameError no-host-error-message))))
                 (if (or install all)
                     (nixos-install #* ctx.args
                                    :I "nixpkgs=https://github.com/<<username>>/nixpkgs/archive/j.tar.gz"
                                    :m/run True
                                    :show-trace True
#+end_src

From [[https://github.com/NixOS/nix/issues/2293#issuecomment-405339738][here]], and documented [[https://nixos.org/manual/nix/stable/expressions/builtins.html#:~:text=The%20fetched%20tarball%20is%20cached%20for%20a%20certain%20amount%20of%20time%20(1%20hour%20by%20default)%20in%20~/.cache/nix/tarballs/.%20You%20can%20change%20the%20cache%20timeout%20either%20on%20the%20command%20line%20with%20%2D%2Dtarball%2Dttl%20number%2Dof%2Dseconds%20or%20in%20the%20Nix%20configuration%20file%20by%20adding%20the%20line%20tarball%2Dttl%20%3D%20number%2Dof%2Dseconds.][here]]:

#+begin_quote
The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/.
You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds
or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds.
#+end_quote

#+begin_src hy
                                    :option "tarball-ttl 0"
#+end_src

#+begin_src hy
))))))
#+end_src

**** Create

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-m" "--mountpoint")
   (.option click "-p" "--pool" :is-flag True)
   (.option click "-r" "--raid")
   (.option click "-s" "--swap" :type int :default 0)
   (.option click "-z" "--zfs-devices" :required True :multiple True)
   click.pass-context
   (defn create [ ctx deduplicated encrypted mountpoint pool raid swap zfs-devices ]
         (if ctx.obj.host
             (try (if (= (input "THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN 'ZFS CREATE'!\n\t") "ZFS CREATE")
                      (let [options (D { "xattr"      "sa"
                                         "acltype"    "posixacl"
                                         "mountpoint"  (or mountpoint "none")
                                         "compression" "zstd-19"
                                         "checksum"    "edonr"
                                         "atime"       "off"
                                         "relatime"    "off" })
                            command (partial zpool.create
                                             :f True
                                             :o { "repeat-with-values" (, "autotrim=on" "altroot=/mnt" "autoexpand=on") })
                            no-raid-error-message "Sorry! For multiple zfs devices a raid configuration must be provided using `-r / --raid'!"
                            zfs-device (if (= (len zfs-devices) 1)
                                        (if raid
                                            (raise (NameError no-raid-error-message))
                                            (get zfs-devices 0))
                                        (if raid
                                            (+ raid (.join " " zfs-devices))
                                            (raise (NameError no-raid-error-message))))]
                           (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                                (if (in ctx.obj.host dataset)
                                    (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
                           (if encrypted
                               (setv options.encryption "aes-256-gcm"
                                     options.keyformat  "passphrase"))
                           (if deduplicated
                               (setv options.dedup "edonr,verify"))
                           (if (.ismount os.path "/mnt")
                               (umount :R True "/mnt"))
                           (.export zpool :f True ctx.obj.host :m/ignore-stderr True)
                           (command :O { "repeat-with-values" (gfor [k v] (.items options) f"{k}={v}") } ctx.obj.host zfs-device)
                           (if (not pool)
                               (update-datasets ctx.obj.host swap encrypted deduplicated :pool True)))
                      (print "Sorry; not continuing!\n\n"))
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

**** Mount

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-b" "--boot-device")
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :cls oreo.Option :xor [ "swap-device" ] :is-flag True)
   (.option click "-S" "--swap-device" :cls oreo.Option :xor [ "swap" ])
   click.pass-context
   (defn mount [ ctx boot-device deduplicated encrypted root-device swap swap-device ]
         (if ctx.obj.host
             (do (update-datasets ctx.obj.host :root-device root-device :encrypted encrypted :deduplicated deduplicated :swap swap)
                 (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                      (if (in ctx.obj.host dataset)
                          (break))
                      (else (.import zpool :f True ctx.obj.host)))
                 (if encrypted
                     (.load-key zfs ctx.obj.host))
                 (try (.mkdir (Path "/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt")
                                  (umount :R True "/mnt"))))
                 (if root-device
                     (Mount root-device "/mnt")
                     (Mount :t "zfs" (+ ctx.obj.host "/system/root") "/mnt"))
#+end_src

Taken from [[https://github.com/NixOS/nixpkgs/issues/73404#issuecomment-1011485428][here]]:

#+begin_src hy
                 (try (.mkdir (Path "/mnt/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt/mnt")
                                  (umount :R True "/mnt/mnt"))))
                 (Mount :bind True "/mnt" "/mnt/mnt")
#+end_src

#+begin_src hy
                 (.mkdir (Path "/mnt/etc/nixos") :parents True :exist-ok True)

                 (.mkdir (Path "/mnt/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/nix") "/mnt/nix")

                 (.mkdir (Path "/mnt/persist") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/persist") "/mnt/persist")

                 (if boot-device
                     (let [boot "/mnt/boot/efi"]
                          (.mkdir (Path boot) :parents True :exist-ok True)
                          (Mount boot-device boot)))
                 (if swap
                     (swapon (+ "/dev/zvol/" ctx.obj.host "/swap" :m/run True)))
                 (if swap-device
                     (swapon swap-device :m/run True))

                 (.mkdir (Path "/tmp") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp") "/tmp" :m/run True)

                 (.mkdir (Path "/tmp/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/tmp/nix" :m/run True)

                 ;; (rsync :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } :delete True "/nix/" "/tmp/nix/")
                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/nix" :m/run True)

                 )
             (raise (NameError no-host-error-message)))))
#+end_src

**** Update

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-f" "--files" :is-flag True :help "Update datasets.nix with any new datasets; the default")
   (.option click "-p" "--pool" :is-flag True :help "Update the pool and datasets.nix with any new datasets")
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :type int :default 0)
   click.pass-context
   (defn update [ ctx deduplicated encrypted files pool root-device swap ]
         (if ctx.obj.host
             (try (setv ud (partial update-datasets ctx.obj.host :swap swap :encrypted encrypted :deduplicated deduplicated :root-device root-device))
                  (cond [files (ud)]
                        [pool (ud :pool True)]
                        [True (ud)])
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

*** End of strapper

#+begin_src hy :noweb-ref no
(if (= __name__ "__main__")
    (strapper :obj (D {})))
#+end_src

* etc
** apk
*** repositories
:PROPERTIES:
:header-args:text+: :noweb-ref repositories
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<repositories>>
#+end_src

#+begin_src text
http://postmarketos.brixit.nl/postmarketos/master
https://dl-cdn.alpinelinux.org/alpine/v3.13/main
https://dl-cdn.alpinelinux.org/alpine/v3.13/community
#+end_src

*** keys
**** build.postmarketos.org.rsa.pub
:PROPERTIES:
:header-args:text+: :noweb-ref build.postmarketos.org.rsa.pub
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<build.postmarketos.org.rsa.pub>>
#+end_src

#+begin_src text
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlXE4h6kp8aCzn6BjuOnz
Z1lcFSY+WRZ2vGUb5hEZ+YG75xYZW+yELr8P8+HSUrpBXF/HTQYKH/cNJc5zmOny
EsmcZskIYB0qgZPg02GXBV8VfjL+Es+y166g14IH2YKkdfplqHYVpCmnkmaZXQZu
ZAOEL2hyuzTAYYFhCZWHYYgdWfpnKDDlVcnw1Q3/LhADBlN63CW0UMWc5oJ7MwlY
SKriM60cHvER1YD5bdbGG/JTBFnB4djliLtvRNp+w3emwHmDhFmnYITN2WOHbYpV
P+RIfzq0IP978sKGJmd0RPuwl2ruifBYikm/F79Ko8lT2gVE40B7wqbInIGquTr1
deERIr47jcPRGl+01Svm0SxbXD1/zBNjo4wvMsZEW7Te689mFjxsXHnD7OEUQqh/
D1DhbnKJwpKwClYOi/aVDyGJunqavSR0QYPqN3nP+uXdBC4wuLI9gRS/yXNaxpMy
9AKwlD3uUhKzmJMJIu3L1/TH/vY9M5xZ2lnFduTZmL/X/4sjhyTb1ycFwU9UIY4C
u2CP/YLqiiquokgzpRfYwJyOP4quBVRC46Tejx5PzTCvnhro7LAzDoS756iBv9E/
2oxwC5VafGSChO+N8SyEBy532Gs+rcZDwUE7M9Y1GbQHW3ALMTwxstWqZ3GKWKd1
Cw6JQoywUhR09tFwQrYZao0CAwEAAQ==
-----END PUBLIC KEY-----
#+end_src

** nixos
*** default.nix

Taken from [[https://github.com/edolstra/flake-compat#usage][here]]:

#+begin_src nix :tangle (meq/tangle-path)
(import
  (
    let lock = builtins.fromJSON (builtins.readFile ./flake.lock); in
    fetchTarball {
      url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
      sha256 = lock.nodes.flake-compat.locked.narHash;
    }
  )
  { src = ./.; }
).defaultNix
#+end_src

*** patches
**** BACKPORT-Linux-5.8-compat-__vmalloc.patch

#+begin_src diff :tangle (meq/tangle-path)
From 6cc95288ccea12ad7b67b2b5b3997dfad8e5b5c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20Niew=C3=B6hner?=
 <c0d3z3r0@users.noreply.github.com>
Date: Tue, 9 Jun 2020 01:32:02 +0200
Subject: [PATCH] BACKPORT: Linux 5.8 compat: __vmalloc()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The `pgprot` argument has been removed from `__vmalloc` in Linux 5.8,
being `PAGE_KERNEL` always now [1].

Detect this during configure and define a wrapper for older kernels.

[1] https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/mm/vmalloc.c?h=next-20200605&id=88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Co-authored-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Co-authored-by: Michael Niewöhner <foss@mniewoehner.de>
Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Signed-off-by: Michael Niewöhner <foss@mniewoehner.de>
Closes #10422
---
 config/kernel-kmem.m4       | 26 ++++++++++++++++++++++++++
 config/kernel.m4            |  2 ++
 include/spl/sys/kmem.h      |  9 +++++++++
 module/spl/spl-kmem-cache.c |  4 ++--
 module/spl/spl-kmem.c       |  9 ++++-----
 5 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/config/kernel-kmem.m4 b/config/kernel-kmem.m4
index cc055e530..f1c0d2412 100644
--- a/config/kernel-kmem.m4
+++ b/config/kernel-kmem.m4
@@ -56,3 +56,29 @@ AC_DEFUN([SPL_AC_DEBUG_KMEM_TRACKING], [
    AC_MSG_CHECKING([whether detailed kmem tracking is enabled])
    AC_MSG_RESULT([$enable_debug_kmem_tracking])
 ])
+
+dnl #
+dnl # 5.8 API,
+dnl # __vmalloc PAGE_KERNEL removal
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL], [
+   ZFS_LINUX_TEST_SRC([__vmalloc], [
+       #include <linux/mm.h>
+       #include <linux/vmalloc.h>
+   ],[
+       void *p __attribute__ ((unused));
+
+       p = __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+   ])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL], [
+   AC_MSG_CHECKING([whether __vmalloc(ptr, flags, pageflags) is available])
+   ZFS_LINUX_TEST_RESULT([__vmalloc], [
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_VMALLOC_PAGE_KERNEL, 1, [__vmalloc page flags exists])
+   ],[
+       AC_MSG_RESULT(no)
+   ])
+])
+-
diff --git a/config/kernel.m4 b/config/kernel.m4
index b67fcef8c..23edfdcd8 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -45,6 +45,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
    ZFS_AC_KERNEL_SRC_SCHED
    ZFS_AC_KERNEL_SRC_USLEEP_RANGE
    ZFS_AC_KERNEL_SRC_KMEM_CACHE
+   ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_SRC_WAIT
    ZFS_AC_KERNEL_SRC_INODE_TIMES
    ZFS_AC_KERNEL_SRC_INODE_LOCK
@@ -163,6 +164,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
    ZFS_AC_KERNEL_SCHED
    ZFS_AC_KERNEL_USLEEP_RANGE
    ZFS_AC_KERNEL_KMEM_CACHE
+   ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_WAIT
    ZFS_AC_KERNEL_INODE_TIMES
    ZFS_AC_KERNEL_INODE_LOCK
diff --git a/include/spl/sys/kmem.h b/include/spl/sys/kmem.h
index 72d3a7765..ca15bfe7f 100644
--- a/include/spl/sys/kmem.h
+++ b/include/spl/sys/kmem.h
@@ -169,6 +169,15 @@ extern void *spl_kmem_alloc(size_t sz, int fl, const char *func, int line);
 extern void *spl_kmem_zalloc(size_t sz, int fl, const char *func, int line);
 extern void spl_kmem_free(const void *ptr, size_t sz);
 
+/*
+ * 5.8 API change, pgprot_t argument removed.
+ */
+#ifdef HAVE_VMALLOC_PAGE_KERNEL
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags, PAGE_KERNEL)
+#else
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags)
+#endif
+
 /*
  * The following functions are only available for internal use.
  */
diff --git a/module/spl/spl-kmem-cache.c b/module/spl/spl-kmem-cache.c
index d71b4b348..4866b2993 100644
--- a/module/spl/spl-kmem-cache.c
+++ b/module/spl/spl-kmem-cache.c
@@ -203,7 +203,7 @@ kv_alloc(spl_kmem_cache_t *skc, int size, int flags)
        ASSERT(ISP2(size));
        ptr = (void *)__get_free_pages(lflags, get_order(size));
    } else {
-       ptr = __vmalloc(size, lflags | __GFP_HIGHMEM, PAGE_KERNEL);
+       ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
    }
 
    /* Resulting allocated memory will be page aligned */
@@ -1242,7 +1242,7 @@ spl_cache_grow(spl_kmem_cache_t *skc, int flags, void **obj)
     * allocation.
     *
     * However, this can't be applied to KVM_VMEM due to a bug that
-    * __vmalloc() doesn't honor gfp flags in page table allocation.
+    * spl_vmalloc() doesn't honor gfp flags in page table allocation.
     */
    if (!(skc->skc_flags & KMC_VMEM)) {
        rc = __spl_cache_grow(skc, flags | KM_NOSLEEP);
diff --git a/module/spl/spl-kmem.c b/module/spl/spl-kmem.c
index cee69ad43..ca1fc145f 100644
--- a/module/spl/spl-kmem.c
+++ b/module/spl/spl-kmem.c
@@ -172,16 +172,15 @@ spl_kmem_alloc_impl(size_t size, int flags, int node)
         * kmem_zalloc() callers.
         *
         * For vmem_alloc() and vmem_zalloc() callers it is permissible
-        * to use __vmalloc().  However, in general use of __vmalloc()
-        * is strongly discouraged because a global lock must be
-        * acquired.  Contention on this lock can significantly
+        * to use spl_vmalloc().  However, in general use of
+        * spl_vmalloc() is strongly discouraged because a global lock
+        * must be acquired.  Contention on this lock can significantly
         * impact performance so frequently manipulating the virtual
         * address space is strongly discouraged.
         */
        if ((size > spl_kmem_alloc_max) || use_vmem) {
            if (flags & KM_VMEM) {
-               ptr = __vmalloc(size, lflags | __GFP_HIGHMEM,
-                   PAGE_KERNEL);
+               ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
            } else {
                return (NULL);
            }
-- 
2.25.1
#+end_src

**** export_kernel_fpu_functions_5_3.patch

#+begin_src diff :tangle (meq/tangle-path)
From 1e010beda2896bdf3082fb37a3e49f8ce20e04d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 2 May 2019 05:28:08 +0100
Subject: [PATCH] x86/fpu: Export kernel_fpu_{begin,end}() with
 EXPORT_SYMBOL_GPL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need these symbols in zfs as the fpu implementation breaks userspace:

https://github.com/zfsonlinux/zfs/issues/9346
Signed-off-by: Jörg Thalheim <joerg@thalheim.io>
---
 arch/x86/kernel/fpu/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 12c70840980e..352538b3bb5d 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -102,7 +102,7 @@ void kernel_fpu_begin(void)
    }
    __cpu_invalidate_fpregs_state();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_begin);
+EXPORT_SYMBOL(kernel_fpu_begin);
 
 void kernel_fpu_end(void)
 {
@@ -111,7 +111,7 @@ void kernel_fpu_end(void)
    this_cpu_write(in_kernel_fpu, false);
    preempt_enable();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_end);
+EXPORT_SYMBOL(kernel_fpu_end);
 
 /*
  * Save the FPU state (mark it for reload if necessary):
-- 
2.23.0
#+end_src

**** fetchpypi.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/fetchpypi.nix b/fetchpypi.nix
index e60c9df..df50c0d 100644
--- a/fetchpypi.nix
+++ b/fetchpypi.nix
@@ -24,5 +24,5 @@ in makeOverridable( {format ? "setuptools", sha256 ? "", hash ? "", ... } @attrs
   let
     url = computeUrl (builtins.removeAttrs attrs ["sha256" "hash"]) ;
   in fetchurl {
-    inherit url sha256 hash;
+    inherit url sha256;
   })
#+end_src

**** fetchurl.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/pkgs/build-support/fetchurl/boot.nix
+++ b/pkgs/build-support/fetchurl/boot.nix
@@ -6,7 +6,8 @@ let mirrors = import ./mirrors.nix; in
 , urls ? []
 , sha256
 , name ? baseNameOf (toString url)
-}:
+, ...
+} @ args:
 
 import <nix/fetchurl.nix> {
   inherit system sha256 name;
diff --git a/pkgs/build-support/fetchzip/default.nix b/pkgs/build-support/fetchzip/default.nix
index c61df8ceb00..d973837f0d3 100644
--- a/pkgs/build-support/fetchzip/default.nix
+++ b/pkgs/build-support/fetchzip/default.nix
@@ -14,7 +14,8 @@
 , name ? "source"
 , ... } @ args:
 
-(fetchurl ({
+let
+ x = (fetchurl ({
   inherit name;
 
   recursiveHash = true;
@@ -46,7 +47,11 @@
       mv "$unpackDir" "$out"
     '') #*/
     + extraPostFetch;
-} // removeAttrs args [ "stripRoot" "extraPostFetch" ])).overrideAttrs (x: {
+  } // removeAttrs args [ "stripRoot" "extraPostFetch" ]));
+
+in
+  x // {
+    # .overrideAttrs (x: {
   # Hackety-hack: we actually need unzip hooks, too
   nativeBuildInputs = x.nativeBuildInputs ++ [ unzip ];
-})
+}
#+end_src

**** grub_zfs.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -285,6 +285,7 @@ static const char *spa_feature_names[] = {
   "com.delphix:embedded_data",
   "com.delphix:extensible_dataset",
   "org.open-zfs:large_blocks",
+  "org.zfsonlinux:large_dnode",
   NULL
 };
#+end_src

**** set_power_mgmt.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/net/wireless/nl80211.c    2019-07-08 00:41:56.000000000 +0200
+++ b/net/wireless/nl80211.c    2020-02-05 19:30:26.352718504 +0100
@@ -10517,10 +10520,7 @@
    if (!rdev->ops->set_power_mgmt)
        return -EOPNOTSUPP;
 
-   state = (ps_state == NL80211_PS_ENABLED) ? true : false;
-
-   if (state == wdev->ps)
-       return 0;
+   state = false;
 
    err = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);
    if (!err)
#+end_src

*** users.json

#+call: hash() :exports none

#+RESULTS:
: 20210601185359809444000

#+name: 20210601185359809444000
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** profiles
**** server.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with lib; {
    services.openssh = {
        enable = true;
        extraConfig = mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
        '';
        permitRootLogin = "yes";
    };

    environment.systemPackages = with pkgs; [ inetutils mtr sysstat git ];
}
#+end_src

*** devices
**** linode.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../profiles/server.nix ];
    boot = {
        kernelParams = [ "console=ttyS0,19200n8" ];
        loader.grub.extraConfig = ''
            serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
            terminal_input serial;
            terminal_output serial;
        '';
        initrd.availableKernelModules = [ "virtio_pci" "ahci" "sd_mod" ];
    };
    networking = {
        usePredictableInterfaceNames = false;
        interfaces.eth0.useDHCP = true;
    };
}
#+end_src

**** rpi4.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports =  [
        ../minimal.nix
        ../profiles/server.nix
        (import ..).inputs.hardware.raspberry-pi-4
    ];
    boot.kernelPackages = lib.mkForce pkgs.linuxPackages_rpi4;
}
#+end_src

*** hosts

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

**** imports.nix

# TODO: remove ~bcachefs~

#+begin_src nix :tangle (meq/tangle-path)
[ ../minimal.nix ../bcachefs.nix ]
#+end_src

**** sandshrew
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        (import ../..).inputs.hardware.microsoft-surface
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
        networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env sh
        for usb in $(ls /dev/disk/by-id).split("\n"):
            if usb and usb[:4] == "usb-":
                for mnt in $(mount).split("\n"):
                    if mnt and usb in mnt:
                        umount @(mnt.split()[2])
    '';
}
#+end_src

**** siluam
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        "${(import ../..).inputs.pinebook-pro}/pinebook_pro.nix"
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    swapDevices = [ { device = "/dev/mmcblk2p2"; } ];
}
#+end_src

**** murasame
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = import ../imports.nix;
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** argus
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports = flatten [
        ../../devices/linode.nix
        import ../imports.nix
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** yggdrasil
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** enterprise
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

*** bcachefs.nix

# TODO: delete

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    boot = {
        supportedFilesystems = [ "bcachefs" ];
        initrd.supportedFilesystems = config.boot.supportedFilesystems;
    };
}
#+end_src

*** lib.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref lib.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<lib.nix>>
#+end_src

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

**** Arguments

#+begin_src nix
with builtins; { pkgs, lib, inputs ? {}, host ? "nixos", system ? currentSystem }: with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** New Lib

#+begin_src nix
newLib = self: rec {
#+end_src

****** Functions

#+begin_src nix
functions = rec {
#+end_src

******* Convert Path To Mount

#+begin_src nix
mntConvert = dir: let mntDir = "/mnt/" + dir; in if (pathExists mntDir) then mntDir else dir;
#+end_src

******* Zip To Set

#+begin_src nix
zipToSet = names: values: listToAttrs (
    map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
        if hasAttrs then names else (sort lessThan names)
    ) (
        if hasAttrs then values else (sort lessThan values)
    ))
);
#+end_src

******* Fold To Set

#+begin_src nix
# TODO: Why is the filter necessary?
foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);
#+end_src

******* My Conditionals

#+begin_src nix
myIf = {
    list = condition: value: optionals condition value;
    singleton = condition: value: optional condition value;
    set = condition: value: if condition then value else {};
    num = condition: value: if condition then value else 0;
    knull = condition: value: if condition then value else null;
    empty = condition: value: if condition then value else "";
    drv = condition: value: if condition then value else pkgs.hello;
};
#+end_src

******* Read Directory if Exists

#+begin_src nix
readDirExists = dir: myIf.set (pathExists dir) (readDir dir);
#+end_src

******* To Capital

#+begin_src nix
toCapital = string: concatImapStrings (
    i: v: if (i == 0) then (toUpper v) else v
) (stringToCharacters string);
#+end_src

******* Sequence

#+begin_src nix
sequence = list: end: foldr (a: b: deepSeq a b) end list;
#+end_src

******* Filters

#+begin_src nix
filters = {
#+end_src

******** Remove

#+begin_src nix
remove = {
#+end_src

********* Prefix

#+begin_src nix
prefix = ignores: list: filter (f: ! any (i: hasPrefix i f) ignores) list;
#+end_src

********* Suffix

#+begin_src nix
suffix = ignores: list: filter (f: ! any (i: hasSuffix i f) ignores) list;
#+end_src

********* Infix

#+begin_src nix
infix = ignores: list: filter (f: ! any (i: hasInfix i f) ignores) list;
#+end_src

********* End of Remove

#+begin_src nix
};
#+end_src

******** End of Filters

#+begin_src nix
};
#+end_src

******* Walk Dir Structure

#+begin_src nix
recurseDir = { dir, local ? false, iter ? 0, ignores ? {} }: with lib; let
    stringDir = toString dir;
    redDir = readDirExists dir;
    recurse = unique (flatten [
        (map (n: "${stringDir}/${n}") (attrNames (filterAttrs (n: v: v != "directory") redDir)))
        (map (dir': recurseDir { dir = "${stringDir}/${dir'}"; inherit local; iter = iter + 1; }) (attrNames (filterAttrs (n: v: v == "directory") redDir)))
    ]);
    processed-prefix = map (i: if (local == null) then i else if (local == 0) then "/${i}" else if local then "./${i}" else if (! local) then "${stringDir}/${i}" else i) (ignores.prefix or []);
    process' = recurse': let
        stringDir' = "${stringDir}/";
    in if (local == null) then (map (f: replaceStrings [ stringDir' ] [ "" ] f) recurse') else if (local == 0) then (map (f: replaceStrings [ stringDir' ] [ "/" ] f) recurse') else if local then (map (f: replaceStrings [ stringDir' ] [ "./" ] f) recurse') else recurse';
    process = recurse': with filters.remove; pipe recurse' [ process' (prefix processed-prefix) (suffix (ignores.suffix or [])) (infix (ignores.infix or [])) ];
in if (iter == 0) then (process recurse) else recurse;
#+end_src

******* Has A
******** Prefix

#+begin_src nix
hasAPrefix = prefixes: string: any (prefix: hasPrefix prefix string) prefixes;
#+end_src

******** Suffix

#+begin_src nix
hasASuffix = suffixes: string: any (suffix: hasSuffix suffix string) suffixes;
#+end_src

******** Infix

#+begin_src nix
hasAnInfix = infixes: string: any (infix: hasInfix infix string) infixes;
#+end_src

******* Import Stuff

#+begin_src nix
args = {
    suffix = "";
    ignores = [];
};

baseNameNoSuffix = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    file
}: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

# !!! This returns a function
filterFunc = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    ignores ? args.ignores,
    dir,
}: let
    _ignores = flatten [
        ignores
        (let _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix"); in myIf.list (pathExists _ignores') (import _ignores'))
        "default" # triggers infinite recursion if modules are defined here
        "deprecated"
        "nix" # niv
        "shell" # nix-shell
    ];
in file: value:
    (if noSuffix then (
        (hasSuffix ".nix" file) || (value == "directory")
    ) else (hasSuffix suffix file)) &&
    (!hasPrefix "_" file) &&
    (!elem (baseNameNoSuffix { inherit suffix file noSuffix; }) _ignores);

contents = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
}: filterAttrs (filterFunc _args) (readDir dir);

list = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/${n}"),

}: let
    __args = removeAttrs _args [ "func" ];
in mapAttrsToList func (contents __args);

listNames = {
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir
}: list {
    inherit suffix ignores dir;
    func = (n: v: baseNameNoSuffix { inherit suffix; file = n; });
};
#+end_src

Set Function:

#+begin_src nix
set = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
    modules ? {},

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/" + n),

}: let
    files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
in listToAttrs (map (file: nameValuePair
    (baseNameNoSuffix { inherit suffix file; })
    (import file (foldToSet [ modules inputs ]))
) files);
#+end_src

Deprecated Set Function:

#+begin_src nix :noweb-ref no
set = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
    modules ? {},

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/" + n),

}: let
    files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
in zipToSet
    (map (file: baseNameNoSuffix { inherit suffix file; }) files)
    (map (file: import file (foldToSet [ modules inputs ])) files);
#+end_src

******* End of Functions

#+begin_src nix
};
#+end_src

****** Attrs

#+begin_src nix
attrs = rec {
#+end_src

******* Machines

#+begin_src nix
machines = {
#+end_src

******** Relay

#+begin_src nix
relays = [ <<relays>> ];
#+end_src

******** No ZFS

#+begin_src nix
no-zfs = [ <<no-zfs>> ];
#+end_src

******** End of Machines

#+begin_src nix
};
#+end_src

******* Relay

#+begin_src nix
relay = elem host machines.relays;
not-relay = ! relay;
#+end_src

******* ZFS

#+begin_src nix
not-zfs = elem host machines.no-zfs;
zfs = ! not-zfs;
#+end_src

******* Configs

#+begin_src nix
configs = {
    nixpkgs = {
        allowUnfree = true;
        allowBroken = true;
        allowUnsupportedSystem = true;
        # preBuild = ''
        #     makeFlagsArray+=(CFLAGS="-w")
        #     buildFlagsArray+=(CC=cc)
        # '';
        permittedInsecurePackages = [
            "python2.7-cryptography-2.9.2"
        ];
    };
    nix = let
        MG = size: let
            mg = stringToCharacters size;
        in toString ((toInt (elemAt mg 0)) * (
            if (elemAt mg 1 == "M") then 1 else 1024
        ) * 1024 * 1024);
    in ''
        <<270d5d30-951e-4171-8c23-67fc45d20578()>>
        min-free = ${MG "250M"}
        max-free = ${MG "1G"}
    '';
    services = rec {
        mkBase = User: {
            enable = true;
            serviceConfig = rec {
                Restart = "on-failure";
                inherit User;
                Group = User;
                Environment = [ "PATH=/run/wrappers/bin:$PATH" ];
            };
            wantedBy = [ "multi-user.target" ];
        };
        base = mkBase users.primary;
        mkdir = path: "/run/current-system/sw/bin/mkdir -p ${path} &> /dev/null";
    };
};
#+end_src

******* Users

#+begin_src nix
users = fromJSON (readFile ./users.json);
excludedUsers = [ "root" ];
mainUsers = attrValues users;
allUsers = mainUsers ++ excludedUsers;
#+end_src

******** Homes

#+begin_src nix
homes = listToAttrs (map (
    user: nameValuePair user "/home/${user}"
) mainUsers);
allHomes = homes // { root = "/root"; };
#+end_src

******* Datasets

#+begin_src nix
datasets = {
    fileSystems = import ./datasets.nix host;
    backup = [
        "system/persist"
        "virt"
        "omniverse"
        users.primary
    ];
};
#+end_src

******* Platforms

#+begin_src nix
platforms = {
    arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
    imd = [ "i686-linux" "x86_64-linux" ];
};
arms = elem system platforms.arm;
no-arms = !arms;
#+end_src

******* SSH

#+begin_src nix
ssh.keys = rec {
    "id_rsa.bak" = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    "id_ed25519.bak" = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO8NzKV52dRBAir8ARoFJX/xQDVCNup6xe1ddX1YVXSO sylvorg@syvl.org";
    jeet_ray_ecdsa = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGsRy6rLDzmLNISdWahFLGDo+ZZLbndj6k8Q8MUQum/mPAzy8lsAQz/0XiicJz7LlM74tWGDYSJG1Ay2Iyc/ew4= jeet.ray@syvl.org";
    jeet_ray_ed25519 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICor+WXoAypnk5rkgTljAN6kk8olvKWqtnmGWVuQu8z9 jeet.ray@syvl.org";
    jeet_ray_rsa = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCs4zqEt/Fkjw0LVQTwJXlovmnqqGWC4UOVPvoLDvo0JD6WeVBDi4cFPX2mpNJYmYJsBLDXeUq5XrQ1ST3BkfVdspsragnD7O92tTEf3/VHfIC1L165pnB08FXQrtIjyLL7Ry4dloUGBYKLnHOtnXlpefKMQzRYUacc7Tr1o2wv+XRoDW9h+qDqJz1O61N68JFLgJWD3/nUkm8siTg1OLvqO9ATp+UgP/Lb08E6HfqYOiD8H+1ZJjz78mo5oZatknvgy8uJJPqEX7/aRM61YA9TG+tw/sf6wlrDtUQUik8Y4k1DLmkhE15wcgq/HF2Rqka/acA9GxA5smNGyjs6CS+H jeet.ray@syvl.org";
    shadowrylander_ecdsa = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNlVuY9reRuMloYvecJHHsOYkAPDyQwELOI3kfibslIKI5hY+o1jx5yVyAUomHynP6wulm5aziNc5kWdsRE9BE8= shadowrylander@syvl.org";
    shadowrylander_ed25519 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINZ2FCMbnetAnDZ63Wzct+O3MYhtO9+BedATbtiHI9BT shadowrylander@syvl.org";
    shadowrylander_rsa = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDP8ifT/3d6L2MzZPoTh0bUjQUXuPKfPP8Tp03E5En2x+iKhv+J/U0z0xk7IdPZ4qEO+ZWI5xWbwVkDdnRnJ/5HgA0/ZwmO5Zpj3llSr4dJMUVSSyO23fFIL2WqOpHyQDeexJWMxbU5SmIi+c855VwewCbGDcPnmDo0XgR/u4LRF2pwYGNGFtJ2/GICEIob/2w0ICwi7TMUEkDbUFcP5web81OzsNu80M60VaNl870uT1rwBeKuW7CXFtImYytZ0mOc5LC6d7ugkFS1zAbLOWjt3PJ8Op2MH9ncBj5jCsIlA/OqI72jKwEPOl8evYqWeEOzlVxA7/AkRj7haQqFE8r/ shadowrylander@syvl.org";
    id_rsa = shadowrylander_rsa;
    id_ed25519 = jeet_ray_ed25519;
};
#+end_src

******* Filesystems

#+begin_src nix
fileSystems = {
    base = {
        fsType = "zfs";
        options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
    };

    # TODO
    # supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat" "bcachefs" ];

    supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat" ];
};
#+end_src

******* Commands

#+begin_src nix
commands = {
    rebuild = "nixos-rebuild --impure";
    install = "nixos-install --impure --show-trace";
};
#+end_src

******* End of Attrs

#+begin_src nix
};
#+end_src

****** Paths

#+begin_src nix
paths = rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches.base = "${nixos}/patches";
};
#+end_src

****** End of New Lib

#+begin_src nix
};
#+end_src

***** Extension

#+begin_src nix
extension = makeExtensible newLib;
#+end_src

**** Extend

#+begin_src nix
in with lib; extension.extend (final: prev: foldr (new: old: recursiveUpdate new old) {} (attrValues prev))
#+end_src

*** callPackages
**** caddy.nix

Taken from [[https://github.com/NixOS/nixpkgs/issues/14671#issuecomment-1016376290][here]]; allows me to build caddy with plugins:

#+begin_src nix :tangle (meq/tangle-path)
{ lib, fetchFromGitHub, buildGoModule, plugins ? [], vendorSha256 ? "" }:

with lib;

let imports = flip concatMapStrings plugins (pkg: "\t\t\t_ \"${pkg}\"\n");

	main = ''
		package main

		import (
			caddycmd "github.com/caddyserver/caddy/v2/cmd"

			_ "github.com/caddyserver/caddy/v2/modules/standard"
${imports}
		)

		func main() {
			caddycmd.Main()
		}
	'';


in buildGoModule rec {
	pname = "caddy";
	version = "2.4.6";
  runVend = true;
	subPackages = [ "cmd/caddy" ];

  src = fetchFromGitHub {
    owner = "caddyserver";
    repo = "caddy";
    rev = "v${version}";
    sha256 = "sha256-xNCxzoNpXkj8WF9+kYJfO18ux8/OhxygkGjA49+Q4vY=";
  };

	inherit vendorSha256;

	overrideModAttrs = (_: {
		preBuild    = "echo '${main}' > cmd/caddy/main.go";
		postInstall = "cp go.sum go.mod $out/ && ls $out/";
	});

	postPatch = ''
		echo '${main}' > cmd/caddy/main.go
		cat cmd/caddy/main.go
	'';

	postConfigure = ''
		cp vendor/go.sum ./
		cp vendor/go.mod ./
	'';

	meta = {
		homepage = https://caddyserver.com;
		description = "Fast, cross-platform HTTP/2 web server with automatic HTTPS";
		license = licenses.asl20;
    maintainers = with maintainers; [ Br1ght0ne ];
	};
}
#+end_src

*** overlays.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref overlays.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<overlays.nix>>
#+end_src

**** Arguments

#+begin_src nix
args@{ lib, nixpkgs, inputs, pkgs, channel }: with builtins; with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** End of Let

#+begin_src nix
in flatten [
#+end_src

**** J

#+begin_src nix
(final: prev: { j = { inherit pkgs; };})
#+end_src

**** Patched Fetchers

#+begin_src nix :noweb-ref no
(final: prev: {
    fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchurl.patch ];});
    fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchpypi.patch ];});
})
#+end_src

**** NIX

# TODO

#+begin_src nix :noweb-ref no
inputs.nix.overlay
#+end_src

**** NUR

#+begin_src nix
(final: prev: { nur = import inputs.nur { nurpkgs = nixpkgs; pkgs = prev; }; })
#+end_src

**** Emacs

#+begin_src nix
inputs.emacs.overlay
#+end_src

**** Systemd
***** Homed

# TODO

#+begin_src nix :noweb-ref no
(final: prev: { systemd = prev.systemd.overrideAttrs (old: { withHomed = true; }); })
#+end_src

**** Containers
***** Extra-Containers

#+begin_src nix :noweb-ref no
inputs.extra-container.overlay
#+end_src

**** Caddy With Plugins

#+begin_src nix :noweb-ref no
(final: prev: { caddy = prev.callPackage ./callPackages/caddy.nix {
    plugins = [
        "github.com/mholt/caddy-l4@latest"
        "github.com/abiosoft/caddy-yaml@latest"
        "github.com/caddy-dns/cloudflare@latest"
    ];
}; })
#+end_src

**** Mozilla

# TODO

#+begin_src nix :noweb-ref no
(final: prev: inputs.mozilla.overlays)
#+end_src

**** Overlays in Overlays Directory

#+begin_src nix
(map (file:
    (final: prev: {
        "${j.functions.name { inherit file; }}" = import file args;
    })
) (j.functions.list { dir = ./overlays; }))
#+end_src

**** Overrides from Older Channels

#+begin_src nix
(let pkgsets = {
    # nixos-unstable = [ "networkmanager" "gnome-control-center" "bash" "bootstrap-tools" { gcc10 = "gcc11"; } ];
    # nixos-unstable = "nix";
};
in mapAttrsToList (
    pkgchannel: pkglist': let
        pkglist = if (isString pkglist') then [ pkglist' ] else pkglist';
    in map (
        pkg': let
            pkgIsAttrs = isAttrs pkg';
            pkg1 = if pkgIsAttrs then (last (attrNames pkg')) else pkg';
            pkg2 = if pkgIsAttrs then (last (attrValues pkg')) else pkg';
            self = (pkgchannel == channel) || (pkgchannel == "self");
        in (final: prev: { "${pkg1}" = if self then prev.${pkg2} else final.j.pkgs.${pkgchannel}.${pkg2}; })
    ) pkglist
) pkgsets)
#+end_src

**** Guix

#+begin_src nix :noweb-ref no
(final: prev: { guix = final.callPackage "${fetchGit { url = "https://github.com/${j.attrs.users.primary}/nixpkgs"; ref = "guix"; }}/pkgs/development/guix/guix.nix" {  }; })
#+end_src

**** End of overlays.nix

#+begin_src nix
]
#+end_src

*** flake.nix

#+begin_src nix :tangle (meq/tangle-path)
{
    nixConfig = {
        # Adapted From: https://github.com/divnix/digga/blob/main/examples/devos/flake.nix#L4
        <<270d5d30-951e-4171-8c23-67fc45d20578(flake='t)>>
    };

    inputs = rec {
        # nixos-unstable.url = github:NixOS/nixpkgs/nixos-unstable;
        nixos-unstable.url = "https://nixos.org/channels/nixos-unstable/nixexprs.tar.xz";

        # nixos-unstable-small.url = github:NixOS/nixpkgs/nixos-unstable-small;
        nixos-unstable-small.url = "https://nixos.org/channels/nixos-unstable-small/nixexprs.tar.xz";

        # nixos-21-11.url = github:NixOS/nixpkgs/nixos-21.11;
        nixos-21-11.url = "https://nixos.org/channels/nixos-21.11/nixexprs.tar.xz";

        # nixos-21-11-small.url = github:NixOS/nixpkgs/nixos-21.11-small;
        nixos-21-11-small.url = "https://nixos.org/channels/nixos-21.11-small/nixexprs.tar.xz";

        release-21-11.url = github:NixOS/nixpkgs/release-21.11;

        master.url = github:NixOS/nixpkgs/master;

        j.url = github:<<username>>/nixpkgs/j;

        nixpkgs.follows = "j";

        hardware.url = github:nixos/nixos-hardware;

        pinebook-pro = {
            url = github:samueldr/wip-pinebook-pro;
            flake = false;
        };

        <<username>> = {
            url = github:<<username>>/<<username>>;
            flake = false;
        };

        flake-compat = {
            url = github:edolstra/flake-compat;
            flake = false;
        };

        home-manager.url = github:nix-community/home-manager;
        impermanence.url = github:nix-community/impermanence;

        nix.url = github:nixos/nix;
        extra-container.url = github:erikarvstedt/extra-container;
        nur.url = github:nix-community/nur;
        emacs.url = github:nix-community/emacs-overlay;
        mozilla.url = github:mozilla/nixpkgs-mozilla;

        flake-utils.url = github:numtide/flake-utils;
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let
        channel = "j";
        make = {
            pre-pkgs = system: import nixpkgs { inherit system; };
            lib = host: system: nixpkgs.lib.extend (final: prev: {
                j = import ./lib.nix ({
                    inherit inputs system;
                    pkgs = make.pre-pkgs system;
                    lib = final;
                } // (if (host == null) then {} else { inherit host; }));
            });
            pre-nixpkgset = system: lib: { inherit system; config = lib.j.attrs.configs.nixpkgs; };
            overlays = system: lib: import ./overlays.nix {
                inherit lib nixpkgs inputs channel;
                pkgs = mapAttrs (n: v: import v (make.pre-nixpkgset system lib)) (
                    (filterAttrs (n: v: (hasPrefix "nixos-" n) || (hasPrefix "release-" n)) inputs) //
                    (with inputs; { inherit master j; })
                );
            };
            nixpkgset = overlays: system: lib: { inherit overlays system; config = lib.j.attrs.configs.nixpkgs; };
            pkgs = nixpkgset: import nixpkgs nixpkgset;
            specialArgs = name: system: rec {
                inherit inputs nixpkgs system;
                host = name;
                lib = make.lib name system;
                pre-nixpkgset = make.pre-nixpkgset system lib;
                overlays = make.overlays system lib;
                nixpkgset = make.nixpkgset overlays system lib;
                pkgs = make.pkgs nixpkgset;
            };
            config = name: system: nixosSystem rec {
                specialArgs = make.specialArgs name system;
                modules = with inputs; let
                    j-list = specialArgs.lib.j.functions.list;
                in flatten [
                    "${toString ./.}/hosts/${name}"
                    home-manager.nixosModules.home-manager
                    impermanence.nixosModules.impermanence
                    (j-list { dir = ./modules; })
                    (j-list { dir = ./secrets; })
                ];
            };
            nixosConfiguration = system: { packages.nixosConfigurations = listToAttrs (map
                (name: nameValuePair name (make.config name system))
                (attrNames (filterAttrs (n: v: v == "directory") (readDir ./hosts)))
            ); };
        };
    in (eachSystem allSystems make.nixosConfiguration) // { inherit make channel; };
}
#+end_src

*** minimal.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref minimal.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<minimal.nix>>
#+end_src

**** Arguments

#+begin_src nix
with builtins; args@{ config, ... }:
#+end_src

**** Config Let

#+begin_src nix
let
#+end_src

***** Flake

#+begin_src nix
flake = import ./.;
#+end_src

****** Inheritance

#+begin_src nix
system = args.system or currentSystem;
host = args.host or config.networking.hostName;
fromFlake = args ? inputs;
inheritanceSet = if fromFlake then args else (flake.make.specialArgs host system);
inherit (inheritanceSet) lib overlays nixpkgset pkgs;
#+end_src

***** Config Repo

#+begin_src nix
dir = "${lib.j.attrs.homes.${lib.j.attrs.users.primary}}/.local/share/yadm/repo.git";
dirExists = pathExists dir;
repo = with lib; j.functions.mntConvert (if dirExists then (fetchGit { url = "file://${dir}"; ref = "main"; }) else flake.inputs.${j.attrs.users.primary});
#+end_src

***** Configurations

#+begin_src nix
nixos = "${(args.nixpkgs or <nixpkgs>)}/nixos";
nixos-configuration = configuration: import nixos { configuration = import configuration (args // inheritanceSet); inherit system; };
nixos-configurations = {
    server = nixos-configuration ./profiles/server.nix;
    configuration = nixos-configuration ./configuration.nix;
    hardware-configuration = import nixos { inherit system; configuration.imports = [
        ./hardware-configuration.nix
        ({config, ... }: { networking.hostId = substring 0 8 (readFile "/etc/machine-id"); boot.loader.grub.devices = [ "nodev" ]; })
    ]; };
};
#+end_src

**** Begin Set

#+begin_src nix
in with lib; {
#+end_src

**** Imports

#+begin_src nix
imports = with flake.inputs; flatten [
    (if fromFlake then [] else [ home-manager.nixosModules.home-manager impermanence.nixosModules.impermanence ])
];
#+end_src

**** Config

#+begin_src nix
# config = (removeAttrs nixos-configurations.hardware-configuration.config [ "fileSystems" "nesting" "jobs" "fonts" "meta" "documentation" ]) // {
config = (filterAttrs (n: v: elem n [ "boot" "networking" "powerManagement" "hardware" ]) nixos-configurations.hardware-configuration.config) //

    # TODO: What exactly from `system' am I taking? Merge it explicitly.
    # (if fromFlake then (filterAttrs (n: v: elem n [ "system" ]) nixos-configurations.configuration.config) else {}) //

{
#+end_src

***** Boot

#+begin_src nix
boot = {
#+end_src

****** Supported Filesystems

#+begin_src nix
supportedFilesystems = j.attrs.fileSystems.supported;
#+end_src

****** Initrd

#+begin_src nix
initrd = {
    inherit (config.boot) supportedFilesystems;
    compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
    network.ssh.enable = true;
};
#+end_src

****** Extra Modprobe Config

#+begin_src nix
extraModprobeConfig = '' options kvm_intel_nested=1 '';
#+end_src

****** Loader

#+begin_src nix
loader = {
    generic-extlinux-compatible.enable = mkForce false;
    systemd-boot = {
        configurationLimit = 25;
        editor = mkForce false;
        # enable = mkForce false;
        enable = mkForce true;
    };
    grub = {
        # enable = mkForce true;
        enable = mkForce false;
        efiSupport = true;
        efiInstallAsRemovable = mkForce false;
        # efiInstallAsRemovable = mkForce true;
        # devices = [ "nodev" ];
        # device = "nodev";
        device = if config.boot.loader.grub.efiSupport then config.boot.loader.efi.efiSysMountPoint else "/boot";
        version = 2;
        useOSProber = true;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';
    };
    efi = {
        canTouchEfiVariables = mkForce true;
        # canTouchEfiVariables = mkForce false;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    # Also causing EFI stuff not to be installed
    # initScript.enable = mkForce true;

};
#+end_src

****** Kernel

# TODO: Use one of these with ~bcachefs~

#+begin_src nix
# kernelPackages = mkDefault pkgs.linuxPackages_xanmod;
# kernelPackages = mkDefault pkgs.linuxPackages_lqx;
# kernelPackages = mkDefault pkgs.linuxPackages_zen;
#+end_src

******* Patches

#+begin_src nix
kernelPatches = [
#+end_src

******** ZSTD Kernel Compression

# TODO

#+begin_src nix :noweb-ref no
{
    name = "Enable ZSTD Compression";
    patch = null;
    extraConfig = ''
        RD_ZSTD y
        KERNEL_ZSTD y
        KERNEL_XZ n
    '';
}
#+end_src

******** Bcachefs

#+begin_src nix
(last (filter (set: hasPrefix "bcachefs-" set.name) pkgs.linuxKernel.kernels.linux_testing_bcachefs.kernelPatches))
#+end_src

******** End of Kernel Patches

#+begin_src nix
];
#+end_src

******* Extra Module Packages

#+begin_src nix
extraModulePackages = with config.boot.kernelPackages; [
    zfsUnstable
];
#+end_src

******* ZFS

#+begin_src nix
kernelModules = [ "zfs" ];
kernelParams = [ "nohibernate" ];
# loader.grub.zfsSupport = mkIf j.attrs.zfs true;
initrd = {
    postDeviceCommands = mkIf j.attrs.zfs (mkAfter (concatMapStrings (d: "zfs rollback -r ${d}@blank\n") (filter (d: (j.functions.hasAPrefix [
        "${host}/system/home"
    ] d) || (elem d [
        "${host}/system/root"
        # "${host}/system/tmp"
    ])) (attrNames j.attrs.datasets.fileSystems))));
    kernelModules = [ "zfs" "r8169" ];
    availableKernelModules = config.boot.initrd.kernelModules;
};
zfs = mkIf j.attrs.zfs {
    requestEncryptionCredentials = true;
    enableUnstable = true;
    devNodes = "/dev/";
};
#+end_src

****** End of Boot

#+begin_src nix
};
#+end_src

***** Console

#+begin_src nix
console = {
    # Select internationalisation properties.
    # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
    font = "Cartograph CF Extra Bold Italic";
    keyMap = "us";
};
#+end_src

***** Environment

#+begin_src nix
environment = {
#+end_src

****** Etc

#+begin_src nix
etc."nix/nix.conf".text = mkForce j.attrs.configs.nix;
#+end_src

****** System Packages

#+begin_src nix
systemPackages = with pkgs; flatten [
    cachix
    pkgs.j.pkgs.j.xonsh.buildInputs
];
#+end_src

****** ZFS

#+begin_src nix
persistence = mkIf j.attrs.zfs (let
    rootDirSet = {
        user = "root";
        group = "root";
    };
    rootFileSet.parentDirectory = rootDirSet;
in {
    "/persist/root" = {
        hideMounts = true;
        files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // rootFileSet) else (rootFileSet // file)) (flatten [
            "/etc/host"
            "/etc/machine-id"

            # (map (directory: map (fd: "/${directory}/${fd}") (attrNames (filterAttrs (n: v: v != "directory") (let path = "${repo}/${directory}"; in j.functions.readDirExists path)))) [
            #     "etc"
            #     "var"
            # ])

            (map (directory: j.functions.recurseDir { dir = "${repo}/${directory}"; local = 0; ignores.prefix = [ "nixos/" ]; }) [
                "etc"
                "var"
            ])
        ]));
        directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // rootDirSet) else (rootDirSet // directory)) (flatten [
            "/bin"
            "/etc/containers"
            "/etc/NetworkManager/system-connections"
            "/etc/nixos"

            # TODO: Prevents `sshd_config' itself from being created
            # "/etc/ssh"

            "/sbin"
            "/snap"
            "/usr"
            "/var/lib/acme"
            "/var/lib/bluetooth"
            "/var/lib/systemd/coredump"
            "/var/log"

            # (map (directory: map (fd: "/${directory}/${fd}") (attrNames (filterAttrs (n: v: v == "directory") (let path = "${repo}/${directory}"; in j.functions.readDirExists path)))) [
            #     "etc"
            #     "var"
            # ])
        ]));
    };
    "/persist" = let
        redRepo = readDir repo;
        redRepoFiles = flatten [
            (attrNames (filterAttrs (n: v: v != "directory") redRepo))
        ];
        redRepoDirectories = flatten [
            (attrNames (filterAttrs (n: v: v == "directory") redRepo))
        ];
    in {
        users = listToAttrs (map (user: let
            home = j.attrs.allHomes.${user};
            userDirSet = {
                inherit user;
                group = user;
            };
            userFileSet.parentDirectory = userDirSet;
            predRepo = let pHome = "/persist/${home}"; in j.functions.readDirExists pHome;
            predRepoFiles = flatten [
                (attrNames (filterAttrs (n: v: v != "directory") predRepo))
            ];
            predRepoDirectories = flatten [
                (attrNames (filterAttrs (n: v: v == "directory") predRepo))
            ];
        in nameValuePair user {
            inherit home;
            files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // userFileSet) else (userFileSet // file)) (flatten [
                ".bash_history"
                ".emacs-profile"
                ".fasd"
                ".gitignore"
                ".globalignore"
                ".nix-channels"
                ".python-history"
                ".screenrc"
                ".viminfo"
                ".zsh_history"
                redRepoFiles
            ]));
            directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // userDirSet) else (userDirSet // directory)) (flatten [
                ".atom"
                ".byobu"
                ".cache"
                ".caddy"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".repos"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                ".z"
                "Documents"
                "Downloads"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "tests"
                "Videos"
                "VirtualBox VMs"
                { directory = ".gnupg"; mode = "0700"; }
                { directory = ".nixops"; mode = "0700"; }
                { directory = ".ssh"; mode = "0700"; }
                redRepoDirectories
            ]));}) j.attrs.allUsers);
    };
});
#+end_src

****** End of Environment

#+begin_src nix
};
#+end_src

***** Memory

#+begin_src nix
zramSwap = {
    enable = true;
    algorithm = "zstd";
};
#+end_src

***** Filesystems

#+begin_src nix
fileSystems = let
    inherit (j.attrs.fileSystems) base;
in mkMerge [
    # (filterAttrs (n: v: !elem "bind" v.options) nixos-configurations.hardware-configuration.config.fileSystems)
    (filterAttrs (n: v: elem n [ "/boot" "/boot/efi" ]) nixos-configurations.hardware-configuration.config.fileSystems)
    (mkIf j.attrs.zfs (mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
        mkForce (base // { device = dataset; ${
            j.functions.myIf.knull ((j.functions.hasAnInfix [
                j.attrs.users.primary
                "persist"
                "home"
            ] dataset) || (elem dataset [ ])) "neededForBoot"
        } = true; })
    )) j.attrs.datasets.fileSystems))
];
#+end_src

***** Hardware

#+begin_src nix
hardware = {
    enableRedistributableFirmware = lib.mkDefault true;
    # Enable sound
    pulseaudio.enable = true;
};
sound.enable = true;
#+end_src

***** Networking

#+begin_src nix

networking = {
    networkmanager.enable = mkForce true;
    interfaces = if fromFlake then (mapAttrs (n: v: v // {
        useDHCP = mkForce (! config.networking.networkmanager.enable);
        wakeOnLan.enable = true;
    }) (filterAttrs (n: v: !elem n [ "wg0" ]) nixos-configurations.configuration.config.networking.interfaces)) else {};

    # The global useDHCP flag is deprecated, therefore explicitly set to false here.
    # Per-interface useDHCP will be mandatory in the future, so this generated config
    # replicates the default behaviour.
    useDHCP = false;

    # Configure network proxy if necessary
    # proxy = {
    # default = "http://user:password@proxy:port/";
    # noProxy = "127.0.0.1,localhost,internal.domain";
    # };

    # Or disable the firewall altogether.
    # enable = false;
    # };

    wireguard.interfaces.wg0 = {
        generatePrivateKeyFile = true;
        privateKeyFile = "/persist/etc/wireguard/wg0";
    };

    firewall = mkIf j.attrs.relay {
        allowedTCPPorts = [ 22 80 222 443 2022 8080 9418 ];
        allowedUDPPortRanges = [
            {
                from = 60000;
                to = 61000;
            }
        ];
    };
};
#+end_src

***** Nix

#+begin_src nix
nix = rec {
    gc = j.functions.foldToSet [
        { automatic = true; }
        { dates = "monthly"; }
        # {
        #   dates = "monthly";
        #   options = "-d";
        # }
        # {
        #   dates = "daily";
        #   options = "--delete-older-than 30d";
        # }
    ];
    optimise = {
        automatic = true;
        dates = [ "05:00" ];
    };
    extraOptions = j.attrs.configs.nix;
    settings = {
        auto-optimise-store = true;
        sandbox = true;
    };
    # sandboxPaths = [];
};
#+end_src

***** Nixpkgs

#+begin_src nix
nixpkgs = nixpkgset;
#+end_src

***** Power

#+begin_src nix
services.logind.lidSwitch = "hybrid-sleep";
powerManagement = {
    enable = true;
    cpuFreqGovernor = mkForce "ondemand";
};
#+end_src

***** Programs

#+begin_src nix
programs = {
    xonsh.enable = true;
    fish.enable = true;
    zsh.enable = true;
    tmux = {
        enable = true;
        extraConfig = ''
            <<20211018140524183223400>>
        '';
    };
};
#+end_src

***** Services

#+begin_src nix
services = {
#+end_src

****** SSH

#+begin_src nix
openssh = mkForce nixos-configurations.server.config.services.openssh;
#+end_src

****** UDEV

#+begin_src nix
udev.extraRules = mkIf j.attrs.zfs ''
    ACTION=="add|change", KERNEL=="sd[a-z]*[0-9]*|mmcblk[0-9]*p[0-9]*|nvme[0-9]*n[0-9]*p[0-9]*", ENV{ID_FS_TYPE}=="zfs_member", ATTR{../queue/scheduler}="none"
''; # zfs already has its own scheduler. without this my(@Artturin) computer froze for a second when i nix build something.
#+end_src

****** XServer

#+begin_src nix :noweb-ref no
xserver = {
    enable = true;
    layout = "us";
    # xkbOptions = "eurosign:e";
    # Enable touchpad support.
    libinput = {
        enable = true;
        touchpad = {
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
        };
    };
    # synaptics.enable = true;
    desktopManager.gnome.enable = true;
    displayManager = {
        startx.enable = true;
        lightdm.enable = mkForce false;
    };
    autorun = false;
};
#+end_src

****** End of Services

#+begin_src nix
};
#+end_src

***** Users

#+begin_src nix
users = with j.attrs.users; let
    base = {
        hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
        isNormalUser = true;
        createHome = true;
        extraGroups = [
            "wheel"
            "networkmanager"
            "persist"
            "libvirtd"
            "docker"
        ];
        openssh.authorizedKeys.keys = unique (flatten [
            (attrValues j.attrs.ssh.keys)
        ]);
    };
in rec {
    users = mkMerge [
        (genAttrs j.attrs.allUsers (user: base))
        {
            "${primary}" = {
                uid = 4362;
                home = j.attrs.homes.${primary};
                description = "Jeet Ray";
                group = primary;
                extraGroups = [ secondary ];
                shell = pkgs.xonsh;
            };
            "${secondary}" = {
                uid = 1111;
                home = j.attrs.homes.${secondary};
                description = "Alicia Summers";
                group = secondary;
                extraGroups = [ primary ];
                shell = pkgs.fish;
            };
            "${nightingale}" = {
                uid = 8888;
                home = j.attrs.homes.${nightingale};
                description = "Curtis Nightingale";
                group = "root";
                extraGroups = [ primary secondary ];
                shell = pkgs.zsh;
            };
            root = {
                shell = mkForce pkgs.zsh;
                home = j.attrs.allHomes.root;
                isNormalUser = mkForce false;
                isSystemUser = mkForce true;
            };
        }
    ];

    mutableUsers = false;

    groups = {
        "${primary}" = {
            gid = config.users.users.${primary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${secondary}" = {
            gid = config.users.users.${secondary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${nightingale}" = {
            gid = config.users.users.${nightingale}.uid;
            members = [ nightingale ];
        };
    };
};
#+end_src

***** End of Config

#+begin_src nix
};
#+end_src

**** End of minimal.nix

#+begin_src nix
}
#+end_src

*** modules
**** boot.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    boot = {
        binfmt.emulatedSystems = [
            "armv7l-linux"
            "aarch64-linux"
        ];
        extraModulePackages = with config.boot.kernelPackages; [
            # anbox
            # wireguard
        ];
    };
}
#+end_src

**** environment.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    environment = {
        pathsToLink = [ "/share/nix-direnv" ];
        systemPackages = [
            # bcachefs-tools
            acpilight
            alacritty
            asdf-vm
            assh
            atom
            autojump
            autossh
            bat
            bc
            btrfs-progs
            byobu
            cascadia-code
            cmake
            copyq
            coreutils
            ctop
            curl
            darling-dmg
            # ddar
            direnv
            diskus
            dos2unix
            duf
            elvish
            emacs
            entr
            exa
            exfat
            # extra-container
            fasd
            fd
            fd
            fff
            ffmpeg
            figlet
            filet
            firefox
            fish
            fzf
            gcc
            git
            git-crypt
            git-filter-repo
            git-fire
            git-lfs
            gitoxide
            glances
            gnumake
            google-chrome google-chrome-beta google-chrome-dev
            gotop
            gparted
            gptfdisk
            # haskellPackages.hocker
            inetutils
            j-settings
            jupyter
            keybase-gui kitty
            libffi
            libguestfs
            libsForQt5.qtstyleplugin-kvantum
            libtool
            lolcat
            lorri
            man
            micro
            mkpasswd
            monkeysphere
            mosh
            mtr
            neo-cowsay
            neovim
            niv
            nix-direnv
            nnn
            nodePackages.prettier
            nox
            ntfs3g nixos-shell
            pandoc
            par2cmdline
            parted pmutils
            peru
            pfetch
            pypy
            python310
            python39Packages.pipx
            ranger
            refind
            ripgrep
            rsync
            sd
            shadowfox
            shellcheck
            silver-searcher
            snapper
            spacevim
            sqlite
            starship
            sysstat
            thefuck
            thermald
            tmux
            tmuxp
            tree
            udftools
            ulauncher
            uutils-coreutils
            vagrant
            vim
            vivaldi vivaldi-ffmpeg-codecs vivaldi-widevine
            vlc
            vscode vscodium
            wget
            win-qemu
            woeusb
            wtf
            xclip
            xclip
            xfce.thunar
            xz
            yubico-pam yubico-piv-tool yubikey-manager yubikey-agent yubikey-personalization yubioath-desktop
            yubikey-manager-qt yubikey-personalization-gui
            zenith
            zsh
            zoxide
        ] ++ (map (pkg: pkgs.gnome."gnome-${pkg}") [
            "boxes"
            "characters"
            "tweaks"
            "session"
        ]) ++ (map (pkg: pkgs."nix-prefetch-${pkg}") [
            "github"
            "docker"
            "scripts"
        ]) ++ (with pkgs.gnome; [
            dconf-editor
        ]) ++ (with pkgs.gitAndTools; [
            git-extras
            git-hub
            gitflow
            gh
            hub
            lab
        ]) ++ (with pkgs.python310Packages; [
            black
            black-macchiato
            poetry
            jupyterlab
            xonsh
        ]);
    };
}
#+end_src

**** miscellaneous.nix

#+begin_quote
Help is available in the configuration.nix(5) man page and in the NixOS manual (accessible by running 'nixos-help').
#+end_quote

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, system, ... }: with lib;

{
    xdg.portal = {
        enable = mkForce j.attrs.no-arms;
        extraPortals = map (portal: pkgs."xdg-desktop-portal-${portal}") [ "gtk" "kde" ];
    };
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. It's perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            # flake = "https://github.com/nixos/nixpkgs/archive/master.tar.gz";
            flake = "https://github.com/${j.attrs.users.primary}/nixpkgs/archive/j.tar.gz";
        };
    };
}
#+end_src

**** programs.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    programs = {
        extra-container.enable = true;
    };
}
#+end_src

**** home-manager.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with lib;

{
    home-manager = {
        useGlobalPkgs = true;
        users = j.functions.foldToSet [
            listToAttrs (map (user: nameValuePair user {
                home = {
                    homeDirectory = j.attrs.homes.${user};
                    file.<<20220205031620372930929>>.source = repo;
                };
            }) j.attrs.allUsers)
        ];
    };
}
#+end_src

**** security.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

**** services.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref services.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<services.nix>>
#+end_src

#+begin_src nix
{ config, lib, pkgs, system, host, ... }: with lib;

{
    services = {
#+end_src

***** Emacs

#+begin_src nix
emacs = {
    package = pkgs.emacsGcc;
    enable = true;
    defaultEditor = true;
};
#+end_src

***** Flatpak

#+begin_src nix
# flatpak.enable = j.attrs.no-arms;
flatpak.enable = true;
#+end_src

***** Guix

#+begin_src nix
guix.enable = true;
#+end_src

***** Printing

#+begin_src nix
printing.enable = true;
#+end_src

***** Yubikey

#+begin_src nix
udev.packages = with pkgs; [
    yubikey-personalization
    libu2f-host
];
pcscd.enable = true;
#+end_src

***** ZFS

#+begin_src nix
zfs = mkIf j.attrs.zfs {
    trim.enable = true;
    autoScrub.enable = true;

    # Managed by Sanoid
    autoSnapshot.enable = false;
};
#+end_src

****** Sanoid

#+begin_src nix
sanoid = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) (flatten [
        j.attrs.datasets.backup
        host
    ]));
};
#+end_src

****** Syncoid

#+begin_src nix
syncoid = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        # (mkIf vars.encrypted {
        #     sendOptions = "vvwRI";
        #     recvOptions = "vvFs";
        # })
        # (mkIf (!vars.encrypted) {
        #     recvOptions = "vvFds";
        #     sendOptions = "vvRI";
        # })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) (flatten [
        j.attrs.datasets.backup
        host
    ]));
};
#+end_src

***** End of services.nix

#+begin_src nix
};}
#+end_src

**** systemd.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, host, ... }: with lib;

{
    systemd = {
        # packages = with pkgs; [ runit ];
        services = {
            # runit.enable = true;
            caddy = mkIf j.attrs.relay (j.attrs.configs.services.base // {
                serviceConfig = {
                    ExecStart = ''
                        ${pkgs.caddy}/bin/caddy run --config ${j.attrs.homes.${j.attrs.users.primary}}/.config/caddy/files/${host} --adapter yaml 2>&1
                    '';
                    ExecStop = ''
                        pkill caddy
                    '';
                };
            });
        };
    };
}
#+end_src

**** virtualisation.nix

#+begin_src nix
{ config, pkgs, ... }:

{
    virtualisation = {
        xen.enable = false;
        lxd.zfsSupport = mkIf j.attrs.zfs true;
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = mkIf j.attrs.zfs "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

** nix
*** nix.conf

Adapted from [[][here]]:

#+name: 270d5d30-951e-4171-8c23-67fc45d20578
#+begin_src emacs-lisp :var delim="" comment="" quoted='nil flake='nil
;; (format-spec "extra-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/ https://sylvorg.cachix.org/%q%d
(format-spec "trusted-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/ https://sylvorg.cachix.org/%q%d
# extra-trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= sylvorg.cachix.org-1:xd1jb7cDkzX+D+Wqt6TemzkJH9u9esXEFu1yaR9p8H8=%q%d
trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= sylvorg.cachix.org-1:xd1jb7cDkzX+D+Wqt6TemzkJH9u9esXEFu1yaR9p8H8=%q%d
%ckeep-derivations = true%d
%ckeep-outputs = true%d
extra-experimental-features = %qnix-command flakes%q%d
%callow-unsafe-native-code-during-evaluation = true%d
%cmin-free = 262144000%d
%cmax-free = 1073741824%d" `((?d . ,(if flake ";" delim)) (?c . ,(if flake "# " comment)) (?q . ,(if (or flake quoted) "\"" ""))))
#+end_src

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** zsh
*** keephack

#+call: hash() :exports none

#+RESULTS:
: 20210601185403002625400

#+name: 20210601185403002625400
#+begin_src emacs-lisp
(concat
    (let
        ((file "~/resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+begin_src sh :tangle (meq/tangle-path)
<<20210601185403002625400()>>
#+end_src

** sv

I just keeping these here for reference.

*** caddy
**** log
***** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
exec svlogd -tt /etc/sv/caddy/log
#+end_src

**** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
for port in 22 80 222 443 2022 8080 9418 60000:61000/udp; do
    ufw allow $port &> /dev/null
done
chmod +x /etc/sv/caddy/{finish,log/run}
exec /usr/bin/caddy run --config /.config/caddy/files/<<hostname>> --adapter yaml 2>&1
#+end_src

**** finish

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
killall caddy
#+end_src

* .gitattributes

The LFS filter are from both
[[https://raw.githubusercontent.com/sindresorhus/binary-extensions/main/binary-extensions.json][here]] and
[[https://rehansaeed.com/gitattributes-best-practices/#final-form][here]]:

#+begin_src gitattributes :tangle (meq/tangle-path)
*.3dm filter=lfs diff=lfs merge=lfs -text
*.3ds filter=lfs diff=lfs merge=lfs -text
*.3g2 filter=lfs diff=lfs merge=lfs -text
*.3gp filter=lfs diff=lfs merge=lfs -text
*.7z filter=lfs diff=lfs merge=lfs -text
*.a filter=lfs diff=lfs merge=lfs -text
*.aac filter=lfs diff=lfs merge=lfs -text
*.aax filter=lfs diff=lfs merge=lfs -text
*.adp filter=lfs diff=lfs merge=lfs -text
*.ai filter=lfs diff=lfs merge=lfs -text
*.aif filter=lfs diff=lfs merge=lfs -text
*.aiff filter=lfs diff=lfs merge=lfs -text
*.alz filter=lfs diff=lfs merge=lfs -text
*.ape filter=lfs diff=lfs merge=lfs -text
*.apk filter=lfs diff=lfs merge=lfs -text
*.appimage filter=lfs diff=lfs merge=lfs -text
*.ar filter=lfs diff=lfs merge=lfs -text
*.arj filter=lfs diff=lfs merge=lfs -text
*.asf filter=lfs diff=lfs merge=lfs -text
*.au filter=lfs diff=lfs merge=lfs -text
*.avi filter=lfs diff=lfs merge=lfs -text
*.bak filter=lfs diff=lfs merge=lfs -text
*.baml filter=lfs diff=lfs merge=lfs -text
*.bh filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text
*.bk filter=lfs diff=lfs merge=lfs -text
*.bmp filter=lfs diff=lfs merge=lfs -text
*.br filter=lfs diff=lfs merge=lfs -text
*.btif filter=lfs diff=lfs merge=lfs -text
*.bz2 filter=lfs diff=lfs merge=lfs -text
*.bzip2 filter=lfs diff=lfs merge=lfs -text
*.cab filter=lfs diff=lfs merge=lfs -text
*.caf filter=lfs diff=lfs merge=lfs -text
*.cgm filter=lfs diff=lfs merge=lfs -text
*.class filter=lfs diff=lfs merge=lfs -text
*.cmx filter=lfs diff=lfs merge=lfs -text
*.cpio filter=lfs diff=lfs merge=lfs -text
*.cr2 filter=lfs diff=lfs merge=lfs -text
*.cur filter=lfs diff=lfs merge=lfs -text
*.dat filter=lfs diff=lfs merge=lfs -text
*.dcm filter=lfs diff=lfs merge=lfs -text
*.deb filter=lfs diff=lfs merge=lfs -text
*.dex filter=lfs diff=lfs merge=lfs -text
*.djvu filter=lfs diff=lfs merge=lfs -text
*.dll filter=lfs diff=lfs merge=lfs -text
*.dmg filter=lfs diff=lfs merge=lfs -text
*.dng filter=lfs diff=lfs merge=lfs -text
*.doc filter=lfs diff=lfs merge=lfs -text
*.docm filter=lfs diff=lfs merge=lfs -text
*.docx filter=lfs diff=lfs merge=lfs -text
*.dot filter=lfs diff=lfs merge=lfs -text
*.dotm filter=lfs diff=lfs merge=lfs -text
*.dra filter=lfs diff=lfs merge=lfs -text
*.DS_Store filter=lfs diff=lfs merge=lfs -text
*.dsk filter=lfs diff=lfs merge=lfs -text
*.dts filter=lfs diff=lfs merge=lfs -text
*.dtshd filter=lfs diff=lfs merge=lfs -text
*.dvb filter=lfs diff=lfs merge=lfs -text
*.dwg filter=lfs diff=lfs merge=lfs -text
*.dxf filter=lfs diff=lfs merge=lfs -text
*.ecelp4800 filter=lfs diff=lfs merge=lfs -text
*.ecelp7470 filter=lfs diff=lfs merge=lfs -text
*.ecelp9600 filter=lfs diff=lfs merge=lfs -text
*.egg filter=lfs diff=lfs merge=lfs -text
*.eol filter=lfs diff=lfs merge=lfs -text
*.eot filter=lfs diff=lfs merge=lfs -text
*.epub filter=lfs diff=lfs merge=lfs -text
*.exe filter=lfs diff=lfs merge=lfs -text
*.f4v filter=lfs diff=lfs merge=lfs -text
*.fbs filter=lfs diff=lfs merge=lfs -text
*.fh filter=lfs diff=lfs merge=lfs -text
*.fla filter=lfs diff=lfs merge=lfs -text
*.flac filter=lfs diff=lfs merge=lfs -text
*.flatpak filter=lfs diff=lfs merge=lfs -text
*.fli filter=lfs diff=lfs merge=lfs -text
*.flv filter=lfs diff=lfs merge=lfs -text
*.fpx filter=lfs diff=lfs merge=lfs -text
*.fst filter=lfs diff=lfs merge=lfs -text
*.fvt filter=lfs diff=lfs merge=lfs -text
*.g3 filter=lfs diff=lfs merge=lfs -text
*.gh filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.graffle filter=lfs diff=lfs merge=lfs -text
*.gz filter=lfs diff=lfs merge=lfs -text
*.gzip filter=lfs diff=lfs merge=lfs -text
*.h261 filter=lfs diff=lfs merge=lfs -text
*.h263 filter=lfs diff=lfs merge=lfs -text
*.h264 filter=lfs diff=lfs merge=lfs -text
*.icns filter=lfs diff=lfs merge=lfs -text
*.ico filter=lfs diff=lfs merge=lfs -text
*.ief filter=lfs diff=lfs merge=lfs -text
*.img filter=lfs diff=lfs merge=lfs -text
*.ipa filter=lfs diff=lfs merge=lfs -text
*.iso filter=lfs diff=lfs merge=lfs -text
*.jar filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpgv filter=lfs diff=lfs merge=lfs -text
*.jpm filter=lfs diff=lfs merge=lfs -text
*.jxr filter=lfs diff=lfs merge=lfs -text
*.key filter=lfs diff=lfs merge=lfs -text
*.ktx filter=lfs diff=lfs merge=lfs -text
*.lha filter=lfs diff=lfs merge=lfs -text
*.lib filter=lfs diff=lfs merge=lfs -text
*.lvp filter=lfs diff=lfs merge=lfs -text
*.lz filter=lfs diff=lfs merge=lfs -text
*.lzh filter=lfs diff=lfs merge=lfs -text
*.lzma filter=lfs diff=lfs merge=lfs -text
*.lzo filter=lfs diff=lfs merge=lfs -text
*.m3u filter=lfs diff=lfs merge=lfs -text
*.m4a filter=lfs diff=lfs merge=lfs -text
*.m4v filter=lfs diff=lfs merge=lfs -text
*.mar filter=lfs diff=lfs merge=lfs -text
*.mdi filter=lfs diff=lfs merge=lfs -text
*.mht filter=lfs diff=lfs merge=lfs -text
*.mid filter=lfs diff=lfs merge=lfs -text
*.midi filter=lfs diff=lfs merge=lfs -text
*.mj2 filter=lfs diff=lfs merge=lfs -text
*.mka filter=lfs diff=lfs merge=lfs -text
*.mkv filter=lfs diff=lfs merge=lfs -text
*.mmr filter=lfs diff=lfs merge=lfs -text
*.mng filter=lfs diff=lfs merge=lfs -text
*.mobi filter=lfs diff=lfs merge=lfs -text
*.mov filter=lfs diff=lfs merge=lfs -text
*.movie filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.mp4a filter=lfs diff=lfs merge=lfs -text
*.mpeg filter=lfs diff=lfs merge=lfs -text
*.mpg filter=lfs diff=lfs merge=lfs -text
*.mpga filter=lfs diff=lfs merge=lfs -text
*.mxu filter=lfs diff=lfs merge=lfs -text
*.nef filter=lfs diff=lfs merge=lfs -text
*.npx filter=lfs diff=lfs merge=lfs -text
*.numbers filter=lfs diff=lfs merge=lfs -text
*.nupkg filter=lfs diff=lfs merge=lfs -text
*.o filter=lfs diff=lfs merge=lfs -text
*.odp filter=lfs diff=lfs merge=lfs -text
*.ods filter=lfs diff=lfs merge=lfs -text
*.odt filter=lfs diff=lfs merge=lfs -text
*.oga filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text
*.ogv filter=lfs diff=lfs merge=lfs -text
*.otf filter=lfs diff=lfs merge=lfs -text
*.ott filter=lfs diff=lfs merge=lfs -text
*.pages filter=lfs diff=lfs merge=lfs -text
*.pbm filter=lfs diff=lfs merge=lfs -text
*.pcx filter=lfs diff=lfs merge=lfs -text
*.pdb filter=lfs diff=lfs merge=lfs -text
*.pdf filter=lfs diff=lfs merge=lfs -text
*.pea filter=lfs diff=lfs merge=lfs -text
*.pgm filter=lfs diff=lfs merge=lfs -text
*.pic filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.pnm filter=lfs diff=lfs merge=lfs -text
*.pot filter=lfs diff=lfs merge=lfs -text
*.potm filter=lfs diff=lfs merge=lfs -text
*.potx filter=lfs diff=lfs merge=lfs -text
*.ppa filter=lfs diff=lfs merge=lfs -text
*.ppam filter=lfs diff=lfs merge=lfs -text
*.ppm filter=lfs diff=lfs merge=lfs -text
*.pps filter=lfs diff=lfs merge=lfs -text
*.ppsm filter=lfs diff=lfs merge=lfs -text
*.ppsx filter=lfs diff=lfs merge=lfs -text
*.ppt filter=lfs diff=lfs merge=lfs -text
*.pptm filter=lfs diff=lfs merge=lfs -text
*.pptx filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text
*.pya filter=lfs diff=lfs merge=lfs -text
*.pyc filter=lfs diff=lfs merge=lfs -text
*.pyo filter=lfs diff=lfs merge=lfs -text
*.pyv filter=lfs diff=lfs merge=lfs -text
*.qt filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.ras filter=lfs diff=lfs merge=lfs -text
*.raw filter=lfs diff=lfs merge=lfs -text
*.resources filter=lfs diff=lfs merge=lfs -text
*.rgb filter=lfs diff=lfs merge=lfs -text
*.rip filter=lfs diff=lfs merge=lfs -text
*.rlc filter=lfs diff=lfs merge=lfs -text
*.rmf filter=lfs diff=lfs merge=lfs -text
*.rmvb filter=lfs diff=lfs merge=lfs -text
*.rpm filter=lfs diff=lfs merge=lfs -text
*.rtf filter=lfs diff=lfs merge=lfs -text
*.rz filter=lfs diff=lfs merge=lfs -text
*.s3m filter=lfs diff=lfs merge=lfs -text
*.s7z filter=lfs diff=lfs merge=lfs -text
*.scpt filter=lfs diff=lfs merge=lfs -text
*.sgi filter=lfs diff=lfs merge=lfs -text
*.shar filter=lfs diff=lfs merge=lfs -text
*.snap filter=lfs diff=lfs merge=lfs -text
*.sil filter=lfs diff=lfs merge=lfs -text
*.sketch filter=lfs diff=lfs merge=lfs -text
*.slk filter=lfs diff=lfs merge=lfs -text
*.smv filter=lfs diff=lfs merge=lfs -text
*.snk filter=lfs diff=lfs merge=lfs -text
*.so filter=lfs diff=lfs merge=lfs -text
*.stl filter=lfs diff=lfs merge=lfs -text
*.suo filter=lfs diff=lfs merge=lfs -text
*.sub filter=lfs diff=lfs merge=lfs -text
*.swf filter=lfs diff=lfs merge=lfs -text
*.tar filter=lfs diff=lfs merge=lfs -text
*.tbz filter=lfs diff=lfs merge=lfs -text
*.tbz2 filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tgz filter=lfs diff=lfs merge=lfs -text
*.thmx filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.tlz filter=lfs diff=lfs merge=lfs -text
*.ttc filter=lfs diff=lfs merge=lfs -text
*.ttf filter=lfs diff=lfs merge=lfs -text
*.txz filter=lfs diff=lfs merge=lfs -text
*.udf filter=lfs diff=lfs merge=lfs -text
*.uvh filter=lfs diff=lfs merge=lfs -text
*.uvi filter=lfs diff=lfs merge=lfs -text
*.uvm filter=lfs diff=lfs merge=lfs -text
*.uvp filter=lfs diff=lfs merge=lfs -text
*.uvs filter=lfs diff=lfs merge=lfs -text
*.uvu filter=lfs diff=lfs merge=lfs -text
*.viv filter=lfs diff=lfs merge=lfs -text
*.vob filter=lfs diff=lfs merge=lfs -text
*.war filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.wax filter=lfs diff=lfs merge=lfs -text
*.wbmp filter=lfs diff=lfs merge=lfs -text
*.wdp filter=lfs diff=lfs merge=lfs -text
*.weba filter=lfs diff=lfs merge=lfs -text
*.webm filter=lfs diff=lfs merge=lfs -text
*.webp filter=lfs diff=lfs merge=lfs -text
*.whl filter=lfs diff=lfs merge=lfs -text
*.wim filter=lfs diff=lfs merge=lfs -text
*.wm filter=lfs diff=lfs merge=lfs -text
*.wma filter=lfs diff=lfs merge=lfs -text
*.wmv filter=lfs diff=lfs merge=lfs -text
*.wmx filter=lfs diff=lfs merge=lfs -text
*.woff filter=lfs diff=lfs merge=lfs -text
*.woff2 filter=lfs diff=lfs merge=lfs -text
*.wrm filter=lfs diff=lfs merge=lfs -text
*.wvx filter=lfs diff=lfs merge=lfs -text
*.xbm filter=lfs diff=lfs merge=lfs -text
*.xif filter=lfs diff=lfs merge=lfs -text
*.xla filter=lfs diff=lfs merge=lfs -text
*.xlam filter=lfs diff=lfs merge=lfs -text
*.xls filter=lfs diff=lfs merge=lfs -text
*.xlsb filter=lfs diff=lfs merge=lfs -text
*.xlsm filter=lfs diff=lfs merge=lfs -text
*.xlsx filter=lfs diff=lfs merge=lfs -text
*.xlt filter=lfs diff=lfs merge=lfs -text
*.xltm filter=lfs diff=lfs merge=lfs -text
*.xltx filter=lfs diff=lfs merge=lfs -text
*.xm filter=lfs diff=lfs merge=lfs -text
*.xmind filter=lfs diff=lfs merge=lfs -text
*.xpi filter=lfs diff=lfs merge=lfs -text
*.xpm filter=lfs diff=lfs merge=lfs -text
*.xwd filter=lfs diff=lfs merge=lfs -text
*.xz filter=lfs diff=lfs merge=lfs -text
*.z filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.zipx filter=lfs diff=lfs merge=lfs -text
#+end_src

* .xonshrc
:PROPERTIES:
:header-args:xonsh+: :noweb-ref .xonshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xonshrc>>
#+end_src

** imports

#+begin_src xonsh
import sys, os
from pathlib import Path
#+end_src

** environment

#+begin_src xonsh
$AUTO_CD = True
$AUTO_PUSHD = True
$AUTO_SUGGEST = True
$AUTO_SUGGEST_IN_COMPLETIONS = True
$BASH_COMPLETIONS += [ f"{Path.home()}/resources/bashCompletions" ]
$COMPLETION_IN_THREAD = True
$COMPLETIONS_CONFIRM = True
$DOTGLOB = True
$FUZZY_PATH_COMPLETION = True
$HISTCONTROL = { "ignoreboth", "erasedups", "ignoreerr" }
$MOUSE_SUPPORT = True
$PRETTY_PRINT_RESULTS = True
$PROMPT_TOOLKIT_COLOR_DEPTH = "DEPTH_24_BIT"
$SHELL_TYPE = "prompt_toolkit"
$UPDATE_COMPLETIONS_ON_KEYPRESS = True
$UPDATE_OS_ENVIRON = True
$VI_MODE = True
$XONSH_AUTOPAIR = True
$XONSH_CACHE_EVERYTHING = True
$XONSH_HISTORY_BACKEND = "sqlite"
$XONSH_STORE_STDOUT = True

# This enumerates all history files when set to true
$XONSH_DEBUG = False

$XONSH_SHOW_TRACEBACK = True

# Xonsh Prompt
$PROMPT_FIELDS["prompt_end"] = "Wheee! 😹 "
# $PROMPT = "{BOLD_#E5004D}{env_name} {BOLD_#FF4081}{prompt_end}"
# $PROMPT = lambda: $(starship prompt)
execx($(starship init xonsh))
$RIGHT_PROMPT = "{BOLD_#E5004D} {prompt_end}{BOLD_#FC9F71} || {BOLD_#E5004D} {user}@{hostname} "
# $BOTTOM_TOOLBAR = $RIGHT_PROMPT

# Path
sys.path.insert(0, "")
<<profile-paths(shell="xonsh")>>

# Shell
# $EDITOR = "emacsclient -c"
# $VISUAL = "emacsclient -c"

# Etc
$LESSOPEN = "| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
$LESS = " -R "
#+end_src

** functions

#+begin_src xonsh
def _mdg(args, stdin=None):
    mkdir -p @(args) && cd @(args[0])

def _direnv_allow(args, stdin=None):
    if args:
        for argument in args:
            direnv allow @(argument)
    else:
        direnv allow

def _get_fzfdf_output(*args):
    if args:
        return $(fd @((".", *args) if os.path.exists(args[0]) else args) | fzf-tmux).strip("\n")
    else:
        return $(fd | fzf-tmux).strip("\n")

def _cdi(args, stdin=None):
    cd @(_get_fzfdf_output(*args, "-t", "d"))

def _cdr(args, stdin=None):
    cd @($(zoxide query -l | fzf-tmux).strip("\n"))

def _cdf(args, stdin=None):
    cd @($(fasd -ld | fzf-tmux).strip("\n"))

def _rc(args, stdin=None):
    hist = $(history show @(args))
    command = $(echo @(hist) | fzf-tmux).strip("\n").split()
    if command:
        $(@(command))

def _run(args, stdin=None):
    args = list(args)
    args[0] = Path(args[0]).absolute()
    chmod +x @(args[0]) && @(args)

def _Run(args, stdin=None):
    curl --create-dirs -fsSLo @(args[1]) @(args[0])
    _run(args[1:])
#+end_src

** xontribs

#+begin_src xonsh
# xontrib load coreutils
# xontrib load docker_tabcomplete
# xontrib load schedule
# xontrib load ssh_agent
# xontrib load vox_tabcomplete

xontrib load abbrevs
xontrib load autoxsh
xontrib load bashisms
xontrib load direnv
xontrib load pipeliner
xontrib load readable-traceback
xontrib load sh
xontrib load vox
xontrib load whole_word_jumping

# Jedi was what was causing the python function completions
# instead of the path completions
# xontrib load jedi
#+end_src

** base

#+begin_src xonsh
execx($(zoxide init xonsh), 'exec', __xonsh__.ctx, filename='zoxide')

aliases["-"] = "pushd"
aliases[".."] = "cd .."
aliases["."] = "exa -la"
aliases["c"] = "clear"
aliases["cdf"] = _cdf
aliases["cdi"] = _cdi
aliases["cdr"] = _cdr
aliases["da"] = _direnv_allow
aliases["emd"] = "systemctl --user start emacs.service"
aliases["git"] = lambda args, stdin=None: $(hub @(args))
aliases["kemd"] = "systemctl --user stop emacs.service"
aliases["la"] = lambda args, stdin=None: $(exa -la --octal-permissions @(args))
aliases["md"] = lambda args, stdin=None: $(mkdir -p @(args))
aliases["mdg"] = _mdg
aliases["mosh"] = lambda args, stdin=None: $(mosh --experimental-remote-ip=remote @(args))
aliases["n"] = "exit"
aliases["rc"] = _rc
aliases["remd"] = "systemctl --user restart emacs.service"
aliases["Run"] = _Run
aliases["run"] = _run
aliases["s"] = "source ~/.xonshrc"
aliases["semd"] = "systemctl status emacs"
aliases["ssh"] = lambda args, stdin=None: $(assh wrapper ssh -- @(args))
aliases["ve"] = lambda args, stdin=None: $(vox enter @(args)) if args else $(vox exit)
aliases["vim"] = lambda args, stdin=None: $(emacsclient -c @(args))

# fasd aliases
aliases["o"] = lambda args, stdin=None: $(fasd -ae xdg-open @(args)) # quick opening files with xdg-open

# quick opening files with emacs
aliases["e"] = lambda args, stdin=None: $(fasd -fe 'emacsclient -c' @(args))
#+end_src

* .config
** nix
*** nix.conf

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** borgmatic

#+name: borgmatic-ls
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "    one_file_system: false
    numeric_owner: false
    atime: true
    ctime: true
    birthtime: true
    read_special: true
    bsd_flags: true
    files_cache: ctime,size,inode
    local_path: borg
    remote_path: borg1
    exclude_caches: true
    exclude_nodump: true

storage:
    checkpoint_interval: 300
    compression: zstd,22
    ssh_command: assh wrapper ssh --
    archive_name_format: \"borgmatic-%r-{now:%%Y%%m%%dT%%H%%M%%S%%f}\"
    relocated_repo_access_is_ok: true
    unknown_unencrypted_repo_access_is_ok: true" `((?r . ,repo)))
#+end_src

#+name: borgmatic-rc
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "retention:
    keep_within: 6H
    keep_secondly: 60
    keep_minutely: 60
    keep_hourly: 24
    keep_daily: 7
    keep_weekly: 4
    keep_monthly: 6
    keep_yearly: 4
    prefix: \"borgmatic-%r-\"

consistency:
    checks:
        - repository
        - data
        - extract
    prefix: \"borgmatic-%r-\"" `((?r . ,repo)))
#+end_src

*** sylvorg.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref sylvorg.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<sylvorg.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/sylvorg
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-sylvorg
<<borgmatic-ls(repo="sylvorg")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="sylvorg")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

*** oreo.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref oreo.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<oreo.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/oreo
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-oreo
<<borgmatic-ls(repo="oreo")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="oreo")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

** systemd
*** user
**** emacs.service
:PROPERTIES:
:header-args:systemd+: :noweb-ref emacs.service
:END:

#+begin_src text :tangle (meq/tangle-path)
<<emacs.service>>
#+end_src

#+begin_src
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --bg-daemon=damascus --update
ExecStop=/usr/bin/emacsclient -s damascus -e "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure
TimeoutSec=900

[Install]
WantedBy=default.target
#+end_src

** yadm
*** bootstrap
:PROPERTIES:
:header-args:shell+: :noweb-ref 879a83d3-17ad-446f-8ad2-9945ac588f07
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#! /usr/bin/env sh"
<<879a83d3-17ad-446f-8ad2-9945ac588f07>>
#+end_src

#+begin_src shell
set -eo pipefail
[ -z "$1" ] && worktree="$HOME" || worktree="$1"
#+end_src

*** config

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

** yadm-sec
*** config

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

** direnv
*** .direnvrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src zsh
use_flake() {
    watch_file flake.nix
    watch_file flake.lock
    eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
}
#+end_src

** kitty
*** kitty.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref kitty.conf
:END:

#+begin_src text :tangle (meq/tangle-path)
<<kitty.conf>>
#+end_src

#+begin_src conf
include ~/resources/kittyThemes/themes/Monokai_Pro_(Filter_Ristretto).conf
#+end_src

** ion
*** initrc
:PROPERTIES:
:header-args:ion+: :noweb-ref initrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<initrc>>
#+end_src

#+begin_src ion
eval $(starship init ion)
#+end_src

** git
*** config
:PROPERTIES:
:header-args:conf+: :noweb-ref ee416303-b507-49b2-9e6b-8dc71a97c171
:END:

#+name: c635d49e-5f0e-4245-bc91-81e9f8de0a12
#+begin_src text :tangle (meq/tangle-path)
<<ee416303-b507-49b2-9e6b-8dc71a97c171>>
#+end_src

#+begin_src conf
[core]
    excludesfile = ~/.globalignore
    attributesfile = ~/.gitattributes
    fileMode = false
    hookPath = ~/.config/git/hooks

[user]
    email = jeet.ray@syvl.org
    name = Jeet Ray

[alias]
    cnm = commit --allow-empty-message -am ""
    chRun = !chmod +x $1 &&
    sec = !git chRun ~/.config/git/scripts/sec

[protocol "keybase"]
	allow = always

[protocol "restic"]
	allow = always
#+end_src

*** scripts
**** sec
:PROPERTIES:
:header-args:shell+: :noweb-ref sec
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
<<sec>>
#+end_src

#+begin_src shell
command="yadm --yadm-data $HOME/.local/share/yadm-sec"
if [ "$(yadm status 2>&1)" == "ERROR: Git repo does not exist. did you forget to run 'init' or 'clone'?" ]; then
    $command $@
else
    $command --yadm-dir "$HOME/.config/yadm-sec" $@
fi
#+end_src

** powershell
*** Microsoft.PowerShell_profile.ps1
:PROPERTIES:
:header-args:powershell+: :noweb-ref Microsoft.PowerShell_profile.ps1
:END:

#+begin_src text :tangle (meq/tangle-path)
<<Microsoft.PowerShell_profile.ps1>>
#+end_src

#+begin_src powershell
# For zoxide v0.8.0+
Invoke-Expression (& {
    $hook = if ($PSVersionTable.PSVersion.Major -lt 6) { 'prompt' } else { 'pwd' }
    (zoxide init --hook $hook powershell | Out-String)
})
Invoke-Expression (&starship init powershell)
#+end_src

** fish
*** config.fish
:PROPERTIES:
:header-args:fish+: :noweb-ref config.fish
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.fish>>
#+end_src

#+begin_src fish
source ~/resources/nix-env.fish/conf.d/nix-env.fish
cd ~/resources/bass
make install &>/dev/null
cd -
<<20211028011434584909200>>
<<profile-paths(shell="fish")>>
alias s=source ~/.config/fish/config.fish
direnv hook fish | source
zoxide init fish | source
starship init fish | source
#+end_src

** qtile
*** config.py
:PROPERTIES:
:header-args:python+: :noweb-ref config.py
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.py>>
#+end_src

This config is taken from [[http://gegenokitaro.github.io/tuts/2015/05/14/qtile-ricchan/][here]]:

#+begin_src python
# Copyright (c) 2010 Aldo Cortesi
# Copyright (c) 2010, 2014 dequis
# Copyright (c) 2012 Randall Ma
# Copyright (c) 2012-2014 Tycho Andersen
# Copyright (c) 2012 Craig Barnes
# Copyright (c) 2013 horsik
# Copyright (c) 2013 Tao Sauvage
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libqtile.config import Key, Screen, Group, Drag, Click, Match
from libqtile.command import lazy
from libqtile import layout, bar, widget
from libqtile.dgroups import simple_key_binder

mod = "mod4"

keys = [
    # Switch between windows in current stack pane
    Key(
        [mod], "j",
        lazy.layout.down()
    ),
    Key(
        [mod], "k",
        lazy.layout.up()
    ),

    # Move windows up or down in current stack
    Key(
        [mod, "control"], "j",
        lazy.layout.shuffle_down()
    ),
    Key(
        [mod, "control"], "k",
        lazy.layout.shuffle_up()
    ),

    # Switch window focus to other pane(s) of stack
    Key(
        [mod], "space",
        lazy.layout.next()
    ),

    Key(
        [mod], "Left",
        lazy.screen.prevgroup()
    ),

    Key(
        [mod], "Right",
        lazy.screen.nextgroup()
    ),

    # Swap panes of split stack
    Key(
        [mod, "shift"], "space",
        lazy.layout.rotate()
    ),

    # Toggle between split and unsplit sides of stack.
    # Split = all windows displayed
    # Unsplit = 1 window displayed, like Max layout, but still with
    # multiple stack panes
    Key(
        [mod, "shift"], "Return",
        lazy.layout.toggle_split()
    ),
    Key([mod], "Return", lazy.spawn("urxvt")),

    # Toggle between different layouts as defined below
    Key([mod], "Tab", lazy.nextlayout()),
    Key([mod], "w", lazy.window.kill()),

    Key([mod, "control"], "r", lazy.restart()),
    Key([mod, "control"], "q", lazy.shutdown()),
    Key([mod], "r", lazy.spawncmd()),
]

groups = [
    Group(" urxvt "),
    Group(" web ", matches=[Match(wm_class=["Firefox"])]),
    Group(" blender "),
    Group(" inkscape "),
    Group(" gimp "),
    Group(" doc "),
]

dgroups_key_binder = simple_key_binder("mod4")


layouts = [
    layout.TreeTab(
            font='Cartograph CF Light Italic',
            name="tree tab",
            bg_color="#222222",
            inactive_bg="#AB5DEE",
            panel_width=150,
            margin_left=0,
            margin_y=0,
            sections=['TreeTab'],
            section_left=0,
            padding_x=4,
            active_bg="#FFB86C",
            rounded=False,
        ),
    layout.MonadTall(
            name="xmonad tall",
            ratio=0.5,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Stack(
            num_stacks=2,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        )
]

floating_layout = layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#69B2B8",
            border_normal="#335260",
        )

widget_defaults = dict(
    font='Cartograph CF Light Italic',
    fontsize=12,
    background="#222222",
    markup=True,
)

screens = [
    Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(
                        borderwidth=0,
                        margin=0,
                        padding=6,
                        active="FFFFFF",
                        inactive="FFB86C",
                        highlight_method="block",
                        this_current_screen_border="#AB5DEE",
                        invert_mouse_wheel=True,
                        rounded=False,
                    ),
                widget.Prompt(),
                widget.CurrentLayout(
                        background="#E11B22",
                    ),
                widget.Spacer(),
                #widget.WindowName(),
                widget.TextBox("testing", name="default"),
                widget.Systray(),
                widget.Clock(format=' %I:%M %p '),
            ],
            24,
            background="#335260",
        ),
    ),
]

# Drag floating layouts.
mouse = [
    Drag([mod], "Button1", lazy.window.set_position_floating(),
        start=lazy.window.get_position()),
    Drag([mod], "Button3", lazy.window.set_size_floating(),
        start=lazy.window.get_size()),
    Click([mod], "Button2", lazy.window.bring_to_front())
]

dgroups_app_rules = []
main = None
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
auto_fullscreen = True

# XXX: Gasp! We're lying here. In fact, nobody really uses or cares about this
# string besides java UI toolkits; you can see several discussions on the
# mailing lists, github issues, and other WM documentation that suggest setting
# this string if your java app doesn't work correctly. We may as well just lie
# and say that we're a working one by default.
#
# We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in
# java that happens to be on java's whitelist.
wmname = "LG3D"
#+end_src

* .SpaceVim.d
** init.toml
:PROPERTIES:
:header-args:conf+: :noweb-ref init.toml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<init.toml>>
#+end_src

#+begin_src conf
#=============================================================================
# dark_powered.toml --- dark powered configuration example for SpaceVim
# Copyright (c) 2016-2020 Wang Shidong & Contributors
# Author: Wang Shidong < wsdjeg at 163.com >
# URL: https://spacevim.org
# License: GPLv3
#=============================================================================

# All SpaceVim option below [option] section
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    colorscheme = "gruvbox"
    colorscheme_bg = "dark"
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = "arrow"
    statusline_iseparator = "arrow"
    buffer_index_type = 4
    enable_tabline_filetype_icon = true
    enable_statusline_mode = false
    bootstrap_before = 'vimrc#before'
    bootstrap_after = 'vimrc#after'
    escape_key_binding = ""
#+end_src

*** layers

#+begin_src conf
# Enable autocomplete layer
[[layers]]
name = 'autocomplete'
auto_completion_return_key_behavior = "complete"
auto_completion_tab_key_behavior = "smart"

[[layers]]
name = 'shell'
default_position = 'top'
default_height = 30

[[layers]]
name = "lang#nix"
#+end_src

*** plugins

#+begin_src conf
[[custom_plugins]]
    repo = "tssm/fairyfloss.vim"
    merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/mountaineer.vim"
#     merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/gunmetal.vim"
#     merged = true

[[custom_plugins]]
    repo = "megantiu/true.vim"
    merged = true

# From:
# Answer: https://vi.stackexchange.com/questions/678/how-do-i-save-a-file-in-a-directory-that-does-not-yet-exist/679#679
# User: https://vi.stackexchange.com/users/51/martin-tournoij
[[custom_plugins]]
    repo = "arp242/auto_mkdir2.vim"
    merged = true

[[custom_plugins]]
    repo = "tpope/vim-eunuch"
    merged = true

# [[custom_plugins]]
#     repo = "johannesthyssen/vim-signit"
#     merged = true

[[custom_plugins]]
    repo = "jupyter-vim/jupyter-vim"
    merged = true

[[custom_plugins]]
    repo = "haya14busa/dein-command.vim"
    merged = true

[[custom_plugins]]
    repo = "andrep/vimacs"
    merged = true

[[custom_plugins]]
    repo = "shougo/denite.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/defx.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/deoplete.nvim"
    merged = true
#+end_src

** autoload
*** vimrc.vim

#+begin_src vimrc :tangle (meq/tangle-path)
function! vimrc#before() abort
endfunction

function! vimrc#after() abort
    syntax on
    filetype plugin indent on

    " enable 24bit true color
    if (has("termguicolors"))
    set termguicolors
    endif

    " enable the theme
    syntax enable
    colorscheme fairyfloss

    let g:true_airline = 1
    let g:airline_theme='true'

    " for kitty
    let &t_ut=""

    " disables border on left side
    set foldcolumn=0

    " Spaces & Tabs
    set tabstop=4       " number of visual spaces per TAB
    set softtabstop=4   " number of spaces in tab when editing
    set shiftwidth=4    " number of spaces to use for autoindent
    set expandtab       " tabs are space
    set autoindent
    set copyindent      " copy indent from the previous line

    " set number relativenumber

    " Insert Toggle
    imap ;; <ESC>
    map ;; i <BACKSPACE>

    " Change two spaces to four
    map \\ :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>
    imap \\ <ESC> :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>

    " Change movement keys to <space>wasd
    noremap <Space-a> h
    noremap <Space-s> j
    noremap <Space-w> k
    noremap <Space-d> l

    " Set Paste
    command SMP :set paste <CR>

    " Set NoPaste
    command SNP :set nopaste <CR>

    " Tab to insert
    map <TAB> i <TAB>

    " Vim Signit
    let g:signit_initials = "JR"
    let g:signit_name = "Jeet Ray"
    " let g:signit_extra_1
    " let g:signit_extra_2
    " let g:signit_position
    let g:signit_ascii_font = "isometric1.flf"
    " let g:signit_ascii_spacing

    if has('nvim')
        call dein#add('iron-e/nvim-libmodal')
        call dein#add('shougo/deol.nvim')
        call dein#add('shougo/deoppet.nvim')
        call dein#add('shougo/deorise.nvim')
    else
        call dein#add('iron-e/vim-libmodal')
        call dein#add('roxma/nvim-yarp')
        call dein#add('roxma/vim-hug-neovim-rpc')
    endif

    let g:deoplete#enable_at_startup = 1
endfunction
#+end_src

* .byobu
** .tmux.conf

#+begin_src conf :tangle (meq/tangle-path)
<<20211018140524183223400>>
#+end_src

* .tmux.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref .tmux.conf
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211018140524183223400

#+name: 20211018140524183223400
#+begin_src text :tangle (meq/tangle-path)
<<20210601214303404504400()>>
<<.tmux.conf>>
#+end_src

** aleclearmind active-row replacement

#+call: hash() :exports none

#+RESULTS:
: 20210601214303404504400

#+name: 20210601214303404504400
#+begin_src emacs-lisp :noweb-ref no
(replace-regexp-in-string
    "set -g prefix C-a"
    "set -g prefix C-Space"
    (replace-regexp-in-string
        "unbind C-b"
        "# unbind C-b"
        (let ((file "./resources/aleclearmind/active-row.conf"))
            (if (file-directory-p file)
                (insert-file-contents file)
                ""))))
#+end_src

** powerline

#+begin_src conf
# source ./resources/powerline/powerline/bindings/tmux/powerline-base.conf
source ./resources/powerline/powerline/bindings/tmux/powerline.conf
# source ./resources/powerline/powerline/bindings/tmux/powerline_tmux_2.1_plus.conf
#+end_src

** oh-my-tmux

#+begin_src conf
source ./resources/oh-my-tmux/.tmux.conf
source ./resources/oh-my-tmux/.tmux.conf.local
#+end_src

** keybindings

From: https://man7.org/linux/man-pages/man1/tmux.1.html#KEY_BINDINGS

*** unbindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214314440746200

#+name: 20210601214314440746200
#+begin_src text :noweb-ref no
C-b
C-x
C-z
#+end_src

#+begin_src conf
unbind <<20210601214314440746200>>
#+end_src

*** bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214317258641300

#+name: 20210601214317258641300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key <<20210601214317258641300>>
#+end_src

*** root bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214320148298300

#+name: 20210601214320148298300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -n <<20210601214320148298300>>
#+end_src

*** root repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214322950137300

#+name: 20210601214322950137300
#+begin_src text :noweb-ref no
M-s send-prefix
C-S-F5 send-keys M-F5
C-S-Left send-keys M-Left
C-S-Right send-keys M-Right
#+end_src

#+begin_src conf
bind-key -nr <<20210601214322950137300>>
#+end_src

*** repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214325764323500

#+name: 20210601214325764323500
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -r <<20210601214325764323500>>
#+end_src

*** prefix table bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214331744518200

#+name: 20210601214331744518200
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -T prefix <<20210601214331744518200>>
#+end_src

** base

#+begin_src conf
set -g prefix2 S-Space

# Mouse support - set to on if you want to use the mouse
# setw -g mode-mouse on
# set -g mouse-select-pane on
# set -g mouse-resize-pane on
# set -g mouse-select-window on

# enable activity alerts
setw -g monitor-activity off
set -g visual-activity off

# Center the window list
set -g status-justify centre

# VI Mode
set -g status-keys vi

# utf8 is on
# set -g utf8 on
# set -g status-utf8 on

run-shell "powerline-daemon -q"

set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Spacemacs Settings:
set -gs escape-time 10

# address vim mode switching delay (http://superuser.com/a/252717/65504)
set -s escape-time 0

# increase scrollback buffer size
set -g history-limit 50000

# tmux messages are displayed for 1.25 seconds
set -g display-time 1250

# refresh 'status-left' and 'status-right' more often
# set -g status-interval 1

# focus events enabled for terminals that support them
set -g focus-events on

# border thickness
set-option -g pane-active-border-style "bg=default"
set-option -ag pane-active-border-style "fg=colour208"
set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Adapted From: https://www.reddit.com/r/tmux/comments/einuqy/make_tmux_modal/
set-option -g prefix None
bind-key -n C-Space {
  set-option key-table prefix
  set-option status-bg yellow
}
bind-key -T prefix C-Space {
  set-option key-table root
  set-option status-bg green
}

setw -g aggressive-resize on
#+end_src

** plugins

#+call: hash() :exports none

#+RESULTS:
: 20210601214334528396400

#+name: 20210601214334528396400
#+begin_src text :noweb-ref no
tmux-plugins/tpm
tmux-plugins/tmux-battery
tmux-plugins/tmux-cpu
tmux-plugins/tmux-fpp
tmux-plugins/tmux-logging
tmux-plugins/tmux-online-status
tmux-plugins/tmux-open
tmux-plugins/tmux-pain-control
tmux-plugins/tmux-prefix-highlight
tmux-plugins/tmux-sessionist
tmux-plugins/tmux-sidebar
tmux-plugins/vim-tmux-focus-events
tmux-plugins/tmux-yank
tmux-plugins/tmux-continuum
tmux-plugins/tmux-resurrect
christoomey/vim-tmux-navigator
sainnhe/tmux-fzf
samoshkin/tmux-plugin-sysstat
wfxr/tmux-fzf-url
schasse/tmux-jump
eraserhd/tmux-ctrlw
jlipps/tmux-safekill
fcsonline/tmux-thumbs
addisonlynch/tmux-sidebar-plus
#+end_src

#+begin_src conf
set -g @plugin <<20210601214334528396400>>
set -g @continuum-boot 'on'
set -g @continuum-save-interval '10'
set -g @continuum-restore 'on'
set -g @resurrect-save-bash-history 'on'
set -g @resurrect-dir '~/.byobu/tmux_resurrect'
set -g @resurrect-processes '"mc --nocolor" "tail -f" bat docker elvish emacs fish glances gotop htop ipython irssi jupyter-lab jupyter-notebook less man more mosh mutt nvim ssh syncthing tail top vi vim weechat wtf xonsh xsh zsh'
set -g @resurrect-capture-pane-contents 'on'
set -g @resurrect-strategy-vim 'session'
set -g @resurrect-strategy-nvim 'session'
run "./resources/tpm/tpm"
#+end_src

* .tmuxp
** default.yaml
:PROPERTIES:
:header-args:conf+: :noweb-ref default.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<default.yaml>>
#+end_src

#+begin_src conf
session_name: default
#+end_src

* .profile
:PROPERTIES:
:header-args:shell+: :noweb-ref .profile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.profile>>
#+end_src

#+name: profile-sources
#+begin_src shell
# source $HOME/.nix-profile/etc/profile.d/nix.sh
eval "$(fasd --init auto)"
#+end_src

#+name: cd-home-and-profile-aliases
#+begin_src shell
# Adapted From:
# Answer: https://askubuntu.com/a/146034/1058868
# User: https://askubuntu.com/users/1059/gilles-so-stop-being-evil
alias -- -="pushd"

alias ..="cd .."
alias .="exa -la --octal-permissions"
alias c="clear"
alias cdf='cdf'
alias cdi='cdi'
alias cdr='cdr'
alias da='direnvAllow'
alias emd="systemctl --user start emacs.service"
alias git="hub"
alias kemd="systemctl --user stop emacs.service"
alias la='exa -la --octal-permissions'
alias md="mkdir -p"
alias mdg='mdg'
alias mosh="mosh --experimental-remote-ip=remote"
alias n="exit"
alias rc="rc"
alias remd="systemctl --user restart emacs.service"
alias Run="Run"
alias run="run"
alias semd="systemctl status emacs"
alias ssh="assh wrapper ssh --"
alias vi="emacsclient -c"
alias vim="emacsclient -c"

# fasd
alias o="fasd -ae xdg-open"

# quick opening files with emacs
alias e="fasd -fe 'emacsclient -t'"
#+end_src

#+name: profile-functions
#+begin_src shell
cdf () { cd $(fasd -ld | fzf-tmux); }
cdi () { cd $(getFzfdfOutput "$@" "-t" "d"); }
cdr () { cd $(zoxide query -l | fzf-tmux); }
direnvAllow () {
    if [ -z "$1" ]; then
        direnv allow
    else
        for d in "$@"; do
            direnv allow "$d"
        done
    fi
}
getFzfdfOutput () {
    if [ -z "$1" ]; then
        echo $(fd | fzf-tmux)
    else
        if [ -d "$1" ]; then
            echo $(fd "." "$@" | fzf-tmux)
        else
            echo $(fd "$@" | fzf-tmux)
        fi
    fi
}
mdg () { mkdir -p "$@" && cd "$1"; }

Run () { curl --create-dirs -fsSLo "$2" "$1" && shift && run "$@"; }
run () { chmod +x "$1" && "$@"; }
#+end_src

#+name: profile-exports
#+begin_src shell
# export EDITOR='emacsclient -c'
# export VISUAL='emacsclient -c'
export HISTCONTROL='ignoreboth:erasedups'
export LESSOPEN='| /usr/share/source-highlight/src-hilite-lesspipe.sh %s'
export LESS=' -R '
#+end_src

#+name: profile-paths
#+begin_src emacs-lisp :noweb-ref no :var shell=""
(let* ((path '("$HOME/.local/bin"
            "$HOME/.nimble/bin"
            "/home/linuxbrew/.linuxbrew/bin"
            "/home/linuxbrew/.linuxbrew/sbin"
            "$HOME/.nix-profile/bin"
            "$HOME/.guix-profile/bin"
            "$HOME/go/bin"
            "/usr/local/sbin"
            "/usr/local/bin"
            "/usr/sbin"
            "/usr/bin"
            "/sbin"
            "/bin"
            "/usr/games"
            "/usr/local/games"
            "/snap/bin"
            "/usr/local/go/bin"
            "/usr/lib/node_modules")))
    (pcase shell
        ("fish" (concat "set -gx PATH $PATH" (string-join path " ")))
        ("xonsh" (concat "$PATH += [ \"" (string-join path "\",\n\t\"") "\" ]"))
        (t (concat "export PATH=\"$PATH:" (string-join path ":") "\""))))
#+end_src

#+name: profile-all-together
#+begin_src text
<<profile-sources>>
<<profile-functions>>
<<profile-exports>>
<<cd-home-and-profile-aliases>>
<<profile-paths()>>
#+end_src

#+begin_src shell
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

alias s="source $HOME/.profile"
#+end_src

* .bashrc
:PROPERTIES:
:header-args:bash+: :noweb-ref .bashrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.bashrc>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20211027212836251792500

#+name: 20211027212836251792500
#+begin_src bash
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.bashrc"
eval "$(direnv hook bash)"
eval "$(zoxide init bash)"
eval "$(starship init bash)"
set -o vi
#+end_src

* .elvish
** lib
*** direnv.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref direnv.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<direnv.elv>>
#+end_src

#+begin_src elvish
direnv hook elvish
#+end_src

* rc.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref rc.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<rc.elv>>
#+end_src

#+begin_src elvish
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
use direnv
eval (zoxide init elvish | slurp)
eval (starship init elvish)
#+end_src

* .xinitrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .xinitrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xinitrc>>
#+end_src

#+begin_src shell
# exec emacs
exec emacsclient -a "" -c
#+end_src

* .direnvrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src shell
source ~/resources/nix-direnv/direnvrc
source ~/.config/direnv/direnvrc

if [[ -f /run/current-system/sw/share/nix-direnv/direnvrc ]]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

* .globalignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .globalignore
:END:

#+call: hash() :exports none

#+RESULTS:
: 20210601185925524999600

#+name: 20210601185925524999600
#+begin_src text :tangle (meq/tangle-path)
<<.globalignore>>
#+end_src

#+begin_src gitignore
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

* .gitignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .gitignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.gitignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .hgignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .hgignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.hgignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .zshrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshrc>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshrc

# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history 0 | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.zshrc"
eval "$(direnv hook zsh)"
eval "$(zoxide init zsh)"
prompt off
eval "$(starship init zsh)"

bindkey -v

# From: https://leetschau.github.io/remove-duplicate-zsh-history.html
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_SAVE_NO_DUPS

source ~/resources/zsh-autosuggestions/zsh-autosuggestions.zsh
# source ~/resources/zsh-autocomplete/zsh-autocomplete.plugin.zsh

# Adapted From: https://github.com/zsh-users/zsh-history-substring-search#usage
source ~/resources/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/resources/zsh-history-substring-search/zsh-history-substring-search.zsh
#+end_src

* .zshenv
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshenv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshenv>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshenv
skip_global_compinit=1
#+end_src

* .zprofile
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zprofile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zprofile>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zprofile
#+end_src

* .zlogout
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogout
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogout>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogout
eval "$(direnv hook zsh)"
#+end_src

* .zlogin
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogin
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogin>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogin
eval "$(direnv hook zsh)"
#+end_src

* .stow-global-ignore
:PROPERTIES:
:header-args:conf+: :noweb-ref .stow-global-ignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.stow-global-ignore>>
#+end_src

#+begin_src conf
\.git
#+end_src

* .termux
** termux.properties
:PROPERTIES:
:header-args:conf+: :noweb-ref termux.properties
:END:

#+begin_src text :tangle (meq/tangle-path)
<<termux.properties>>
#+end_src

#+begin_src conf
### After making changes and saving you need to run `termux-reload-settings`
### to update the terminal.  All information here can also be found on the
### wiki: https://wiki.termux.com/wiki/Terminal_Settings

###############
# Extra keys
###############

### Settings for choosing which set of symbols to use for illustrating keys.
### Choose between default, arrows-only, arrows-all, all and none
# extra-keys-style = default

### Default extra-key configuration
# extra-keys = [[ESC, TAB, CTRL, ALT, {key: '-', popup: '|'}, DOWN, UP]]

### Two rows with more keys
# extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'], \
#               ['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]

### Configuration with additional popup keys (swipe up from an extra key)
# extra-keys = [[ \
#   {key: ESC, popup: {macro: "CTRL f d", display: "tmux exit"}}, \
#   {key: CTRL, popup: {macro: "CTRL f BKSP", display: "tmux ←"}}, \
#   {key: ALT, popup: {macro: "CTRL f TAB", display: "tmux →"}}, \
#   {key: TAB, popup: {macro: "ALT a", display: A-a}}, \
#   {key: LEFT, popup: HOME}, \
#   {key: DOWN, popup: PGDN}, \
#   {key: UP, popup: PGUP}, \
#   {key: RIGHT, popup: END}, \
#   {macro: "ALT j", display: A-j, popup: {macro: "ALT g", display: A-g}}, \
#   {key: KEYBOARD, popup: {macro: "CTRL d", display: exit}} \
# ]]

###############
# Colors/themes
###############

### Force black colors for drawer and dialogs
# use-black-ui = true

###############
# Keyboard shortcuts
###############

### Open a new terminal with ctrl + t (volume down + t)
# shortcut.create-session = ctrl + t

### Go one session down with (for example) ctrl + 2
# shortcut.next-session = ctrl + 2

### Go one session up with (for example) ctrl + 1
# shortcut.previous-session = ctrl + 1

### Rename a session with (for example) ctrl + n
# shortcut.rename-session = ctrl + n

###############
# Bell key
###############

### Vibrate device (default).
# bell-character = vibrate

### Beep with a sound.
# bell-character = beep

### Ignore bell character.
# bell-character = ignore

###############
# Back key
###############

### Send the Escape key.
# back-key=escape

### Hide keyboard or leave app (default).
# back-key=back

###############
# Keyboard issue workarounds
###############

### Letters might not appear until enter is pressed on Samsung devices
# enforce-char-based-input = true

### ctrl+space (for marking text in emacs) does not work on some devices
# ctrl-space-workaround = true

allow-external-apps = true
#+end_src