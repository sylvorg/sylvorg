#+setupfile: ./README.org
#+include: ./README.org

This can be used with =GNU Stow= as well! :D

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* .config
*** yadm
**** bootstrap

#+call: hash("resources")

#+RESULTS:
: 676db0abb976db0a506bad2b0e523575

#+name: 676db0abb976db0a506bad2b0e523575
#+begin_src python
resources = f"{os.environ["HOME"]}/system/etc/nixos/resources"
#+end_src

#+call: hash("while-setup")

#+RESULTS:
: a847be184b015d06a2e776f51f25971a

#+name: a847be184b015d06a2e776f51f25971a
#+begin_src python
while true:
    pool_name = raw_input("What's the pool name?\n\t")
    if pool_name == "":
        print("Wait a minute... That's not a valid pool name! Try again, please!\n")
    elif pool_name == "quit bootstrap":
        print("Catch ya' later!")
        exit(0)
    else:
        print("Alright; let's get crackin'!\n\n")
        encrypted = raw_input('''
            Is this pool [to be] encrypted?
                y | n\n\t
        ''') == "y"
        break
#+end_src

# Rewrite this for python 3.9

#+call: hash("")

#+RESULTS:
: 5918a1d90f5b7e61007371faf087dff7

#+name: 5918a1d90f5b7e61007371faf087dff7
#+begin_src python :tangle (jr/tangle-path) :shebang "#!/usr/bin/env xonsh"
import json os
from sys import exit

<<676db0abb976db0a506bad2b0e523575>>

<<b42270f71a0086b3d3e42a785d8b5bb0>>

<<be9a81e82f7c0ddadaf4c4cbada241b5>>

def xrun(command):
    @(command.split())

xrun("nix-env -i sd rsync")

try:

    <<a847be184b015d06a2e776f51f25971a>>

    while true:
        input = input or raw_input("Pick an option, any option! :D\n\t")
        saved_input = [c for c in input]
        input = ""
        for c in saved_input:
            if c == "c":
                if raw_input('THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN "ZFS CREATE"!\n\t') == "ZFS CREATE":

                    <<82fa6951dc98acdbbce8fce980732d4a>>

                else:
                    print("Sorry; not continuing!\n\n")
            elif c == "m":

                <<3836516e33beb8c8a336b3ac75d26e05>>

            elif c == "u":
                while true:
                    input2 = raw_input('''
                        Would you like to update the resource files, or the pool?
                            f | p | [g]o back\n\t
                    ''')
                    for cc in input2:
                        if cc == "f":

                            <<aa6815ffe0495e012a80a5e3ddb4b0bd>>

                        elif cc == "p":

                            <<03fc24d52cd1b15f6c3a2cb83ccaf5d2>>

                        elif cc == "g":
                            print("Goin' back!\n\n")
                            break
                        else:
                            print("Wait a minute... That's not a valid option! Try again, please!\n\n")
            elif c == "g":
                if raw_input('''
                    Would you like to generate a nixos "[hardware-]configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-generate-config")

            # TODO
            elif c == "b":
                if raw_input('''
                    Would you like to include the bootstrap file in the nixos "configuration.nix" file?
                        y | n\n\t
                ''') == "y":
                    xrun('sd "./hardware-configuration.nix" "./bootstrap.nix" /mnt/etc/nixos/configuration.nix')

            # TODO: Also include a one-stop-install, mounting, generating, copying, etc. all in one go
            elif c == "a":
                input = ""
                break

            elif c == "r":
                if raw_input('''
                    Would you like to rsync over the bootstrap files to "/mnt"?
                        y | n\n\t
                ''') == "y":
                    xrun("rsync -avvczz ../../ /mnt/")
            elif c == "i":
                if raw_input('''
                    Would you like to begin the NixOS bootstrap installation?
                        y | n\n\t
                ''') == "y":
                    xrun("nixos-install --show-trace")
            elif c == "h":

                <<be9a81e82f7c0ddadaf4c4cbada241b5>>

            elif c == "s":

                <<a847be184b015d06a2e776f51f25971a>>

            elif c == "H":

                

            elif c == "q":
                print("Catch ya' later!")
                break
            else:
                print(f'Wait a minute... The value "{c}" is not a valid option! Try again, please!\n\n')
                break

finally:
    xrun(f"zpool export {pool_name} &> /dev/null")
    exit(0)
#+end_src

***** tab completion for =raw_input=

Lifted From [[https://stackoverflow.com/a/5638688/10827766][this answer]] on Stack Overflow,
by [[https://stackoverflow.com/users/538718/samplebias][samplebias]]:

#+call: hash("")

#+RESULTS:
: b42270f71a0086b3d3e42a785d8b5bb0

#+name: b42270f71a0086b3d3e42a785d8b5bb0
#+begin_src python
import os
import re
import readline

COMMANDS = ['extra', 'extension', 'stuff', 'errors',
            'email', 'foobar', 'foo']
RE_SPACE = re.compile('.*\s+$', re.M)

class Completer(object):

    def _listdir(self, root):
        "List directory 'root' appending the path separator to subdirs."
        res = []
        for name in os.listdir(root):
            path = os.path.join(root, name)
            if os.path.isdir(path):
                name += os.sep
            res.append(name)
        return res

    def _complete_path(self, path=None):
        "Perform completion of filesystem path."
        if not path:
            return self._listdir('.')
        dirname, rest = os.path.split(path)
        tmp = dirname if dirname else '.'
        res = [os.path.join(dirname, p)
                for p in self._listdir(tmp) if p.startswith(rest)]
        # more than one match, or single match which does not exist (typo)
        if len(res) > 1 or not os.path.exists(path):
            return res
        # resolved to a single directory, so return list of files below it
        if os.path.isdir(path):
            return [os.path.join(path, p) for p in self._listdir(path)]
        # exact file match terminates this completion
        return [path + ' ']

    def complete_extra(self, args):
        "Completions for the 'extra' command."
        if not args:
            return self._complete_path('.')
        # treat the last arg as a path and complete it
        return self._complete_path(args[-1])

    def complete(self, text, state):
        "Generic readline completion entry point."
        buffer = readline.get_line_buffer()
        line = readline.get_line_buffer().split()
        # show all commands
        if not line:
            return [c + ' ' for c in COMMANDS][state]
        # account for last argument ending in a space
        if RE_SPACE.match(buffer):
            line.append('')
        # resolve command to the implementation function
        cmd = line[0].strip()
        if cmd in COMMANDS:
            impl = getattr(self, 'complete_%s' % cmd)
            args = line[1:]
            if args:
                return (impl(args) + [None])[state]
            return [cmd + ' '][state]
        results = [c + ' ' for c in COMMANDS if c.startswith(cmd)] + [None]
        return results[state]

comp = Completer()
# we want to treat '/' as part of a word, so override the delimiters
readline.set_completer_delims(' \t\n;')
readline.parse_and_bind("tab: complete")
readline.set_completer(comp.complete)
#+end_src

***** show help text

#+call: hash("")

#+RESULTS:
: be9a81e82f7c0ddadaf4c4cbada241b5

#+name: be9a81e82f7c0ddadaf4c4cbada241b5
#+begin_src python
print('''
    Create a new ZFS device:         c
    Mount a ZFS device:              m
    Update:                          u
            Files:                           f
            Pool:                            p
            Go back:                         g
    Generate nixos config:           g
    Include boostrap config:         b
    One-Stop Install:                a
    Rsync over bootstrap config:     r
    Begin install:                   i
    Show this help text:             h
    Setup:                           s
    Quit:                            q
    Install and Set Up Home-Manager: H
    \n\n
''')
#+end_src

***** create

#+call: hash("")

#+RESULTS:
: 82fa6951dc98acdbbce8fce980732d4a

#+name: create
#+begin_src python
options = {
    "xattr": "sa",
    "acltype": "posixacl",
    "mountpoint": "none",
    "compression": "zstd-19",
    "checksum": "edonr",
    "atime": "off",
    "relatime": "off",
}

if encrypted:
    options["encryption"] = "aes-256-gcm"
    options["keyformat"] = "passphrase"
if (dedup := (raw_input('''
    Should this pool be deduplicated?
        y | n\n\t
''') == "y")):
    options["dedup"] = "edonr,verify"

for dataset in $(zfs list -rH).split("\n"):
    if pool_name in dataset:
        xrun(f"zpool export {pool_name}")
        break

command = f"zpool create -fo autotrim=on -o altroot=/mnt"

for key, value in options.items():
    command += f" -O {key}={value}"

zfs_device = raw_input("Please enter the device to be initialized:\n\t")

xrun(f"{command} {pool_name} {zfs_device}")

<<03fc24d52cd1b15f6c3a2cb83ccaf5d2>>

#+end_src

****** open =f{resources}/users.json=

#+call: hash("")

#+RESULTS:
: d61c11eac203bfa4ee2cb42f93e5c959

#+name: d61c11eac203bfa4ee2cb42f93e5c959
#+begin_src python
users = json.loads('''
    <<4b4166b2bebff5d6dc0a9118372f6e36>>
'''.strip())

for user in users.values():
    dsd["home"][d][user] = dd
    datasets["virt"][d]["podman"][d][user] = dd
    for dataset in (persist := dsd["persist"][d]).keys():
        persist[dataset][d][user] = dd
#+end_src

****** open =f{resources}/datasets.nix=
******* before opening =f{resources}/datasets.nix=

#+call: hash("")

#+RESULTS:
: 9b6d5ff07d5ba4ca0e95609407d6f5e4

#+name: 9b6d5ff07d5ba4ca0e95609407d6f5e4
#+begin_src python
with open(f"{resources}/datasets.nix", "w+") as dnix:

    dnix.write("host: {\n")

    def recurse(ddict, dname, droot, mountpoint = ""):

        _dataset = f"{droot}/{dname}"

        # cc: clone or create
        # son: snapshot or none
        if (dname != "base") and (encrypted and dedup):
            cc = "clone"
            son = f"{pool_name}/base@root"
        else:
            cc = "create"
            son = ""

        _doptions = ddict.get("options", [])
        if _dataset not in ( f"{pool_name}/{dataset}" for dataset in (
            "system",
            "system/root",
            "swap",
            "base",
            "hold",
            "omniverse",
            "reserved",
        )):
            pn1 = pool_name
            pn2 = f"{pn1}/{pn1}"

            # TODO: Make this such that the current dataset directory
            #       is placed under the parent directory's mountpoint
            if (mountpoint := (_mountpoint := ddict.get("mountpoint", ""))) == "":
                if mountpoint = "":
                    _mountpoint = _dataset.replace(
                        pn2 if pn2 in _dataset else pn1
                        "${host}",
                        1
                    )
                else:
                    mountpoint = _mountpoint = f"{mountpoint}/{dname}"

            dnix.write(f'\t"{_dataset}" = "{_mountpoint}";\n')
        doptions = " -o ".join(_doptions)
#+end_src

******* after opening =f{resources}/datasets.nix=

#+call: hash("")

#+RESULTS:
: 9bde4e3ed9b0f8a5edd7ce3e86bbcdeb

#+name: 9bde4e3ed9b0f8a5edd7ce3e86bbcdeb
#+begin_src python
        for dataset in (ddictd := ddict.get(
            d,
            dd
        )):
            recurse(ddictd[dataset], dataset, _dataset, mountpoint)

    for dataset in datasets:
        recurse(datasets[dataset], dataset, pool_name)

    dnix.write("}")
#+end_src

****** open =datasets.json=

#+call: hash("datasets-json")

#+RESULTS:
: d13f2d313813c806f6f6bd1040516bd9

#+name: d13f2d313813c806f6f6bd1040516bd9
#+begin_src json
{
    "base": {  },
    "hold": {  },
    "omniverse": {  },
    "reserved": {  },
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": {
                "datasets": {
                    "cache": {
                        "datasets": { "root": {  }},
                        "options": [ "sync=disabled" ]
                    },
                    "home": { "datasets": { "root": {  }}}
                }
            },
            "root": {  },
            "tmp": { "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

#+call: hash("")

#+RESULTS:
: cb652aaddb0e92c44ba367a0ea174f81

#+name: cb652aaddb0e92c44ba367a0ea174f81
#+begin_src python
datasets = json.loads('''
    <<d13f2d313813c806f6f6bd1040516bd9>>
'''.strip())

dsd = datasets[s][d]

datasets[args.pool_name] = {
    "datasets": {
        "b": {
            "datasets": {
                "a": dd,
                "cc": { "options": snapDir },
                "cl": dd,
                "cj": { "datasets": {
                    "cc": { "options": extraCopies },
                    "m": { "options": snapDir }
                }},
                "eb": { "options": extraCopies },
                "oreo": { "option": snapDir },
                "p": { "options": snapDir }
            },
        },
        "borg": { "datasets": { "cache": { "options": cache }}},
        "jails": { "datasets": { "base": dd}},
        "las": {
            "datasets": {
                "dreadnought": ddd,
                "redstone": ddd,
                "sinnoh": ddd
            }
        },
        "y": dd,
        "z": dd
    },
    "options": [ ml ]
}

<<d61c11eac203bfa4ee2cb42f93e5c959>>

for backup in (las := datasets[pool_name][d]["las"][d]).keys():
    for zz in [ "zpax", "zsyncs" ]:
        las[backup][d][zz] = dd

<<9b6d5ff07d5ba4ca0e95609407d6f5e4>>

#+end_src

***** mount

#+call: hash("")

#+RESULTS:
: 3836516e33beb8c8a336b3ac75d26e05

#+name: 3836516e33beb8c8a336b3ac75d26e05
#+begin_src python
from collections import namedtuple
from functools import partial
from os import path as osPath
from subprocess import DEVNULL

for dataset in $(zfs list).split("\n"):
    if pool_name in dataset:
        break
else:
    xrun(f"zpool import -f {pool_name}")

if encrypted:
    xrun(f"zfs load-key {pool_name}")

if osPath.isdir("/mnt"):
    xrun("umount -R /mnt")
else:
    xrun("mkdir /mnt")

xrun(f"mount -t zfs {pool_name}/system/root /mnt")

with open(f"{resources}/datasets.nix") as datasets:
    for dataset in datasets.readlines()[1:-1]:
        dataset = dataset.strip().strip('"')

        r = f"{pool_name}/"
        sr = r + "system/"
        _mount = dataset.replace(
            sr if sr in dataset else r,
            '',
            1
        )

        if not osPath.isdir(mount := f"/mnt/{_mount}"):
            xrun(f"mkdir -p {mount}")
        xrun(f"mount -t zfs {dataset} {mount}")

if not osPath.isdir(boot := "/mnt/boot/efi"):
    xrun(f"mkdir -p {boot}")

boot_device = raw_input("Please enter the boot device:\n\t")
xrun(f"mount {boot_device} {boot}")

if (swap := (raw_input('''
    Does this pool use SWAP?
        y | n\n\t
''') == "y")):
    xrun(f"swapon /dev/zvol/{pool_name}/swap")
#+end_src

***** update
****** before updating

#+call: hash("")

#+RESULTS:
: cde010f5bc96de0ae2d7961aa9a71dc4

#+name: cde010f5bc96de0ae2d7961aa9a71dc4
#+begin_src python
snapDir = [ "snapdir=visible" ]
extraCopies = snapDir + [ f"copies={2 if encrypted else 3}" ]
cache = [ "sync=disabled" ]
ml = "mountpoint=legacy"
dd = {  }
ddd = { "datasets": {  }}
d = "datasets"
s = "system"

<<cb652aaddb0e92c44ba367a0ea174f81>>

#+end_src

****** after updating the pool

#+call: hash("")

#+RESULTS:
: b09868eb4eaf5d508a70a487a8f2a5dc

#+name: b09868eb4eaf5d508a70a487a8f2a5dc
#+begin_src python
pool_size_plus_metric = $(zpool get -H size @(pool_name)).split()[2]
pool_size = round(float(pool_size_plus_metric[:-1]), 2)
pool_metric = pool_size_plus_metric[-1]

def pool_percentage_value(percentage):
    return (
        str(
            round(
                (
                    (float(percentage) / 100)
                    * pool_size
                ),
                2,
            )
        )
        + pool_metric
    )

# Apparently, if python internal keywords exist in the argument, such as "set", etc.
# the command errors out; perhaps something to raise an issue of.
# This seems to work as an alternative.
xrun(f"zfs set refreservation={pool_percentage_value(15)} {pool_name}/reserved")

if (swap := (raw_input('''
    Will this pool use SWAP?
        y | n\n\t
''') == "y")):
    _swoptions = [
        "com.sun:auto-snapshot=false",
        "compression=zle",
        "logbias=throughput",
        "primarycache=metadata",
        "secondarycache=none"
        "sync=standard",
    ]
    swoptions = " -o ".join(_swoptions)

    ps = $(getconf PAGESIZE)
    swap_size = int(raw_input("Please enter the (integer) SWAP size in GiB:\n\t"))
    xrun(f"zfs create -V {2**swap_size}G -b {ps} -o {swoptions} {pool_name}/swap")

    xrun(f"mkswap -f /dev/zvol/{pool_name}/swap")
#+end_src

****** if updating the pool

#+call: hash("")

#+RESULTS:
: 89b42fd94e35a06e40a08750404e994a

#+name: 89b42fd94e35a06e40a08750404e994a
#+begin_src python
        xrun(f"zfs {cc} {'-o ' if _doptions else ''} {doptions} {son} {_dataset}")
        xrun(f"zfs snapshot -r {_dataset}@root")
#+end_src

****** files

#+call: hash("")

#+RESULTS:
: aa6815ffe0495e012a80a5e3ddb4b0bd

#+name: aa6815ffe0495e012a80a5e3ddb4b0bd
#+begin_src python
<<cde010f5bc96de0ae2d7961aa9a71dc4>>

<<9bde4e3ed9b0f8a5edd7ce3e86bbcdeb>>

#+end_src

****** pool

#+call: hash("")

#+RESULTS:
: 03fc24d52cd1b15f6c3a2cb83ccaf5d2

#+name: 03fc24d52cd1b15f6c3a2cb83ccaf5d2
#+begin_src python
<<cde010f5bc96de0ae2d7961aa9a71dc4>>

<<89b42fd94e35a06e40a08750404e994a>>

<<9bde4e3ed9b0f8a5edd7ce3e86bbcdeb>>

<<b09868eb4eaf5d508a70a487a8f2a5dc>>

#+end_src

* system
** etc
*** nixos
**** configs

#+call: hash("pre")

#+RESULTS:
: 4c712913b902da3ab3e4d6a6c4b61f4e

#+name: 4c712913b902da3ab3e4d6a6c4b61f4e
#+begin_src nix
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = flatten [
        (imprelib.list { dir = ./.; })
        (imprelib.list { dir = ../../config; })
    ];
#+end_src

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

***** doppel
****** default.nix

#+call: hash("")

#+RESULTS:
: 29a9e8bb050717f9b80f1642ae7a4ec6

#+name: 29a9e8bb050717f9b80f1642ae7a4ec6
#+begin_src nix :tangle (jr/tangle-path)
<<4c712913b902da3ab3e4d6a6c4b61f4e>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

***** sandshrew
****** default.nix

#+call: hash("")

#+RESULTS:
: be5dee49c9f1a4329ab24cbd0e992e52

#+name: be5dee49c9f1a4329ab24cbd0e992e52
#+begin_src nix :tangle (jr/tangle-path)
<<4c712913b902da3ab3e4d6a6c4b61f4e>>
    config.networking.hostId = <<hostId()>>;
}
#+end_src

**** configuration.nix

#+call: hash("")

#+RESULTS:
: 85c71d57cb6422039ae10ee7e4a830ed

#+name: 85c71d57cb6422039ae10ee7e4a830ed
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, pkgs, ... } : with builtins; let
    source = fetchGit {
        url = "https://github.com/shadowrylander/shadowrylander";
        ref = "master";
    };

    flake = let
        flakePath = "${source}/system/etc/nixos";
        lock = builtins.fromJSON (builtins.readFile "${flakePath}/flake.lock");
    in (import (
        fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash; }
        ) { src =  flakePath; }).defaultNix;

    inherit (flake) lib;
    inherit (flake.legacyPackages) sources;

    stc = lib.j.attrs.default-stc // {
        device = "";
        host = "";
        type = "";
    };
    stc-home = stc // {
        nixos = 1;
        zfs = null;
    };

    integer-default-truths = lib.mapAttrs (
        n: v: v == 1
    ) (lib.filterAttrs (n: v: isInt v) stc-home);

    home-manager' = fetchGit {
        url = "https://github.com/nix-community/home-manager";
        ref = "master";
    };
    impermanence = fetchGit {
        url = "https://github.com/nix-community/impermanence";
        ref = "master";
    };
    hash = user: lib.j.hostName { stc = stc-home // { inherit user; }; };
    customInputs = inputs // { inherit stc lib sources; };
in
with lib;
with j;
with stc;
with integer-default-truths;
if (
    device == "" || host == "" || type == "" || zfs == null
) then (abort "Sorry! The device, host, type, and zfs status must be set!") else {
    <<e76b4601025ef4ed0071b29a0161182f>>
    imports = [
        (import (./. + "/configs/${stc.host}") customInputs)
        (import ./modules/variables.nix customInputs)
        (import ./modules/users.nix customInputs)
        (import "${home-manager'}/nixos")
        (import "${impermanence}/nixos.nix")
        (myIf.set (type == "pinebook") (
            "${fetchGit {
                url = "https://github.com/shadowrylander/wip-pinebook-pro";
                ref = "master";
            }}/configuration.nix"
        ))
        (myIf.shell (type == "rpi") (import ./devices/rpi (inputs // stc)))
    ];
    config = {

        # No need to merge "v" here, as that is taken care of by the module system
        users.users = mapAttrs (n: v: { packages = mkForce []; }) attrs.allUsers;

        home-manager = {
            useUserPackages = true;
            useGlobalPkgs = true;
            backupFileExtension = "bak";
            verbose = true;

            # TODO
            sharedModules = [
                {  }
            ];

            extraSpecialArgs = flake.legacyPackages.make.specialArgs { inherit stc; };

            users = listToAttrs (map (user: nameValuePair user (let
                homeDirectory = attrs.allHomes.${user};
            in {
                imports = [ (import "${impermanence}/home-manager.nix") ];
                programs.home-manager = {
                    enable = true;
                    path = home-manager';
                };
                home = {
                    file = mkMerge [{
                            "${attrs.users.primary}".source = source;
                            <<43603ebd7da002155f7108935561456a>>
                        }
                        (myIf.set (user == "root") (attrs.link "/" "${source}/system"))
                        (attrs.link homeDirectory "${source}/home")
                    ];
                    ${myIf.knull (nixos && zfs) "persistence"} = attrs.persistence.home {  };
                };
            })) attrs.allUsers);
        };
        environment = {
            ${myIf.knull zfs "persistence"} = attrs.persistence.system {  };
            etc."nix/nix.conf".text = attrs.configs.nix;
        };
        nixpkgs = {
            overlays = import ./overlays { inherit stc; };
            config = {
                <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
            };
        };
        boot.loader = {
            systemd-boot.enable = mkForce config.vars.bootPart;
            efi.efiSysMountPoint = "/boot/efi";
            efi.canTouchEfiVariables = mkForce true;
            grub.efiInstallAsRemovable = mkForce false;
            grub.enable = mkForce false;
            grub.efiSupport = mkForce true;
            grub.device = mkForce "nodev";
            grub.version = mkForce 1;
            grub.copyKernels = mkForce true;
            grub.forceInstall = mkForce true;
            grub.zfsSupport = mkForce false;

            # Used for Bedrock Linux
            initScript.enable = mkForce true;
        };
        nix = {
            package = pkgs.nixUnstable;
            extraOptions = '' experimental-features = nix-command flakes '';
        };
        environment.systemPackages = with pkgs; [ vim git rsync tmux byobu xonsh yadm
            # python39
        ];
    }
}
#+end_src

**** devices
***** hyper-v
****** boot.nix

Taken from [[https://github.com/NixOS/nixos-hardware/tree/master/microsoft/hyper-v][here]]:

#+call: hash("")

#+RESULTS:
: 30fdd17346f1ba60dd27355abe17b217

#+name: 30fdd17346f1ba60dd27355abe17b217
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # REQUIRED - see: https://github.com/nixos/nixpkgs/issues/9899

        kernelModules = [ "hv_vmbus" "hv_storvsc" ];
        initrd = {
            kernelModules = [ "hv_vmbus" "hv_storvsc" ];
            availableKernelModules = [ "hv_vmbus" "hv_storvsc" ];

            # UNKNOWN - not sure if below are needed; were suggested for VirtualBox and I used them
            checkJournalingFS = false;

        };
        extraModulePackages = with pkgs.linuxPackages_latest; [ hyperv-daemons ];

        # RECOMMENDED
        # - use 800x600 resolution for text console, to make it easy to fit on screen
        kernelParams = ["video=hyperv_fb:800x600"];  # https://askubuntu.com/a/399960
        # - avoid a problem with `nix-env -i` running out of memory
        # kernel.sysctl."vm.overcommit_memory" = "1"; # https://github.com/NixOS/nix/issues/421
    };
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 67725f65856c58234fc34b9275c4da43

#+name: 67725f65856c58234fc34b9275c4da43
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.noSwap = true;
        networking = {
            wireless.enable = false;
            interfaces.eth0.useDHCP = true;
        };
        virtualisation.hypervGuest.enable = true;
    };
}
#+end_src

***** linode
****** default.nix

#+call: hash("")

#+RESULTS:
: c8c26a3e2ac4a096597804d50e69fca2

#+name: c8c26a3e2ac4a096597804d50e69fca2
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        vars.terminal = true;
        boot = {
            kernelParams = [ "console=ttyS0,19200n8" ];
            loader.grub.extraConfig = ''
                serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
                terminal_input serial;
                terminal_output serial;
            '';
        };
        networking = {
            usePredictableInterfaceNames = false;
            interfaces.eth0.useDHCP = true;
        };
    };
}
#+end_src

***** rpi
****** 3b.nix

#+call: hash("")

#+RESULTS:
: 210b033fdaac881a3a29e9cb4224e623

#+name: 210b033fdaac881a3a29e9cb4224e623
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, type, ... }: with builtins; with lib; with j; mkIf (type == "3b") {
    vars.terminal = true;
    boot = {
        kernelParams = ["cma=256M"];
        loader = {
            raspberryPi = {
                enable = true;
                version = 3;
                uboot.enable = mkForce true;
                firmwareConfig = '' gpu_mem=256 '';
            };
        };
    };
    environment.systemPackages = with pkgs; [ raspberrypi-tools ];
}
#+end_src

****** 4b.nix

# TODO

#+call: hash("")

#+RESULTS:
: cca75de16da0c6105a43698cfaa4062d

#+name: cca75de16da0c6105a43698cfaa4062d
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, type, ... }: with builtins; with lib; with j; mkIf (type == "4b") {
    vars.terminal = true;
    boot = {
        kernelParams = ["cma=256M"];
        loader = {
            raspberryPi = {
                enable = true;
                version = 4;
                uboot.enable = true;
                firmwareConfig = '' gpu_mem=256 '';
            };
        };
    };
    environment.systemPackages = with pkgs; [ raspberrypi-tools ];
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: de4cfea4004dafc40636fe57881e6b9d

#+name: de4cfea4004dafc40636fe57881e6b9d
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** surface
****** _specialisation.nix

#+call: hash("")

#+RESULTS:
: ea28ac80f3af59ac23ca4fbb069d6c65

#+name: ea28ac80f3af59ac23ca4fbb069d6c65
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (specialisation_base) patches base;
    in {
        clear = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                        });
                    }));
                })];
            };
        };
        clear_xen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_latest_xen_dom0.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."57";
                        });
                    }));
                })];
            };
        };
        zen = base.settings // {
            configuration = {
                config.nixpkgs.overlays = [(self: super: {
                    surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                            kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                                { patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch"; name = "BACKPORT-Linux-5.8-compat-__vmalloc"; }
                            ];
                        });
                    }));
                })];
            };
        };
        bcachefs = base.settings // {
            configuration = {
                config = {
                    nixpkgs.overlays = [(self: super: {
                        surface_kernel_latest = super.linuxPackages_zen.extend( self: (ksuper: {
                        kernel = ksuper.kernel.override (base.kernel // {
                                kernelPatches = base.patches ++ base.iabg ++ patches.get patches.dir."58";
                            });
                        }));
                    })];
                    boot = {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
    };
}
#+end_src

****** nixpkgs.nix

#+call: hash("")

#+RESULTS:
: eee0f35786c35108f7d2dadbf8184200

#+name: eee0f35786c35108f7d2dadbf8184200
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    nixpkgs.overlays = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (specialisation_base) patches base;
    in [
        (self: super: { surface_kernel_latest = super.linuxPackages_zen.extend (
            self: (ksuper: { kernel = ksuper.kernel.override (
                base.kernel // { kernelPatches = base.patches ++ patches.get patches.dir."58" ++ [
                    {
                        patch = /. + "${patches.dir.base._}/BACKPORT-Linux-5.8-compat-__vmalloc.patch";
                        name = "BACKPORT-Linux-5.8-compat-__vmalloc";
                    }
                ];}
            );})
        );})
    ];
}
#+end_src

****** b2.nix

#+call: hash("")

#+RESULTS:
: 8d6dfe74baf8060aa28a2739c067d0ef

#+name: 8d6dfe74baf8060aa28a2739c067d0ef
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, device, ... }: with builtins; with lib; with j; mkIf (device == "b2") {
    boot.extraModprobeConfig = mkAfter '' options ipts singletouch=y '';
    powerManagement.resumeCommands = mkAfter '' modprobe ipts_surface singletouch=y '';
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env xonsh
        for usb in $(ls /dev/disk/by-id).split("\n"):
        if usb and usb[:4] == "usb-":
            for mnt in $(mount).split("\n"):
                if mnt and usb in mnt:
                    umount @(mnt.split()[2])
    '';
}
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 39c1556081e175b60672d04d9b7323c4

#+name: 39c1556081e175b60672d04d9b7323c4
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config = {
        boot.kernelPackages = pkgs.surface_kernel_latest;
        networking.networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
}
#+end_src

***** pinebook
****** import.nix

#+call: hash("")

#+RESULTS:
: e0a851a952ea6c27e7ad3ec227fd2a0d

#+name: e0a851a952ea6c27e7ad3ec227fd2a0d
#+begin_src nix :tangle (jr/tangle-path)
{ sources, ... }: { imports = [ "${sources.wip-pinebook-pro}/pinebook_pro.nix" ]; }
#+end_src

****** default.nix

#+call: hash("")

#+RESULTS:
: 0237cb109adc9f4a9631623c0b89fd0b

#+name: 0237cb109adc9f4a9631623c0b89fd0b
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
}
#+end_src

***** android
****** default.nix

#+call: hash("")

#+RESULTS:
: 55b5d44226e5746225157e35195ad435

#+name: 55b5d44226e5746225157e35195ad435
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    imports = imprelib.list { dir = ./.; };
    config.vars = { terminal = true; minimal = true; };
}
#+end_src

**** flake.nix

#+call: hash("modules")

#+RESULTS:
: bc8e4c4ef661dde1e91ee70adf2a661f

#+name: bc8e4c4ef661dde1e91ee70adf2a661f
#+begin_src nix
inherit (stc) system;
pkgs =  j.get (configBase // { set = all.pkgs; });
#+end_src

#+call: hash("")

#+RESULTS:
: 7b32bbc9949ccb99f79e4c691b878b5a

#+name: 7b32bbc9949ccb99f79e4c691b878b5a
#+begin_src nix :tangle (jr/tangle-path)
{
    description = "Wheee!";

    inputs = rec {
        <<da5fe3496669eea2dcae419277ad3927>>
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, flake-compat, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let

        mkOverlay = import ./overlays;

        prepkgs = import nixpkgs {
            overlays = mkOverlay {};
            config = {
                system = currentSystem;
                <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
            };
        };

        sources = inputs // prepkgs.j.sources;
        inherit (sources) nix;
        lib = nixpkgs.lib.extend (final: prev: {
            j = import ./lib {
                inherit sources;
                pkgs = prepkgs;
                lib = final;
            };
            h = sources.hlissner.lib;
        });

        inherit (lib) j;
        inherit (lib.j) attrs;
        fas = j.forAllSystems;
        make = {
            overlay = mkOverlay;
            pkgs = { stc, ... }: import prepkgs.j.nixpkgset.${stc.channel} {
                overlays = j.get { inherit stc; set = all.overlays; };
                config =  j.get { inherit stc; set = all.config; };
            };
            specialArgs = { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ];};
                config =  j.get (configBase // { set = all.config; });
                overlays =  j.get (configBase // { set = all.overlays; });
            in stc // {
                inherit sources inputs make all stc overlays lib;
                config' = config;
                hostName =  j.get { inherit stc; set = all.hostName; };
                stdenv =  j.get (configBase // { set = all.stdenv; });
                nixpkgs =  j.get (configBase // { set = all.nixpkgs; });
                nixpkgset = {
                    inherit (stc) system;
                    inherit overlays config;
                };
            };
            modules = nmports: { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ];};
                superPort = (nmports // {
                    <<bc8e4c4ef661dde1e91ee70adf2a661f>>
                } // (make.specialArgs { inherit stc; }));
            in flatten [
                (map (file: import file superPort) (j.imprelib.list { dir = ./modules; }))
                (with stc; [
                    (import (./. + "/configs/${host}") superPort)
                    (if (type == "def") then {} else (import (./. + "/devices/${type}") superPort))
                    (let path = ./. + "/platforms/${system}"; in
                        if (pathExists path) then (import path superPort) else {})
                ])
                (with sources; [
                    home-manager-flake.nixosModules.home-manager
                    agenix.nixosModules.age
                    impermanence-flake.nixosModules.impermanence
                ])
            ];
            nixosConfiguration = { stc, ... }: let
                configBase = { inherit stc; ignoredAttrs = [ "host" ];};
            in lib.nixosSystem {
                <<bc8e4c4ef661dde1e91ee70adf2a661f>>
                specialArgs = make.specialArgs { inherit stc; };
                modules = flatten [
                    (make.modules {} { inherit stc; })
                    (j.imprelib.list { dir = ./modules; })
                ];
            };
            nixosModule = { stc, ... }: nmports@{ config, ... }: { imports = flatten [
                (make.modules nmports { inherit stc; })
            ];};
        };
        all' = {
            inherit sources make;
            type = attrs.types;
            device = attrs.devices;
            nixpkgs = prepkgs.j.nixpkgset;
            channel = prepkgs.j.channels;
            host = attrs.hosts;
            # system = allSystems;
            system = [ "aarch64-linux" "x86_64-linux" ];
            # system = defaultSystems;
        } // (genAttrs (attrNames attrs.integer-defaults) (attr: range 0 1));
        all = let
            sc = {
                all = all';
                inheritance.pkgs = import nixpkgs {};
            };
        in {
            config = fas (recursiveUpdate sc {
                func = j.config;
                inheritance.stdenvs = all.stdenv;
            });
            hostName = fas {
                all = all';
                func = j.hostName;
                attrList = attrs.stc ++ (toList "host");
            };
            overlays = fas {
                all = all';
                func = make.overlay;
            };
            pkgs = fas {
                all = all';
                func = make.pkgs;
            };
            stdenv = fas (recursiveUpdate sc { func = j.stdenv; });
            hmConfigs = fas {
                all = all';
                func = j.hostName;
                inherit (all.vars) extraListSets;
            };
            vars = {
                extraListSets = {
                    user = attrs.allUsers;
                } // (genAttrs attrs.home-manager-integer-defaults (attr: range 0 1));
            };
        } // all';

        overlays =  j.get { stc = attrs.default-stc; set = all.overlays; };

    in with lib; with j; {

        inherit overlays lib;

        legacyPackages = all;

        nixosConfigurations = forAllSystems' { inherit all; func = make.nixosConfiguration; };
        nixosModules = forAllSystems' { inherit all; func = make.nixosModule; };

        # From: https://nixos.wiki/wiki/Flakes#Getting_Instant_System_Flakes_Repl
        nix.nixPath = let path = toString ./.; in [ "repl=${path}/repl.nix" "nixpkgs=${sources.nixpkgs}" ];

    } // (eachSystem all.system (system: {  }));

}
#+end_src

***** inputs

#+name: ff
#+begin_src emacs-lisp :var name="" :var ur=""
(format-spec "%n = {
    url = \"github:%u\";
    flake = false;
};" `((?n . ,name) (?u . ,ur)))
#+end_src

#+call: hash("")

#+RESULTS:
: da5fe3496669eea2dcae419277ad3927

#+name: da5fe3496669eea2dcae419277ad3927
#+begin_src nix :exports none
<<1ec89530455a22dd615fef7bcc833129>>
<<c5166e5f5e4c4cc5aa86a74ab5790120>>
<<7838098bf5241e080fc8c4f9bbe060f5>>
<<7461570ae52d935de8ba8b2f3c302192>>
<<90806cf21053b8c9c0b3da27fd374329>>
<<afedeb2f54e96f9a6beedcf19ece0d42>>
<<d51a5c8bfac4ed3d6a289147d52ec8e1>>
#+end_src

****** base

#+call: hash("")

#+RESULTS:
: 1ec89530455a22dd615fef7bcc833129

#+name: 1ec89530455a22dd615fef7bcc833129
#+begin_src nix
home-manager-flake = {
    url = "github:nix-community/home-manager/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

impermanence-flake = {
    url = "github:nix-community/impermanence/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

agenix = {
    url = "github:ryantm/agenix/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

flake-utils = {
    url = "github:numtide/flake-utils/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

hlissner = {
    url = "github:hlissner/dotfiles/master";
    inputs.nixpkgs.follows = "nixpkgs";
};

<<ff(name="flake-compat", ur="edolstra/flake-compat")>>

nixpkgs.url = "github:NixOS/nixpkgs/master";
#+end_src

****** tmux

#+call: hash("")

#+RESULTS:
: c5166e5f5e4c4cc5aa86a74ab5790120

#+name: c5166e5f5e4c4cc5aa86a74ab5790120
#+begin_src nix
<<ff(name="aleclearmind", ur="aleclearmind/nested-tmux")>>
<<ff(name="oh-my-tmux", ur="gpakosz/.tmux")>>
<<ff(name="powerline", ur="powerline/powerline")>>
<<ff(name="tpm", ur="tmux-plugins/tpm")>>
#+end_src

****** editors

#+call: hash("")

#+RESULTS:
: 7838098bf5241e080fc8c4f9bbe060f5

#+name: 7838098bf5241e080fc8c4f9bbe060f5
#+begin_src nix
<<ff(name="doom-emacs", ur="hlissner/doom-emacs")>>
<<ff(name="spacevim", ur="spacevim/spacevim")>>
#+end_src

****** shell

#+call: hash("")

#+RESULTS:
: 7461570ae52d935de8ba8b2f3c302192

#+name: 7461570ae52d935de8ba8b2f3c302192
#+begin_src nix
<<ff(name="bashCompletions", ur="scop/bash-completion")>>
<<ff(name="grml", ur="grml/grml-etc-core")>>
#+end_src

****** terminal

#+call: hash("")

#+RESULTS:
: 90806cf21053b8c9c0b3da27fd374329

#+name: 90806cf21053b8c9c0b3da27fd374329
#+begin_src nix
<<ff(name="kittyThemes", ur="dexpota/kitty-themes")>>
<<ff(name="xeroFigletFonts", ur="xero/figlet-fonts")>>
#+end_src

****** nixos

#+call: hash("")

#+RESULTS:
: afedeb2f54e96f9a6beedcf19ece0d42

#+name: afedeb2f54e96f9a6beedcf19ece0d42
#+begin_src nix
<<ff(name="extraContainer", ur="erikarvstedt/extra-container")>>
<<ff(name="nixos-surface", ur="anthe/nixos-surface")>>
#+end_src

****** kernels

#+call: hash("")

#+RESULTS:
: d51a5c8bfac4ed3d6a289147d52ec8e1

#+name: d51a5c8bfac4ed3d6a289147d52ec8e1
#+begin_src nix
xanmodV5104Cacule = {
    url = "github:xanmod/linux/5.10.4-xanmod1-cacule";
    flake = false;
};
xanmodV5914Cacule = {
    url = "github:xanmod/linux/5.9.14-xanmod1-cacule";
    flake = false;
};
#+end_src

**** lib

#+call: hash("")

#+RESULTS:
: ee56d4a974b19cdf64e1e8f02e47ccaa

#+name: ee56d4a974b19cdf64e1e8f02e47ccaa
#+begin_src nix
allowUnfree = true;
allowBroken = true;
allowUnsupportedSystem = true;
# preBuild = ''
#     makeFlagsArray+=(CFLAGS="-w")
#     buildFlagsArray+=(CC=cc)
# '';
permittedInsecurePackages = [
    "python2.7-cryptography-2.9.2"
];
#+end_src

***** default.nix

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

#+call: hash("")

#+RESULTS:
: 7415044e41c4923b87ec041b1f78173b

#+name: 7415044e41c4923b87ec041b1f78173b
#+begin_src nix :tangle (jr/tangle-path)
inputs@{
    sources ? ({
        nixpkgs = <nixpkgs>;
    }),
    pkgs ? (import sources.nixpkgs {}),
    lib ? pkgs.lib,
    preattrs ? (import ./_preattrs.nix lib),
    prelib ? (import ./_prelib.nix preattrs lib),
    primprelib ? (import ./_primprelib.nix preattrs prelib lib),
    ...
}: with builtins; with lib; let
    explicitInputs = { inherit
        sources
        pkgs
        lib
        preattrs
        prelib
        primprelib;
    };
    templib = self: prelib
        // (with prelib; {
            attrs = preattrs // (import ./_attrs.nix explicitInputs);
            imprelib = primprelib // (import ./_imprelib.nix explicitInputs);
        })
        // (listToAttrs (map (file: nameValuePair
            file
            (import (./. + "/${file}.nix") explicitInputs)
        ) (primprelib.listNames { dir = ./.; })));

    __ = makeExtensible templib;
in __.extend (final: prev: prelib.foldToSet (attrValues prev))
#+end_src

***** _preattrs.nix

#+call: hash("")

#+RESULTS:
: 218fdf4ae891826e566d02e51d8f323b

#+name: 218fdf4ae891826e566d02e51d8f323b
#+begin_src nix :tangle (jr/tangle-path)
lib: with builtins; with lib; rec {
    integer-defaults = {
        minimal = 0;
        musl = 1;
        noSwap = 0;
        terminal = 0;
        zfs = 1;
    };
    default-stc = integer-defaults // {
        system = currentSystem;
        type = "def";
        device = "def";
        channel = "pkgs";
    };
    stc = attrNames default-stc;
    home-manager-integer-defaults = { nixos = 1; };
    home-manager-default-stc = default-stc
        // home-manager-integer-defaults
        // { user = "root"; };
    home-manager-stc = attrNames home-manager-default-stc;
}
#+end_src

***** _prelib.nix

#+call: hash("")

#+RESULTS:
: 67c8aa904c9f23a0cd84d5743c7af83b

#+name: 67c8aa904c9f23a0cd84d5743c7af83b
#+begin_src nix :tangle (jr/tangle-path)
preattrs: lib:
with builtins;
with preattrs;
with lib;
rec {

    get = {
        stc ? preattrs.default-stc,
        set,
        ignoredAttrs ? []
    } : getAttrFromPath (
        map toString (attrValues (removeAttrs stc ignoredAttrs))
    ) set;

    hostName = { stc, ... }: substring 0 61 (hashString "sha512" (concatStrings (
        map toString (attrValues stc)
    )));

    forAllSystems' = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n (flatten [
            attrList
            [ "host" ]
        ])) all) // extraListSets;
        product = cartesianProductOfSets all';
    in listToAttrs (map (
        stc: nameValuePair (hostName { inherit stc; }) (func ({ inherit stc; } // inheritance))
    ) product);

    forAllSystems = {
        func,
        all,
        extraListSets ? {},
        attrList ? preattrs.stc,
        inheritance ? {}
    } : let
        all' = (filterAttrs (n: v: elem n attrList) all) // extraListSets;
        product = cartesianProductOfSets all';
    in foldToSet (map (
        # !!! There is no need to alphabetically sort the output of attrValues! !!!
        stc: setAttrByPath
            (map toString (attrValues stc))
            (func ({ inherit stc; } // inheritance))
    ) product);

    # TODO: Why is the filter necessary?
    foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);

    myIf = {
        list = condition: value: optionals condition value;
        singleton = condition: value: optional condition value;
        set = condition: value: if condition then value else {};
        num = condition: value: if condition then value else 0;
        knull = condition: value: if condition then value else null;
        empty = condition: value: if condition then value else "";
        drv = condition: evalue: value: if condition then value else evalue;
    };

    zipToSet = names: values: listToAttrs (
        map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
            if hasAttrs then names else (sort lessThan names)
        ) (
            if hasAttrs then values else (sort lessThan values)
        ))
    );

    stdenv = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        ...
    }: with stc; let
        musl = stc.musl == 1;
        arm = {
            systems = [
                "armv7a-linux"
                "armv7l-linux"
                "armv6a-linux"
                "armv6l-linux"
                "aarch64-linux"
            ];
            enable = elem system arm.systems;
            stdenv = {
                package = pkgs.clang10.stdenv;
                targetPlatform = if "armv7l-linux" then systems.examples.armv7l-hf-multiplatform
                    else systems.examples.aarch64-multiplatform;
            };
        };
        musl' = {
            enable = musl && (elem system ([
                "x86_64-linux"
            ] ++ arm.systems));
            stdenv = {
                package = pkgs.musl.stdenv;
                targetPlatform = systems.examples.musl64;
            };
        };
    in foldToSet [
        {
            inherit system;
            hostPlatform = currentSystem;
            buidPlatform = currentSystem;
        }
        (with arm; myIf.set enable stdenv)
        (with musl'; myIf.set enable stdenv)
    ];

    config = {
        pkgs,
        stc ? ({ system = currentSystem; musl = 1; }),
        buildEnvOvr ? true,
        stdenvs ? {},
        stdenv ? (attrByPath (attrValues stc) (stdenv { inherit pkgs stc; }) stdenvs),
        ...
    } : with stc; {
        inherit system;
        <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
        ${if buildEnvOvr then null else "buildEnv"} = {
            override = { inherit stdenv; };
        };
    };

    toCapital = string: concatImapStrings (
        i: v: if (i == 0) then (toUpper v) else v
    ) (stringToCharacters string);

    generatePersistentFD = filtered: persistentDirectory: let
        _ = type: filter (n: !elem n filtered) (
            mapAttrsToList (n: v: removePrefix persistentDirectory n)
        (filterAttrs (n: v: v == type) (readDir persistentDirectory)));
    in { directories = _ "directories"; files = _ "regular"; };

    sequence = list: end: foldr (a: b: deepSeq a b) end list;
}
#+end_src

***** _primprelib.nix

#+call: hash("")

#+RESULTS:
: dee6dcfbb1931e148059399abb661232

#+name: dee6dcfbb1931e148059399abb661232
#+begin_src nix :tangle (jr/tangle-path)
preattrs: prelib: lib:
with builtins;
with preattrs;
with prelib;
with lib;
rec {
    args = {
        suffix = "";
        ignores = [];
    };

    name = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        file
    }: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

    # !!! This returns a function
    filterFunc = {
        suffix ? args.suffix,
        noSuffix ? suffix == "",
        ignores ? args.ignores,
        dir,
    }: let
        _ignores = flatten [
            ignores
            (let
                _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
            in if (pathExists _ignores') then (import _ignores') else [])
            [ "default" "deprecated" ]
        ];
    in file: value:
        (if noSuffix then (
            (hasSuffix ".nix" file) || (value == "directory")
        ) else (hasSuffix suffix file)) &&
        (!hasPrefix "_" file) &&
        (!elem (name { inherit suffix file noSuffix; }) _ignores);

    contents = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
    }: filterAttrs (filterFunc _args) (readDir dir);

    list = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/${n}"),

    }: let
        __args = removeAttrs _args [ "func" ];
    in mapAttrsToList func (contents __args);

    listNames = {
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir
    }: list {
        inherit suffix ignores dir;
        func = (n: v: name { inherit suffix; file = n; });
    };
}
#+end_src

***** _attrs.nix

#+call: hash("prenix")

#+RESULTS:
: 4f8559fab44b31eee3bd94b54447bea2

#+name: 4f8559fab44b31eee3bd94b54447bea2
#+begin_src conf
keep-derivations = true
keep-outputs = true
experimental-features = nix-command flakes
allow-unsafe-native-code-during-evaluation = true
#+end_src

#+call: hash("")

#+RESULTS:
: fae48c3c1376c250513d68afedbb6450

#+name: fae48c3c1376c250513d68afedbb6450
#+begin_src nix :tangle (jr/tangle-path)
{ lib, preattrs, primprelib, ... }:
with builtins;
with preattrs;
with primprelib;
with lib;
rec {
    persistent = {
        files = {
            system = flatten [[ "/etc/host" ]];
            home = flatten [[
                ".emacs-profile"
                ".gitignore"
                ".nix-channels"
                ".python-history"
                ".viminfo"
                ".zsh-history"
                "README.org"
                "LICENSE"
            ]];
            cache = flatten [[  ]];
        };
        directories = {
            system = flatten [[
                "/etc/containers"
                "/etc/NetworkManager/system-connections"
                "/etc/nix"
                "/etc/nixos"
                "/etc/nixos/config"
                "/etc/ssh"
                "/etc/wireguard"
                "/var/lib/acme"
                "/var/lib/bluetooth"
            ]];
            home = flatten [[
                ".atom"
                ".bash-history"
                ".byobu"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                "Documents"
                "Downloads"
                "etc"
                "inca"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "Videos"
                users.primary
            ]];
            cache = flatten [(map (dir: ".cache/${dir}") [
                "flatpak"
                "gnome-software"
                "google-chrome-beta"
                "google-chrome-dev"
                "google-chrome"
                "Homebrew"
                "keybase"
                "mozilla"
                "nix"
                "pip"
                "pypoetry"
                "qtile"
                "starship"
                "vivaldi"
            ])];
        };
    };

    persistence = {
        system = extraFD: let persistent-directory = "/persist"; in {
            "${persistent-directory}" = mkMerge [
                ({
                    directories = persistent.directories.system;
                    files = persistent.files.system;
                })
                (generatePersistentFD [ "home" "cache" ] persistent-directory)
                extraFD
            ];
        };
        home = { user ? "root", extraCache ? {}, extraFD ? {}}: let
            phu = "/persist/home/${user}";
        in mapAttrs (n: v: v // { allowOther = true; }) {
            "/persist/cache/${user}" = foldToSet [
                ({
                    directories = persistent.directories.cache;
                    files = persistent.files.cache;
                })
                extraCache
            ];
            "${phu}" = foldToSet [
                ({
                    directories = persistent.directories.home;
                    files = persistent.files.home;
                })
                (generatePersistentFD [""] phu)
                extraFD
            ];
        };
    };

    link = root: source: listToAttrs (map (
        fd: nameValuePair "${root}/${fd}" {
            source = "${source}/${fd}";
            recursive = true;
        }
    ) (attrNames (readDir source)));

    # Device Types
    types = flatten [
        (listNames { dir = ../devices; })
        [ "def" ]
    ];

    devices = [
        "4b"
        "3b"
        "pro"
        "b2"
        "def"
    ];

    hosts = listNames { dir = ../configs; };

    # hosts = listToAttrs (flatten [
    #     (map (host: nameValuePair host {}) [
    #         # "bastion"
    #         "chimchar"
    #         # "fell"
    #         # "flipper"
    #         # "infernape"
    #         # "monferno"
    #         # "murasame"
    #         # "p20"
    #         # "p5"
    #         # "piplup"
    #         # "sandshrew"
    #         "sandslash"
    #         # "siluam"
    #         # "silvester"
    #     ])
    # ]);

    configs = rec {
        prenix = ''
            <<4f8559fab44b31eee3bd94b54447bea2>>
        '';
        nix = let
            MG = size: let
                mg = stringToCharacters size;
            in toString ((toInt (elemAt mg 0)) * (
                if (elemAt mg 1 == "M") then 1 else 1024
            ) * 1024 * 1024);
        in prenix + ''
            min-free = ${MG "250M"}
            max-free = ${MG "1G"}
        '';
    };
    services = {
        base = {
            enable = true;
            serviceConfig = {
                Restart = "on-failure";
                User = "shadowrylander";
            };
            wantedBy = [ "multi-user.target" ];
        };
        mkdir = path: "mkdir -p /persist/${path} &> /dev/null";
    };
    users = fromJSON (readFile ../resources/users.json);
    excludedUsers = [ "root" ];
    mainUsers = attrValues users;
    allUsers = mainUsers ++ excludedUsers;
    homes = listToAttrs (map (
        user: nameValuePair user "/home/${user}"
    ) mainUsers);
    allHomes = homes // { root = "/root"; };
    commands = {
        rebuild = "nixos-rebuild --impure";
        install = "nixos-install --impure --show-trace";
    };
    fileSystems = {
        base = {
            fsType = "zfs";
            options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
        };
        supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
    };
    versions = {
        python = "39";
        emacs = "26";
    };
    ssh.keys = {
        master = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    };
    platforms = {
        arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
        imd = [ "i686-linux" "x86_64-linux" ];
    };
}
#+end_src

***** paths.nix

#+call: hash("")

#+RESULTS:
: f91c0d27c14d4f8930db2234747ec9dc

#+name: f91c0d27c14d4f8930db2234747ec9dc
#+begin_src nix :tangle (jr/tangle-path)
{ sources, ... }: with builtins; rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches = {
        _  = "${nixos}/patches";
        surface = "${sources.nixos-surface}/linux-surface/patches";
    };
}
#+end_src

***** _imprelib.nix

#+call: hash("")

#+RESULTS:
: 445fa1f5b80d0f6437d4b366f304bc6f

#+name: 445fa1f5b80d0f6437d4b366f304bc6f
#+begin_src nix :tangle (jr/tangle-path)
{ lib, primprelib, ... }:
with builtins;
with primprelib;
with lib;
rec {
    set = _args@{
        suffix ? args.suffix,
        ignores ? args.ignores,
        dir,
        modules ? {},

        # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
        func ? (n: v: dir + "/" + n),

    }: let
        files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
    in zipToSet
        (map (file: name { inherit suffix file; }) files)
        (map (file: import file (foldToSet [ modules inputs ])) files);
}
#+end_src

**** modules
***** bcachefs.nix

#+call: hash("")

#+RESULTS:
: a796b1296ba0c7f4a66ce7467b7afe59

# TODO: Does not work on aarch64-linux yet

#+name: a796b1296ba0c7f4a66ce7467b7afe59
#+begin_src nix :tangle (jr/tangle-path)
{ config, pkgs, lib, system, ... }: with builtins; with lib; with j; let b = "bcachefs"; in mkIf (
    !elem system [ "aarch64-linux" ]
) {
    boot = {
        kernelPackages = mkForce pkgs."linuxPackages_testing_${b}";
        kernelModules = [ b ];
        initrd = {
            kernelModules = [ b ];
            availableKernelModules = [ b ];
        };
        supportedFilesystems = [ "bcachefs" ];
    };
}
#+end_src

***** boot.nix

#+call: hash("loader")

#+RESULTS:
: c0328b5b40730a0936ba5b5b494421a9

#+name: c0328b5b40730a0936ba5b5b494421a9
#+begin_src nix
loader = {
    systemd-boot = {
        enable = mkForce config.vars.bootPart;
        configurationLimit = 25;
        editor = false;
    };
    grub = {
        enable = mkForce false;
        efiSupport = true;
        devices = [ "nodev" ];
        version = 2;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';

    };
    efi = {
        canTouchEfiVariables = mkForce true;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    initScript.enable = mkForce true;
};
#+end_src

#+call: hash("")

#+RESULTS:
: a741daba47568ef930a9860652930bed

#+name: a741daba47568ef930a9860652930bed
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, host, ... }: with builtins; with lib; with j; {
    boot = let
        p = attrs.users.primary;
        pHome = config.users.users.${p}.home;
    in mkMerge [{
            <<c0328b5b40730a0936ba5b5b494421a9>>
            supportedFilesystems = attrs.fileSystems.supported;
            initrd = {
                inherit (config.boot) supportedFilesystems;
                compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
            };
            postBootCommands = let
                chowned = concatStringsSep "\n" (
                    map (user:
                        "sudo -u ${user} chown -R ${user}:${user} /persist/${attrs.allHomes.${user}} /persist/cache/${user}")
                    attrs.allUsers);
            in mkAfter (''
                mkdir -p /mnt
                sudo -u ${p} chown -R ${p}:${p} /${host}
            '' + chowned);
        }
        (mkIf (!config.vars.minimal) {
            extraModprobeConfig = '' options kvm_intel_nested=1 '';
        })
    ];
}
#+end_src

***** console.nix

#+call: hash("")

#+RESULTS:
: 92ac647bd78a14f38ebb0cd944903507

#+name: 92ac647bd78a14f38ebb0cd944903507
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    console = {
        # Select internationalisation properties.
        # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
        font = "Cartograph CF Light Italic";
        keyMap = "us";
    };
}
#+end_src

***** etc.nix

#+call: hash("")

#+RESULTS:
: 0fa3e0c1eb2ddb98d1de605ae7d805dc

#+name: 0fa3e0c1eb2ddb98d1de605ae7d805dc
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; {
    environment.etc = let
        kata-containers = {
            default-runtime = "kata-runtime";
            # runtimes.kata-runtime.path = "${getBin pkgs.kata-containers}/bin/kata-runtime";
            runtimes.kata-runtime.path = "${getBin pkgs.kata-containers.runtime}/bin/kata-runtime";
        };
        kc = toJSON kata-containers;
    in {
        "nix/nix.conf".text = attrs.configs.nix;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/storage.conf"}.text = kc + ''
            [storage]
            driver = "zfs"
            rootless_storage_path = "/var/lib/podman/$USER"

            [storage.options]
            additionalimagestores = [
                "/var/lib/docker",
            ]

            # [storage.options.zfs]
        '';
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "containers/libpod.conf"}.text = kc;
        ${myIf.knull (!elem system [ "aarch64-linux" ]) "docker/daemon.json"}.text = kc;
    };
}
#+end_src

***** filesystems.nix

#+call: hash("")

#+RESULTS:
: f75c7aea962922162380ecc15061163b

#+name: f75c7aea962922162380ecc15061163b
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; mkIf (config.vars.zfs) { fileSystems = let
    inherit (attrs.fileSystems) base;
    fileSystems' = import ./resources/datasets.nix host;
in mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
    mkForce (base // { device = dataset; ${
        myIf.knull (hasInfix "persist" dataset) "neededForBoot"
    } = true; })
)) fileSystems'; }
#+end_src

***** global.nix

#+begin_src text
Help is available in the configuration.nix(5) man page
and in the NixOS manual (accessible by running nixos-help).
#+end_src

#+call: hash("")

#+RESULTS:
: 84e11f81345c124be7b087d5c8c17d6a

#+name: 84e11f81345c124be7b087d5c8c17d6a
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, nixpkgset, system, ... }: with builtins; with lib; with j; {
    nixpkgs = nixpkgset;
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. Its perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            flake = https://github.com/nixos/nixpkgs/archive/master.tar.gz;
        };
    };
    boot.binfmt.emulatedSystems = [
        "armv7l-linux"
        "aarch64-linux"
    ];

    # Flatpak
    xdg.portal.enable = !elem system [ "aarch64-linux" ];

    environment.pathsToLink = [ "/share/nix-direnv" ];
    zramSwap = {
        enable = true;
        algorithm = "zstd";
    };
}
#+end_src

***** hardware.nix

#+call: hash("")

#+RESULTS:
: 3ae0b13c8f587784975d67a4717c20d8

#+name: 3ae0b13c8f587784975d67a4717c20d8
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    hardware = {
        enableRedistributableFirmware = lib.mkDefault true;
        # Enable sound
        pulseaudio.enable = true;
    };
    sound.enable = true;
}
#+end_src

***** home.nix

#+call: hash("")

#+RESULTS:
: baefabe5722e89e236e4925fa4c88af2

#+name: baefabe5722e89e236e4925fa4c88af2
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    # home-manager.users = let
    #     stc = {}
    #     inherit (config.vars) nixos zfs;
    # in listToAttrs (map (user: nameValuePair user (import /root/.config/nixpkgs/home.nix nixos zfs stc)) attrs.allUsers);
}
#+end_src

***** kernel.nix

#+call: hash("")

#+RESULTS:
: 1f6b4bbf4b1e571f3b746ff11b294b91

#+name: 1f6b4bbf4b1e571f3b746ff11b294b91
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    boot = {
        # kernelPackages = pkgs.linuxPackages_latest_xen_dom0_hardened;
        # kernelPackages = pkgs."linuxPackages_xanmod_v5.10.4_cacule";
        kernelPackages = pkgs.linuxPackages_lqx;
        # kernelPackages = pkgs.linuxPackages_zen;
        kernelPatches = [
            # { name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
            {
                name = "Enable ZSTD Compression";
                patch = null;
                extraConfig = ''
                    RD_ZSTD y
                    KERNEL_ZSTD y
                    KERNEL_XZ n
                '';
            }
        ];
        # extraModulePackages = with config.boot.kernelPackages; [ anbox wireguard ];
    };
}
#+end_src

***** memory.nix

Set the =SWAP= device if:

1. The configuration is not minimal, or
2. the =noSwap= variable is set to false.

I am currently not using =SWAP= on =ZFS Zvols= due to the issues detailed
[[https://github.com/openzfs/zfs/issues/7734][here]].

#+call: hash("")

#+RESULTS:
: da58947ae8facffd0bc1115d35641080

#+name: da58947ae8facffd0bc1115d35641080
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; mkIf (
    config.vars.minimal -> config.vars.noSwap
) { swapDevices = [{ device = "/dev/zvol/${host}/swap"; }]; }
#+end_src

***** networking.nix

#+call: hash("")

#+RESULTS:
: 8c1c76e68a6ad327be798ea5c62a7fc1

#+name: 8c1c76e68a6ad327be798ea5c62a7fc1
#+begin_src nix
{ config, lib, hostName, ... }: with builtins; with lib; with j; {
    networking = let
        primus = "58a4bafc38c2cc6e91ba27c7f1ca910c8fba857ee02f03648450b963db2519fc";
    in {
        inherit hostName;
        wireless = {
            enable = true; # Enables wireless support via wpa_supplicant.
            enable = false; # Enables wireless support via wpa_supplicant.
            networks = {
                "Primus-17FE-2.4" = {
                    pskRaw = primus;
                    priority = 0;
                };
                "Primus-17FE" = {
                    pskRaw = primus;
                    priority = 1;
                };
            };
        };
        networkmanager.enable = mkForce true;

        # The global useDHCP flag is deprecated, therefore explicitly set to false here.
        # Per-interface useDHCP will be mandatory in the future, so this generated config
        # replicates the default behaviour.
        useDHCP = false;

        # Configure network proxy if necessary
        # proxy = {
        # default = "http://user:password@proxy:port/";
        # noProxy = "127.0.0.1,localhost,internal.domain";
        # };

        # Open ports in the firewall.
        # firewall = {
        # allowedTCPPorts = [ ... ];
        # allowedUDPPorts = [ ... ];

        # Or disable the firewall altogether.
        # enable = false;
        # };

        # wireguard.interfaces.wg0 = {
        #   generatePrivateKeyFile = true;
        #   privateKeyFile = "/persist/etc/wireguard/wg0";
        # };
    };
}
#+end_src

***** nix.nix

#+call: hash("")

#+RESULTS:
: c0cedf33f5b5d915586e1ff9899331b0

#+name: c0cedf33f5b5d915586e1ff9899331b0
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = rec {
        gc = foldToSet [
            { automatic = true; }
            { dates = "monthly"; }
            # {
            #   dates = "monthly";
            #   options = "-d";
            # }
            # {
            #   dates = "daily";
            #   options = "--delete-older-than 30d";
            # }
        ];
        optimise = {
            automatic = true;
            dates = [ "05:00" ];
        };
        autoOptimiseStore = true;
        extraOptions = attrs.configs.nix;
        useSandbox = true;
        binaryCaches = flatten [
            (map (dir: "file:///${dir}/") [
                "chimchar"
                "empoleon"
            ])
        ];
        # sandboxPaths = [];
    };
}
#+end_src

***** packages.nix

#+call: hash("")

#+RESULTS:
: 150fb2f9ed97ee98bfb4c13d444892d0

#+name: 150fb2f9ed97ee98bfb4c13d444892d0
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, pkgs, sources, lib, ... } : { environment.systemPackages = import ../packages.nix inputs; }
#+end_src

***** persistence.nix

#+call: hash("")

#+RESULTS:
: a83c0f0caee15a1e432a618311cfb94f

#+name: a83c0f0caee15a1e432a618311cfb94f
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    environment.${myIf.knull config.vars.zfs "persistence"} = attrs.persistence.system {};
}
#+end_src

***** power.nix

#+call: hash("")

#+RESULTS:
: 6be210bd87996e57ea0297c46c5b432b

#+name: 6be210bd87996e57ea0297c46c5b432b
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    services.logind.lidSwitch = "hybrid-sleep";
    powerManagement = {
        enable = true;
        cpuFreqGovernor = mkForce "powersave";
    };
}
#+end_src

***** security.nix

This is mostly for Yubikey Authentication:

#+call: hash("")

#+RESULTS:
: 758b0e4461401df04a7c98e6aee9c027

#+name: 758b0e4461401df04a7c98e6aee9c027
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

***** services.nix

#+call: hash("sanoid")

#+RESULTS:
: 6b796fbba5d593b48cdc5c6eadab9b65

#+name: 6b796fbba5d593b48cdc5c6eadab9b65
#+begin_src nix
${myIf.knull config.vars.zfs "sanoid"} = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" sanoidBase) [
        host
        "system/persist"
        "virt"
        "omniverse"
    ]);
};
#+end_src

#+call: hash("syncoid")

#+RESULTS:
: 97c4bebd14fdabfc6ae83b9c0808043e

#+name: 97c4bebd14fdabfc6ae83b9c0808043e
#+begin_src nix
${myIf.knull config.vars.zfs "syncoid"} = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        (mkIf vars.encrypted {
            sendOptions = "vvwRI";
            recvOptions = "vvFs";
        })
        (mkIf (!vars.encrypted) {
            recvOptions = "vvFds";
            sendOptions = "vvRI";
        })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) [
        host
        "virt"
        "system/persist"
        "omniverse"
    ]);
};
#+end_src

#+call: hash("")

#+RESULTS:
: 5aecf05c58be2fe47ff406f3fdb2a823

#+name: 5aecf05c58be2fe47ff406f3fdb2a823
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, host, system, ... }: with builtins; with lib; with j; {
    services = {
        <<6b796fbba5d593b48cdc5c6eadab9b65>>

        <<97c4bebd14fdabfc6ae83b9c0808043e>>

        wakeonlan.interfaces = map (interface:
            { inherit interface; method = "magicpacket"; }
        ) (attrNames config.networking.interfaces);

        flatpak.enable = !elem system [ "aarch64-linux" ];

        # For Yubikey
        udev.packages = with pkgs; [
            yubikey-personalization
            libu2f-host
        ];
        pcscd.enable = true;

        openssh = {
            enable = true;
            extraConfig = mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
            '';
            permitRootLogin = "yes";
        };

        # Keybase
        kbfs.enable = true;
        keybase.enable = true;

        # Enable CUPS to print documents.
        printing.enable = true;

        # Enable the X11 windowing system.
        xserver = {
            enable = true;
            layout = "us";
            # xkbOptions = "eurosign:e";
            # Enable touchpad support.
            libinput = {
            enable = true;
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
            };
            # synaptics.enable = true;
            desktopManager = { xterm.enable = false; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+qtile"; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { startx.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { qtile.enable = true; };
            # "${ if (with config.vars; minimal || terminal) then null else "displayManager"}" = { defaultSession = "none+exwm"; };
            # "${ if (with config.vars; minimal || terminal) then null else "windowManager"}" = { exwm.enable = true; };
            # displayManager = { defaultSession = "none+qtile"; };
            displayManager = { startx.enable = true; };
            windowManager = { qtile.enable = true; };
            # displayManager = { defaultSession = "none+exwm"; };
            # windowManager = { exwm.enable = true; };
            # desktopManager.gnome3.enable = true;
            # desktopManager.gnome3.enable = true;
            # displayManager.gdm.enable = true;
        };

        ${myIf.knull config.vars.zfs "zfs"} = {
            autoScrub.enable = true;

            # Managed by Sanoid
            autoSnapshot.enable = false;
        };
    };
}
#+end_src

***** shell.nix

#+call: hash("")

#+RESULTS:
: 7eb7fea5811e26ec2a492a053e899cf5

#+name: 7eb7fea5811e26ec2a492a053e899cf5
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    programs = {
        xonsh.enable = true;
        fish.enable = true;
        zsh.enable = true;
    };
}
#+end_src

***** _specialisation.nix

#+call: hash("base")

#+RESULTS:
: bcfc9f879ab6b1c92ceecdb3462cc32d

#+name: bcfc9f879ab6b1c92ceecdb3462cc32d
#+begin_src nix
rec {
    patches = {
        dir = rec {
            base = lib.j.paths.patches;
            "57" = "${base.surface}/5.7";
            "58" = "${base.surface}/5.8";
        };
        get = dir: with r; list {
            suffix = ".patch";
            dir = (/. + d);
            func = (file: v: { patch = file; name = name { inherit suffix file; }; });
        };
    };
    base = {
        settings = { inheritParentConfig = true; };
        kernel.extraConfig = ''
            SERIAL_DEV_BUS y
            SERIAL_DEV_CTRL_TTYPORT y
            SURFACE_SAM m
            SURFACE_SAM_SSH m
            SURFACE_SAM_SAN m
            SURFACE_SAM_DTX m
            INPUT_SOC_BUTTON_ARRAY m
            SURFACE_3_POWER_OPREGION m
            SURFACE_3_BUTTON m
            SURFACE_3_POWER_OPREGION m
            SURFACE_PRO3_BUTTON m
        '';
        patches = [
            { patch = /. + "${patches.dir.base._}/export_kernel_fpu_functions_5_3.patch"; name = "export_kernel_fpu_functions_5_3"; }
            { patch = /. + "${patches.dir.base._}/set_power_mgmt.patch"; name = "set_power_mgmt"; }
        ];
        iabg = [{ patch = /. + "${patches.dir.base._}/0110-initialize-ata-before-graphics.patch"; name = "0110-initialize-ata-before-graphics"; }];
    };
}
#+end_src

#+call: hash("")

#+RESULTS:
: 62aabe9c8df8861b6117e855abd978f6

#+name: 62aabe9c8df8861b6117e855abd978f6
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    specialisation = let
        specialisation_base =
            <<bcfc9f879ab6b1c92ceecdb3462cc32d>>;
        inherit (lib.j.paths.patches) _;
        base = {
            specialisation = { inheritParentConfig = true; };
            kernel = {
                kernelPatches = specialisation_base.base.iabg;
            };
        };
    in {
        clear = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest; };
                };
            };
        };
        zen = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_zen; };
                };
            };
        };
        bcachefs = base.specialisation // {
            configuration = {
                config = {
                    boot = base.kernel // {
                        kernelModules = [ "bcachefs" ];
                        initrd = {
                            kernelModules = [ "bcachefs" ];
                            availableKernelModules = [ "bcachefs" ];
                            supportedFilesystems = [ "bcachefs" ];
                        };
                        supportedFilesystems = [ "bcachefs" ];
                    };
                };
            };
        };
        clear_xen = base.specialisation // {
            inheritParentConfig = true;
            configuration = {
                config = {
                    boot = base.kernel // { kernelPackages = pkgs.linuxPackages_latest_xen_dom0; };
                };
            };
        };
    };
}
#+end_src

***** systemd.nix

#+call: hash("")

#+RESULTS:
: 5e996eb2911402ddd75e66eb5df1fc51

#+name: 5e996eb2911402ddd75e66eb5df1fc51
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, ... }: with builtins; with lib; with j; {
    systemd = {
        packages = with pkgs; [ runit ly ];
        services = {
            runit.enable = true;
            ly.enable = true;
        };
    };
}
#+end_src

***** users.nix

#+call: hash("")

#+RESULTS:
: 9d513589a6349ecf2f69e7f3a3fd695d

#+name: 9d513589a6349ecf2f69e7f3a3fd695d
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, lib, pkgs, sources, stc, ... }: with builtins; with lib; with j; {
    users = with attrs.users; let
        base = mkMerge [{
                hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
                isNormalUser = true;
                createHome = true;
                extraGroups = [
                    "wheel"
                    "networkmanager"
                    "persist"
                ];
                openssh.authorizedKeys.keys = [
                    attrs.ssh.keys.master
                ];
                packages = import (
                    if (pathExists ../packages.nix) then ../packages.nix else ./packages.nix
                ) inputs;
            }
            (mkIf (!config.vars.minimal) {
                extraGroups = [ "libvirtd" "docker" ];
            })
        ];
    in rec {
        users = mkMerge [
            (genAttrs attrs.allUsers (user: base))
            {
                "${primary}" = {
                    uid = 4362;
                    home = attrs.allHomes.${primary};
                    description = "Jeet Ray";
                    group = primary;
                    extraGroups = [ secondary ];
                    shell = pkgs.xonsh;
                };
                "${secondary}" = {
                    uid = 1111;
                    home = attrs.allHomes.${secondary};
                    description = "Alicia Summers";
                    group = secondary;
                    extraGroups = [ primary ];
                    shell = pkgs.fish;
                };
                "${nightingale}" = {
                    uid = 8888;
                    home = attrs.allHomes.${nightingale};
                    description = "Curtis Nightingale";
                    group = "root";
                    extraGroups = [ primary secondary ];
                    shell = pkgs.zsh;
                };
                root = {
                    shell = mkForce pkgs.xonsh;
                    home = attrs.allHomes.root;
                    isNormalUser = mkForce false;
                    isSystemUser = mkForce true;
                };
            }
        ];

        mutableUsers = false;

        groups = {
            "${primary}" = {
                gid = config.users.users.${primary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${secondary}" = {
                gid = config.users.users.${secondary}.uid;
                members = [ primary secondary nightingale ];
            };
            "${nightingale}" = {
                gid = config.users.users.${nightingale}.uid;
                members = [ nightingale ];
            };
        };
    };
}
#+end_src

***** variables.nix

#+call: hash("options")

#+RESULTS:
: e76b4601025ef4ed0071b29a0161182f

#+name: e76b4601025ef4ed0071b29a0161182f
#+begin_src nix
options = {
    vars = mkOption {
        default = mkDefault {  };
        type = with lib.types; attrsOf bool;
    };
};
#+end_src

#+call: hash("")

#+RESULTS:
: 33c7c54f72f832ea599cfbf1021691f9

#+name: 33c7c54f72f832ea599cfbf1021691f9
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, stc, ... }: with builtins; with lib; with j; {
    <<e76b4601025ef4ed0071b29a0161182f>>
    config.vars = {
        bootPart = mkDefault true;
        syncDevice = mkDefault false;
    } // (mapAttrs (
        n: v: mkDefault (if (isInt v) then (v == 1) else v)
    ) (default-stc // stc));
}
#+end_src

***** virtualisation.nix

#+call: hash("")

#+RESULTS:
: 03ee73c0ac41094064d4eac783592662

#+name: 03ee73c0ac41094064d4eac783592662
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, pkgs, system, ... }: with builtins; with lib; with j; mkIf (
    !(config.vars.minimal || elem system [ "aarch64-linux" ])
) {
    virtualisation = {
        xen.enable = false;
        lxd = { zfsSupport = true; };
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

***** zfs.nix

#+call: hash("")

#+RESULTS:
: 43de72c9036fc67563aafc176269d329

#+name: 43de72c9036fc67563aafc176269d329
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, host, ... }: with builtins; with lib; with j; {
    boot = {
        kernelModules = [ "zfs" ];
        # loader.grub.zfsSupport = true;
        initrd = {
            postDeviceCommands = myIf.empty config.vars.zfs (mkAfter ''
                zfs rollback -r ${host}/system/root@blank
                zfs rollback -r ${host}/system/home@blank
            '');
            kernelModules = [ "zfs" ];
            availableKernelModules = [ "zfs" ];
        };
        zfs = {
            requestEncryptionCredentials = true;
            enableUnstable = true;
        };
        extraModulePackages = with config.boot.kernelPackages; [ zfsUnstable ];
    };
    # networking.hostId = substring 0 8 (readFile "/etc/machine-id");
}
#+end_src


**** overlays
***** base

#+call: hash("")

#+RESULTS:
: dc8e809f242cfa0de24ca1a4feb6134f

#+name: dc8e809f242cfa0de24ca1a4feb6134f
#+begin_src nix
let
    sc = { inherit pkgs stc; };
    stdenv = j.stdenv sc;
    config = j.config (sc // { inherit stdenv; });
in flatten [
    [(final: prev: { j = rec {
        inherit config stdenv sources;
        inherit (sources) nixpkgs;
        nixpkgset = 
            let
                withNPrefix = filterAttrs (
                    n: v: (hasPrefix nprefix n) || (n == nprefix)
                ) sources;
                withoutNPrefix = mapAttrs' (name: v: nameValuePair (
                    if (name == nprefix) then prefix else (
                        replaceStrings ["${nprefix}-"] [""] name
                    )
                ) v) withNPrefix;
            in removeAttrs withoutNPrefix (flatten [
                (filter (name: !elem name [
                    "pkgs"
                    "unstable"
                ]) (attrNames withoutNPrefix))
                [  ]
            ]);
        pkgset = (
            mapAttrs (n: v: import v { inherit config; }) nixpkgset
        ) // { "${channel}" = final; };
        channels = attrNames nixpkgset;
    };})]
    # [(
    #     final: prev: {
    #         fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchurl.patch ];}); }
    # )]
    # [(
    #     final: prev: {
    #         fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = attrs.patches ++ [ ../patches/fetchpypi.patch ];}); }
    # )]
    [
        (import sources.emacs)
        (final: prev: {
            nur = import sources.nur {
                nurpkgs = prev;
                pkgs = prev;
            };
        })
        (import ("${sources.wip-pinebook-pro}/overlay.nix"))
        # sources.emacs.overlay
        # sources.nur.overlay
    ]
    [
        # (final: prev: { nix = sources.nix.packages.${system}.nix; })
        (final: prev: { nix = (import sources.nix).packages.${system}.nix; })
        (final: prev: { niv = (import sources.niv {}).niv; })
        (final: prev: { emacs-nox = final.emacsGit-nox; })
    ]
    [
        (final: prev: {
            systemd = prev.systemd.overrideAttrs (old: { withHomed = true; });
        })
        (final: prev: {
            kata-containers = prev.kata-containers or (
                prev.callPackage ./_kataContainers.nix {}
            );
        })
    ]
    (
        let
            dir = sources.mozilla;
            mozilla = final: prev: listToAttrs (map (file: nameValuePair
                (removeSuffix "-overlay" file)
                (import "${dir}/${file}.nix" final prev)
            ) (filter (file: hasSuffix "-overlay" file) (j.imprelib.listNames { inherit dir; })));
        in [
            (final: prev: { firefox = final.mozilla.firefox.latest.firefox-bin; })
            (final: prev: { firefox-unbuilt = prev.firefox; })
            (final: prev: { mozilla = mozilla final prev; })
        ]
    )

    # TODO
    # (map (kernel': let
    #     kernel = "linuxPackages_${kernel'}";
    # in [( final: prev: { "${kernel}" = prev."${kernel}".extend (self:
    #     <<ab69b7b5650b908a61c99f5d0b07b92b>>
    # );})]) [ "lqx" "testing_bcachefs" "zen" ])

    # TODO
    # (let base.mach-nix = {
    #     inherit pkgs sources lib;
    #     mach-nix = import sources.mach-nix { inherit pkgs; python = "python39"; };
    # }; in map (overlay: import overlay base.mach-nix) (j.imprelib.list { dir = ./_mach-nix; }))

    (flatten (map (file:
        [(final: prev: {
            "${j.imprelib.name { inherit file; }}" = import file {
                inherit sources pkgs lib;
            };
        })]
    ) (j.imprelib.list { dir = ./.; ignores = [ "nix" ]; })))

    # TODO
    # (
    #     <<624779f89c5c4412effd0af738d38bdc>>
    # )
]
#+end_src

***** overrides

#+call: hash("")

#+RESULTS:
: 89dc592c50565b862b8b7f8585a34890

#+name: 89dc592c50565b862b8b7f8585a34890
#+begin_src nix
let pkgsets' = { unstable = [ "git" "go" "webkitgtk" ]; };
in flatten (mapAttrsToList (
    channel': pkglist: map (
        pkg: [(final: prev: {
            "${pkg}" = if (channel' == channel) then prev.${pkg} else final.j.pkgset.${channel'}.${pkg};
        })]
    ) pkglist
) pkgsets')
#+end_src

***** _mach-nix

#+call: hash("inputs")

#+RESULTS:
: 8ec5744691821b51c17805abe3a39695

#+name: 8ec5744691821b51c17805abe3a39695
#+begin_src nix
{
  sources ? ((import (
        let
            lock = builtins.fromJSON (builtins.readFile ../flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash;
        }
    ) { src =  ./. + "/.."; }).defaultNix),
  pkgs ? (import sources.nixpkgs {}),
  mach-nix ? (import sources.mach-nix { inherit pkgs; python = "python39"; }),
  ...
}
#+end_src

#+call: hash("extra")

#+RESULTS:
: fd90f4bebcfee78f3ce5049d7270da6c

#+name: fd90f4bebcfee78f3ce5049d7270da6c
#+begin_src nix
packagesExtra = [
    # "https://github.com/psf/requests/tarball/v2.22.0"
    (mach-nix.buildPythonPackage { src = sources.nanite; })      
    "https://files.pythonhosted.org/packages/bc/ab/c49f97516f78c2b0cacb4f45873abc4ca9872942a9c4c19ded8052c8edda/python-wifi-0.6.1.tar.bz2"
];
#+end_src

#+call: hash("providers")

#+RESULTS:
: b32c37f54eb384ffef676ce5785892e6

#+name: b32c37f54eb384ffef676ce5785892e6
#+begin_src nix
providers._defaults = "conda-forge,conda,wheel,sdist,nixpkgs";
#+end_src

#+call: hash("post")

#+RESULTS:
: 60a9ccf457d076fd00a2b7388fb3f993

#+name: 60a9ccf457d076fd00a2b7388fb3f993
#+begin_src emacs-lisp :var pkg="" :var version="" :var pythonPackages=""
(format-spec "
    newPkgs = machnixPy.nixpkgs;
    pythonPackages = newPkgs.python%v.pkgs;
    %p_py_%v = newPkgs.%p.override {
        %q = newPkgs.python%vPackages;
    };
    %p_with_pkgs = %p_py_%v.overrideAttrs (oa: {
        version = \"master\";
        src = sources.%p;
        inherit pythonPath;
    });
    finalOverlay = self: super: { %p = %p_with_pkgs; };
in finalOverlay" `((?p . ,pkg) (?q . ,pythonPackages) (?v . ,version)))
#+end_src

****** qtile.nix

#+call: hash("")

#+RESULTS:
: 90dea894ffe829f2e6306a244e87fa27

#+name: 90dea894ffe829f2e6306a244e87fa27
#+begin_src nix :tangle (jr/tangle-path)
<<8ec5744691821b51c17805abe3a39695>>:

with builtins; let

    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<fd90f4bebcfee78f3ce5049d7270da6c>>
        requirements = ''
        cairocffi
        iwlib
        '';
        _.iwlib.buildInputs.add = [ pkgs.wirelesstools ];
        <<b32c37f54eb384ffef676ce5785892e6>>
        providers.cairocffi = "wheel,sdist";
    };

    pythonPath =
        oa.pythonPath
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            # From https://github.com/NixOS/nixpkgs/issues/45038
            dateutil
            dbus-python
            keyring
            mpd2
            psutil
            pyxdg
            pygobject3
            nixpkgs
        ]);

<<60a9ccf457d076fd00a2b7388fb3f993(pkg="qtile", version="39", pythonPackages="python37Packages")>>
#+end_src

****** xonsh.nix

#+call: hash("")

#+RESULTS:
: 763dc29c9c55bfc541566514bc8fda66

#+name: 763dc29c9c55bfc541566514bc8fda66
#+begin_src nix :tangle (jr/tangle-path)
<<8ec5744691821b51c17805abe3a39695>>:

with builtins; let
    # build a mach-nix python env
    machnixPy = mach-nix.mkPython {
        <<fd90f4bebcfee78f3ce5049d7270da6c>>
        requirements = ''
        # add requirements here
        # jedi
        borgmatic
        dephell
        ply
        prompt_toolkit
        pygments
        pipx
        yubico-client
        ansible

        # add xontribs here
        # xonsh-direnv
        # xonsh-docker-tabcomplete
        # xonsh-vox-tabcomplete
        # xontrib-prompt-bar
        # xontrib-ssh-agent
        xonsh-autoxsh
        xontrib-autojump
        xontrib-fzf-widgets
        xontrib-kitty
        xontrib-pipeliner
        xontrib-powerline2
        xontrib-prompt-vi-mode
        xontrib-readable-traceback
        xontrib-schedule
        xontrib-z
        '';
        <<b32c37f54eb384ffef676ce5785892e6>>
    };

    pythonPath =
        (oa.pythonPath or [])
        ++ machnixPy.selectPkgs pythonPackages
        ++ (with pythonPackages; [
            ply
            prompt_toolkit
            pygments
            pipx
            yubico-client
            nixpkgs
        ]);

<<60a9ccf457d076fd00a2b7388fb3f993(pkg="xonsh", version="39", pythonPackages="python3Packages")>>
#+end_src

***** default.nix

#+call: hash("")

#+RESULTS:
: e7292651473712daff5abd4bee73fd9a

#+name: e7292651473712daff5abd4bee73fd9a
#+begin_src nix :tangle (jr/tangle-path)
with builtins; {
    stc ? ({ system = currentSystem; channel = "pkgs"; }),
    ...
} : with stc; let

    flake = (import (
        let
            lock = builtins.fromJSON (builtins.readFile ./flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash;
        }
    ) { src =  ./.; }).defaultNix;

    sources = flake.inputs;

    nprefix = "nixpkgs";
    prefix = "pkgs";
    inherit (sources) nixpkgs;
    pkgs = import nixpkgs {
        inherit (stc) system;
        config = {
            <<ee56d4a974b19cdf64e1e8f02e47ccaa>>
        };
    };
    lib = nixpkgs.lib.extend (final: prev: {
        j = import ../lib {
            inherit sources pkgs;
            lib = final;
        };
    });
in with lib; flatten [
    (
        <<dc8e809f242cfa0de24ca1a4feb6134f>>
    )
    (
        <<89dc592c50565b862b8b7f8585a34890>>
    )
]
#+end_src

***** kernels

This is the base extension, overriding the =nativeBuildInputs= attribute to include the =zstd= package, to facilitate =zstd=
compression for the kernel:

#+call: hash("")

#+RESULTS:
: ab69b7b5650b908a61c99f5d0b07b92b

#+name: ab69b7b5650b908a61c99f5d0b07b92b
#+begin_src nix
const (super: { kernel = super.kernel.overrideDerivation (drv: {
    nativeBuildInputs = drv.nativeBuildInputs ++ [ pkgs.zstd ];
});})
#+end_src

****** xanmod cacule

Adapted from [[https://www.reddit.com/r/NixOS/comments/jtgi35/cant_build_custom_kernel/][here]]:

#+call: hash("")

#+RESULTS:
: 624779f89c5c4412effd0af738d38bdc

#+name: 624779f89c5c4412effd0af738d38bdc
#+begin_src nix
map (ver: let
        inherit ver;
        _ = makeExtensible { "linuxPackages_xanmod_v${ver}_cacule" = prev.recurseIntoAttrs (
            prev.linuxPackagesFor (
                prev.callPackage (
                    args@{ fetchFromGitHub, buildLinux, ... }: buildLinux (args // rec {
                        version = "${ver}-xanmod1";
                        modDirVersion = version;
                        src = sources."xanmodV${replace ["."] [""] ver}Cacule" // { extraPostFetch = '' rm $out/.config ''; };
                        kernelPatches = [];
                        # postConfigure = '' make ARCH=x86_64 mrproper '';
                        extraConfig = ''
                        #     USER_NS_UNPRIVILEGED y
                        #     FUNCTION_TRACER n
                        #     GRAPH_TRACER n
                        #     NUMA n
                            RD_ZSTD y
                            KERNEL_ZSTD y
                            KERNEL_XZ n
                        '';
                        extraMeta.branch = "${ver}-xanmod1";
                    } // (args.argsOverride or {}))
                ) {}
            )
        );};
    in [( final: prev: { "linuxPackages_xanmod_v${ver}_cacule" = _.extend (self:
        <<ab69b7b5650b908a61c99f5d0b07b92b>>
);})]) [ "5.9.14" "5.10.4" ]
#+end_src

***** flake.nix

#+call: hash("")

#+RESULTS:
: 4e3ff4df217af0a51d77a1a30c4a3f60

#+name: 4e3ff4df217af0a51d77a1a30c4a3f60
#+begin_src nix :tangle (jr/tangle-path)
{
    description = "Overlay Sources";

    inputs = {
        <<ff(name="flake-compat", ur="edolstra/flake-compat/master")>>
        <<ff(name="emacs", ur="nix-community/emacs-overlay/master")>>
        nur.url = "github:nix-community/nur/master";
        mach-nix.url = "github:davhau/mach-nix/master";
        <<ff(name="mozilla", ur="mozilla/nixpkgs-mozilla/master")>>
        nanite = {
            url = "git+https://gitlab.com/picotech/nanotech/nanite.git";
            flake = false;
        };
        <<ff(name="niv", ur="nmattia/niv/master")>>
        nix.url = "github:nixos/nix/master";
        <<ff(name="qtile", ur="qtile/qtile/master")>>
        <<ff(name="xonsh", ur="xonsh/xonsh/main")>>
        <<ff(name="wip-pinebook-pro", ur="shadowrylander/wip-pinebook-pro/master")>>
        nixpkgs.url = "github:nixos/nixpkgs/master";
        nixpkgs-20-03.url = "github:nixos/nixpkgs/nixos-20.03";
        nixpkgs-20-03-small.url = "github:nixos/nixpkgs/nixos-20.03-small";
        nixpkgs-20-09.url = "github:nixos/nixpkgs/nixos-20.09";
        nixpkgs-20-09-small.url = "github:nixos/nixpkgs/nixos-20.09-small";
        nixpkgs-unstable.url = "github:nixos/nixpkgs/nixos-unstable";
        nixpkgs-unstable-small.url = "github:nixos/nixpkgs/nixos-unstable-small";
        nixpkgs-master.url = "github:nixos/nixpkgs/master";
    };

    outputs = inputs@{ self, flake-compat, ... } : {  };
}
#+end_src

**** packages.nix

#+begin_src nix :tangle (jr/tangle-path)
inputs@{
    pkgs,
    lib,
    sources,
    stc,
    config,
    ...
} : with lib; with j; with stc; let
    inherit (config.vars) minimal terminal;
    inherit (attrs) versions;
    neither = !(minimal || terminal);
    mkifnt = myIf.drv (!terminal) pkgs.hello;
    mkifn = myIf.drv neither pkgs.hello;
    mkifnm = myIf.drv (!minimal) pkgs.hello;
    extra-container = let pkgSrc = sources.extraContainer; in pkgs.callPackage pkgSrc { inherit pkgSrc; };
in with pkgs; [
    # autojump
    # acpilight
    # (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello appimage-run)
    # (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello appimagekit)
    # assh
    # autossh
    # bat
    # bc
    # bcachefs-tools
    # btrfs-progs
    # byobu
    # cascadia-code
    # copyq
    # coreutils
    # ctop
    # curl
    # darling-dmg
    # ddar
    # diskus
    # dos2unix
    # elvish
    # entr
    # exa
    # exfat
    # fasd
    # fd
    # fff
    # ffmpeg
    # ffmpeg
    # figlet
    # filet
    # fzf
    # gcc
    # git
    # git-crypt
    # git-fire
    # gotop
    # gptfdisk
    # inetutils
    # libffi
    # lolcat
    # lorri
    # micro
    # mkpasswd
    # monkeysphere
    # mosh
    # mtr
    # neo-cowsay
    # neovim
    # niv
    # nix-direnv
    # nixops
    # nnn
    # nox
    # ntfs3g
    # pandoc
    # par2cmdline
    # parted
    # peru
    # pfetch
    # pmutils
    # ranger
    # ripgrep
    # rsync
    # sd
    # shellcheck
    # silver-searcher
    # snapper
    # libguestfs
    # qemu_xen_4_10-light
    # starship
    # sysstat
    # thefuck
    # thermald
    # tmux
    # tmuxp
    # tree
    # udftools
    # uutils-coreutils
    # vagrant
    # vim
    # wget
    # win-qemu
    # wtf
    # xclip
    # xenPackages.xen_4_10-light
    # xz
    # yadm
    # yubico-pam
    # yubico-piv-tool
    # yubikey-manager
    # yubikey-personalization
    # yubioath-desktop
] ++ (map mkifn [
    # gnome3.gnome-boxes
    # gnome3.gnome-tweaks
    # google-chrome
    # google-chrome-beta
    # google-chrome-dev
    # vivaldi
    # vivaldi-ffmpeg-codecs
    # vivaldi-widevine
    # vscodium
]) ++ (map mkifnm [
    # extra-container
    # haskellPackages.hocker
    # refind
]) ++ (map mkifnt [
    # alacritty
    # atom
    # (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello etcher)
    # firefox
    # gnome3.gnome-disk-utility
    # gparted
    # keybase-gui
    # kitty
    # libsForQt5.qtstyleplugin-kvantum
    # shadowfox
    # vlc
    # vscode
    # woeusb
    # xclip
    # xfce.thunar
    # yubikey-manager-qt
    # yubikey-personalization-gui
]) ++ (with pkgs.j.pkgset.20-09."emacs${versions.emacs}Packages"; [
    # (mkifnm exwm)
]) ++ (with pkgs."python${versions.python}Packages"; [
    # (myIf.drv (!elem system [ "aarch64-linux" ]) pkgs.hello pyls-black)
    # pyls-black
    # (mkifnm jupyter)
    # nixpkgs
    # poetry
]) ++ (with pkgs.gitAndTools; [
    # git-annex
    # git-extras
    # git-hub
    # gitflow
    # gh
    # hub
    # lab
]) ++ (map (npp: mkifnm pkgs."nix-prefetch-${npp}") [
    # "github"
    # "docker"
    # "scripts"
]) ++ (with pkgs.nur.repos; [
    # (mkifnt onny.foliate)
]) ++ [
    # # For emacs

    # # org-roam
    # sqlite

    # # org-md-export-to-markdown
    # nodePackages.prettier
] ++ (let
    p = "python${versions.python}Packages";
in [
    # (getAttr "black" (
    #     if (pkgs ? black) then pkgs else pkgs."${p}"
    # ))

    # (myIf.drv (
    #     (pkgs ? black-macchiato) || (pkgs."${p}" ? black-macchiato)
    # ) pkgs.hello (getAttr "black-macchiato" (
    #     if (pkgs ? black-macchiato) then pkgs else pkgs."${p}"
    # )))

    # (myIf.drv (pkgs ? duf) pkgs.hello (getAttr "duf" pkgs))
    # (myIf.drv (pkgs ? gitoxide) pkgs.hello (getAttr "gitoxide" pkgs))
    # (myIf.drv (pkgs ? glances) pkgs.hello (getAttr "glances" pkgs))
    # (myIf.drv (pkgs ? nixos-shell) pkgs.hello (getAttr "nixos-shell" pkgs))
    # (myIf.drv (pkgs ? obsidian && !neither) pkgs.hello (getAttr "obsidian" pkgs))
    # (myIf.drv (pkgs ? yubikey-agent) pkgs.hello (getAttr "yubikey-agent" pkgs))
    # (myIf.drv (pkgs ? zenith) pkgs.hello (getAttr "zenith" pkgs))
    # (myIf.drv (pkgs."${p}" ? pipx) pkgs.hello (getAttr "pipx" pkgs."${p}"))
])
#+end_src

**** platforms
***** shared
****** armv67l.nix

#+call: hash("")

#+RESULTS:
: ae4d89307b8e79de7de4d6b3b013fe4f

#+name: ae4d89307b8e79de7de4d6b3b013fe4f
#+begin_src nix :tangle (jr/tangle-path)
{ config, lib, ... }: with builtins; with lib; with j; {
    nix = {
        binaryCaches = [
            "http://nixos-arm.dezgeg.me/channel"
            "https://app.cachix.org/cache/thefloweringash-armv7"
        ];
        binaryCachePublicKeys = [
            "nixos-arm.dezgeg.me-1:xBaUKS3n17BZPKeyxL4JfbTqECsT+ysbDJz29kLFRW0=%"
            "thefloweringash-armv7.cachix.org-1:v+5yzBD2odFKeXbmC+OPWVqx4WVoIVO6UXgnSAWFtso="
        ];
    };
}
#+end_src

***** arm
****** default.nix

#+call: hash("")

#+RESULTS:
: 66a218b142afada2a828f04a8d8a3ba7

#+name: 66a218b142afada2a828f04a8d8a3ba7
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (file: import file inputs) (imprelib.list { dir = ./.; });
    config = {
        # NixOS wants to enable GRUB by default
        boot.loader.grub.enable = false;
        # Enables the generation of /boot/extlinux/extlinux.conf
        boot.loader.generic-extlinux-compatible.enable = true;
    };
}
#+end_src

***** armv6l-linux
****** default.nix

#+call: hash("")

#+RESULTS:
: 72cb27fb954a94b3fb1f5fe55e70b000

#+name: 72cb27fb954a94b3fb1f5fe55e70b000
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

***** armv7l-linux
****** default.nix

#+call: hash("")

#+RESULTS:
: c35840e7b11bd1168fcb3322bfb98fef

#+name: c35840e7b11bd1168fcb3322bfb98fef
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ../shared/armv67l.nix ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

***** aarch64-linux
****** default.nix

#+call: hash("")

#+RESULTS:
: a5b3a096d1cdc7efefdc21274f566aef

#+name: a5b3a096d1cdc7efefdc21274f566aef
#+begin_src nix :tangle (jr/tangle-path)
inputs@{ config, lib, ... }: with builtins; with lib; with j; {
    imports = map (fd: import fd inputs) (flatten [
        [ ../arm ]
        (imprelib.list { dir = ./.; })
    ]);
}
#+end_src

**** repl.nix

#+call: hash("")

#+RESULTS:
: d97b95e355f4a2c3ea9b4b071a3b6f89

#+name: d97b95e355f4a2c3ea9b4b071a3b6f89
#+begin_src nix :tangle (jr/tangle-path)
let
  flake = builtins.getFlake (toString ./.);
  nixpkgs = import <nixpkgs> { };
in
{ inherit flake; }
// flake
// builtins
// nixpkgs
// nixpkgs.lib
// flake.nixosConfigurations
#+end_src

**** resources
***** users.json

#+call: hash("")

#+RESULTS:
: 4b4166b2bebff5d6dc0a9118372f6e36

#+name: 4b4166b2bebff5d6dc0a9118372f6e36
#+begin_src json :tangle (jr/tangle-path)
{
    "primary": "shadowrylander",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** nix
**** nix.conf

#+call: hash("")

#+RESULTS:
: 34e26ea775bf30b2ee891fce9fcd39a5

#+name: 34e26ea775bf30b2ee891fce9fcd39a5
#+begin_src nix :tangle (jr/tangle-path)
<<5585804cafd4d120113b762c4e097541>>
#+end_src

*** zsh
**** keephack

#+call: hash("pre")

#+RESULTS:
: 70d62a901e2d13d41930afa279c62a5f

#+name: 70d62a901e2d13d41930afa279c62a5f
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 7fa800ae7af5b2ef406e2ae619952c6a

#+name: 7fa800ae7af5b2ef406e2ae619952c6a
#+begin_src sh :tangle (jr/tangle-path)
<<70d62a901e2d13d41930afa279c62a5f()>>
#+end_src

* home
** .gitattributes

#+call: hash("")

#+RESULTS:
: 0e934803846ff23710dd8874b37bcd39

#+name: 0e934803846ff23710dd8874b37bcd39
#+begin_src gitattributes :tangle (jr/tangle-oreo)
<<08dbff12d7941b00d17c353f5fe4e078>>
#+end_src

** .xonsh.d
*** fzf_tmux_dir_file.sh

#+call: hash("")

#+RESULTS:
: 0de7faf0cd17a1a0331065aecac3d1f3

#+name: 0de7faf0cd17a1a0331065aecac3d1f3
#+begin_src sh :tangle (jr/tangle-path)
echo $(find "$1" | fzf-tmux)
#+end_src

*** fzf_tmux_pkg.sh

#+call: hash("")

#+RESULTS:
: 4e80721df27f5fe6796c0a85ae03d390

#+name: 4e80721df27f5fe6796c0a85ae03d390
#+begin_src sh :tangle (jr/tangle-path)
echo $(dpkg --get-selections | fzf-tmux)
#+end_src

** .xonshrc

#+call: hash("")

#+RESULTS:
: 7ac499a656c336e7e715cc4c56df6fac

#+name: 7ac499a656c336e7e715cc4c56df6fac
#+begin_src xonsh :tangle (jr/tangle-oreo)
<<b7a800fefe161963d69a4d47eb645f78>>
#+end_src

#+call: hash("hm")

#+RESULTS:
: c440f22ba3bfdf95901cc661a825d4b0

#+name: c440f22ba3bfdf95901cc661a825d4b0
#+begin_src nix
".xonshrc".text = let
    python_ver = concatStringsSep "." (stringToCharacters attrs.versions.python);
    Channel = toCapital channel;
in with attrs.commands; ''
homeManager = True

<<7ac499a656c336e7e715cc4c56df6fac>>
'' + (myIf.empty nixos ''

<<8bdf510b6e8257d68db1657608ac1add>>
'');
#+end_src

*** nixos

#+call: hash("")

#+RESULTS:
: 8bdf510b6e8257d68db1657608ac1add

#+name: 8bdf510b6e8257d68db1657608ac1add
#+begin_src xonsh
#################
# NixOS ${Channel}
#################

aliases["rebuild"] = lambda args, stdin=None: $(${rebuild} @(args) -p ${host})
aliases["install"] = lambda args, stdin=None: $(${install})

# TODO: Revise this
def _deploy(args, stdin=None):
    sudo nixops create /etc/nixos/nixops/home.nix -d home
    sudo nixops set-args --arg hostName ${get {
        set = all.hostName;
        stc = (filterAttrs (n: v: elem n j.attrs.stc) stc) // { inherit (stc) host; };
    }} -d home
    if "all" in args:
        sudo nixops deploy -d home
aliases["deploy"] = _deploy
#+end_src

** zsh

#+call: hash("")

#+RESULTS:
: e3c9522290eaca30dc3548b3373abbee

#+name: e3c9522290eaca30dc3548b3373abbee
#+begin_src nix
zsh = let zedFile = file: let
    grml = "${sources.grml}/etc/zsh/${file}";
in myIf.empty (pathExists grml) (readFile grml); in {
    enable = true;
    enableAutosuggestions = true;
    enableVteIntegration = true;
    autocd = true;

    # TODO: Maybe this could be all paths in $PATH?
    cdpath = [  ];

    defaultKeymap = "viins";
    history.extended = true;
    initExtra = '' '';
    # initExtraFirst = '' '';
    initExtraBeforeCompInit = (zedFile "zshrc") + ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    profileExtra = (zedFile "zprofile") + '' '';
    envExtra = (zedFile "zshenv") + '' '';
    loginExtra = (zedFile "zlogin") + '' '';
    logoutExtra = (zedFile "zlogout") + '' '';
    oh-my-zsh = {
        enable = false;
        plugins = [  ];
        extraConfig = '' '';
        # theme = "sushi";
        custom = "";
    };
    plugins = [  ];
    prezto = {
        enable = true;
        editor = {
            dotExpansion = true;
            keymap = "vi";
        };
        extraConfig = '' '';
        extraFunctions = [  ];
        extraModules = [  ];
        pmodules = [  ];
        pmoduleDirs = [  ];
        # prompt.theme = "paradox";
        tmux.itermIntegration = true;
        utility.safeOps = true;
    };
    inherit shellAliases;
    shellGlobalAliases = {  };
};
starship.enableZshIntegration = true;
#+end_src

** .zshrc

#+call: hash("pre")

#+RESULTS:
: 9d1f2431e218c2cb00bf6f327a47eb2e

#+name: 9d1f2431e218c2cb00bf6f327a47eb2e
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshrc"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            ""))
    "\nsource ~/.nix-profile/etc/profile.d/hm-session-vars.sh\n"
    "eval \"$(starship init zsh)\"")
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: eedec1f071fc8797a259ee4782ef4ae1

#+name: eedec1f071fc8797a259ee4782ef4ae1
#+begin_src sh :tangle (jr/tangle-path)
<<9d1f2431e218c2cb00bf6f327a47eb2e()>>
#+end_src

** .zshenv

#+call: hash("pre")

#+RESULTS:
: 4574f2b39635370ecb451f6bb98ac782

#+name: 4574f2b39635370ecb451f6bb98ac782
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zshenv"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: e4bdd7035e68ad25bf7601a613a30286

#+name: e4bdd7035e68ad25bf7601a613a30286
#+begin_src sh :tangle (jr/tangle-path)
<<4574f2b39635370ecb451f6bb98ac782()>>
#+end_src

** .zprofile

#+call: hash("pre")

#+RESULTS:
: 78ce427e065f3552c838fe54085acdfd

#+name: 78ce427e065f3552c838fe54085acdfd
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zprofile"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 756501ce3e856f5ca93fffddf7d1fb22

#+name: 756501ce3e856f5ca93fffddf7d1fb22
#+begin_src sh :tangle (jr/tangle-path)
<<78ce427e065f3552c838fe54085acdfd()>>
#+end_src

** .zlogout

#+call: hash("pre")

#+RESULTS:
: 1ed1e29f1f67c0bdc343b12368df60a5

#+name: 1ed1e29f1f67c0bdc343b12368df60a5
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogout"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: 87b1d7b7615b7888dc93cc7b7924808f

#+name: 87b1d7b7615b7888dc93cc7b7924808f
#+begin_src sh :tangle (jr/tangle-path)
<<1ed1e29f1f67c0bdc343b12368df60a5()>>
#+end_src

** .zlogin

#+call: hash("pre")

#+RESULTS:
: cec0e99ea02e55fb6dbf99f230a283c5

#+name: cec0e99ea02e55fb6dbf99f230a283c5
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/grml/etc/zsh/zlogin"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+call: hash("")

#+RESULTS:
: fff4069a824df27cfa8f20481fcb466d

#+name: fff4069a824df27cfa8f20481fcb466d
#+begin_src sh :tangle (jr/tangle-path)
<<cec0e99ea02e55fb6dbf99f230a283c5()>>
#+end_src

** .config
*** kitty

#+call: hash("programs")

#+RESULTS:
: d46b4b74ffb23d4335d4797f45067031

#+name: 6b65ba25e46bf89e07ec8b638f44e9c3
#+begin_src nix
kitty = {
    enable = true;
    extraConfig = readFile "${homeDirectory}/${primary.user}/home/.config/kitty/kitty.conf";
    settings.font_family = "Cartograph CF Light Italic";
};
#+end_src

#+call: hash("theme")

#+RESULTS:
: 338a3b4e851f416dd70aa64a977efb96

#+name: 338a3b4e851f416dd70aa64a977efb96
#+begin_src text
Monokai_Soda
#+end_src

#+call: hash("files")

#+RESULTS:
: 6b65ba25e46bf89e07ec8b638f44e9c3

#+name: 6b65ba25e46bf89e07ec8b638f44e9c3
#+begin_src nix
".config/kitty/theme.conf".source = sources.kittyThemes + "/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf";
#+end_src

**** kitty.conf

#+call: hash("")

#+RESULTS:
: d5cad3354664f4ad4e5802cf2dc76abd

#+name: d5cad3354664f4ad4e5802cf2dc76abd
#+begin_src conf :tangle (jr/tangle-path)
include ./theme.conf
#+end_src

**** theme.conf

#+call: hash("pre")

#+RESULTS:
: 641e23c8f738164a8ff4f2234396e19d

#+name: 641e23c8f738164a8ff4f2234396e19d
#+begin_src emacs-lisp
(concat
    (let
        ((file "./resources/kittyThemes/themes/<<338a3b4e851f416dd70aa64a977efb96>>.conf"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

#+call: hash("")

#+RESULTS:
: bc36e158c20fa8907fa07bb998f74ddc

#+name: bc36e158c20fa8907fa07bb998f74ddc
#+begin_src conf :tangle (jr/tangle-path)
<<641e23c8f738164a8ff4f2234396e19d()>>
#+end_src

*** qtile

#+call: hash("")

#+RESULTS:
: 20def59e134751937775a539588c359a

#+name: 20def59e134751937775a539588c359a
#+begin_src nix
".config/qtile/config.py".source = "${homeDirectory}/${primary.user}/home/.config/qtile/config.py";
#+end_src

**** config.py

#+call: hash("")

#+RESULTS:
: 7e005c00414442d051268853d7f8cb48

#+name: 7e005c00414442d051268853d7f8cb48
#+begin_src python :tangle (jr/tangle-oreo)
<<56382ca914291d6df41adbd417b19df2>>
#+end_src

*** fish

#+call: hash("")

#+RESULTS:
: 9c831035ff1aab8cf5467639c4b6ddc4

#+name: 9c831035ff1aab8cf5467639c4b6ddc4
#+begin_src nix
fish = {
    enable = true;
    package = pkgs.fish;
    functions = shellAliases // {
        sf = "source ~/.config/fish/config.fish";
    };
    interactiveShellInit = ''
        bass source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    plugins = [
        {
            name = "bass";
            src = fetchGit {
                url = "https://github.com/edc/bass";
                ref = "master";
            };
        }
    ];
};
starship.enableFishIntegration = true;
#+end_src

**** config.fish

#+call: hash("")

#+RESULTS:
: 9c0077fdacc601fe6caec99e8c8f75d6

#+name: 9c0077fdacc601fe6caec99e8c8f75d6
#+begin_src fish :tangle (jr/tangle-path)
bass source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias sf=source ~/.config/fish/config.fish
alias n=exit
alias c=clear
starship init fish | source
#+end_src

*** ion

#+call: hash("")

#+RESULTS:
: b370468cc7d7048c2fca654384bf409f

#+name: b370468cc7d7048c2fca654384bf409f
#+begin_src nix
".config/ion/initrc".source = "${homeDirectory}/${primary.user}/home/.config/ion/initrc";
#+end_src

**** initrc

#+call: hash("")

#+RESULTS:
: d00469abd110d42d30147634bf86ace9

#+name: d00469abd110d42d30147634bf86ace9
#+begin_src ion :tangle (jr/tangle-path)
eval $(starship init ion)
#+end_src

*** powershell

#+call: hash("")

#+RESULTS:
: 8a50158d25e446dd85b7a0c8bda9c113

#+name: 8a50158d25e446dd85b7a0c8bda9c113
#+begin_src nix
".config/powershell/Microsoft.PowerShell_profile.ps1".source = "${homeDirectory}/${primary.user}/home/.config/powershell/Microsoft.PowerShell_profile.ps1";
#+end_src

**** Microsoft.PowerShell_profile.ps1

#+call: hash("")

#+RESULTS:
: f1e0f68a73ddf5bce156364bd43b5524

#+name: f1e0f68a73ddf5bce156364bd43b5524
#+begin_src powershell :tangle (jr/tangle-path)
Invoke-Expression (&starship init powershell)
#+end_src

*** nixpkgs

#+call: hash("pre")

#+RESULTS:
: 1ed0e2f1a5109f8af2a280a16b4eb269

#+name: 1ed0e2f1a5109f8af2a280a16b4eb269
#+begin_src emacs-lisp :var oc=""
(format-spec "
    with builtins;
    with (getFlake \"/etc/nixos\");
    with lib;
    with j;
let stc = legacyPackages.hostName.${getEnv \"HOSTNAME\"};
in getAttrFromPath (attrValues stc) legacyPackages.%o" `((?o . ,oc)))
#+end_src

#+call: hash("")

#+RESULTS:
: 43603ebd7da002155f7108935561456a

#+name: 43603ebd7da002155f7108935561456a
#+begin_src nix
".config/nixpkgs/overlays.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/overlays.nix";
".config/nixpkgs/config.nix".source = "${homeDirectory}/${primary.user}/home/.config/nixpkgs/config.nix";
".config/nix/nix.conf".text = attrs.configs.nix;
#+end_src

**** overlays.nix

#+call: hash("")

#+RESULTS:
: 2b4d9f0b772a93416e5f4674ed96ed87

#+name: 2b4d9f0b772a93416e5f4674ed96ed87
#+begin_src nix :tangle (jr/tangle-path)
<<1ed0e2f1a5109f8af2a280a16b4eb269(oc="overlays")>>
#+end_src

**** config.nix

#+call: hash("")

#+RESULTS:
: 9c8535c9269073f1e3c081f7595eb7fe

#+name: 9c8535c9269073f1e3c081f7595eb7fe
#+begin_src nix :tangle (jr/tangle-path)
<<1ed0e2f1a5109f8af2a280a16b4eb269(oc="config")>>
#+end_src

**** home.nix

#+call: hash("vars")

#+RESULTS:
: 7f0e66916c2f315cb8ef3f098a5299db

#+name: 7f0e66916c2f315cb8ef3f098a5299db
#+begin_src nix
fromAll = category: get {
    set = all.${category};
    stc = removeAttrs (
        attrNames attrs.home-manager-integer-defaults
    ) stc;
};
pkgs = fromAll "pkgs";
overlays = fromAll "overlays";
config = fromAll "config";

integer-default-truths = mapAttrs (
    n: v: v == 1
) (filterAttrs (n: v: isInt v) stc);

primary = {
    user = attrs.users.primary;
    home = attrs.allHomes.${primary.user};
};
homeDirectory = attrs.allHomes.${user};

baseOptions = {
    # force = true;
};

userName  = primary.user;
userEmail = "aiern@protonmail.com";

links' = rec {
    cookiejar = {
        source = "/${host}/b/cj";
        target = "cj";
    };
    picotech = {
        source = "${cookiejar.source}/cc/.pico";
        target = ".pico";
    };
    byobu = {
        source = "${homeDirectory}/.tmux.conf";
        target = ".byobu/.tmux.conf";
    };
};
links = mapAttrs (link: st: {
    inherit (st) target;
    source = /. + st.source;
}) (filterAttrs (link: st: pathExists (/. + st.source)) links');

shellAliases = {
    n = "exit";
    c = "clear";
};

withLink = link: with link; { "${target}" = { inherit source; }; };

hash = user: j.hostName { stc = stc // { inherit user; }; };
#+end_src

#+call: hash("programs")

#+RESULTS:
: b8786b3a304b41cac890b67b0d489482

#+name: b8786b3a304b41cac890b67b0d489482
#+begin_src nix
({
    <<e3c9522290eaca30dc3548b3373abbee>>
})
({
    <<c0f02c8e18aaf90b2db3568216a0f7b4>>
})
({
    <<9c831035ff1aab8cf5467639c4b6ddc4>>
})
({
    <<4790b5c880f2991fff358970c8ae652f>>
})
({
    <<6c9703c9e8d7c1dfd7081a89ba30b713>>
})
({
    <<0f713b3a4ffd4b5c77b96597753d4d77>>
})
({
    <<6b65ba25e46bf89e07ec8b638f44e9c3>>
})
({
    <<5e11372671a7413353f2df031f63bcda>>
})
({
    <<b7bb86447f895ccb29ee0524e2f0ab42>>
})
({
    <<7701583d01c93a70b96d051e6eee2ea8>>
})
#+end_src

#+call: hash("files")

#+RESULTS:
: 33a8f6e58d91e946436eee8b8f8a1fa5

#+name: 33a8f6e58d91e946436eee8b8f8a1fa5
#+begin_src nix
({
    <<246ca7e4d33bc1b57d6cee0768532d38>>
})
({
    <<c440f22ba3bfdf95901cc661a825d4b0>>
})
({
    <<686d2e9e79fc3a96bf63b5d18b5eb4cb>>
})
({
    <<b370468cc7d7048c2fca654384bf409f>>
})
({
    <<8a50158d25e446dd85b7a0c8bda9c113>>
})
({
    <<41e1a054113e318e196b0a8a0ccf5cb5>>
})
({
    <<8c9f6caafcb32cd315c3f5a8d52f4b19>>
})
({
    <<e530065768d9c227fc6b5cb199d6af41>>
})
({
    <<948976000227fb0afe43a2da70bcb5c6>>
})
({
    <<20def59e134751937775a539588c359a>>
})
({
    <<6b65ba25e46bf89e07ec8b638f44e9c3>>
})
({
    <<43603ebd7da002155f7108935561456a>>
})
#+end_src

#+call: hash("")

#+RESULTS:
: 0fdd9f7014b87a898a3c8660a3df9d07

#+name: 0fdd9f7014b87a898a3c8660a3df9d07
#+begin_src nix :tangle (jr/tangle-path)
with builtins; let
    base = { stc, all, flake, ... }:
        with builtins;
        with lib;
        with j;
        with stc;
        with integer-default-truths;
    let
        <<7f0e66916c2f315cb8ef3f098a5299db>>
    in rec {
        inherit lib;
        nixpkgs = { inherit (stc) system; inherit overlays config; };
        fonts.fontconfig.enable = mkForce true;
        imports = [ "${sources.impermanence}/home-manager.nix" ];
        useUserPackages = true;
        useGlobalPkgs = true;
        backupFileExtension = "bak";
        verbose = true;

        # TODO
        sharedModules = [
            {  }
        ];

        extraSpecialArgs = flake.legacyPackages.make.specialArgs { inherit stc; };

        programs = foldToSet (map (set: mapAttrs (
            n: v: baseOptions // v
        ) set) (flatten [
            [
                {
                    home-manager = {
                        enable = true;
                        path = sources.home-manager.outPath;
                    };
                }
                <<b8786b3a304b41cac890b67b0d489482>>
            ]
        ]));

        services = {
            gpg-agent = {
                enable = true;
                enableSshSupport = false;
                pinentryFlavor = "curses";
            };
            emacs = {
                enable = true;
                package = if (programs ? emacs) then programs.emacs.package else pkgs.emacsGcc;
            };
        };

        home = let
            persistence = {
                ${
                    myIf.knull (nixos && zfs) "persistence"
                } = attrs.persistence.home { inherit user; };
            };

            seqList = [

                # !!! CAREFUL! THE ORDER HERE MATTERS! !!!
                persistence

            ];

        in sequence seqList (foldToSet [{
                packages = import ../../etc/nixos/packages.nix { inherit stc lib pkgs; };
                file = foldToSet (map (set: mapAttrs (
                    n: v: { force = true; } // v
                ) set) (flatten [
                    [
                        ({ ".hgignore".source = "${homeDirectory}/${primary.user}/home/.hgignore"; })
                        (let source = "/persist/home/root/${primary.user}"; in foldToSet [
                            (myIf.set (user == "root") (attrs.link "/" "${source}/system"))
                            (attrs.link homeDirectory "${source}/home")
                            {
                                "${primary.user}".source = source;
                                ${myIf.knull (user == "root") "/usr/local/etc/doas.conf"}.text = ''
                                    permit keepenv :wheel
                                    permit nopass keepenv root as root
                                '';
                            })
                            <<33a8f6e58d91e946436eee8b8f8a1fa5>>
                        ]
                    ]
                    (map withLink (attrValues links))
                ]));
            }
            persistence
        ]);
    };

    flake = (import (
        let
            lock = builtins.fromJSON (builtins.readFile /etc/nixos/flake.lock);
        in fetchTarball {
            url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
            sha256 = lock.nodes.flake-compat.locked.narHash; }
        ) {
            src =  /etc/nixos;
        }).defaultNix
    inherit (flake) all;

in with lib; with j; forAllSystems' {
    inherit all;
    func = base;
    inherit extraListSets;
    inheritance = { inherit all flake; };
}
#+end_src

*** nix
**** nix.conf

#+call: hash("")

#+RESULTS:
: 5585804cafd4d120113b762c4e097541

#+name: 5585804cafd4d120113b762c4e097541
#+begin_src conf :tangle (jr/tangle-path)
<<4f8559fab44b31eee3bd94b54447bea2>>
min-free = 262144000
max-free = 1073741824
#+end_src

*** yadm
**** bootstrap

#+call: hash("")

#+RESULTS:
: 6fe6b364d9fba7cd66bd9cf730282b2a

#+name: 6fe6b364d9fba7cd66bd9cf730282b2a
#+begin_src python :tangle (jr/tangle-path)
<<5918a1d90f5b7e61007371faf087dff7>>
#+end_src

** .bashrc

#+call: hash("hm")

#+RESULTS:
: c0f02c8e18aaf90b2db3568216a0f7b4

#+name: c0f02c8e18aaf90b2db3568216a0f7b4
#+begin_src nix
bash = {
    enable = true;
    enableVteIntegration = true;
    initExtra = ''
        source ${homeDirectory}/.nix-profile/etc/profile.d/hm-session-vars.sh
    '';
    inherit shellAliases;
    shellOptions = [  ];
};
starship.enableBashIntegration = true;
#+end_src

#+call: hash("")

#+RESULTS:
: f14c4cd75f29401f56be846a13cb86c2

#+name: f14c4cd75f29401f56be846a13cb86c2
#+begin_src sh :tangle (jr/tangle-path)
source ~/.nix-profile/etc/profile.d/hm-session-vars.sh
alias c=clear
alias n=exit
alias sb=source ~/.bashrc
eval "$(starship init bash)"
#+end_src

** rc.elv

#+call: hash("hm")

#+RESULTS:
: 686d2e9e79fc3a96bf63b5d18b5eb4cb

#+name: 686d2e9e79fc3a96bf63b5d18b5eb4cb
#+begin_src nix
"rc.elv".source = "${homeDirectory}/${primary.user}/home/rc.elv";
#+end_src

#+call: hash("")

#+RESULTS:
: 8563464483cb5d919d84774684320f18

#+name: 8563464483cb5d919d84774684320f18
#+begin_src elvish :tangle (jr/tangle-path)
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
eval (starship init elvish)
#+end_src

** .SpaceVim.d

#+call: hash("")

#+RESULTS:
: 41e1a054113e318e196b0a8a0ccf5cb5

#+name: 41e1a054113e318e196b0a8a0ccf5cb5
#+begin_src nix
".config/nvim" = {
    source = sources.spacevim;
    recursive = true;
};
".vim" = {
    source = sources.spacevim;
    recursive = true;
};
".SpaceVim.d/init.toml".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/init.toml";
".SpaceVim.d/autoload/vimrc.vim".source = "${homeDirectory}/${primary.user}/home/.SpaceVim.d/autoload/vimrc.vim";
#+end_src

*** init.toml

#+call: hash("")

#+RESULTS:
: ef0ca6b027b247fed6e95bb31f027708

#+name: ef0ca6b027b247fed6e95bb31f027708
#+begin_src conf :tangle (jr/tangle-oreo)
<<610e9954e5b1fa36fd50580e2061424f>>
#+end_src

*** autoload
**** vimrc.vim

#+call: hash("")

#+RESULTS:
: e4619751678bb7065fc7ec1a80a0ff98

#+name: e4619751678bb7065fc7ec1a80a0ff98
#+begin_src vimrc :tangle (jr/tangle-oreo)
<<a9f44e9cd05fda5b5e5dffb41d946748>>
#+end_src

** makefile

#+call: hash("repos")

#+RESULTS:
: 7e5d38a2c9af18003ca89c3dad2d1b97

#+name: 7e5d38a2c9af18003ca89c3dad2d1b97
#+begin_src text
scop/bash-completion ~/<<username>>/resources/bashCompletions
xero/figlet-fonts ~/<<username>>/resources/xeroFigletFonts
grml/grml-etc-core ~/<<username>>/resources/grml
SpaceVim/SpaceVim ~/<<username>>/home/.vim
hlissner/doom-emacs ~/<<username>>/home/.emacs.d
dexpota/kitty-themes ~/<<username>>/resources/kittyThemes
aleclearmind/nested-tmux ~/<<username>>/resources/aleclearmind
gpakosz/.tmux ~/<<username>>/resources/oh-my-tmux
powerline/powerline ~/<<username>>/resources/powerline
tmux-plugins/tpm ~/<<username>>/resources/tpm
#+end_src

#+call: hash("")

#+RESULTS:
: c9792b0b851c8df28651f125f42b1868

#+name: c9792b0b851c8df28651f125f42b1868
#+begin_src makefile :tangle (jr/tangle-path)
.RECIPEPREFIX := |

init:
|-git clone --recurse-submodule https://github.com/<<7e5d38a2c9af18003ca89c3dad2d1b97>>
|-ln -sf home/.vim ~/<<username>>/home/.config/nvim
#+end_src

** git

#+call: hash("programs")

#+RESULTS:
: 4790b5c880f2991fff358970c8ae652f

#+name: 4790b5c880f2991fff358970c8ae652f
#+begin_src nix
git = {
    # File at ~/.config/git/config
    enable = true;
    package = pkgs.git;
    lfs.enable = true;
    extraConfig = {
        core = {
            excludesfile = "${homeDirectory}/.gitignore";
            attributesfile = "${homeDirectory}/.gitattributes";
        };

        # TODO: Add the greater-than sizes
        annex.largefiles = ''
            include=**/__pycache__/* or \
            include=**/dist/* or \
            include=**/tests/* or \
            include=**/deprecated/* or \
            include=**/unfinished/* or \
            include=**/.vscode/* or \
            include=**/*.test.* or \
            include=**/*.envrc
        '';

    };
    inherit userEmail userName;
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 246ca7e4d33bc1b57d6cee0768532d38

#+name: 246ca7e4d33bc1b57d6cee0768532d38
#+begin_src nix
".gitignore".text = "${homeDirectory}/${primary.user}/home/.gitignore";
".gitattributes".text = "${homeDirectory}/${primary.user}/home/.gitattributes";
#+end_src

** .gitignore

#+call: hash("")

#+RESULTS:
: 1ea4bb5fe97c460bf6cd50db65f78bbe

#+name: 1ea4bb5fe97c460bf6cd50db65f78bbe
#+begin_src gitignore :tangle (jr/tangle-path)
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

** .hgrc

#+call: hash("hm")

#+RESULTS:
: 6c9703c9e8d7c1dfd7081a89ba30b713

#+name: 6c9703c9e8d7c1dfd7081a89ba30b713
#+begin_src nix
mercurial = {
    enable = true;
    package = pkgs.mercurial;
    inherit userEmail userName;
    ignoresRegexp = [];
    extraConfig = {
        extensions = {
            # hgext = {
            #     bookmarks = "";
            #     convert = "";
            # };
            # hggit = "/usr/lib/python2.7/site-packages/hggit";
            hggit = "";
            strip = "";
            share = "";
        };
        trusted = {
            users = primary.user;
            groups = primary.user;
        };
        git.blockdothg = "false";
        ui.ignore = "${homeDirectory}/.hgignore";
    };
};
#+end_src

** .hgignore

#+call: hash("")

#+RESULTS:
: 9f58d4089d36710d31eaed9419ed38cd

#+name: 9f58d4089d36710d31eaed9419ed38cd
#+begin_src gitignore :tangle (jr/tangle-path)
<<1ea4bb5fe97c460bf6cd50db65f78bbe>>
#+end_src

** emacs

#+call: hash("programs")

#+RESULTS:
: 0f713b3a4ffd4b5c77b96597753d4d77

#+name: 0f713b3a4ffd4b5c77b96597753d4d77
#+begin_src nix
emacs = {
    enable = true;
    package = pkgs.emacsGcc;
    overrides = final: prev: {
        magit-delta = super.magit-delta.overrideAttrs (eprev: {
            buildInputs = eprev.buildInputs ++ [ pkgs.git ];
        });
    };
    # extraPackages = with pkgs."emacs${j.attrs.versions.emacs}Packages"; [
    #     sqlite3
    #     emacsql-sqlite3
    # ];
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 8c9f6caafcb32cd315c3f5a8d52f4b19

#+name: 8c9f6caafcb32cd315c3f5a8d52f4b19
#+begin_src nix
# ".doom.d/system_init.el".text = ''
#   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".emacsql-sqlite3}/bin")
#   (add-to-list 'exec-path "${pkgs."emacs${j.attrs.versions.emacs}Packages".sqlite3}/bin")
# '';
".doom.d".source = "${homeDirectory}/${primary.user}/home/.doom.d";
".emacs.d".source = sources.doom-emacs;
#+end_src

** starship

#+call: hash("")

#+RESULTS:
: b7bb86447f895ccb29ee0524e2f0ab42

#+name: b7bb86447f895ccb29ee0524e2f0ab42
#+begin_src nix
starship = {
    enable = true;
    package = pkgs.starship;
    settings = {

    };
};
#+end_src

** .tmux.conf

#+call: hash("")

#+RESULTS:
: f8c37c2c0aee46bde39319b837f36e16

#+name: f8c37c2c0aee46bde39319b837f36e16
#+begin_src conf :tangle (jr/tangle-oreo)
<<67bb84ea2b3abf4eba054728fef72e40>>
#+end_src

** .byobu
*** .tmux.conf

#+call: hash("")

#+RESULTS:
: 376191d12bcf3a386a37cd100cf20711

#+name: 376191d12bcf3a386a37cd100cf20711
#+begin_src conf :tangle (jr/tangle-oreo)
<<67bb84ea2b3abf4eba054728fef72e40>>
#+end_src

** tmux

#+call: hash("programs")

#+RESULTS:
: 5e11372671a7413353f2df031f63bcda

#+name: 5e11372671a7413353f2df031f63bcda
#+begin_src nix
<<8182b9565b9c8ccb0a8f2c87319c9955>>
#+end_src

#+call: hash("files")

#+RESULTS:
: e530065768d9c227fc6b5cb199d6af41

#+name: e530065768d9c227fc6b5cb199d6af41
#+begin_src nix
".tmuxp/default.yaml".text = "session_name: default";
#+end_src

** .direnvrc

#+call: hash("")

#+RESULTS:
: 0f61833f5f550b3981d8bf80354f4bc5

#+name: 0f61833f5f550b3981d8bf80354f4bc5
#+begin_src shell :tangle (jr/tangle-path)
source $HOME/.nix-direnv/direnvrc
source $HOME/.config/direnv/direnvrc

if [ -f /run/current-system/sw/share/nix-direnv/direnvrc ]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

** direnv

#+call: hash("programs")

#+RESULTS:
: 7701583d01c93a70b96d051e6eee2ea8

#+name: 7701583d01c93a70b96d051e6eee2ea8
#+begin_src nix
direnv = {
    # File at ~/.config/direnv/direnvrc
    enable = true;
    enableBashIntegration = true;
    enableFishIntegration = true;
    enableNixDirenvIntegration = true;
    enableZshIntegration = true;
    stdlib = ''
        use_flake() {
            watch_file flake.nix
            watch_file flake.lock
            eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
        }
    '';
};
#+end_src

#+call: hash("files")

#+RESULTS:
: 948976000227fb0afe43a2da70bcb5c6

#+name: 948976000227fb0afe43a2da70bcb5c6
#+begin_src nix
".direnvrc".source = "${homeDirectory}/${primary.user}/home/.direnvrc";
#+end_src


* wheee

#+call: hash("")

#+RESULTS:
: 98b2f4dcc6b880dfefca30da2b287931

#+name: 98b2f4dcc6b880dfefca30da2b287931
#+begin_src python :tangle (jr/tangle-path) :shebang "#!/usr/bin/env python3.9"
import argparse
import os
from sys import argv
from itertools import zip_longest
from subprocess import run
parser = argparse.ArgumentParser()
parser.add_argument("-D", "--directory", default="/etc/nixos")
parser.add_argument("-f", "--flake", action="store_true")
parser.add_argument("-F", "--file")
parser.add_argument("-c", "--command", default="switch")
parser.add_argument("-s", "--hash", action="store_true")
parser.add_argument("--use-hash")
parser.add_argument("-v", "--verbose", action="store_true")
parser.add_argument("-d", "--dry-run", action="store_true")
parser.add_argument("-m", "--home-manager", action="store_true")
parser.add_argument("-H", "--host", required=True)
parser.add_argument("-u", "--user", default="root")
args, unknown = parser.parse_known_args(argv[1:])

homeManager = args.home_manager or args.file

def grouper(iterable, n, fillvalue=None):
    "Collect data into fixed-length chunks or blocks"
    # grouper('ABCDEFG', 3, 'x') --> ABC DEF Gxx"
    args = [iter([
        s.removeprefix("--") if s.startswith("--") else s for s in iterable
    ])] * n
    return zip_longest(*args, fillvalue=fillvalue)

unknown = dict(grouper(unknown, 2, ""))

if homeManager:
    unknown["user"] = args.user
unknown["host"] = args.host

commandPre = f"nix-instantiate --read-write-mode --show-trace --eval -E 'let j = import " + os.path.dirname(os.path.realpath(argv[0])) + "/system/etc/nixos/lib {  }; in j.hostName"

commandSet = "{ stc = j.attrs.default-stc // " + ("j.attrs.home-manager-default-stc" if homeManager else "{  }") + " // { "
for k, v in unknown.items():
    commandSet += f'{k} = "{v}"; '
commandSet += "};"

hashCommand = " ".join([
    commandPre,
    commandSet,
    "}'",
])

flake = lambda _hash: f'--flake "{args.directory}#{_hash}"' if args.flake else (
    f'-A {_hash} -f {args.file or "~/.config/nixpkgs/home.nix"}' if homeManager else ""
)

if homeManager:
    command = lambda _hash: f"home-manager {args.command} {flake(_hash)}"
else:
    command = lambda _hash: f'nixos-rebuild {args.command} --impure --show-trace {flake(_hash)}'

getHash = lambda: args.use_hash or run(hashCommand, shell = True, capture_output = True, text = True).stdout.strip().strip('\"')

if args.verbose or args.dry_run:
    if args.hash:
        print(hashCommand)
    else:
        _hash = getHash()
        print(command(getHash()))
if not args.dry_run:
    if args.hash:
        print(getHash())
    else:
        run(command(getHash()), shell = True)
#+end_src
