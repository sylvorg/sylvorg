#+setupfile: ./settings/README.org

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* shell.nix

#+begin_src nix :tangle (meq/tangle-path)
with builtins; let flake = import ./etc/nixos;
in with import flake.inputs.nixpkgs (flake.make.specialArgs null currentSystem).nixpkgset; let
    strapper = stdenv.mkDerivation rec {
        pname = "strapper";
        version = "1.0.0.0";

        src = ./strapper;

        buildInputs = [ python310 sd gcc rsync xonsh ] ++ (with python310Packages; [ bakery ]);
        nativeBuildInputs = buildInputs;

        phases = [ "installPhase" ];

        installPhase = ''
            mkdir --parents $out
            cp -r $src $out/bin
            chmod +x $out/bin/strapper
        '';
    };
in mkShell rec {
    buildInputs = [ strapper ] ++ strapper.buildInputs;
    nativeBuildInputs = buildInputs;
    shellHook = ''
        exec xonsh
    '';
}
#+end_src

* strapper
** strapper

#+begin_src py :tangle (meq/tangle-path) :shebang "#!/usr/bin/env python3"
import hy, os
from addict import Dict
from oreo import module_installed
strapper = module_installed(os.path.dirname(os.path.realpath(__file__)) + "/strapper.hy").strapper
if __name__ == "__main__":
    strapper(obj=Dict(dict()))
#+end_src

** strapper.hy
:PROPERTIES:
:header-args:hy+: :noweb-ref nwr20220129201318455450756
:END:

#+begin_src text :tangle (meq/tangle-path)
<<nwr20220129201318455450756>>
#+end_src

*** Imports

#+begin_src hy
(import click)
(import json)
(import oreo)
(import os)
#+end_src

**** From

#+begin_src hy
(import addict [Dict :as D])
(import bakery [ getconf
                 mkswap
                 mount :as Mount
                 nixos-generate-config
                 nixos-install
                 nixos-rebuild
                 rsync
                 sd
                 swapon
                 umount
                 zfs
                 zpool ])
(import functools [partial])
(import pathlib [Path])
(import sys [argv])
#+end_src

**** Coconut

[[https://coconut.readthedocs.io/en/latest/index.html][Coconut]]:

#+begin_src hy
(try (import coconut *)
     (except [ImportError] None))
#+end_src

**** Toolz

[[https://github.com/pytoolz/toolz][Toolz]] and [[https://github.com/pytoolz/cytoolz/][CyToolz]]:

#+begin_src hy
(try (import cytoolz [last])
     (except [ImportError]
             (import toolz [last])))
#+end_src

*** Requires

#+begin_src hy
(require hyrule [-> assoc])
#+end_src

*** Set Resources Directory

#+begin_src hy
;; (setv resources (+ (.dirname os.path (.realpath os.path __file__)) "/etc/nixos/"))
(setv resources (+ (.getcwd os) "/etc/nixos/"))
#+end_src

*** Datasets

#+call: hash() :exports none

#+RESULTS:
: 20220205031620372930929

#+name: 20220205031620372930929
#+begin_src text
dross
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20210601190015343762700

#+name: 20210601190015343762700
#+begin_src json
{
    "base": {  },
    "omniverse": {  },
    "reserved": {  },
    "<<username>>": { "datasets": {
            "oreo": { "mountpoint": "/home/<<username>>/oreo" },
            "sylveon": { "mountpoint": "/home/<<username>>/sylveon" },
            "sylvorg": { "mountpoint": "/home/<<username>>/sylvorg" },
            "syvlorg": { "mountpoint": "/home/<<username>>/syvlorg" },
            "<<20220205031620372930929>>": { "mountpoint": "/home/<<username>>/<<20220205031620372930929>>" },
            "uru": { "mountpoint": "/home/<<username>>/uru" }},
        "options": [ "mountpoint=legacy" ]},
    "system": {
        "datasets": {
            "home": { "datasets": { "root": { "mountpoint": "/root" }}},
            "nix": {  },
            "persist": { "datasets": { "root": { "mountpoint": "/persist/root" }}},
            "root": {  },
            "tmp": { "datasets": { "nix": {  }}, "options": [ "sync=disabled" ] }
        },
        "options": [ "mountpoint=legacy" ]
    },
    "virt": {
        "datasets": {
            "docker": {  },
            "kvm": {  },
            "podman": { "datasets": {  }},
            "qemu": {  },
            "vagrant": {  },
            "xen": {  }
        },
        "options": [ "mountpoint=legacy", "refreservation=none" ],
        "mountpoint": "/var/lib"
    }
}
#+end_src

*** Update Datasets

#+begin_src hy
(defn update-datasets [host [swap 0] [encrypted False] [deduplicated False] [pool False] [root-device None]]
      (setv snap-dir     [ "snapdir=visible" ]
            extra-copies (+ snap-dir [ "copies=3" ])
            cache        [ "sync=disabled" ]
            ml           "mountpoint=legacy"
            d            "datasets"
            s            "system"
            datasets     (D (.loads json (.strip #[[
                                <<20210601190015343762700>>
                         ]])))
            users        (D (.loads json (.strip #[[
                                <<20210601185359809444000>>
                         ]]))))
      (assoc datasets "${host}" (D { "datasets" { "jails" { "datasets" { "base" (dict)}}}
                                     "options" [ ml ]}))
      (for [user (.values users)]
           (assoc (. datasets [s] [d] home [d]) user (dict))
           (assoc (. datasets virt [d] podman [d]) user (dict)))
      (with [dnix (open (+ resources "/datasets.nix") "w")]
            (.write dnix (+ "host: { \""
                            (or root-device "${host}/system/root")
                            "\" = \"/\";"
                            "\n"))
            (defn recurse [ddict dname droot [mountpoint ""]]
                  (setv recurse/datasets     (.list zfs :r True :o "name" :m/list True :m/ignore-stderr True)
                        recurse/datasets     (cut recurse/datasets 2 (len recurse/datasets))
                        recurse/dataset      (+ droot "/" dname)
                        recurse/real-dataset (.replace recurse/dataset "${host}" host)
                        cloning              (and (!= dname "base")
                                                  (and encrypted deduplicated))
                        prefixes             (, "system"
                                                "system/root"
                                                "swap"
                                                "base"
                                                "hold"
                                                "omniverse"
                                                "reserved" ))
                  (if cloning
                      (setv clone-or-create  "clone"
                            snapshot-or-none (+ host "/base@root"))
                      (setv clone-or-create  "create"
                            snapshot-or-none ""))
                  (if (not (in recurse/real-dataset (lfor prefix prefixes (+ host "/" prefix))))
                      (do (if (setx recurse/mountpoint (.get ddict "mountpoint" ""))
                              (setv mountpoint recurse/mountpoint)
                              (if mountpoint
                                  (setv mountpoint (+ mountpoint "/" dname)
                                        recurse/mountpoint mountpoint)
                                  (do (setv recurse/mountpoint (.removeprefix recurse/dataset "${host}/"))
                                      (for [prefix prefixes]
                                           (setv recurse/mountpoint (.removeprefix recurse/mountpoint (+ prefix "/"))))
                                      (setv recurse/mountpoint (+ "/" recurse/mountpoint)))))
                          (.write dnix (+ "\t\""
                                          recurse/dataset
                                          "\" = \""
                                          recurse/mountpoint
                                          "\";\n"))))
                  (if (and pool (not (in recurse/real-dataset recurse/datasets)))
                      (do (zfs :m/subcommand clone-or-create
                               :o { "repeat-with-values" (.get ddict "options" []) }
                               snapshot-or-none
                               recurse/real-dataset)
                          (.snapshot zfs :r True (+ recurse/real-dataset "@blank"))))
                  (for [[key value] (.items (.get ddict d (D {  })))]
                       (recurse value key recurse/dataset mountpoint)))
            (for [[key value] (.items datasets)]
                 (recurse value key "${host}"))
            (.write dnix "}"))
      (if pool
          (let [pool-size-plus-metric (get (.get zpool :H True "size" host :m/list True :m/split True) 2)
                pool-size             (-> pool-size-plus-metric
                                          (cut 0 -1)
                                          (float)
                                          (round 2))
                pool-metric           (last pool-size-plus-metric)]
               (defn pool-percentage-value [percentage]
                     (-> percentage
                         (float)
                         (/ 100)
                         (round 2)
                         (str)
                         (+ pool-metric)
                         (return)))
               (.set zfs
                     (+ "refreservation=" (pool-percentage-value 15))
                     (+ host "/reserved"))

               ;; Apparently, if python internal keywords exist in the argument, such as "set", etc.
               ;; the command errors out; perhaps something to raise an issue of.
               ;; This seems to work as an alternative.
               ;; run(f"zfs set refreservation={pool_percentage_value(15)} {args.Pool}/reserved", shell = True)

               (if swap
                   (let [swoptions [ "com.sun:auto-snapshot=false"
                                     "compression=zle"
                                     "logbias=throughput"
                                     "primarycache=metadata"
                                     "secondarycache=none"
                                     "sync=standard" ]
                         page-size (getconf "PAGESIZE" :m/str True)]
                        (.create zfs
                                 :V (+ (str swap) "G")
                                 :b page-size
                                 :o { "repeat-with-values" swoptions }
                                 (+ host "/swap"))
                        (mkswap (+ "/dev/zvol" host "/swap")))))))
#+end_src

*** Click

#+begin_src hy
(setv no-host-error-message "Sorry! The host needs to be set; do this with the main command while running the subcommand!")
#@((.group click :no-args-is-help True)
   (.option click "-d" "--dazzle" :is-flag True)
   (.option click "-H" "--host")
   (.option click "-i" "--inspect" :is-flag True)
   (.option click "-p" "--print-run" :is-flag True)
   click.pass-context
   (defn strapper [ ctx dazzle host inspect print-run ]
         (.ensure-object ctx dict)
         (setv ctx.obj.host host)
         (if print-run (.bake-all- getconf :m/print-command-and-run True))
         (if inspect (.bake-all- getconf :m/debug True))))
#+end_src

**** Main

#+begin_src hy
#@((.command strapper :no-args-is-help True
                        :context-settings { "ignore_unknown_options" True
                                            "allow_extra_args"       True })
   (.argument click "program-arguments" :nargs -1)
   (.option click "-a" "--all" :is-flag True)
   (.option click "-c" "--copy" :is-flag True)
   (.option click "-g" "--generate" :is-flag True)
   (.option click "-i" "--install" :is-flag True)
   (.option click "-r" "--replace" :is-flag True)
#+end_src

This can't use a default value, as that would trigger a rebuild all the time.

#+begin_src hy
   (.option click "-R" "--rebuild")
#+end_src

#+begin_src hy
   click.pass-context
   (defn main [ ctx all copy generate install program-arguments rebuild replace ]
         (.bake-all- getconf :m/sudo True)
         (setv copy-partial (partial rsync :m/run True :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } f"{resources}/"))
         (if rebuild
             (do (if copy
                     (copy-partial "/etc/nixos/"))
                 (nixos-rebuild rebuild #* ctx.args :show-trace True))
             (do (if (or copy all)
                     (do (update-datasets ctx.obj.host)
                         (copy-partial "/mnt/etc/nixos/")))
                 (if (or generate all)
                     (nixos-generate-config :m/run True :root "/mnt"))
                 (if (or replace all)
                     (if ctx.obj.host
                         (do (sd :m/run True
                                 "./hardware-configuration.nix"
                                 (+ "./hosts/" ctx.obj.host)
                                 "/mnt/etc/nixos/configuration.nix")
                             (sd :m/run True
                                 "'device = \"\"'"
                                 "'device = \"!\"'"
                                 "/mnt/etc/nixos/hardware-configuration.nix"))
                         (raise (NameError no-host-error-message))))
                 (if (or install all)
                     (nixos-install #* ctx.args
                                    :I "nixpkgs=https://github.com/<<username>>/nixpkgs/archive/j.tar.gz"
                                    :m/run True
                                    :show-trace True
#+end_src

From [[https://github.com/NixOS/nix/issues/2293#issuecomment-405339738][here]], and documented [[https://nixos.org/manual/nix/stable/expressions/builtins.html#:~:text=The%20fetched%20tarball%20is%20cached%20for%20a%20certain%20amount%20of%20time%20(1%20hour%20by%20default)%20in%20~/.cache/nix/tarballs/.%20You%20can%20change%20the%20cache%20timeout%20either%20on%20the%20command%20line%20with%20%2D%2Dtarball%2Dttl%20number%2Dof%2Dseconds%20or%20in%20the%20Nix%20configuration%20file%20by%20adding%20the%20line%20tarball%2Dttl%20%3D%20number%2Dof%2Dseconds.][here]]:

#+begin_quote
The fetched tarball is cached for a certain amount of time (1 hour by default) in ~/.cache/nix/tarballs/.
You can change the cache timeout either on the command line with --tarball-ttl number-of-seconds
or in the Nix configuration file by adding the line tarball-ttl = number-of-seconds.
#+end_quote

#+begin_src hy
                                    :option "tarball-ttl 0"
#+end_src

#+begin_src hy
))))))
#+end_src

**** Create

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-s" "--swap" :type int :default 0)
   (.option click "-z" "--zfs-device" :required True)
   click.pass-context
   (defn create [ ctx deduplicated encrypted swap zfs-device ]
         (if ctx.obj.host
             (try (if (= (input "THIS WILL DELETE ALL DATA ON THE SELECTED DEVICE / PARTITION! TO CONTINUE, TYPE IN 'ZFS CREATE'!\n\t") "ZFS CREATE")
                      (let [options (D { "xattr"      "sa"
                                         "acltype"    "posixacl"
                                         "mountpoint"  "none"
                                         "compression" "zstd-19"
                                         "checksum"    "edonr"
                                         "atime"       "off"
                                         "relatime"    "off" })
                            command (partial zpool.create
                                             :f True
                                             :o { "repeat-with-values" (, "autotrim=on" "altroot=/mnt" "autoexpand=on") })]
                           (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                                (if (in ctx.obj.host dataset)
                                    (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
                           (if encrypted
                               (setv options.encryption "aes-256-gcm"
                                     options.keyformat  "passphrase"))
                           (if deduplicated
                               (setv options.dedup "edonr,verify"))
                           (if (.ismount os.path "/mnt")
                               (umount :R True "/mnt"))
                           (.export zpool :f True ctx.obj.host :m/ignore-stderr True)
                           (command :O { "repeat-with-values" (gfor [k v] (.items options) f"{k}={v}") } ctx.obj.host zfs-device)
                           (update-datasets ctx.obj.host swap encrypted deduplicated :pool True))
                      (print "Sorry; not continuing!\n\n"))
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

**** Mount

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-b" "--boot-device")
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :cls oreo.Option :xor [ "swap-device" ] :is-flag True)
   (.option click "-S" "--swap-device" :cls oreo.Option :xor [ "swap" ])
   click.pass-context
   (defn mount [ ctx boot-device deduplicated encrypted root-device swap swap-device ]
         (if ctx.obj.host
             (do (update-datasets ctx.obj.host :root-device root-device :encrypted encrypted :deduplicated deduplicated :swap swap)
                 (for [dataset (.list zfs :r True :H True :m/list True :m/split True)]
                      (if (in ctx.obj.host dataset)
                          (break))
                      (else (.import zpool :f True ctx.obj.host)))
                 (if encrypted
                     (.load-key zfs ctx.obj.host))
                 (try (.mkdir (Path "/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt")
                                  (umount :R True "/mnt"))))
                 (if root-device
                     (Mount root-device "/mnt")
                     (Mount :t "zfs" (+ ctx.obj.host "/system/root") "/mnt"))
#+end_src

Taken from [[https://github.com/NixOS/nixpkgs/issues/73404#issuecomment-1011485428][here]]:

#+begin_src hy
                 (try (.mkdir (Path "/mnt/mnt"))
                      (except [FileExistsError]
                              (if (.ismount os.path "/mnt/mnt")
                                  (umount :R True "/mnt/mnt"))))
                 (Mount :bind True "/mnt" "/mnt/mnt")
#+end_src

#+begin_src hy
                 (.mkdir (Path "/mnt/etc/nixos") :parents True :exist-ok True)

                 (.mkdir (Path "/mnt/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/nix") "/mnt/nix")

                 (.mkdir (Path "/mnt/persist") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/persist") "/mnt/persist")

                 (if boot-device
                     (let [boot "/mnt/boot/efi"]
                          (.mkdir (Path boot) :parents True :exist-ok True)
                          (Mount boot-device boot)))
                 (if swap
                     (swapon (+ "/dev/zvol/" ctx.obj.host "/swap" :m/run True)))
                 (if swap-device
                     (swapon swap-device :m/run True))

                 (.mkdir (Path "/tmp") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp") "/tmp" :m/run True)

                 (.mkdir (Path "/tmp/nix") :parents True :exist-ok True)
                 (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/tmp/nix" :m/run True)

                 ;; (rsync :a True :v { "repeat" 2 } :c True :z { "repeat" 2 } :delete True "/nix/" "/tmp/nix/")
                 ;; (Mount :t "zfs" (+ ctx.obj.host "/system/tmp/nix") "/nix" :m/run True)

                 )
             (raise (NameError no-host-error-message)))))
#+end_src

**** Update

#+begin_src hy
#@((.command strapper :no-args-is-help True)
   (.option click "-d" "--deduplicated" :is-flag True)
   (.option click "-e" "--encrypted" :is-flag True)
   (.option click "-f" "--files" :is-flag True :help "Update datasets.nix with any new datasets; the default")
   (.option click "-p" "--pool" :is-flag True :help "Update the pool and datasets.nix with any new datasets")
   (.option click "-r" "--root-device")
   (.option click "-s" "--swap" :type int :default 0)
   click.pass-context
   (defn update [ ctx deduplicated encrypted files pool root-device swap ]
         (if ctx.obj.host
             (try (setv ud (partial update-datasets ctx.obj.host :swap swap :encrypted encrypted :deduplicated deduplicated :root-device root-device))
                  (cond [files (ud)]
                        [pool (ud :pool True)]
                        [True (ud)])
                  (finally (.export zpool :f True ctx.obj.host :m/ignore-stderr True)))
             (raise (NameError no-host-error-message)))))
#+end_src

*** End of strapper

#+begin_src hy :noweb-ref no
(if (= __name__ "__main__")
    (strapper :obj (D {})))
#+end_src

* etc
** apk
*** repositories
:PROPERTIES:
:header-args:text+: :noweb-ref repositories
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<repositories>>
#+end_src

#+begin_src text
http://postmarketos.brixit.nl/postmarketos/master
https://dl-cdn.alpinelinux.org/alpine/v3.13/main
https://dl-cdn.alpinelinux.org/alpine/v3.13/community
#+end_src

*** keys
**** build.postmarketos.org.rsa.pub
:PROPERTIES:
:header-args:text+: :noweb-ref build.postmarketos.org.rsa.pub
:END:

#+begin_src text :noweb-ref no :tangle (meq/tangle-path)
<<build.postmarketos.org.rsa.pub>>
#+end_src

#+begin_src text
-----BEGIN PUBLIC KEY-----
MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlXE4h6kp8aCzn6BjuOnz
Z1lcFSY+WRZ2vGUb5hEZ+YG75xYZW+yELr8P8+HSUrpBXF/HTQYKH/cNJc5zmOny
EsmcZskIYB0qgZPg02GXBV8VfjL+Es+y166g14IH2YKkdfplqHYVpCmnkmaZXQZu
ZAOEL2hyuzTAYYFhCZWHYYgdWfpnKDDlVcnw1Q3/LhADBlN63CW0UMWc5oJ7MwlY
SKriM60cHvER1YD5bdbGG/JTBFnB4djliLtvRNp+w3emwHmDhFmnYITN2WOHbYpV
P+RIfzq0IP978sKGJmd0RPuwl2ruifBYikm/F79Ko8lT2gVE40B7wqbInIGquTr1
deERIr47jcPRGl+01Svm0SxbXD1/zBNjo4wvMsZEW7Te689mFjxsXHnD7OEUQqh/
D1DhbnKJwpKwClYOi/aVDyGJunqavSR0QYPqN3nP+uXdBC4wuLI9gRS/yXNaxpMy
9AKwlD3uUhKzmJMJIu3L1/TH/vY9M5xZ2lnFduTZmL/X/4sjhyTb1ycFwU9UIY4C
u2CP/YLqiiquokgzpRfYwJyOP4quBVRC46Tejx5PzTCvnhro7LAzDoS756iBv9E/
2oxwC5VafGSChO+N8SyEBy532Gs+rcZDwUE7M9Y1GbQHW3ALMTwxstWqZ3GKWKd1
Cw6JQoywUhR09tFwQrYZao0CAwEAAQ==
-----END PUBLIC KEY-----
#+end_src

** nixos
*** default.nix

Taken from [[https://github.com/edolstra/flake-compat#usage][here]]:

#+begin_src nix :tangle (meq/tangle-path)
(import
  (
    let lock = builtins.fromJSON (builtins.readFile ./flake.lock); in
    fetchTarball {
      url = "https://github.com/edolstra/flake-compat/archive/${lock.nodes.flake-compat.locked.rev}.tar.gz";
      sha256 = lock.nodes.flake-compat.locked.narHash;
    }
  )
  { src = ./.; }
).defaultNix
#+end_src

*** patches
**** BACKPORT-Linux-5.8-compat-__vmalloc.patch

#+begin_src diff :tangle (meq/tangle-path)
From 6cc95288ccea12ad7b67b2b5b3997dfad8e5b5c9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20Niew=C3=B6hner?=
 <c0d3z3r0@users.noreply.github.com>
Date: Tue, 9 Jun 2020 01:32:02 +0200
Subject: [PATCH] BACKPORT: Linux 5.8 compat: __vmalloc()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The `pgprot` argument has been removed from `__vmalloc` in Linux 5.8,
being `PAGE_KERNEL` always now [1].

Detect this during configure and define a wrapper for older kernels.

[1] https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git/commit/mm/vmalloc.c?h=next-20200605&id=88dca4ca5a93d2c09e5bbc6a62fbfc3af83c4fca

Reviewed-by: Brian Behlendorf <behlendorf1@llnl.gov>
Co-authored-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Co-authored-by: Michael Niewöhner <foss@mniewoehner.de>
Signed-off-by: Sebastian Gottschall <s.gottschall@dd-wrt.com>
Signed-off-by: Michael Niewöhner <foss@mniewoehner.de>
Closes #10422
---
 config/kernel-kmem.m4       | 26 ++++++++++++++++++++++++++
 config/kernel.m4            |  2 ++
 include/spl/sys/kmem.h      |  9 +++++++++
 module/spl/spl-kmem-cache.c |  4 ++--
 module/spl/spl-kmem.c       |  9 ++++-----
 5 files changed, 43 insertions(+), 7 deletions(-)

diff --git a/config/kernel-kmem.m4 b/config/kernel-kmem.m4
index cc055e530..f1c0d2412 100644
--- a/config/kernel-kmem.m4
+++ b/config/kernel-kmem.m4
@@ -56,3 +56,29 @@ AC_DEFUN([SPL_AC_DEBUG_KMEM_TRACKING], [
    AC_MSG_CHECKING([whether detailed kmem tracking is enabled])
    AC_MSG_RESULT([$enable_debug_kmem_tracking])
 ])
+
+dnl #
+dnl # 5.8 API,
+dnl # __vmalloc PAGE_KERNEL removal
+dnl #
+AC_DEFUN([ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL], [
+   ZFS_LINUX_TEST_SRC([__vmalloc], [
+       #include <linux/mm.h>
+       #include <linux/vmalloc.h>
+   ],[
+       void *p __attribute__ ((unused));
+
+       p = __vmalloc(0, GFP_KERNEL, PAGE_KERNEL);
+   ])
+])
+
+AC_DEFUN([ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL], [
+   AC_MSG_CHECKING([whether __vmalloc(ptr, flags, pageflags) is available])
+   ZFS_LINUX_TEST_RESULT([__vmalloc], [
+       AC_MSG_RESULT(yes)
+       AC_DEFINE(HAVE_VMALLOC_PAGE_KERNEL, 1, [__vmalloc page flags exists])
+   ],[
+       AC_MSG_RESULT(no)
+   ])
+])
+-
diff --git a/config/kernel.m4 b/config/kernel.m4
index b67fcef8c..23edfdcd8 100644
--- a/config/kernel.m4
+++ b/config/kernel.m4
@@ -45,6 +45,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_SRC], [
    ZFS_AC_KERNEL_SRC_SCHED
    ZFS_AC_KERNEL_SRC_USLEEP_RANGE
    ZFS_AC_KERNEL_SRC_KMEM_CACHE
+   ZFS_AC_KERNEL_SRC_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_SRC_WAIT
    ZFS_AC_KERNEL_SRC_INODE_TIMES
    ZFS_AC_KERNEL_SRC_INODE_LOCK
@@ -163,6 +164,7 @@ AC_DEFUN([ZFS_AC_KERNEL_TEST_RESULT], [
    ZFS_AC_KERNEL_SCHED
    ZFS_AC_KERNEL_USLEEP_RANGE
    ZFS_AC_KERNEL_KMEM_CACHE
+   ZFS_AC_KERNEL_VMALLOC_PAGE_KERNEL
    ZFS_AC_KERNEL_WAIT
    ZFS_AC_KERNEL_INODE_TIMES
    ZFS_AC_KERNEL_INODE_LOCK
diff --git a/include/spl/sys/kmem.h b/include/spl/sys/kmem.h
index 72d3a7765..ca15bfe7f 100644
--- a/include/spl/sys/kmem.h
+++ b/include/spl/sys/kmem.h
@@ -169,6 +169,15 @@ extern void *spl_kmem_alloc(size_t sz, int fl, const char *func, int line);
 extern void *spl_kmem_zalloc(size_t sz, int fl, const char *func, int line);
 extern void spl_kmem_free(const void *ptr, size_t sz);
 
+/*
+ * 5.8 API change, pgprot_t argument removed.
+ */
+#ifdef HAVE_VMALLOC_PAGE_KERNEL
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags, PAGE_KERNEL)
+#else
+#define    spl_vmalloc(size, flags)    __vmalloc(size, flags)
+#endif
+
 /*
  * The following functions are only available for internal use.
  */
diff --git a/module/spl/spl-kmem-cache.c b/module/spl/spl-kmem-cache.c
index d71b4b348..4866b2993 100644
--- a/module/spl/spl-kmem-cache.c
+++ b/module/spl/spl-kmem-cache.c
@@ -203,7 +203,7 @@ kv_alloc(spl_kmem_cache_t *skc, int size, int flags)
        ASSERT(ISP2(size));
        ptr = (void *)__get_free_pages(lflags, get_order(size));
    } else {
-       ptr = __vmalloc(size, lflags | __GFP_HIGHMEM, PAGE_KERNEL);
+       ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
    }
 
    /* Resulting allocated memory will be page aligned */
@@ -1242,7 +1242,7 @@ spl_cache_grow(spl_kmem_cache_t *skc, int flags, void **obj)
     * allocation.
     *
     * However, this can't be applied to KVM_VMEM due to a bug that
-    * __vmalloc() doesn't honor gfp flags in page table allocation.
+    * spl_vmalloc() doesn't honor gfp flags in page table allocation.
     */
    if (!(skc->skc_flags & KMC_VMEM)) {
        rc = __spl_cache_grow(skc, flags | KM_NOSLEEP);
diff --git a/module/spl/spl-kmem.c b/module/spl/spl-kmem.c
index cee69ad43..ca1fc145f 100644
--- a/module/spl/spl-kmem.c
+++ b/module/spl/spl-kmem.c
@@ -172,16 +172,15 @@ spl_kmem_alloc_impl(size_t size, int flags, int node)
         * kmem_zalloc() callers.
         *
         * For vmem_alloc() and vmem_zalloc() callers it is permissible
-        * to use __vmalloc().  However, in general use of __vmalloc()
-        * is strongly discouraged because a global lock must be
-        * acquired.  Contention on this lock can significantly
+        * to use spl_vmalloc().  However, in general use of
+        * spl_vmalloc() is strongly discouraged because a global lock
+        * must be acquired.  Contention on this lock can significantly
         * impact performance so frequently manipulating the virtual
         * address space is strongly discouraged.
         */
        if ((size > spl_kmem_alloc_max) || use_vmem) {
            if (flags & KM_VMEM) {
-               ptr = __vmalloc(size, lflags | __GFP_HIGHMEM,
-                   PAGE_KERNEL);
+               ptr = spl_vmalloc(size, lflags | __GFP_HIGHMEM);
            } else {
                return (NULL);
            }
-- 
2.25.1
#+end_src

**** 0110-initialize-ata-before-graphics.patch

#+begin_src diff :tangle (meq/tangle-path)
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Arjan van de Ven <arjan@linux.intel.com>
Date: Thu, 2 Jun 2016 23:36:32 -0500
Subject: [PATCH] initialize ata before graphics

ATA init is the long pole in the boot process, and its asynchronous.
move the graphics init after it so that ata and graphics initialize
in parallel
---
 drivers/Makefile | 15 ++++++++-------
 1 file changed, 8 insertions(+), 7 deletions(-)

diff --git a/drivers/Makefile b/drivers/Makefile
index c0cd1b9..af1e2fb 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -59,15 +59,8 @@ obj-y                += char/
 # iommu/ comes before gpu as gpu are using iommu controllers
 obj-y              += iommu/
 
-# gpu/ comes after char for AGP vs DRM startup and after iommu
-obj-y              += gpu/
-
 obj-$(CONFIG_CONNECTOR)        += connector/
 
-# i810fb and intelfb depend on char/agp/
-obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
-obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
-
 obj-$(CONFIG_PARPORT)      += parport/
 obj-$(CONFIG_NVM)      += lightnvm/
 obj-y              += base/ block/ misc/ mfd/ nfc/
@@ -80,6 +73,14 @@ obj-$(CONFIG_IDE)        += ide/
 obj-y              += scsi/
 obj-y              += nvme/
 obj-$(CONFIG_ATA)      += ata/
+
+# gpu/ comes after char for AGP vs DRM startup and after iommu
+obj-y              += gpu/
+
+# i810fb and intelfb depend on char/agp/
+obj-$(CONFIG_FB_I810)           += video/fbdev/i810/
+obj-$(CONFIG_FB_INTEL)          += video/fbdev/intelfb/
+
 obj-$(CONFIG_TARGET_CORE)  += target/
 obj-$(CONFIG_MTD)      += mtd/
 obj-$(CONFIG_SPI)      += spi/
-- 
https://clearlinux.org
#+end_src

**** export_kernel_fpu_functions_5_3.patch

#+begin_src diff :tangle (meq/tangle-path)
From 1e010beda2896bdf3082fb37a3e49f8ce20e04d8 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B6rg=20Thalheim?= <joerg@thalheim.io>
Date: Thu, 2 May 2019 05:28:08 +0100
Subject: [PATCH] x86/fpu: Export kernel_fpu_{begin,end}() with
 EXPORT_SYMBOL_GPL
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We need these symbols in zfs as the fpu implementation breaks userspace:

https://github.com/zfsonlinux/zfs/issues/9346
Signed-off-by: Jörg Thalheim <joerg@thalheim.io>
---
 arch/x86/kernel/fpu/core.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/fpu/core.c b/arch/x86/kernel/fpu/core.c
index 12c70840980e..352538b3bb5d 100644
--- a/arch/x86/kernel/fpu/core.c
+++ b/arch/x86/kernel/fpu/core.c
@@ -102,7 +102,7 @@ void kernel_fpu_begin(void)
    }
    __cpu_invalidate_fpregs_state();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_begin);
+EXPORT_SYMBOL(kernel_fpu_begin);
 
 void kernel_fpu_end(void)
 {
@@ -111,7 +111,7 @@ void kernel_fpu_end(void)
    this_cpu_write(in_kernel_fpu, false);
    preempt_enable();
 }
-EXPORT_SYMBOL_GPL(kernel_fpu_end);
+EXPORT_SYMBOL(kernel_fpu_end);
 
 /*
  * Save the FPU state (mark it for reload if necessary):
-- 
2.23.0
#+end_src

**** fetchpypi.patch

#+begin_src diff :tangle (meq/tangle-path)
diff --git a/fetchpypi.nix b/fetchpypi.nix
index e60c9df..df50c0d 100644
--- a/fetchpypi.nix
+++ b/fetchpypi.nix
@@ -24,5 +24,5 @@ in makeOverridable( {format ? "setuptools", sha256 ? "", hash ? "", ... } @attrs
   let
     url = computeUrl (builtins.removeAttrs attrs ["sha256" "hash"]) ;
   in fetchurl {
-    inherit url sha256 hash;
+    inherit url sha256;
   })
#+end_src

**** fetchurl.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/pkgs/build-support/fetchurl/boot.nix
+++ b/pkgs/build-support/fetchurl/boot.nix
@@ -6,7 +6,8 @@ let mirrors = import ./mirrors.nix; in
 , urls ? []
 , sha256
 , name ? baseNameOf (toString url)
-}:
+, ...
+} @ args:
 
 import <nix/fetchurl.nix> {
   inherit system sha256 name;
diff --git a/pkgs/build-support/fetchzip/default.nix b/pkgs/build-support/fetchzip/default.nix
index c61df8ceb00..d973837f0d3 100644
--- a/pkgs/build-support/fetchzip/default.nix
+++ b/pkgs/build-support/fetchzip/default.nix
@@ -14,7 +14,8 @@
 , name ? "source"
 , ... } @ args:
 
-(fetchurl ({
+let
+ x = (fetchurl ({
   inherit name;
 
   recursiveHash = true;
@@ -46,7 +47,11 @@
       mv "$unpackDir" "$out"
     '') #*/
     + extraPostFetch;
-} // removeAttrs args [ "stripRoot" "extraPostFetch" ])).overrideAttrs (x: {
+  } // removeAttrs args [ "stripRoot" "extraPostFetch" ]));
+
+in
+  x // {
+    # .overrideAttrs (x: {
   # Hackety-hack: we actually need unzip hooks, too
   nativeBuildInputs = x.nativeBuildInputs ++ [ unzip ];
-})
+}
#+end_src

**** grub_zfs.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/grub-core/fs/zfs/zfs.c
+++ b/grub-core/fs/zfs/zfs.c
@@ -285,6 +285,7 @@ static const char *spa_feature_names[] = {
   "com.delphix:embedded_data",
   "com.delphix:extensible_dataset",
   "org.open-zfs:large_blocks",
+  "org.zfsonlinux:large_dnode",
   NULL
 };
#+end_src

**** set_power_mgmt.patch

#+begin_src diff :tangle (meq/tangle-path)
--- a/net/wireless/nl80211.c    2019-07-08 00:41:56.000000000 +0200
+++ b/net/wireless/nl80211.c    2020-02-05 19:30:26.352718504 +0100
@@ -10517,10 +10520,7 @@
    if (!rdev->ops->set_power_mgmt)
        return -EOPNOTSUPP;
 
-   state = (ps_state == NL80211_PS_ENABLED) ? true : false;
-
-   if (state == wdev->ps)
-       return 0;
+   state = false;
 
    err = rdev_set_power_mgmt(rdev, dev, state, wdev->ps_timeout);
    if (!err)
#+end_src

*** users.json

#+call: hash() :exports none

#+RESULTS:
: 20210601185359809444000

#+name: 20210601185359809444000
#+begin_src json :tangle (meq/tangle-path)
{
    "primary": "<<username>>",
    "secondary": "frost",
    "nightingale": "curtis"
}
#+end_src

*** profiles
**** server.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with lib; {
    services.openssh = {
        enable = true;
        extraConfig = mkOrder 0 ''
            TCPKeepAlive yes
            ClientAliveCountMax 480
            ClientAliveInterval 3m
        '';
        permitRootLogin = "yes";
    };

    environment.systemPackages = with pkgs; [ inetutils mtr sysstat git ];
}
#+end_src

*** devices
**** linode.nix

Adapted from the following:

- [[https://github.com/hlissner/dotfiles/blob/master/hosts/linode.nix][hlissner's dotfiles]]
- [[https://www.linode.com/docs/guides/install-nixos-on-linode/#prepare-your-linode][Install and Configure NixOS on a Linode]]

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../profiles/server.nix ];
    boot = {
        kernelParams = [ "console=ttyS0,19200n8" ];
        loader.grub.extraConfig = ''
            serial --speed=19200 --unit=0 --word=8 --parity=no --stop=1;
            terminal_input serial;
            terminal_output serial;
        '';
        initrd.availableKernelModules = [ "virtio_pci" "ahci" "sd_mod" ];
    };
    networking = {
        usePredictableInterfaceNames = false;
        interfaces.eth0.useDHCP = true;
    };
}
#+end_src

**** rpi4.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports =  [
        ../minimal.nix
        ../profiles/server.nix
        (import ..).inputs.hardware.raspberry-pi-4
    ];
    boot.kernelPackages = lib.mkForce pkgs.linuxPackages_rpi4;
}
#+end_src

*** hosts

#+name: hostId
#+begin_src emacs-lisp
(concat "\"" (string-trim (shell-command-to-string "head -c4 /dev/urandom | od -A none -t x4")) "\"")
#+end_src

**** imports.nix

#+begin_src nix :tangle (meq/tangle-path)
[ ../minimal.nix ../bcachefs.nix ]
#+end_src

**** sandshrew
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        (import ../..).inputs.hardware.microsoft-surface
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
        networkmanager.extraConfig = ''
            [connection]
            wifi.powersave = 2

            [device]
            wifi.scan-rand-mac-address=false
        '';
    };
    services.surface-dtx-daemon.detach = mkForce ''
        #!/usr/bin/env sh
        for usb in $(ls /dev/disk/by-id).split("\n"):
            if usb and usb[:4] == "usb-":
                for mnt in $(mount).split("\n"):
                    if mnt and usb in mnt:
                        umount @(mnt.split()[2])
    '';
}
#+end_src

**** siluam
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }:

{
    imports =  [
        ../../minimal.nix
        "${(import ../..).inputs.pinebook-pro}/pinebook_pro.nix"
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
    swapDevices = [ { device = "/dev/mmcblk2p2"; } ];
}
#+end_src

**** murasame
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = import ../imports.nix;
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** argus
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, ... }:

{
    imports = flatten [
        ../../devices/linode.nix
        import ../imports.nix
    ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** yggdrasil
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

**** enterprise
***** default.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    imports = [ ../../devices/rpi4.nix ];
    networking = {
        hostName = baseNameOf (toString ./.);
        hostId = <<hostId()>>;
    };
}
#+end_src

*** bcachefs.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    boot = {
        supportedFilesystems = [ "bcachefs" ];
        initrd.supportedFilesystems = config.boot.supportedFilesystems;
    };
}
#+end_src

*** lib.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref lib.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<lib.nix>>
#+end_src

With help from [[Henrik Lissner / hlissner][https://github.com/hlissner/dotfiles]]:

**** Arguments

#+begin_src nix
with builtins; { pkgs, lib, inputs ? {}, host ? "nixos", system ? currentSystem }: with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** New Lib

#+begin_src nix
newLib = self: rec {
#+end_src

****** Functions

#+begin_src nix
functions = rec {
#+end_src

******* Convert Path To Mount

#+begin_src nix
mntConvert = dir: let mntDir = "/mnt/" + dir; in if (pathExists mntDir) then mntDir else dir;
#+end_src

******* Zip To Set

#+begin_src nix
zipToSet = names: values: listToAttrs (
    map (nv: nameValuePair nv.fst nv.snd) (let hasAttrs = any isAttrs values; in zipLists (
        if hasAttrs then names else (sort lessThan names)
    ) (
        if hasAttrs then values else (sort lessThan values)
    ))
);
#+end_src

******* Fold To Set

#+begin_src nix
# TODO: Why is the filter necessary?
foldToSet = list: foldr (new: old: recursiveUpdate new old) {} (filter (item: isAttrs item) list);
#+end_src

******* My Conditionals

#+begin_src nix
myIf = {
    list = condition: value: optionals condition value;
    singleton = condition: value: optional condition value;
    set = condition: value: if condition then value else {};
    num = condition: value: if condition then value else 0;
    knull = condition: value: if condition then value else null;
    empty = condition: value: if condition then value else "";
    drv = condition: value: if condition then value else pkgs.hello;
};
#+end_src

******* To Capital

#+begin_src nix
toCapital = string: concatImapStrings (
    i: v: if (i == 0) then (toUpper v) else v
) (stringToCharacters string);
#+end_src

******* Sequence

#+begin_src nix
sequence = list: end: foldr (a: b: deepSeq a b) end list;
#+end_src

******* Import Stuff

#+begin_src nix
args = {
    suffix = "";
    ignores = [];
};

baseNameNoSuffix = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    file
}: removeSuffix (if noSuffix then ".nix" else suffix) (baseNameOf (toString file));

# !!! This returns a function
filterFunc = {
    suffix ? args.suffix,
    noSuffix ? suffix == "",
    ignores ? args.ignores,
    dir,
}: let
    _ignores = flatten [
        ignores
        (let
            _ignores' = (/. + "/${unsafeDiscardStringContext dir}/_ignores.nix");
        in if (pathExists _ignores') then (import _ignores') else [])
        "default" # triggers infinite recursion if modules are defined here
        "deprecated"
        "nix" # niv
        "shell" # nix-shell
    ];
in file: value:
    (if noSuffix then (
        (hasSuffix ".nix" file) || (value == "directory")
    ) else (hasSuffix suffix file)) &&
    (!hasPrefix "_" file) &&
    (!elem (baseNameNoSuffix { inherit suffix file noSuffix; }) _ignores);

contents = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
}: filterAttrs (filterFunc _args) (readDir dir);

list = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/${n}"),

}: let
    __args = removeAttrs _args [ "func" ];
in mapAttrsToList func (contents __args);

listNames = {
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir
}: list {
    inherit suffix ignores dir;
    func = (n: v: baseNameNoSuffix { inherit suffix; file = n; });
};
#+end_src

Set Function:

#+begin_src nix
set = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
    modules ? {},

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/" + n),

}: let
    files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
in listToAttrs (map (file: nameValuePair
    (baseNameNoSuffix { inherit suffix file; })
    (import file (foldToSet [ modules inputs ]))
) files);
#+end_src

Deprecated Set Function:

#+begin_src nix :noweb-ref no
set = _args@{
    suffix ? args.suffix,
    ignores ? args.ignores,
    dir,
    modules ? {},

    # !!! This cannot be integrated into the "args" set above, due to "dir" then being permanently set !!!
    func ? (n: v: dir + "/" + n),

}: let
    files = list (filterAttrs (arg: v: !elem arg [ "modules" "self" ]) _args);
in zipToSet
    (map (file: baseNameNoSuffix { inherit suffix file; }) files)
    (map (file: import file (foldToSet [ modules inputs ])) files);
#+end_src

******* End of Functions

#+begin_src nix
};
#+end_src

****** Attrs

#+begin_src nix
attrs = rec {
#+end_src

******* Machines

#+begin_src nix
machines = {
#+end_src

******** Relay

#+begin_src nix
relays = [ <<relays>> ];
#+end_src

******** No ZFS

#+begin_src nix
no-zfs = [ <<no-zfs>> ];
#+end_src

******** End of Machines

#+begin_src nix
};
#+end_src

******* Relay

#+begin_src nix
relay = elem host machines.relays;
not-relay = ! relay;
#+end_src

******* ZFS

#+begin_src nix
not-zfs = elem host machines.no-zfs;
zfs = ! not-zfs;
#+end_src

******* Configs

#+begin_src nix
configs = {
    nixpkgs = {
        allowUnfree = true;
        allowBroken = true;
        allowUnsupportedSystem = true;
        # preBuild = ''
        #     makeFlagsArray+=(CFLAGS="-w")
        #     buildFlagsArray+=(CC=cc)
        # '';
        permittedInsecurePackages = [
            "python2.7-cryptography-2.9.2"
        ];
    };
    nix = let
        MG = size: let
            mg = stringToCharacters size;
        in toString ((toInt (elemAt mg 0)) * (
            if (elemAt mg 1 == "M") then 1 else 1024
        ) * 1024 * 1024);
    in ''
        <<270d5d30-951e-4171-8c23-67fc45d20578()>>
        min-free = ${MG "250M"}
        max-free = ${MG "1G"}
    '';
    services = rec {
        mkBase = User: {
            enable = true;
            serviceConfig = rec {
                Restart = "on-failure";
                inherit User;
                Group = User;
                Environment = [ "PATH=/run/wrappers/bin:$PATH" ];
            };
            wantedBy = [ "multi-user.target" ];
        };
        base = mkBase users.primary;
        mkdir = path: "/run/current-system/sw/bin/mkdir -p ${path} &> /dev/null";
    };
};
#+end_src

******* Users

#+begin_src nix
users = fromJSON (readFile ./users.json);
excludedUsers = [ "root" ];
mainUsers = attrValues users;
allUsers = mainUsers ++ excludedUsers;
#+end_src

******** Homes

#+begin_src nix
homes = listToAttrs (map (
    user: nameValuePair user "/home/${user}"
) mainUsers);
allHomes = homes // { root = "/root"; };
#+end_src

******* Datasets

#+begin_src nix
datasets = {
    fileSystems = import ./datasets.nix host;
    backup = [
        "system/persist"
        "virt"
        "omniverse"
        users.primary
    ];
};
#+end_src

******* Platforms

#+begin_src nix
platforms = {
    arm = [ "aarch64-linux" "armv7l-linux" "armv6l-linux" ];
    imd = [ "i686-linux" "x86_64-linux" ];
};
arms = elem system platforms.arm;
no-arms = !arms;
#+end_src

******* SSH

#+begin_src nix
ssh.keys = rec {
    "id_rsa.bak" = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDlwBJ7E2qeqw9kMW19indbeLdnEKs/Yrhn9HE0c/gZDzvXYBPQYyf5xr9I9kYxWcHlqp7XEI0LVT4DCA/mgemQtM8ulc1mxwekKtk64uWRi5wLi1E17NWKJfXWRn8XZejwi0iJa0twwVE8m8G2AuFOCSa86sYD3x5X5W+7spAuNET7kl0DLueUHu1u31c7HE1ciV2tIn/f60/bbgEJm9MPcRVZkRxkp+bouaZ1cjWRYDhvyJS30DRhBYtIIort2XVAshQs2Y58oKeCDnjt0gxotfqqWlt4nTQzKtbSN2M6/M+clFQBdT1oUJqpTUJbVxK8+xSEOJcBubupTj0USpmftDf/3WMoMwq+hNEc9C0EN1BYtKk68QWhAz8NROvnx7h6y3UKejhQOg0ueNZggmeNJLbebEs46QmA92khO8zc2pfBRsEa5yP0IgdvWpruTZ1QwjqhGQqGnCw3Oli1PK+5zgT2vXy5yHl3f3duPq8h+LOc+lSBbi2jjkC0gwTQDDDNyzFZ+U9xF7fCmL3V8DCEeO/4HqVxmLJir2TVEDo/3Ug/Q22Yp7P2EZrI2pikZIyBJc5aZJO3d7nGoDB/1BJp9Qm82wvyEpjiOnxHsL4osUqrf401XbiwNqpFkVUoRZkwGraJnrlsYkdHS2Mrrny9sr+PtgZhTjqIuW8z6iVIfQ== titaniumfiles@outlook.com";
    "id_ed25519.bak" = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIO8NzKV52dRBAir8ARoFJX/xQDVCNup6xe1ddX1YVXSO sylvorg@syvl.org";
    jeet_ray_ecdsa = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBGsRy6rLDzmLNISdWahFLGDo+ZZLbndj6k8Q8MUQum/mPAzy8lsAQz/0XiicJz7LlM74tWGDYSJG1Ay2Iyc/ew4= jeet.ray@syvl.org";
    jeet_ray_ed25519 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAICor+WXoAypnk5rkgTljAN6kk8olvKWqtnmGWVuQu8z9 jeet.ray@syvl.org";
    jeet_ray_rsa = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCs4zqEt/Fkjw0LVQTwJXlovmnqqGWC4UOVPvoLDvo0JD6WeVBDi4cFPX2mpNJYmYJsBLDXeUq5XrQ1ST3BkfVdspsragnD7O92tTEf3/VHfIC1L165pnB08FXQrtIjyLL7Ry4dloUGBYKLnHOtnXlpefKMQzRYUacc7Tr1o2wv+XRoDW9h+qDqJz1O61N68JFLgJWD3/nUkm8siTg1OLvqO9ATp+UgP/Lb08E6HfqYOiD8H+1ZJjz78mo5oZatknvgy8uJJPqEX7/aRM61YA9TG+tw/sf6wlrDtUQUik8Y4k1DLmkhE15wcgq/HF2Rqka/acA9GxA5smNGyjs6CS+H jeet.ray@syvl.org";
    shadowrylander_ecdsa = "ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBNlVuY9reRuMloYvecJHHsOYkAPDyQwELOI3kfibslIKI5hY+o1jx5yVyAUomHynP6wulm5aziNc5kWdsRE9BE8= shadowrylander@syvl.org";
    shadowrylander_ed25519 = "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAINZ2FCMbnetAnDZ63Wzct+O3MYhtO9+BedATbtiHI9BT shadowrylander@syvl.org";
    shadowrylander_rsa = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDP8ifT/3d6L2MzZPoTh0bUjQUXuPKfPP8Tp03E5En2x+iKhv+J/U0z0xk7IdPZ4qEO+ZWI5xWbwVkDdnRnJ/5HgA0/ZwmO5Zpj3llSr4dJMUVSSyO23fFIL2WqOpHyQDeexJWMxbU5SmIi+c855VwewCbGDcPnmDo0XgR/u4LRF2pwYGNGFtJ2/GICEIob/2w0ICwi7TMUEkDbUFcP5web81OzsNu80M60VaNl870uT1rwBeKuW7CXFtImYytZ0mOc5LC6d7ugkFS1zAbLOWjt3PJ8Op2MH9ncBj5jCsIlA/OqI72jKwEPOl8evYqWeEOzlVxA7/AkRj7haQqFE8r/ shadowrylander@syvl.org";
    id_rsa = shadowrylander_rsa;
    id_ed25519 = jeet_ray_ed25519;
};
#+end_src

******* Filesystems

#+begin_src nix
fileSystems = {
    base = {
        fsType = "zfs";
        options = [ "defaults" "x-systemd.device-timeout=5" "nofail" ];
    };
    supported = [ "zfs" "xfs" "btrfs" "ext4" "fat" "vfat"  ];
};
#+end_src

******* Commands

#+begin_src nix
commands = {
    rebuild = "nixos-rebuild --impure";
    install = "nixos-install --impure --show-trace";
};
#+end_src

******* End of Attrs

#+begin_src nix
};
#+end_src

****** Paths

#+begin_src nix
paths = rec {
    nixos = toString (./. + "/..");
    lib = "${nixos}/lib";
    extras = "${nixos}/extras";
    configs = "${nixos}/configs";
    modules.flakes = "${nixos}/flake_modules";
    global = "${nixos}/global";
    patches.base = "${nixos}/patches";
};
#+end_src

****** End of New Lib

#+begin_src nix
};
#+end_src

***** Extension

#+begin_src nix
extension = makeExtensible newLib;
#+end_src

**** Extend

#+begin_src nix
in with lib; extension.extend (final: prev: foldr (new: old: recursiveUpdate new old) {} (attrValues prev))
#+end_src

*** callPackages
**** caddy.nix

Taken from [[https://github.com/NixOS/nixpkgs/issues/14671#issuecomment-1016376290][here]]; allows me to build caddy with plugins:

#+begin_src nix :tangle (meq/tangle-path)
{ lib, fetchFromGitHub, buildGoModule, plugins ? [], vendorSha256 ? "" }:

with lib;

let imports = flip concatMapStrings plugins (pkg: "\t\t\t_ \"${pkg}\"\n");

	main = ''
		package main

		import (
			caddycmd "github.com/caddyserver/caddy/v2/cmd"

			_ "github.com/caddyserver/caddy/v2/modules/standard"
${imports}
		)

		func main() {
			caddycmd.Main()
		}
	'';


in buildGoModule rec {
	pname = "caddy";
	version = "2.4.6";
  runVend = true;
	subPackages = [ "cmd/caddy" ];

  src = fetchFromGitHub {
    owner = "caddyserver";
    repo = "caddy";
    rev = "v${version}";
    sha256 = "sha256-xNCxzoNpXkj8WF9+kYJfO18ux8/OhxygkGjA49+Q4vY=";
  };

	inherit vendorSha256;

	overrideModAttrs = (_: {
		preBuild    = "echo '${main}' > cmd/caddy/main.go";
		postInstall = "cp go.sum go.mod $out/ && ls $out/";
	});

	postPatch = ''
		echo '${main}' > cmd/caddy/main.go
		cat cmd/caddy/main.go
	'';

	postConfigure = ''
		cp vendor/go.sum ./
		cp vendor/go.mod ./
	'';

	meta = {
		homepage = https://caddyserver.com;
		description = "Fast, cross-platform HTTP/2 web server with automatic HTTPS";
		license = licenses.asl20;
    maintainers = with maintainers; [ Br1ght0ne ];
	};
}
#+end_src

*** overlays.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref overlays.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<overlays.nix>>
#+end_src

**** Arguments

#+begin_src nix
args@{ lib, nixpkgs, inputs, pkgs, channel }: with builtins; with lib;
#+end_src

**** Let

#+begin_src nix
let
#+end_src

***** End of Let

#+begin_src nix
in flatten [
#+end_src

**** J

#+begin_src nix
(final: prev: { j = { inherit pkgs; };})
#+end_src

**** Patched Fetchers

#+begin_src nix :noweb-ref no
(final: prev: {
    fetchurl = prev.fetchurl.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchurl.patch ];});
    fetchpypi = prev.fetchpypi.overrideAttrs (attrs: { patches = j.attrs.patches ++ [ ./patches/fetchpypi.patch ];});
})
#+end_src

**** NIX

# TODO

#+begin_src nix :noweb-ref no
inputs.nix.overlay
#+end_src

**** NUR

#+begin_src nix
(final: prev: { nur = import inputs.nur { nurpkgs = nixpkgs; pkgs = prev; }; })
#+end_src

**** Emacs

#+begin_src nix
inputs.emacs.overlay
#+end_src

**** Systemd
***** Homed

# TODO

#+begin_src nix :noweb-ref no
(final: prev: { systemd = prev.systemd.overrideAttrs (old: { withHomed = true; }); })
#+end_src

**** Containers
***** Extra-Containers

#+begin_src nix :noweb-ref no
inputs.extra-container.overlay
#+end_src

**** Caddy With Plugins

#+begin_src nix :noweb-ref no
(final: prev: { caddy = prev.callPackage ./callPackages/caddy.nix {
    plugins = [
        "github.com/mholt/caddy-l4@latest"
        "github.com/abiosoft/caddy-yaml@latest"
        "github.com/caddy-dns/cloudflare@latest"
    ];
}; })
#+end_src

**** Mozilla

# TODO

#+begin_src nix :noweb-ref no
(final: prev: inputs.mozilla.overlays)
#+end_src

**** Overlays in Overlays Directory

#+begin_src nix
(map (file:
    (final: prev: {
        "${j.functions.name { inherit file; }}" = import file args;
    })
) (j.functions.list { dir = ./overlays; }))
#+end_src

**** Overrides from Older Channels

#+begin_src nix
(let pkgsets = {
    # nixos-unstable = [ "networkmanager" "gnome-control-center" "bash" "bootstrap-tools" { gcc10 = "gcc11"; } ];
    # nixos-unstable = "nix";
};
in mapAttrsToList (
    pkgchannel: pkglist': let
        pkglist = if (isString pkglist') then [ pkglist' ] else pkglist';
    in map (
        pkg': let
            pkgIsAttrs = isAttrs pkg';
            pkg1 = if pkgIsAttrs then (last (attrNames pkg')) else pkg';
            pkg2 = if pkgIsAttrs then (last (attrValues pkg')) else pkg';
            self = (pkgchannel == channel) || (pkgchannel == "self");
        in (final: prev: { "${pkg1}" = if self then prev.${pkg2} else final.j.pkgs.${pkgchannel}.${pkg2}; })
    ) pkglist
) pkgsets)
#+end_src

**** Guix

#+begin_src nix :noweb-ref no
(final: prev: { guix = final.callPackage "${fetchGit { url = "https://github.com/${j.attrs.users.primary}/nixpkgs"; ref = "guix"; }}/pkgs/development/guix/guix.nix" {  }; })
#+end_src

**** End of overlays.nix

#+begin_src nix
]
#+end_src

*** flake.nix

#+begin_src nix :tangle (meq/tangle-path)
{
    nixConfig = {
        # Adapted From: https://github.com/divnix/digga/blob/main/examples/devos/flake.nix#L4
        <<270d5d30-951e-4171-8c23-67fc45d20578(flake='t)>>
    };

    inputs = rec {
        # nixos-unstable.url = github:NixOS/nixpkgs/nixos-unstable;
        nixos-unstable.url = "https://nixos.org/channels/nixos-unstable/nixexprs.tar.xz";

        # nixos-unstable-small.url = github:NixOS/nixpkgs/nixos-unstable-small;
        nixos-unstable-small.url = "https://nixos.org/channels/nixos-unstable-small/nixexprs.tar.xz";

        # nixos-21-11.url = github:NixOS/nixpkgs/nixos-21.11;
        nixos-21-11.url = "https://nixos.org/channels/nixos-21.11/nixexprs.tar.xz";

        # nixos-21-11-small.url = github:NixOS/nixpkgs/nixos-21.11-small;
        nixos-21-11-small.url = "https://nixos.org/channels/nixos-21.11-small/nixexprs.tar.xz";

        release-21-11.url = github:NixOS/nixpkgs/release-21.11;

        master.url = github:NixOS/nixpkgs/master;

        j.url = github:<<username>>/nixpkgs/j;

        nixpkgs.follows = "j";

        hardware.url = github:nixos/nixos-hardware;

        pinebook-pro = {
            url = github:samueldr/wip-pinebook-pro;
            flake = false;
        };

        <<username>> = {
            url = github:<<username>>/<<username>>;
            flake = false;
        };

        flake-compat = {
            url = github:edolstra/flake-compat;
            flake = false;
        };

        home-manager.url = github:nix-community/home-manager;
        impermanence.url = github:nix-community/impermanence;

        nix.url = github:nixos/nix;
        extra-container.url = github:erikarvstedt/extra-container;
        nur.url = github:nix-community/nur;
        emacs.url = github:nix-community/emacs-overlay;
        mozilla.url = github:mozilla/nixpkgs-mozilla;

        flake-utils.url = github:numtide/flake-utils;
    };

    outputs = inputs@{ self, nixpkgs, flake-utils, ... }: with builtins; with nixpkgs.lib; with flake-utils.lib; let
        channel = "j";
        make = {
            pre-pkgs = system: import nixpkgs { inherit system; };
            lib = host: system: nixpkgs.lib.extend (final: prev: {
                j = import ./lib.nix ({
                    inherit inputs system;
                    pkgs = make.pre-pkgs system;
                    lib = final;
                } // (if (host == null) then {} else { inherit host; }));
            });
            pre-nixpkgset = system: lib: { inherit system; config = lib.j.attrs.configs.nixpkgs; };
            overlays = system: lib: import ./overlays.nix {
                inherit lib nixpkgs inputs channel;
                pkgs = mapAttrs (n: v: import v (make.pre-nixpkgset system lib)) (
                    (filterAttrs (n: v: (hasPrefix "nixos-" n) || (hasPrefix "release-" n)) inputs) //
                    (with inputs; { inherit master j; })
                );
            };
            nixpkgset = overlays: system: lib: { inherit overlays system; config = lib.j.attrs.configs.nixpkgs; };
            pkgs = nixpkgset: import nixpkgs nixpkgset;
            specialArgs = name: system: rec {
                inherit inputs nixpkgs system;
                host = name;
                lib = make.lib name system;
                pre-nixpkgset = make.pre-nixpkgset system lib;
                overlays = make.overlays system lib;
                nixpkgset = make.nixpkgset overlays system lib;
                pkgs = make.pkgs nixpkgset;
            };
            config = name: system: nixosSystem rec {
                specialArgs = make.specialArgs name system;
                modules = with inputs; let
                    j-list = specialArgs.lib.j.functions.list;
                in flatten [
                    "${toString ./.}/hosts/${name}"
                    home-manager.nixosModules.home-manager
                    impermanence.nixosModules.impermanence
                    (j-list { dir = ./modules; })
                    (j-list { dir = ./secrets; })
                ];
            };
            nixosConfiguration = system: { packages.nixosConfigurations = listToAttrs (map
                (name: nameValuePair name (make.config name system))
                (attrNames (filterAttrs (n: v: v == "directory") (readDir ./hosts)))
            ); };
        };
    in (eachSystem allSystems make.nixosConfiguration) // { inherit make channel; };
}
#+end_src

*** minimal.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref minimal.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<minimal.nix>>
#+end_src

**** Arguments

#+begin_src nix
with builtins; args@{ config, ... }:
#+end_src

**** Config Let

#+begin_src nix
let
#+end_src

***** Flake

#+begin_src nix
flake = import ./.;
#+end_src

****** Inheritance

#+begin_src nix
system = args.system or currentSystem;
host = args.host or config.networking.hostName;
fromFlake = args ? inputs;
inheritanceSet = if fromFlake then args else (flake.make.specialArgs host system);
inherit (inheritanceSet) lib overlays nixpkgset pkgs;
#+end_src

***** Config Repo

#+begin_src nix
dir = "${lib.j.attrs.homes.${lib.j.attrs.users.primary}}/.local/share/yadm/repo.git";
dirExists = pathExists dir;
repo = with lib; j.functions.mntConvert (if dirExists then (fetchGit { url = "file://${dir}"; ref = "main"; }) else flake.inputs.${j.attrs.users.primary});
#+end_src

***** Configurations

#+begin_src nix
nixos = "${(args.nixpkgs or <nixpkgs>)}/nixos";
nixos-configuration = configuration: import nixos { configuration = import configuration (args // inheritanceSet); inherit system; };
nixos-configurations = {
    server = nixos-configuration ./profiles/server.nix;
    configuration = nixos-configuration ./configuration.nix;
    hardware-configuration = import nixos { inherit system; configuration.imports = [
        ./hardware-configuration.nix
        ({config, ... }: { networking.hostId = substring 0 8 (readFile "/etc/machine-id"); boot.loader.grub.devices = [ "nodev" ]; })
    ]; };
};
#+end_src

**** Begin Set

#+begin_src nix
in with lib; {
#+end_src

**** Imports

#+begin_src nix
imports = with flake.inputs; flatten [
    (if fromFlake then [] else [ home-manager.nixosModules.home-manager impermanence.nixosModules.impermanence ])
];
#+end_src

**** Config

#+begin_src nix
# config = (removeAttrs nixos-configurations.hardware-configuration.config [ "fileSystems" "nesting" "jobs" "fonts" "meta" "documentation" ]) // {
config = (filterAttrs (n: v: elem n [ "boot" "networking" "powerManagement" "hardware" ]) nixos-configurations.hardware-configuration.config) //

    # TODO: What exactly from `system' am I taking? Merge it explicitly.
    # (if fromFlake then (filterAttrs (n: v: elem n [ "system" ]) nixos-configurations.configuration.config) else {}) //

{
#+end_src

***** Boot

#+begin_src nix
boot = {
#+end_src

****** Supported Filesystems

#+begin_src nix
supportedFilesystems = j.attrs.fileSystems.supported;
#+end_src

****** Initrd

#+begin_src nix
initrd = {
    inherit (config.boot) supportedFilesystems;
    compressor = "${lib.getBin pkgs.zstd}/bin/zstd";
    network.ssh.enable = true;
};
#+end_src

****** Extra Modprobe Config

#+begin_src nix
extraModprobeConfig = '' options kvm_intel_nested=1 '';
#+end_src

****** Loader

#+begin_src nix
loader = {
    generic-extlinux-compatible.enable = mkForce false;
    systemd-boot = {
        configurationLimit = 25;
        editor = mkForce false;
        # enable = mkForce false;
        enable = mkForce true;
    };
    grub = {
        # enable = mkForce true;
        enable = mkForce false;
        efiSupport = true;
        efiInstallAsRemovable = mkForce false;
        # efiInstallAsRemovable = mkForce true;
        # devices = [ "nodev" ];
        # device = "nodev";
        device = if config.boot.loader.grub.efiSupport then config.boot.loader.efi.efiSysMountPoint else "/boot";
        version = 2;
        useOSProber = true;

        # TODO: Get more options
        extraEntries = ''
            menuentry "Reboot" { reboot }
            menuentry "Poweroff" { halt }
        '';
    };
    efi = {
        canTouchEfiVariables = mkForce true;
        # canTouchEfiVariables = mkForce false;
        efiSysMountPoint = "/boot/efi";
    };
    timeout = 10;

    # Used for Bedrock Linux
    # Also causing EFI stuff not to be installed
    # initScript.enable = mkForce true;

};
#+end_src

****** Kernel

#+begin_src nix
# kernelPackages = mkDefault pkgs.linuxPackages_xanmod;
# kernelPackages = mkDefaultpkgs.linuxPackages_lqx;
# kernelPackages = mkDefaultpkgs.linuxPackages_zen;
#+end_src

******* Patches

#+begin_src nix
kernelPatches = [
#+end_src

******** Clear Linux

# TODO

#+begin_src nix :noweb-ref no
{ name = "clear"; patch = ./patches/0110-initialize-ata-before-graphics.patch; }
#+end_src

******** ZSTD Kernel Compression

# TODO

#+begin_src nix :noweb-ref no
{
    name = "Enable ZSTD Compression";
    patch = null;
    extraConfig = ''
        RD_ZSTD y
        KERNEL_ZSTD y
        KERNEL_XZ n
    '';
}
#+end_src

******** End of Kernel Patches

#+begin_src nix
];
#+end_src

******* Extra Module Packages

#+begin_src nix
extraModulePackages = with config.boot.kernelPackages; [
    zfsUnstable
];
#+end_src

******* ZFS

#+begin_src nix
kernelModules = [ "zfs" ];
kernelParams = [ "nohibernate" ];
# loader.grub.zfsSupport = mkIf j.attrs.zfs true;
initrd = {
    postDeviceCommands = mkIf j.attrs.zfs (mkAfter ''
        zfs rollback -r ${config.networking.hostName}/system/root@blank
        zfs rollback -r ${config.networking.hostName}/system/home@blank
        # zfs rollback -r ${config.networking.hostName}/system/tmp@blank
    '');
    kernelModules = [ "zfs" "r8169" ];
    availableKernelModules = config.boot.initrd.kernelModules;
};
zfs = mkIf j.attrs.zfs {
    requestEncryptionCredentials = true;
    enableUnstable = true;
    devNodes = "/dev/";
};
#+end_src

****** End of Boot

#+begin_src nix
};
#+end_src

***** Console

#+begin_src nix
console = {
    # Select internationalisation properties.
    # font = lib.mkDefault "${terminus_font}/share/consolefonts/ter-u28n.psf.gz";
    font = "Cartograph CF Extra Bold Italic";
    keyMap = "us";
};
#+end_src

***** Environment

#+begin_src nix
environment = {
#+end_src

****** Etc

#+begin_src nix
etc."nix/nix.conf".text = mkForce j.attrs.configs.nix;
#+end_src

****** System Packages

#+begin_src nix
systemPackages = with pkgs; flatten [
    cachix
    pkgs.j.pkgs.j.xonsh.buildInputs
];
#+end_src

****** ZFS

#+begin_src nix
persistence = mkIf j.attrs.zfs (let
    rootDirSet = {
        user = "root";
        group = "root";
    };
    rootFileSet.parentDirectory = rootDirSet;
in {
    "/persist/root" = {
        hideMounts = true;
        files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // rootFileSet) else (rootFileSet // file)) (flatten [
            "/etc/host"
            "/etc/machine-id"

            (map (directory: map (fd: "/${directory}/${fd}") (attrNames (filterAttrs (n: v: v != "directory") (let path = "${repo}/${directory}"; in if (pathExists path) then (readDir path) else {})))) [
                "etc"
                "var"
            ])
        ]));
        directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // rootDirSet) else (rootDirSet // directory)) (flatten [
            "/bin"
            "/etc/containers"
            "/etc/NetworkManager/system-connections"
            "/etc/nix"
            "/etc/nixos"

            # TODO: Prevents `sshd_config' itself from being created
            "/etc/ssh"

            # TODO: Note that this may fail in the above situation as well
            "/etc/wireguard"

            "/etc/zsh"
            "/sbin"
            "/snap"
            "/usr"
            "/var/lib/acme"
            "/var/lib/bluetooth"
            "/var/lib/systemd/coredump"
            "/var/log"

            (map (directory: map (fd: "/${directory}/${fd}") (attrNames (filterAttrs (n: v: v == "directory") (let path = "${repo}/${directory}"; in if (pathExists path) then (readDir path) else {})))) [
                "etc"
                "var"
            ])
        ]));
    };
    "/persist" = let
        redRepo = readDir repo;
        redRepoFiles = flatten [
            (attrNames (filterAttrs (n: v: v != "directory") redRepo))
        ];
        redRepoDirectories = flatten [
            (attrNames (filterAttrs (n: v: v == "directory") redRepo))
        ];
    in {
        users = listToAttrs (map (user: let
            userDirSet = {
                inherit user;
                group = user;
            };
            userFileSet.parentDirectory = userDirSet;
        in nameValuePair user {
            home = j.attrs.allHomes.${user};
            files = unique (map (file: if ((typeOf file) == "string") then ({ inherit file; } // userFileSet) else (userFileSet // file)) (flatten [
                ".bash_history"
                ".emacs-profile"
                ".fasd"
                ".gitignore"
                ".globalignore"
                ".nix-channels"
                ".python-history"
                ".screenrc"
                ".viminfo"
                ".zsh_history"
                redRepoFiles
            ]));
            directories = unique (map (directory: if ((typeOf directory) == "string") then ({ inherit directory; } // userDirSet) else (userDirSet // directory)) (flatten [
                ".atom"
                ".byobu"
                ".cache"
                ".caddy"
                ".config"
                ".linuxbrew"
                ".local"
                ".mozilla"
                ".peru"
                ".pki"
                ".repos"
                ".vim_runtime"
                ".virtualenvs"
                ".vscode-oss"
                ".vscode"
                ".yubico"
                ".z"
                "Documents"
                "Downloads"
                "keybase"
                "Music"
                "nix-plugins"
                "Pictures"
                "Public"
                "Templates"
                "tests"
                "Videos"
                "VirtualBox VMs"
                { directory = ".gnupg"; mode = "0700"; }
                { directory = ".nixops"; mode = "0700"; }
                { directory = ".ssh"; mode = "0700"; }
                redRepoDirectories

            # TODO: Using `j.attrs.allUsers' means that `root' is being bound multiple times
            #       Is `/root' being wiped? If not, why is being included?
            ]));}) j.attrs.allUsers);
    };
});
#+end_src

****** End of Environment

#+begin_src nix
};
#+end_src

***** Memory

#+begin_src nix
zramSwap = {
    enable = true;
    algorithm = "zstd";
};
#+end_src

***** Filesystems

#+begin_src nix
fileSystems = let
    inherit (j.attrs.fileSystems) base;
    fileSystems' = j.attrs.datasets.fileSystems;
    hasAnInfix = infixes: dataset: any (infix: hasInfix infix dataset) infixes;
in mkMerge [
    # (filterAttrs (n: v: !elem "bind" v.options) nixos-configurations.hardware-configuration.config.fileSystems)
    (filterAttrs (n: v: elem n [ "/boot" "/boot/efi" ]) nixos-configurations.hardware-configuration.config.fileSystems)
    (mkIf j.attrs.zfs (mapAttrs' (dataset: mountpoint: nameValuePair mountpoint (
        mkForce (base // { device = dataset; ${
            j.functions.myIf.knull (hasAnInfix [
                j.attrs.users.primary
                "persist"
                "home"
            ] dataset) "neededForBoot"
        } = true; })
    )) fileSystems'))
];
#+end_src

***** Hardware

#+begin_src nix
hardware = {
    enableRedistributableFirmware = lib.mkDefault true;
    # Enable sound
    pulseaudio.enable = true;
};
sound.enable = true;
#+end_src

***** Networking

#+begin_src nix

networking = {
    networkmanager.enable = mkForce true;
    interfaces = if fromFlake then (mapAttrs (n: v: v // {
        useDHCP = mkForce !config.networking.networkmanager.enable;
        wakeOnLan.enable = true;
    }) (filterAttrs (n: v: !elem n [ "wg0" ]) nixos-configurations.configuration.config.networking.interfaces)) else {};

    # The global useDHCP flag is deprecated, therefore explicitly set to false here.
    # Per-interface useDHCP will be mandatory in the future, so this generated config
    # replicates the default behaviour.
    useDHCP = false;

    # Configure network proxy if necessary
    # proxy = {
    # default = "http://user:password@proxy:port/";
    # noProxy = "127.0.0.1,localhost,internal.domain";
    # };

    # Or disable the firewall altogether.
    # enable = false;
    # };

    wireguard.interfaces.wg0 = {
        generatePrivateKeyFile = true;
        privateKeyFile = "/persist/etc/wireguard/wg0";
    };

    firewall = mkIf j.attrs.relay {
        allowedTCPPorts = [ 22 80 222 443 2022 8080 9418 ];
        allowedUDPPortRanges = [
            {
                from = 60000;
                to = 61000;
            }
        ];
    };
};
#+end_src

***** Nix

#+begin_src nix
nix = rec {
    gc = j.functions.foldToSet [
        { automatic = true; }
        { dates = "monthly"; }
        # {
        #   dates = "monthly";
        #   options = "-d";
        # }
        # {
        #   dates = "daily";
        #   options = "--delete-older-than 30d";
        # }
    ];
    optimise = {
        automatic = true;
        dates = [ "05:00" ];
    };
    extraOptions = j.attrs.configs.nix;
    settings = {
        auto-optimise-store = true;
        sandbox = true;
    };
    # sandboxPaths = [];
};
#+end_src

***** Nixpkgs

#+begin_src nix
nixpkgs = nixpkgset;
#+end_src

***** Power

#+begin_src nix
services.logind.lidSwitch = "hybrid-sleep";
powerManagement = {
    enable = true;
    cpuFreqGovernor = mkForce "ondemand";
};
#+end_src

***** Programs

#+begin_src nix
programs = {
    xonsh.enable = true;
    fish.enable = true;
    zsh.enable = true;
    tmux = {
        enable = true;
        extraConfig = ''
            <<20211018140524183223400>>
        '';
    };
};
#+end_src

***** Services

#+begin_src nix
services = {
#+end_src

****** SSH

#+begin_src nix
openssh = mkForce nixos-configurations.server.config.services.openssh;
#+end_src

****** UDEV

#+begin_src nix
udev.extraRules = mkIf j.attrs.zfs ''
    ACTION=="add|change", KERNEL=="sd[a-z]*[0-9]*|mmcblk[0-9]*p[0-9]*|nvme[0-9]*n[0-9]*p[0-9]*", ENV{ID_FS_TYPE}=="zfs_member", ATTR{../queue/scheduler}="none"
''; # zfs already has its own scheduler. without this my(@Artturin) computer froze for a second when i nix build something.
#+end_src

****** XServer

#+begin_src nix :noweb-ref no
xserver = {
    enable = true;
    layout = "us";
    # xkbOptions = "eurosign:e";
    # Enable touchpad support.
    libinput = {
        enable = true;
        touchpad = {
            naturalScrolling = true;
            middleEmulation = true;
            tapping = true;
        };
    };
    # synaptics.enable = true;
    desktopManager.gnome.enable = true;
    displayManager = {
        startx.enable = true;
        lightdm.enable = mkForce false;
    };
    autorun = false;
};
#+end_src

****** End of Services

#+begin_src nix
};
#+end_src

***** Users

#+begin_src nix
users = with j.attrs.users; let
    base = {
        hashedPassword = "$6$DoC/h6kR66Sa$aZKtTOXAqnan/jAC.4dH9tCYshheiKUZItR4g/kmMMLsfLQh0KslINL9zUTX2IjAZh9DE18eAh1AAz48.n/cm.";
        isNormalUser = true;
        createHome = true;
        extraGroups = [
            "wheel"
            "networkmanager"
            "persist"
            "libvirtd"
            "docker"
        ];
        openssh.authorizedKeys.keys = unique (flatten [
            (attrValues j.attrs.ssh.keys)
        ]);
    };
in rec {
    users = mkMerge [
        (genAttrs j.attrs.allUsers (user: base))
        {
            "${primary}" = {
                uid = 4362;
                home = j.attrs.homes.${primary};
                description = "Jeet Ray";
                group = primary;
                extraGroups = [ secondary ];
                shell = pkgs.xonsh;
            };
            "${secondary}" = {
                uid = 1111;
                home = j.attrs.homes.${secondary};
                description = "Alicia Summers";
                group = secondary;
                extraGroups = [ primary ];
                shell = pkgs.fish;
            };
            "${nightingale}" = {
                uid = 8888;
                home = j.attrs.homes.${nightingale};
                description = "Curtis Nightingale";
                group = "root";
                extraGroups = [ primary secondary ];
                shell = pkgs.zsh;
            };
            root = {
                shell = mkForce pkgs.zsh;
                home = j.attrs.allHomes.root;
                isNormalUser = mkForce false;
                isSystemUser = mkForce true;
            };
        }
    ];

    mutableUsers = false;

    groups = {
        "${primary}" = {
            gid = config.users.users.${primary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${secondary}" = {
            gid = config.users.users.${secondary}.uid;
            members = [ primary secondary nightingale ];
        };
        "${nightingale}" = {
            gid = config.users.users.${nightingale}.uid;
            members = [ nightingale ];
        };
    };
};
#+end_src

***** End of Config

#+begin_src nix
};
#+end_src

**** End of minimal.nix

#+begin_src nix
}
#+end_src

*** modules
**** boot.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    boot = {
        binfmt.emulatedSystems = [
            "armv7l-linux"
            "aarch64-linux"
        ];
        extraModulePackages = with config.boot.kernelPackages; [
            # anbox
            # wireguard
        ];
    };
}
#+end_src

**** environment.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, ... }: with pkgs;

{
    environment = {
        pathsToLink = [ "/share/nix-direnv" ];
        systemPackages = [
            # bcachefs-tools
            acpilight
            alacritty
            asdf-vm
            assh
            atom
            autojump
            autossh
            bat
            bc
            btrfs-progs
            byobu
            cascadia-code
            cmake
            copyq
            coreutils
            ctop
            curl
            darling-dmg
            # ddar
            direnv
            diskus
            dos2unix
            duf
            elvish
            emacs
            entr
            exa
            exfat
            # extra-container
            fasd
            fd
            fd
            fff
            ffmpeg
            figlet
            filet
            firefox
            fish
            fzf
            gcc
            git
            git-crypt
            git-filter-repo
            git-fire
            git-lfs
            gitoxide
            glances
            gnumake
            google-chrome google-chrome-beta google-chrome-dev
            gotop
            gparted
            gptfdisk
            # haskellPackages.hocker
            inetutils
            j-settings
            jupyter
            keybase-gui kitty
            libffi
            libguestfs
            libsForQt5.qtstyleplugin-kvantum
            libtool
            lolcat
            lorri
            man
            micro
            mkpasswd
            monkeysphere
            mosh
            mtr
            neo-cowsay
            neovim
            niv
            nix-direnv
            nnn
            nodePackages.prettier
            nox
            ntfs3g nixos-shell
            pandoc
            par2cmdline
            parted pmutils
            peru
            pfetch
            pypy
            python310
            python39Packages.pipx
            ranger
            refind
            ripgrep
            rsync
            sd
            shadowfox
            shellcheck
            silver-searcher
            snapper
            spacevim
            sqlite
            starship
            sysstat
            thefuck
            thermald
            tmux
            tmuxp
            tree
            udftools
            ulauncher
            uutils-coreutils
            vagrant
            vim
            vivaldi vivaldi-ffmpeg-codecs vivaldi-widevine
            vlc
            vscode vscodium
            wget
            win-qemu
            woeusb
            wtf
            xclip
            xclip
            xfce.thunar
            xz
            yubico-pam yubico-piv-tool yubikey-manager yubikey-agent yubikey-personalization yubioath-desktop
            yubikey-manager-qt yubikey-personalization-gui
            zenith
            zsh
            zoxide
        ] ++ (map (pkg: pkgs.gnome."gnome-${pkg}") [
            "boxes"
            "characters"
            "tweaks"
            "session"
        ]) ++ (map (pkg: pkgs."nix-prefetch-${pkg}") [
            "github"
            "docker"
            "scripts"
        ]) ++ (with pkgs.gnome; [
            dconf-editor
        ]) ++ (with pkgs.gitAndTools; [
            git-extras
            git-hub
            gitflow
            gh
            hub
            lab
        ]) ++ (with pkgs.python310Packages; [
            black
            black-macchiato
            poetry
            jupyterlab
            xonsh
        ]);
    };
}
#+end_src

**** miscellaneous.nix

#+begin_quote
Help is available in the configuration.nix(5) man page and in the NixOS manual (accessible by running 'nixos-help').
#+end_quote

#+begin_src nix :tangle (meq/tangle-path)
{ config, pkgs, lib, system, ... }: with lib;

{
    xdg.portal = {
        enable = mkForce j.attrs.no-arms;
        extraPortals = map (portal: pkgs."xdg-desktop-portal-${portal}") [ "gtk" "kde" ];
    };
    i18n = {
        # Select internationalisation properties.
        defaultLocale = "en_US.UTF-8";
    };
    time.timeZone = "America/Toronto";
    system = {
        # This value determines the NixOS release from which the default
        # settings for stateful data, like file locations and database versions
        # on your system were taken. It's perfectly fine and recommended to leave
        # this value at the release version of the first install of this system.
        # Before changing this value read the documentation for this option
        # (e.g. man configuration.nix or on https://nixos.org/nixos/options.html).
        # stateVersion = "20.09"; # Did you read the comment?
        autoUpgrade = {
            enable = true;
            allowReboot = false;
            # flake = "https://github.com/nixos/nixpkgs/archive/master.tar.gz";
            flake = "https://github.com/${j.attrs.users.primary}/nixpkgs/archive/j.tar.gz";
        };
    };
}
#+end_src

**** programs.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    programs = {
        extra-container.enable = true;
    };
}
#+end_src

**** home-manager.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, ... }: with lib;

{
    home-manager = {
        useGlobalPkgs = true;
        users = j.functions.foldToSet [
            listToAttrs (map (user: nameValuePair user {
                home = {
                    homeDirectory = j.attrs.homes.${user};
                    file.<<20220205031620372930929>>.source = repo;
                };
            }) j.attrs.allUsers)
        ];
    };
}
#+end_src

**** security.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, ... }:

{
    # For Yubikey SSH-GPG Authentication
    environment.shellInit = ''
        export GPG_TTY="$(tty)"
        gpg-connect-agent /bye
        export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
        echo UPDATESTARTUPTTY | gpg-connect-agent
    '';
    programs = {
        # Some programs need SUID wrappers, can be configured further or are
        # started in user sessions.
        # mtr.enable = true;
        gnupg.agent = {
            enable = true;
            enableSSHSupport = false;
            pinentryFlavor = "curses";
        };

        # For use with Yubikey SSH-GPG Authentication, set to false
        ssh.startAgent = true;
    };
    security.pam = {
        yubico = {
            enable = true;
            debug = true;
            mode = "challenge-response";
        };
        enableSSHAgentAuth = true;
    };
}
#+end_src

**** services.nix
:PROPERTIES:
:header-args:nix+: :noweb-ref services.nix
:END:

#+begin_src text :tangle (meq/tangle-path)
<<services.nix>>
#+end_src

#+begin_src nix
{ config, lib, pkgs, system, ... }: with lib;

{
    services = {
#+end_src

***** Emacs

#+begin_src nix
emacs = {
    package = pkgs.emacsGcc;
    enable = true;
    defaultEditor = true;
};
#+end_src

***** Flatpak

#+begin_src nix
# flatpak.enable = j.attrs.no-arms;
flatpak.enable = true;
#+end_src

***** Guix

#+begin_src nix
guix.enable = true;
#+end_src

***** Printing

#+begin_src nix
printing.enable = true;
#+end_src

***** Yubikey

#+begin_src nix
udev.packages = with pkgs; [
    yubikey-personalization
    libu2f-host
];
pcscd.enable = true;
#+end_src

***** ZFS

#+begin_src nix
zfs = mkIf j.attrs.zfs {
    trim.enable = true;
    autoScrub.enable = true;

    # Managed by Sanoid
    autoSnapshot.enable = false;
};
#+end_src

****** Sanoid

#+begin_src nix
sanoid = let
    sanoidBase = {
        useTemplate = [ "base" ];
        recursive = true;
    };
    disabled = { processChildrenOnly = true; };
in {
    enable = true;
    templates."base" = {
        autoprune = true;
        autosnap = true;

        # 6 snapshots an hour
        daily = 144;

        # 2 snapshots a minute
        hourly = 120;

        # 6 snapshots a day for 28 days
        monthly = 168;

        # Twice the weeks in a year
        yearly = 104;
    };

    datasets = listToAttrs (map (dataset: nameValuePair "${config.networking.hostName}/${dataset}" sanoidBase) (flatten [
        j.attrs.datasets.backup
        config.networking.hostName
    ]));
};
#+end_src

****** Syncoid

#+begin_src nix
syncoid = let
    syncoidBase = mkMerge [{
        recursive = true;
        commonArgs = [
            "--compress zstd-slow"
            "--no-stream"
            "--no-sync-snap"
            "--create-bookmark"
        ];
        }
        # (mkIf vars.encrypted {
        #     sendOptions = "vvwRI";
        #     recvOptions = "vvFs";
        # })
        # (mkIf (!vars.encrypted) {
        #     recvOptions = "vvFds";
        #     sendOptions = "vvRI";
        # })
    ];
in {
    enable = false;
    sshKey = "/root/.ssh/id_ecdsa";
    commands = listToAttrs (map (dataset: nameValuePair "${host}/${dataset}" (syncoidBase // { target = ""; })) (flatten [
        j.attrs.datasets.backup
        config.networking.hostName
    ]));
};
#+end_src

***** End of services.nix

#+begin_src nix
};}
#+end_src

**** systemd.nix

#+begin_src nix :tangle (meq/tangle-path)
{ config, lib, pkgs, ... }: with lib;

{
    systemd = {
        # packages = with pkgs; [ runit ];
        services = {
            # runit.enable = true;
            caddy = mkIf j.attrs.relay (j.attrs.configs.services.base // {
                serviceConfig = {
                    ExecStart = ''
                        ${pkgs.caddy}/bin/caddy run --config ${j.attrs.homes.${j.attrs.users.primary}}/.config/caddy/files/${config.networking.hostName} --adapter yaml 2>&1
                    '';
                    ExecStop = ''
                        pkill caddy
                    '';
                };
            });
        };
    };
}
#+end_src

**** virtualisation.nix

#+begin_src nix
{ config, pkgs, ... }:

{
    virtualisation = {
        xen.enable = false;
        lxd.zfsSupport = mkIf j.attrs.zfs true;
        podman.enable = true;
        docker = {
            enable = true;
            storageDriver = mkIf j.attrs.zfs "zfs";
            package = pkgs.docker;
            enableOnBoot = true;
        };
        libvirtd.enable = true;
    };
}
#+end_src

** nix
*** nix.conf

Adapted from [[][here]]:

#+name: 270d5d30-951e-4171-8c23-67fc45d20578
#+begin_src emacs-lisp :var delim="" comment="" quoted='nil flake='nil
;; (format-spec "extra-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/ https://sylvorg.cachix.org/%q%d
(format-spec "trusted-substituters = %qhttps://cache.nixos.org/ https://nix-community.cachix.org/ https://sylvorg.cachix.org/%q%d
# extra-trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= sylvorg.cachix.org-1:xd1jb7cDkzX+D+Wqt6TemzkJH9u9esXEFu1yaR9p8H8=%q%d
trusted-public-keys = %qcache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs= sylvorg.cachix.org-1:xd1jb7cDkzX+D+Wqt6TemzkJH9u9esXEFu1yaR9p8H8=%q%d
%ckeep-derivations = true%d
%ckeep-outputs = true%d
extra-experimental-features = %qnix-command flakes%q%d
%callow-unsafe-native-code-during-evaluation = true%d
%cmin-free = 262144000%d
%cmax-free = 1073741824%d" `((?d . ,(if flake ";" delim)) (?c . ,(if flake "# " comment)) (?q . ,(if (or flake quoted) "\"" ""))))
#+end_src

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** zsh
*** keephack

#+call: hash() :exports none

#+RESULTS:
: 20210601185403002625400

#+name: 20210601185403002625400
#+begin_src emacs-lisp
(concat
    (let
        ((file "~/resources/grml/etc/zsh/keephack"))
        (if
            (file-directory-p file)
            (insert-file-contents file)
            "")))
#+end_src

# From: https://www.draketo.de/light/english/minimal-example-for-literate-programming-noweb-emacs-org-mode
# From: https://emacs.stackexchange.com/questions/47474/setting-variable-for-org-mode-html-export

#+begin_src sh :tangle (meq/tangle-path)
<<20210601185403002625400()>>
#+end_src

** sv

I just keeping these here for reference.

*** caddy
**** log
***** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
exec svlogd -tt /etc/sv/caddy/log
#+end_src

**** run

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
for port in 22 80 222 443 2022 8080 9418 60000:61000/udp; do
    ufw allow $port &> /dev/null
done
chmod +x /etc/sv/caddy/{finish,log/run}
exec /usr/bin/caddy run --config /.config/caddy/files/<<hostname>> --adapter yaml 2>&1
#+end_src

**** finish

#+begin_src zsh :shebang "#!/usr/bin/env zsh"
killall caddy
#+end_src

* .gitattributes

The LFS filter are from both
[[https://raw.githubusercontent.com/sindresorhus/binary-extensions/main/binary-extensions.json][here]] and
[[https://rehansaeed.com/gitattributes-best-practices/#final-form][here]]:

#+begin_src gitattributes :tangle (meq/tangle-path)
*.3dm filter=lfs diff=lfs merge=lfs -text
*.3ds filter=lfs diff=lfs merge=lfs -text
*.3g2 filter=lfs diff=lfs merge=lfs -text
*.3gp filter=lfs diff=lfs merge=lfs -text
*.7z filter=lfs diff=lfs merge=lfs -text
*.a filter=lfs diff=lfs merge=lfs -text
*.aac filter=lfs diff=lfs merge=lfs -text
*.aax filter=lfs diff=lfs merge=lfs -text
*.adp filter=lfs diff=lfs merge=lfs -text
*.ai filter=lfs diff=lfs merge=lfs -text
*.aif filter=lfs diff=lfs merge=lfs -text
*.aiff filter=lfs diff=lfs merge=lfs -text
*.alz filter=lfs diff=lfs merge=lfs -text
*.ape filter=lfs diff=lfs merge=lfs -text
*.apk filter=lfs diff=lfs merge=lfs -text
*.appimage filter=lfs diff=lfs merge=lfs -text
*.ar filter=lfs diff=lfs merge=lfs -text
*.arj filter=lfs diff=lfs merge=lfs -text
*.asf filter=lfs diff=lfs merge=lfs -text
*.au filter=lfs diff=lfs merge=lfs -text
*.avi filter=lfs diff=lfs merge=lfs -text
*.bak filter=lfs diff=lfs merge=lfs -text
*.baml filter=lfs diff=lfs merge=lfs -text
*.bh filter=lfs diff=lfs merge=lfs -text
*.bin filter=lfs diff=lfs merge=lfs -text
*.bk filter=lfs diff=lfs merge=lfs -text
*.bmp filter=lfs diff=lfs merge=lfs -text
*.br filter=lfs diff=lfs merge=lfs -text
*.btif filter=lfs diff=lfs merge=lfs -text
*.bz2 filter=lfs diff=lfs merge=lfs -text
*.bzip2 filter=lfs diff=lfs merge=lfs -text
*.cab filter=lfs diff=lfs merge=lfs -text
*.caf filter=lfs diff=lfs merge=lfs -text
*.cgm filter=lfs diff=lfs merge=lfs -text
*.class filter=lfs diff=lfs merge=lfs -text
*.cmx filter=lfs diff=lfs merge=lfs -text
*.cpio filter=lfs diff=lfs merge=lfs -text
*.cr2 filter=lfs diff=lfs merge=lfs -text
*.cur filter=lfs diff=lfs merge=lfs -text
*.dat filter=lfs diff=lfs merge=lfs -text
*.dcm filter=lfs diff=lfs merge=lfs -text
*.deb filter=lfs diff=lfs merge=lfs -text
*.dex filter=lfs diff=lfs merge=lfs -text
*.djvu filter=lfs diff=lfs merge=lfs -text
*.dll filter=lfs diff=lfs merge=lfs -text
*.dmg filter=lfs diff=lfs merge=lfs -text
*.dng filter=lfs diff=lfs merge=lfs -text
*.doc filter=lfs diff=lfs merge=lfs -text
*.docm filter=lfs diff=lfs merge=lfs -text
*.docx filter=lfs diff=lfs merge=lfs -text
*.dot filter=lfs diff=lfs merge=lfs -text
*.dotm filter=lfs diff=lfs merge=lfs -text
*.dra filter=lfs diff=lfs merge=lfs -text
*.DS_Store filter=lfs diff=lfs merge=lfs -text
*.dsk filter=lfs diff=lfs merge=lfs -text
*.dts filter=lfs diff=lfs merge=lfs -text
*.dtshd filter=lfs diff=lfs merge=lfs -text
*.dvb filter=lfs diff=lfs merge=lfs -text
*.dwg filter=lfs diff=lfs merge=lfs -text
*.dxf filter=lfs diff=lfs merge=lfs -text
*.ecelp4800 filter=lfs diff=lfs merge=lfs -text
*.ecelp7470 filter=lfs diff=lfs merge=lfs -text
*.ecelp9600 filter=lfs diff=lfs merge=lfs -text
*.egg filter=lfs diff=lfs merge=lfs -text
*.eol filter=lfs diff=lfs merge=lfs -text
*.eot filter=lfs diff=lfs merge=lfs -text
*.epub filter=lfs diff=lfs merge=lfs -text
*.exe filter=lfs diff=lfs merge=lfs -text
*.f4v filter=lfs diff=lfs merge=lfs -text
*.fbs filter=lfs diff=lfs merge=lfs -text
*.fh filter=lfs diff=lfs merge=lfs -text
*.fla filter=lfs diff=lfs merge=lfs -text
*.flac filter=lfs diff=lfs merge=lfs -text
*.flatpak filter=lfs diff=lfs merge=lfs -text
*.fli filter=lfs diff=lfs merge=lfs -text
*.flv filter=lfs diff=lfs merge=lfs -text
*.fpx filter=lfs diff=lfs merge=lfs -text
*.fst filter=lfs diff=lfs merge=lfs -text
*.fvt filter=lfs diff=lfs merge=lfs -text
*.g3 filter=lfs diff=lfs merge=lfs -text
*.gh filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.graffle filter=lfs diff=lfs merge=lfs -text
*.gz filter=lfs diff=lfs merge=lfs -text
*.gzip filter=lfs diff=lfs merge=lfs -text
*.h261 filter=lfs diff=lfs merge=lfs -text
*.h263 filter=lfs diff=lfs merge=lfs -text
*.h264 filter=lfs diff=lfs merge=lfs -text
*.icns filter=lfs diff=lfs merge=lfs -text
*.ico filter=lfs diff=lfs merge=lfs -text
*.ief filter=lfs diff=lfs merge=lfs -text
*.img filter=lfs diff=lfs merge=lfs -text
*.ipa filter=lfs diff=lfs merge=lfs -text
*.iso filter=lfs diff=lfs merge=lfs -text
*.jar filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpgv filter=lfs diff=lfs merge=lfs -text
*.jpm filter=lfs diff=lfs merge=lfs -text
*.jxr filter=lfs diff=lfs merge=lfs -text
*.key filter=lfs diff=lfs merge=lfs -text
*.ktx filter=lfs diff=lfs merge=lfs -text
*.lha filter=lfs diff=lfs merge=lfs -text
*.lib filter=lfs diff=lfs merge=lfs -text
*.lvp filter=lfs diff=lfs merge=lfs -text
*.lz filter=lfs diff=lfs merge=lfs -text
*.lzh filter=lfs diff=lfs merge=lfs -text
*.lzma filter=lfs diff=lfs merge=lfs -text
*.lzo filter=lfs diff=lfs merge=lfs -text
*.m3u filter=lfs diff=lfs merge=lfs -text
*.m4a filter=lfs diff=lfs merge=lfs -text
*.m4v filter=lfs diff=lfs merge=lfs -text
*.mar filter=lfs diff=lfs merge=lfs -text
*.mdi filter=lfs diff=lfs merge=lfs -text
*.mht filter=lfs diff=lfs merge=lfs -text
*.mid filter=lfs diff=lfs merge=lfs -text
*.midi filter=lfs diff=lfs merge=lfs -text
*.mj2 filter=lfs diff=lfs merge=lfs -text
*.mka filter=lfs diff=lfs merge=lfs -text
*.mkv filter=lfs diff=lfs merge=lfs -text
*.mmr filter=lfs diff=lfs merge=lfs -text
*.mng filter=lfs diff=lfs merge=lfs -text
*.mobi filter=lfs diff=lfs merge=lfs -text
*.mov filter=lfs diff=lfs merge=lfs -text
*.movie filter=lfs diff=lfs merge=lfs -text
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.mp4 filter=lfs diff=lfs merge=lfs -text
*.mp4a filter=lfs diff=lfs merge=lfs -text
*.mpeg filter=lfs diff=lfs merge=lfs -text
*.mpg filter=lfs diff=lfs merge=lfs -text
*.mpga filter=lfs diff=lfs merge=lfs -text
*.mxu filter=lfs diff=lfs merge=lfs -text
*.nef filter=lfs diff=lfs merge=lfs -text
*.npx filter=lfs diff=lfs merge=lfs -text
*.numbers filter=lfs diff=lfs merge=lfs -text
*.nupkg filter=lfs diff=lfs merge=lfs -text
*.o filter=lfs diff=lfs merge=lfs -text
*.odp filter=lfs diff=lfs merge=lfs -text
*.ods filter=lfs diff=lfs merge=lfs -text
*.odt filter=lfs diff=lfs merge=lfs -text
*.oga filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text
*.ogv filter=lfs diff=lfs merge=lfs -text
*.otf filter=lfs diff=lfs merge=lfs -text
*.ott filter=lfs diff=lfs merge=lfs -text
*.pages filter=lfs diff=lfs merge=lfs -text
*.pbm filter=lfs diff=lfs merge=lfs -text
*.pcx filter=lfs diff=lfs merge=lfs -text
*.pdb filter=lfs diff=lfs merge=lfs -text
*.pdf filter=lfs diff=lfs merge=lfs -text
*.pea filter=lfs diff=lfs merge=lfs -text
*.pgm filter=lfs diff=lfs merge=lfs -text
*.pic filter=lfs diff=lfs merge=lfs -text
*.png filter=lfs diff=lfs merge=lfs -text
*.pnm filter=lfs diff=lfs merge=lfs -text
*.pot filter=lfs diff=lfs merge=lfs -text
*.potm filter=lfs diff=lfs merge=lfs -text
*.potx filter=lfs diff=lfs merge=lfs -text
*.ppa filter=lfs diff=lfs merge=lfs -text
*.ppam filter=lfs diff=lfs merge=lfs -text
*.ppm filter=lfs diff=lfs merge=lfs -text
*.pps filter=lfs diff=lfs merge=lfs -text
*.ppsm filter=lfs diff=lfs merge=lfs -text
*.ppsx filter=lfs diff=lfs merge=lfs -text
*.ppt filter=lfs diff=lfs merge=lfs -text
*.pptm filter=lfs diff=lfs merge=lfs -text
*.pptx filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text
*.pya filter=lfs diff=lfs merge=lfs -text
*.pyc filter=lfs diff=lfs merge=lfs -text
*.pyo filter=lfs diff=lfs merge=lfs -text
*.pyv filter=lfs diff=lfs merge=lfs -text
*.qt filter=lfs diff=lfs merge=lfs -text
*.rar filter=lfs diff=lfs merge=lfs -text
*.ras filter=lfs diff=lfs merge=lfs -text
*.raw filter=lfs diff=lfs merge=lfs -text
*.resources filter=lfs diff=lfs merge=lfs -text
*.rgb filter=lfs diff=lfs merge=lfs -text
*.rip filter=lfs diff=lfs merge=lfs -text
*.rlc filter=lfs diff=lfs merge=lfs -text
*.rmf filter=lfs diff=lfs merge=lfs -text
*.rmvb filter=lfs diff=lfs merge=lfs -text
*.rpm filter=lfs diff=lfs merge=lfs -text
*.rtf filter=lfs diff=lfs merge=lfs -text
*.rz filter=lfs diff=lfs merge=lfs -text
*.s3m filter=lfs diff=lfs merge=lfs -text
*.s7z filter=lfs diff=lfs merge=lfs -text
*.scpt filter=lfs diff=lfs merge=lfs -text
*.sgi filter=lfs diff=lfs merge=lfs -text
*.shar filter=lfs diff=lfs merge=lfs -text
*.snap filter=lfs diff=lfs merge=lfs -text
*.sil filter=lfs diff=lfs merge=lfs -text
*.sketch filter=lfs diff=lfs merge=lfs -text
*.slk filter=lfs diff=lfs merge=lfs -text
*.smv filter=lfs diff=lfs merge=lfs -text
*.snk filter=lfs diff=lfs merge=lfs -text
*.so filter=lfs diff=lfs merge=lfs -text
*.stl filter=lfs diff=lfs merge=lfs -text
*.suo filter=lfs diff=lfs merge=lfs -text
*.sub filter=lfs diff=lfs merge=lfs -text
*.swf filter=lfs diff=lfs merge=lfs -text
*.tar filter=lfs diff=lfs merge=lfs -text
*.tbz filter=lfs diff=lfs merge=lfs -text
*.tbz2 filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.tgz filter=lfs diff=lfs merge=lfs -text
*.thmx filter=lfs diff=lfs merge=lfs -text
*.tif filter=lfs diff=lfs merge=lfs -text
*.tiff filter=lfs diff=lfs merge=lfs -text
*.tlz filter=lfs diff=lfs merge=lfs -text
*.ttc filter=lfs diff=lfs merge=lfs -text
*.ttf filter=lfs diff=lfs merge=lfs -text
*.txz filter=lfs diff=lfs merge=lfs -text
*.udf filter=lfs diff=lfs merge=lfs -text
*.uvh filter=lfs diff=lfs merge=lfs -text
*.uvi filter=lfs diff=lfs merge=lfs -text
*.uvm filter=lfs diff=lfs merge=lfs -text
*.uvp filter=lfs diff=lfs merge=lfs -text
*.uvs filter=lfs diff=lfs merge=lfs -text
*.uvu filter=lfs diff=lfs merge=lfs -text
*.viv filter=lfs diff=lfs merge=lfs -text
*.vob filter=lfs diff=lfs merge=lfs -text
*.war filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.wax filter=lfs diff=lfs merge=lfs -text
*.wbmp filter=lfs diff=lfs merge=lfs -text
*.wdp filter=lfs diff=lfs merge=lfs -text
*.weba filter=lfs diff=lfs merge=lfs -text
*.webm filter=lfs diff=lfs merge=lfs -text
*.webp filter=lfs diff=lfs merge=lfs -text
*.whl filter=lfs diff=lfs merge=lfs -text
*.wim filter=lfs diff=lfs merge=lfs -text
*.wm filter=lfs diff=lfs merge=lfs -text
*.wma filter=lfs diff=lfs merge=lfs -text
*.wmv filter=lfs diff=lfs merge=lfs -text
*.wmx filter=lfs diff=lfs merge=lfs -text
*.woff filter=lfs diff=lfs merge=lfs -text
*.woff2 filter=lfs diff=lfs merge=lfs -text
*.wrm filter=lfs diff=lfs merge=lfs -text
*.wvx filter=lfs diff=lfs merge=lfs -text
*.xbm filter=lfs diff=lfs merge=lfs -text
*.xif filter=lfs diff=lfs merge=lfs -text
*.xla filter=lfs diff=lfs merge=lfs -text
*.xlam filter=lfs diff=lfs merge=lfs -text
*.xls filter=lfs diff=lfs merge=lfs -text
*.xlsb filter=lfs diff=lfs merge=lfs -text
*.xlsm filter=lfs diff=lfs merge=lfs -text
*.xlsx filter=lfs diff=lfs merge=lfs -text
*.xlt filter=lfs diff=lfs merge=lfs -text
*.xltm filter=lfs diff=lfs merge=lfs -text
*.xltx filter=lfs diff=lfs merge=lfs -text
*.xm filter=lfs diff=lfs merge=lfs -text
*.xmind filter=lfs diff=lfs merge=lfs -text
*.xpi filter=lfs diff=lfs merge=lfs -text
*.xpm filter=lfs diff=lfs merge=lfs -text
*.xwd filter=lfs diff=lfs merge=lfs -text
*.xz filter=lfs diff=lfs merge=lfs -text
*.z filter=lfs diff=lfs merge=lfs -text
*.zip filter=lfs diff=lfs merge=lfs -text
*.zipx filter=lfs diff=lfs merge=lfs -text
#+end_src

* .xonshrc
:PROPERTIES:
:header-args:xonsh+: :noweb-ref .xonshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xonshrc>>
#+end_src

** imports

#+begin_src xonsh
import sys, os
from pathlib import Path
#+end_src

** environment

#+begin_src xonsh
$AUTO_CD = True
$AUTO_PUSHD = True
$AUTO_SUGGEST = True
$AUTO_SUGGEST_IN_COMPLETIONS = True
$BASH_COMPLETIONS += [ f"{Path.home()}/resources/bashCompletions" ]
$COMPLETION_IN_THREAD = True
$COMPLETIONS_CONFIRM = True
$DOTGLOB = True
$FUZZY_PATH_COMPLETION = True
$HISTCONTROL = { "ignoreboth", "erasedups", "ignoreerr" }
$MOUSE_SUPPORT = True
$PRETTY_PRINT_RESULTS = True
$PROMPT_TOOLKIT_COLOR_DEPTH = "DEPTH_24_BIT"
$SHELL_TYPE = "prompt_toolkit"
$UPDATE_COMPLETIONS_ON_KEYPRESS = True
$UPDATE_OS_ENVIRON = True
$VI_MODE = True
$XONSH_AUTOPAIR = True
$XONSH_CACHE_EVERYTHING = True
$XONSH_HISTORY_BACKEND = "sqlite"
$XONSH_STORE_STDOUT = True

# This enumerates all history files when set to true
$XONSH_DEBUG = False

$XONSH_SHOW_TRACEBACK = True

# Xonsh Prompt
$PROMPT_FIELDS["prompt_end"] = "Wheee! 😹 "
# $PROMPT = "{BOLD_#E5004D}{env_name} {BOLD_#FF4081}{prompt_end}"
# $PROMPT = lambda: $(starship prompt)
execx($(starship init xonsh))
$RIGHT_PROMPT = "{BOLD_#E5004D} {prompt_end}{BOLD_#FC9F71} || {BOLD_#E5004D} {user}@{hostname} "
# $BOTTOM_TOOLBAR = $RIGHT_PROMPT

# Path
sys.path.insert(0, "")
<<profile-paths(shell="xonsh")>>

# Shell
# $EDITOR = "emacsclient -c"
# $VISUAL = "emacsclient -c"

# Etc
$LESSOPEN = "| /usr/share/source-highlight/src-hilite-lesspipe.sh %s"
$LESS = " -R "
#+end_src

** functions

#+begin_src xonsh
def _mdg(args, stdin=None):
    mkdir -p @(args) && cd @(args[0])

def _direnv_allow(args, stdin=None):
    if args:
        for argument in args:
            direnv allow @(argument)
    else:
        direnv allow

def _get_fzfdf_output(*args):
    if args:
        return $(fd @((".", *args) if os.path.exists(args[0]) else args) | fzf-tmux).strip("\n")
    else:
        return $(fd | fzf-tmux).strip("\n")

def _cdi(args, stdin=None):
    cd @(_get_fzfdf_output(*args, "-t", "d"))

def _cdr(args, stdin=None):
    cd @($(zoxide query -l | fzf-tmux).strip("\n"))

def _cdf(args, stdin=None):
    cd @($(fasd -ld | fzf-tmux).strip("\n"))

def _rc(args, stdin=None):
    hist = $(history show @(args))
    command = $(echo @(hist) | fzf-tmux).strip("\n").split()
    if command:
        $(@(command))

def _run(args, stdin=None):
    args = list(args)
    args[0] = Path(args[0]).absolute()
    chmod +x @(args[0]) && @(args)

def _Run(args, stdin=None):
    curl --create-dirs -fsSLo @(args[1]) @(args[0])
    _run(args[1:])
#+end_src

** xontribs

#+begin_src xonsh
# xontrib load coreutils
# xontrib load docker_tabcomplete
# xontrib load schedule
# xontrib load ssh_agent
# xontrib load vox_tabcomplete

xontrib load abbrevs
xontrib load autoxsh
xontrib load bashisms
xontrib load direnv
xontrib load pipeliner
xontrib load readable-traceback
xontrib load sh
xontrib load vox
xontrib load whole_word_jumping

# Jedi was what was causing the python function completions
# instead of the path completions
# xontrib load jedi
#+end_src

** base

#+begin_src xonsh
execx($(zoxide init xonsh), 'exec', __xonsh__.ctx, filename='zoxide')

aliases["-"] = "pushd"
aliases[".."] = "cd .."
aliases["."] = "exa -la"
aliases["c"] = "clear"
aliases["cdf"] = _cdf
aliases["cdi"] = _cdi
aliases["cdr"] = _cdr
aliases["da"] = _direnv_allow
aliases["emd"] = "systemctl --user start emacs.service"
aliases["git"] = lambda args, stdin=None: $(hub @(args))
aliases["kemd"] = "systemctl --user stop emacs.service"
aliases["la"] = lambda args, stdin=None: $(exa -la --octal-permissions @(args))
aliases["md"] = lambda args, stdin=None: $(mkdir -p @(args))
aliases["mdg"] = _mdg
aliases["mosh"] = lambda args, stdin=None: $(mosh --experimental-remote-ip=remote @(args))
aliases["n"] = "exit"
aliases["rc"] = _rc
aliases["remd"] = "systemctl --user restart emacs.service"
aliases["Run"] = _Run
aliases["run"] = _run
aliases["s"] = "source ~/.xonshrc"
aliases["semd"] = "systemctl status emacs"
aliases["ssh"] = lambda args, stdin=None: $(assh wrapper ssh -- @(args))
aliases["ve"] = lambda args, stdin=None: $(vox enter @(args)) if args else $(vox exit)
aliases["vim"] = lambda args, stdin=None: $(emacsclient -c @(args))

# fasd aliases
aliases["o"] = lambda args, stdin=None: $(fasd -ae xdg-open @(args)) # quick opening files with xdg-open

# quick opening files with emacs
aliases["e"] = lambda args, stdin=None: $(fasd -fe 'emacsclient -c' @(args))
#+end_src

* .config
** nix
*** nix.conf

#+begin_src conf :tangle (meq/tangle-path)
<<270d5d30-951e-4171-8c23-67fc45d20578()>>
#+end_src

** borgmatic

#+name: borgmatic-ls
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "    one_file_system: false
    numeric_owner: false
    atime: true
    ctime: true
    birthtime: true
    read_special: true
    bsd_flags: true
    files_cache: ctime,size,inode
    local_path: borg
    remote_path: borg1
    exclude_caches: true
    exclude_nodump: true

storage:
    checkpoint_interval: 300
    compression: zstd,22
    ssh_command: assh wrapper ssh --
    archive_name_format: \"borgmatic-%r-{now:%%Y%%m%%dT%%H%%M%%S%%f}\"
    relocated_repo_access_is_ok: true
    unknown_unencrypted_repo_access_is_ok: true" `((?r . ,repo)))
#+end_src

#+name: borgmatic-rc
#+begin_src emacs-lisp :var repo=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec "retention:
    keep_within: 6H
    keep_secondly: 60
    keep_minutely: 60
    keep_hourly: 24
    keep_daily: 7
    keep_weekly: 4
    keep_monthly: 6
    keep_yearly: 4
    prefix: \"borgmatic-%r-\"

consistency:
    checks:
        - repository
        - data
        - extract
    prefix: \"borgmatic-%r-\"" `((?r . ,repo)))
#+end_src

*** sylvorg.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref sylvorg.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<sylvorg.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/sylvorg
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-sylvorg
<<borgmatic-ls(repo="sylvorg")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="sylvorg")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

*** oreo.yaml
:PROPERTIES:
:header-args:yaml+: :noweb-ref oreo.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<oreo.yaml>>
#+end_src

#+begin_src yaml
location:
    source_directories:
        - ~/oreo
    repositories:
        - 9237@usw-s009.rsync.net:/data1/home/9237/{fqdn}-oreo
<<borgmatic-ls(repo="oreo")>>

    # Additional options to pass directly to particular Borg
    # commands, handy for Borg options that borgmatic does not yet
    # support natively. Note that borgmatic does not perform any
    # validation on these options. Running borgmatic with
    # "--verbosity 2" shows the exact Borg command-line
    # invocation.
    # extra_borg_options:
        # Extra command-line options to pass to "borg init".
        # init: --make-parent-dirs

        # Extra command-line options to pass to "borg prune".
        # prune: --save-space

        # Extra command-line options to pass to "borg create".
        # create: --no-files-cache

        # Extra command-line options to pass to "borg check".
        # check: --save-space

<<borgmatic-rc(repo="oreo")>>

# Shell commands, scripts, or integrations to execute at various
# points during a borgmatic run. IMPORTANT: All provided commands and
# scripts are executed with user permissions of borgmatic. Do not
# forget to set secure permissions on this configuration file (chmod
# 0600) as well as on any script called from a hook (chmod 0700) to
# prevent potential shell injection or privilege escalation.
# hooks:
    # List of one or more shell commands or scripts to execute
    # before creating a backup, run once per configuration file.
    # before_backup:
        # - echo "Starting a backup."

    # List of one or more shell commands or scripts to execute
    # before pruning, run once per configuration file.
    # before_prune:
        # - echo "Starting pruning."

    # List of one or more shell commands or scripts to execute
    # before consistency checks, run once per configuration file.
    # before_check:
        # - echo "Starting checks."

    # List of one or more shell commands or scripts to execute
    # before extracting a backup, run once per configuration file.
    # before_extract:
        # - echo "Starting extracting."

    # List of one or more shell commands or scripts to execute
    # after creating a backup, run once per configuration file.
    # after_backup:
        # - echo "Finished a backup."

    # List of one or more shell commands or scripts to execute
    # after pruning, run once per configuration file.
    # after_prune:
        # - echo "Finished pruning."

    # List of one or more shell commands or scripts to execute
    # after consistency checks, run once per configuration file.
    # after_check:
        # - echo "Finished checks."

    # List of one or more shell commands or scripts to execute
    # after extracting a backup, run once per configuration file.
    # after_extract:
        # - echo "Finished extracting."

    # List of one or more shell commands or scripts to execute
    # when an exception occurs during a "prune", "create", or
    # "check" action or an associated before/after hook.
    # on_error:
        # - echo "Error during prune/create/check."

    # List of one or more shell commands or scripts to execute
    # before running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once before all of them (prior to all actions).
    # before_everything:
        # - echo "Starting actions."

    # List of one or more shell commands or scripts to execute
    # after running all actions (if one of them is "create").
    # These are collected from all configuration files and then
    # run once after all of them (after any action).
    # after_everything:
        # - echo "Completed actions."

    # Healthchecks ping URL or UUID to notify when a backup
    # begins, ends, or errors. Create an account at
    # https://healthchecks.io if you'd like to use this service.
    # See borgmatic monitoring documentation for details.
    healthchecks: https://hc-ping.com/adb8d488-812a-4edd-b262-6068556264ab

    # Umask used when executing hooks. Defaults to the umask that
    # borgmatic is run with.
    # umask: 0077
#+end_src

** systemd
*** user
**** emacs.service
:PROPERTIES:
:header-args:systemd+: :noweb-ref emacs.service
:END:

#+begin_src text :tangle (meq/tangle-path)
<<emacs.service>>
#+end_src

#+begin_src
[Unit]
Description=Emacs text editor
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=/usr/bin/emacs --bg-daemon=damascus --update
ExecStop=/usr/bin/emacsclient -s damascus -e "(kill-emacs)"
Environment=SSH_AUTH_SOCK=%t/keyring/ssh
Restart=on-failure
TimeoutSec=900

[Install]
WantedBy=default.target
#+end_src

** yadm
*** bootstrap
:PROPERTIES:
:header-args:zsh+: :noweb-ref 879a83d3-17ad-446f-8ad2-9945ac588f07
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#! /usr/bin/env nix-shell"
<<879a83d3-17ad-446f-8ad2-9945ac588f07>>
#+end_src

#+begin_src zsh
#! nix-shell -i sh -p hello
#! nix-shell -I nixpkgs=https://github.com/shadowrylander/nixpkgs/archive/j.tar.gz
#+end_src

*** config

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

** yadm-sec
*** config

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

** direnv
*** .direnvrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src zsh
use_flake() {
    watch_file flake.nix
    watch_file flake.lock
    eval "$(nix print-dev-env --profile "$(direnv_layout_dir)/flake-profile")"
}
#+end_src

** kitty
*** kitty.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref kitty.conf
:END:

#+begin_src text :tangle (meq/tangle-path)
<<kitty.conf>>
#+end_src

#+begin_src conf
include ~/resources/kittyThemes/themes/Monokai_Pro_(Filter_Ristretto).conf
#+end_src

** ion
*** initrc
:PROPERTIES:
:header-args:ion+: :noweb-ref initrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<initrc>>
#+end_src

#+begin_src ion
eval $(starship init ion)
#+end_src

** git
*** config
:PROPERTIES:
:header-args:conf+: :noweb-ref ee416303-b507-49b2-9e6b-8dc71a97c171
:END:

#+name: c635d49e-5f0e-4245-bc91-81e9f8de0a12
#+begin_src text :tangle (meq/tangle-path)
<<ee416303-b507-49b2-9e6b-8dc71a97c171>>
#+end_src

#+begin_src conf
[core]
    excludesfile = ~/.globalignore
    attributesfile = ~/.gitattributes
    fileMode = false
    hookPath = ~/.config/git/hooks

[user]
    email = jeet.ray@syvl.org
    name = Jeet Ray

[alias]
    cnm = commit --allow-empty-message -am ""
    chRun = !chmod +x $1 &&
    sec = !git chRun ~/.config/git/scripts/sec

[protocol "keybase"]
	allow = always

[protocol "restic"]
	allow = always
#+end_src

*** scripts
**** sec
:PROPERTIES:
:header-args:shell+: :noweb-ref sec
:END:

#+begin_src text :tangle (meq/tangle-path) :shebang "#!/usr/bin/env sh"
<<sec>>
#+end_src

#+begin_src shell
command="yadm --yadm-data \"$HOME/.local/share/yadm-sec\""
if [ "$(yadm status 2>&1)" == "ERROR: Git repo does not exist. did you forget to run 'init' or 'clone'?" ]; then
    $command $@
else
    $command --yadm-dir "$HOME/.config/yadm-sec" $@
fi
#+end_src

** powershell
*** Microsoft.PowerShell_profile.ps1
:PROPERTIES:
:header-args:powershell+: :noweb-ref Microsoft.PowerShell_profile.ps1
:END:

#+begin_src text :tangle (meq/tangle-path)
<<Microsoft.PowerShell_profile.ps1>>
#+end_src

#+begin_src powershell
# For zoxide v0.8.0+
Invoke-Expression (& {
    $hook = if ($PSVersionTable.PSVersion.Major -lt 6) { 'prompt' } else { 'pwd' }
    (zoxide init --hook $hook powershell | Out-String)
})
Invoke-Expression (&starship init powershell)
#+end_src

** fish
*** config.fish
:PROPERTIES:
:header-args:fish+: :noweb-ref config.fish
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.fish>>
#+end_src

#+begin_src fish
source ~/resources/nix-env.fish/conf.d/nix-env.fish
cd ~/resources/bass
make install &>/dev/null
cd -
<<20211028011434584909200>>
<<profile-paths(shell="fish")>>
alias s=source ~/.config/fish/config.fish
direnv hook fish | source
zoxide init fish | source
starship init fish | source
#+end_src

** qtile
*** config.py
:PROPERTIES:
:header-args:python+: :noweb-ref config.py
:END:

#+begin_src text :tangle (meq/tangle-path)
<<config.py>>
#+end_src

This config is taken from [[http://gegenokitaro.github.io/tuts/2015/05/14/qtile-ricchan/][here]]:

#+begin_src python
# Copyright (c) 2010 Aldo Cortesi
# Copyright (c) 2010, 2014 dequis
# Copyright (c) 2012 Randall Ma
# Copyright (c) 2012-2014 Tycho Andersen
# Copyright (c) 2012 Craig Barnes
# Copyright (c) 2013 horsik
# Copyright (c) 2013 Tao Sauvage
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from libqtile.config import Key, Screen, Group, Drag, Click, Match
from libqtile.command import lazy
from libqtile import layout, bar, widget
from libqtile.dgroups import simple_key_binder

mod = "mod4"

keys = [
    # Switch between windows in current stack pane
    Key(
        [mod], "j",
        lazy.layout.down()
    ),
    Key(
        [mod], "k",
        lazy.layout.up()
    ),

    # Move windows up or down in current stack
    Key(
        [mod, "control"], "j",
        lazy.layout.shuffle_down()
    ),
    Key(
        [mod, "control"], "k",
        lazy.layout.shuffle_up()
    ),

    # Switch window focus to other pane(s) of stack
    Key(
        [mod], "space",
        lazy.layout.next()
    ),

    Key(
        [mod], "Left",
        lazy.screen.prevgroup()
    ),

    Key(
        [mod], "Right",
        lazy.screen.nextgroup()
    ),

    # Swap panes of split stack
    Key(
        [mod, "shift"], "space",
        lazy.layout.rotate()
    ),

    # Toggle between split and unsplit sides of stack.
    # Split = all windows displayed
    # Unsplit = 1 window displayed, like Max layout, but still with
    # multiple stack panes
    Key(
        [mod, "shift"], "Return",
        lazy.layout.toggle_split()
    ),
    Key([mod], "Return", lazy.spawn("urxvt")),

    # Toggle between different layouts as defined below
    Key([mod], "Tab", lazy.nextlayout()),
    Key([mod], "w", lazy.window.kill()),

    Key([mod, "control"], "r", lazy.restart()),
    Key([mod, "control"], "q", lazy.shutdown()),
    Key([mod], "r", lazy.spawncmd()),
]

groups = [
    Group(" urxvt "),
    Group(" web ", matches=[Match(wm_class=["Firefox"])]),
    Group(" blender "),
    Group(" inkscape "),
    Group(" gimp "),
    Group(" doc "),
]

dgroups_key_binder = simple_key_binder("mod4")


layouts = [
    layout.TreeTab(
            font='Cartograph CF Light Italic',
            name="tree tab",
            bg_color="#222222",
            inactive_bg="#AB5DEE",
            panel_width=150,
            margin_left=0,
            margin_y=0,
            sections=['TreeTab'],
            section_left=0,
            padding_x=4,
            active_bg="#FFB86C",
            rounded=False,
        ),
    layout.MonadTall(
            name="xmonad tall",
            ratio=0.5,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Stack(
            num_stacks=2,
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        ),
    layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#335260",
            border_normal="#69B2B8",
        )
]

floating_layout = layout.Floating(
            name="floating",
            border_width=8,
            border_focus="#69B2B8",
            border_normal="#335260",
        )

widget_defaults = dict(
    font='Cartograph CF Light Italic',
    fontsize=12,
    background="#222222",
    markup=True,
)

screens = [
    Screen(
        bottom=bar.Bar(
            [
                widget.GroupBox(
                        borderwidth=0,
                        margin=0,
                        padding=6,
                        active="FFFFFF",
                        inactive="FFB86C",
                        highlight_method="block",
                        this_current_screen_border="#AB5DEE",
                        invert_mouse_wheel=True,
                        rounded=False,
                    ),
                widget.Prompt(),
                widget.CurrentLayout(
                        background="#E11B22",
                    ),
                widget.Spacer(),
                #widget.WindowName(),
                widget.TextBox("testing", name="default"),
                widget.Systray(),
                widget.Clock(format=' %I:%M %p '),
            ],
            24,
            background="#335260",
        ),
    ),
]

# Drag floating layouts.
mouse = [
    Drag([mod], "Button1", lazy.window.set_position_floating(),
        start=lazy.window.get_position()),
    Drag([mod], "Button3", lazy.window.set_size_floating(),
        start=lazy.window.get_size()),
    Click([mod], "Button2", lazy.window.bring_to_front())
]

dgroups_app_rules = []
main = None
follow_mouse_focus = True
bring_front_click = False
cursor_warp = False
auto_fullscreen = True

# XXX: Gasp! We're lying here. In fact, nobody really uses or cares about this
# string besides java UI toolkits; you can see several discussions on the
# mailing lists, github issues, and other WM documentation that suggest setting
# this string if your java app doesn't work correctly. We may as well just lie
# and say that we're a working one by default.
#
# We choose LG3D to maximize irony: it is a 3D non-reparenting WM written in
# java that happens to be on java's whitelist.
wmname = "LG3D"
#+end_src

* .SpaceVim.d
** init.toml
:PROPERTIES:
:header-args:conf+: :noweb-ref init.toml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<init.toml>>
#+end_src

#+begin_src conf
#=============================================================================
# dark_powered.toml --- dark powered configuration example for SpaceVim
# Copyright (c) 2016-2020 Wang Shidong & Contributors
# Author: Wang Shidong < wsdjeg at 163.com >
# URL: https://spacevim.org
# License: GPLv3
#=============================================================================

# All SpaceVim option below [option] section
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    colorscheme = "gruvbox"
    colorscheme_bg = "dark"
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = "arrow"
    statusline_iseparator = "arrow"
    buffer_index_type = 4
    enable_tabline_filetype_icon = true
    enable_statusline_mode = false
    bootstrap_before = 'vimrc#before'
    bootstrap_after = 'vimrc#after'
    escape_key_binding = ""
#+end_src

*** layers

#+begin_src conf
# Enable autocomplete layer
[[layers]]
name = 'autocomplete'
auto_completion_return_key_behavior = "complete"
auto_completion_tab_key_behavior = "smart"

[[layers]]
name = 'shell'
default_position = 'top'
default_height = 30

[[layers]]
name = "lang#nix"
#+end_src

*** plugins

#+begin_src conf
[[custom_plugins]]
    repo = "tssm/fairyfloss.vim"
    merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/mountaineer.vim"
#     merged = true

# [[custom_plugins]]
#     repo = "co1ncidence/gunmetal.vim"
#     merged = true

[[custom_plugins]]
    repo = "megantiu/true.vim"
    merged = true

# From:
# Answer: https://vi.stackexchange.com/questions/678/how-do-i-save-a-file-in-a-directory-that-does-not-yet-exist/679#679
# User: https://vi.stackexchange.com/users/51/martin-tournoij
[[custom_plugins]]
    repo = "arp242/auto_mkdir2.vim"
    merged = true

[[custom_plugins]]
    repo = "tpope/vim-eunuch"
    merged = true

# [[custom_plugins]]
#     repo = "johannesthyssen/vim-signit"
#     merged = true

[[custom_plugins]]
    repo = "jupyter-vim/jupyter-vim"
    merged = true

[[custom_plugins]]
    repo = "haya14busa/dein-command.vim"
    merged = true

[[custom_plugins]]
    repo = "andrep/vimacs"
    merged = true

[[custom_plugins]]
    repo = "shougo/denite.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/defx.nvim"
    merged = true

[[custom_plugins]]
    repo = "shougo/deoplete.nvim"
    merged = true
#+end_src

** autoload
*** vimrc.vim

#+begin_src vimrc :tangle (meq/tangle-path)
function! vimrc#before() abort
endfunction

function! vimrc#after() abort
    syntax on
    filetype plugin indent on

    " enable 24bit true color
    if (has("termguicolors"))
    set termguicolors
    endif

    " enable the theme
    syntax enable
    colorscheme fairyfloss

    let g:true_airline = 1
    let g:airline_theme='true'

    " for kitty
    let &t_ut=""

    " disables border on left side
    set foldcolumn=0

    " Spaces & Tabs
    set tabstop=4       " number of visual spaces per TAB
    set softtabstop=4   " number of spaces in tab when editing
    set shiftwidth=4    " number of spaces to use for autoindent
    set expandtab       " tabs are space
    set autoindent
    set copyindent      " copy indent from the previous line

    " set number relativenumber

    " Insert Toggle
    imap ;; <ESC>
    map ;; i <BACKSPACE>

    " Change two spaces to four
    map \\ :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>
    imap \\ <ESC> :set ts=2 sts=2 noet <bar> :retab! <bar> :set ts=4 sts=4 et <bar> :retab <CR>

    " Change movement keys to <space>wasd
    noremap <Space-a> h
    noremap <Space-s> j
    noremap <Space-w> k
    noremap <Space-d> l

    " Set Paste
    command SMP :set paste <CR>

    " Set NoPaste
    command SNP :set nopaste <CR>

    " Tab to insert
    map <TAB> i <TAB>

    " Vim Signit
    let g:signit_initials = "JR"
    let g:signit_name = "Jeet Ray"
    " let g:signit_extra_1
    " let g:signit_extra_2
    " let g:signit_position
    let g:signit_ascii_font = "isometric1.flf"
    " let g:signit_ascii_spacing

    if has('nvim')
        call dein#add('iron-e/nvim-libmodal')
        call dein#add('shougo/deol.nvim')
        call dein#add('shougo/deoppet.nvim')
        call dein#add('shougo/deorise.nvim')
    else
        call dein#add('iron-e/vim-libmodal')
        call dein#add('roxma/nvim-yarp')
        call dein#add('roxma/vim-hug-neovim-rpc')
    endif

    let g:deoplete#enable_at_startup = 1
endfunction
#+end_src

* .byobu
** .tmux.conf

#+begin_src conf :tangle (meq/tangle-path)
<<20211018140524183223400>>
#+end_src

* .tmux.conf
:PROPERTIES:
:header-args:conf+: :noweb-ref .tmux.conf
:END:

#+call: hash() :exports none

#+RESULTS:
: 20211018140524183223400

#+name: 20211018140524183223400
#+begin_src text :tangle (meq/tangle-path)
<<20210601214303404504400()>>
<<.tmux.conf>>
#+end_src

** aleclearmind active-row replacement

#+call: hash() :exports none

#+RESULTS:
: 20210601214303404504400

#+name: 20210601214303404504400
#+begin_src emacs-lisp :noweb-ref no
(replace-regexp-in-string
    "set -g prefix C-a"
    "set -g prefix C-Space"
    (replace-regexp-in-string
        "unbind C-b"
        "# unbind C-b"
        (let ((file "./resources/aleclearmind/active-row.conf"))
            (if (file-directory-p file)
                (insert-file-contents file)
                ""))))
#+end_src

** powerline

#+begin_src conf
# source ./resources/powerline/powerline/bindings/tmux/powerline-base.conf
source ./resources/powerline/powerline/bindings/tmux/powerline.conf
# source ./resources/powerline/powerline/bindings/tmux/powerline_tmux_2.1_plus.conf
#+end_src

** oh-my-tmux

#+begin_src conf
source ./resources/oh-my-tmux/.tmux.conf
source ./resources/oh-my-tmux/.tmux.conf.local
#+end_src

** keybindings

From: https://man7.org/linux/man-pages/man1/tmux.1.html#KEY_BINDINGS

*** unbindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214314440746200

#+name: 20210601214314440746200
#+begin_src text :noweb-ref no
C-b
C-x
C-z
#+end_src

#+begin_src conf
unbind <<20210601214314440746200>>
#+end_src

*** bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214317258641300

#+name: 20210601214317258641300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key <<20210601214317258641300>>
#+end_src

*** root bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214320148298300

#+name: 20210601214320148298300
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -n <<20210601214320148298300>>
#+end_src

*** root repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214322950137300

#+name: 20210601214322950137300
#+begin_src text :noweb-ref no
M-s send-prefix
C-S-F5 send-keys M-F5
C-S-Left send-keys M-Left
C-S-Right send-keys M-Right
#+end_src

#+begin_src conf
bind-key -nr <<20210601214322950137300>>
#+end_src

*** repeting bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214325764323500

#+name: 20210601214325764323500
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -r <<20210601214325764323500>>
#+end_src

*** prefix table bindings

#+call: hash() :exports none

#+RESULTS:
: 20210601214331744518200

#+name: 20210601214331744518200
#+begin_src text :noweb-ref no
#+end_src

#+begin_src conf
bind-key -T prefix <<20210601214331744518200>>
#+end_src

** base

#+begin_src conf
set -g prefix2 S-Space

# Mouse support - set to on if you want to use the mouse
# setw -g mode-mouse on
# set -g mouse-select-pane on
# set -g mouse-resize-pane on
# set -g mouse-select-window on

# enable activity alerts
setw -g monitor-activity off
set -g visual-activity off

# Center the window list
set -g status-justify centre

# VI Mode
set -g status-keys vi

# utf8 is on
# set -g utf8 on
# set -g status-utf8 on

run-shell "powerline-daemon -q"

set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Spacemacs Settings:
set -gs escape-time 10

# address vim mode switching delay (http://superuser.com/a/252717/65504)
set -s escape-time 0

# increase scrollback buffer size
set -g history-limit 50000

# tmux messages are displayed for 1.25 seconds
set -g display-time 1250

# refresh 'status-left' and 'status-right' more often
# set -g status-interval 1

# focus events enabled for terminals that support them
set -g focus-events on

# border thickness
set-option -g pane-active-border-style "bg=default"
set-option -ag pane-active-border-style "fg=colour208"
set -g status-right '#{prefix_highlight} | %a %Y-%m-%d %H:%M'

# Adapted From: https://www.reddit.com/r/tmux/comments/einuqy/make_tmux_modal/
set-option -g prefix None
bind-key -n C-Space {
  set-option key-table prefix
  set-option status-bg yellow
}
bind-key -T prefix C-Space {
  set-option key-table root
  set-option status-bg green
}

setw -g aggressive-resize on
#+end_src

** plugins

#+call: hash() :exports none

#+RESULTS:
: 20210601214334528396400

#+name: 20210601214334528396400
#+begin_src text :noweb-ref no
tmux-plugins/tpm
tmux-plugins/tmux-battery
tmux-plugins/tmux-cpu
tmux-plugins/tmux-fpp
tmux-plugins/tmux-logging
tmux-plugins/tmux-online-status
tmux-plugins/tmux-open
tmux-plugins/tmux-pain-control
tmux-plugins/tmux-prefix-highlight
tmux-plugins/tmux-sessionist
tmux-plugins/tmux-sidebar
tmux-plugins/vim-tmux-focus-events
tmux-plugins/tmux-yank
tmux-plugins/tmux-continuum
tmux-plugins/tmux-resurrect
christoomey/vim-tmux-navigator
sainnhe/tmux-fzf
samoshkin/tmux-plugin-sysstat
wfxr/tmux-fzf-url
schasse/tmux-jump
eraserhd/tmux-ctrlw
jlipps/tmux-safekill
fcsonline/tmux-thumbs
addisonlynch/tmux-sidebar-plus
#+end_src

#+begin_src conf
set -g @plugin <<20210601214334528396400>>
set -g @continuum-boot 'on'
set -g @continuum-save-interval '10'
set -g @continuum-restore 'on'
set -g @resurrect-save-bash-history 'on'
set -g @resurrect-dir '~/.byobu/tmux_resurrect'
set -g @resurrect-processes '"mc --nocolor" "tail -f" bat docker elvish emacs fish glances gotop htop ipython irssi jupyter-lab jupyter-notebook less man more mosh mutt nvim ssh syncthing tail top vi vim weechat wtf xonsh xsh zsh'
set -g @resurrect-capture-pane-contents 'on'
set -g @resurrect-strategy-vim 'session'
set -g @resurrect-strategy-nvim 'session'
run "./resources/tpm/tpm"
#+end_src

* .tmuxp
** default.yaml
:PROPERTIES:
:header-args:conf+: :noweb-ref default.yaml
:END:

#+begin_src text :tangle (meq/tangle-path)
<<default.yaml>>
#+end_src

#+begin_src conf
session_name: default
#+end_src

* .profile
:PROPERTIES:
:header-args:shell+: :noweb-ref .profile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.profile>>
#+end_src

#+name: profile-sources
#+begin_src shell
source $HOME/.nix-profile/etc/profile.d/nix.sh
eval "$(fasd --init auto)"
#+end_src

#+name: cd-home-and-profile-aliases
#+begin_src shell
# Adapted From:
# Answer: https://askubuntu.com/a/146034/1058868
# User: https://askubuntu.com/users/1059/gilles-so-stop-being-evil
alias -- -="pushd"

alias ..="cd .."
alias .="exa -la --octal-permissions"
alias c="clear"
alias cdf='cdf'
alias cdi='cdi'
alias cdr='cdr'
alias da='direnvAllow'
alias emd="systemctl --user start emacs.service"
alias git="hub"
alias kemd="systemctl --user stop emacs.service"
alias la='exa -la --octal-permissions'
alias md="mkdir -p"
alias mdg='mdg'
alias mosh="mosh --experimental-remote-ip=remote"
alias n="exit"
alias rc="rc"
alias remd="systemctl --user restart emacs.service"
alias Run="Run"
alias run="run"
alias semd="systemctl status emacs"
alias ssh="assh wrapper ssh --"
alias vi="emacsclient -c"
alias vim="emacsclient -c"

# fasd
alias o="fasd -ae xdg-open"

# quick opening files with emacs
alias e="fasd -fe 'emacsclient -t'"
#+end_src

#+name: profile-functions
#+begin_src shell
cdf () { cd $(fasd -ld | fzf-tmux); }
cdi () { cd $(getFzfdfOutput "$@" "-t" "d"); }
cdr () { cd $(zoxide query -l | fzf-tmux); }
direnvAllow () {
    if [ -z "$1" ]; then
        direnv allow
    else
        for d in "$@"; do
            direnv allow "$d"
        done
    fi
}
getFzfdfOutput () {
    if [ -z "$1" ]; then
        echo $(fd | fzf-tmux)
    else
        if [ -d "$1" ]; then
            echo $(fd "." "$@" | fzf-tmux)
        else
            echo $(fd "$@" | fzf-tmux)
        fi
    fi
}
mdg () { mkdir -p "$@" && cd "$1"; }

Run () { curl --create-dirs -fsSLo "$2" "$1" && shift && run "$@"; }
run () { chmod +x "$1" && "$@"; }
#+end_src

#+name: profile-exports
#+begin_src shell
# export EDITOR='emacsclient -c'
# export VISUAL='emacsclient -c'
export HISTCONTROL='ignoreboth:erasedups'
export LESSOPEN='| /usr/share/source-highlight/src-hilite-lesspipe.sh %s'
export LESS=' -R '
#+end_src

#+name: profile-paths
#+begin_src emacs-lisp :noweb-ref no :var shell=""
(let* ((path '("$HOME/.local/bin"
            "$HOME/.nimble/bin"
            "/home/linuxbrew/.linuxbrew/bin"
            "/home/linuxbrew/.linuxbrew/sbin"
            "$HOME/.nix-profile/bin"
            "$HOME/.guix-profile/bin"
            "$HOME/go/bin"
            "/usr/local/sbin"
            "/usr/local/bin"
            "/usr/sbin"
            "/usr/bin"
            "/sbin"
            "/bin"
            "/usr/games"
            "/usr/local/games"
            "/snap/bin"
            "/usr/local/go/bin"
            "/usr/lib/node_modules")))
    (pcase shell
        ("fish" (concat "set -gx PATH $PATH" (string-join path " ")))
        ("xonsh" (concat "$PATH += [ \"" (string-join path "\",\n\t\"") "\" ]"))
        (t (concat "export PATH=\"$PATH:" (string-join path ":") "\""))))
#+end_src

#+name: profile-all-together
#+begin_src text
<<profile-sources>>
<<profile-functions>>
<<profile-exports>>
<<cd-home-and-profile-aliases>>
<<profile-paths()>>
#+end_src

#+begin_src shell
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

alias s="source $HOME/.profile"
#+end_src

* .bashrc
:PROPERTIES:
:header-args:bash+: :noweb-ref .bashrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.bashrc>>
#+end_src

#+call: hash() :exports none

#+RESULTS:
: 20211027212836251792500

#+name: 20211027212836251792500
#+begin_src bash
# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.bashrc"
eval "$(direnv hook bash)"
eval "$(zoxide init bash)"
eval "$(starship init bash)"
set -o vi
#+end_src

* .elvish
** lib
*** direnv.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref direnv.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<direnv.elv>>
#+end_src

#+begin_src elvish
direnv hook elvish
#+end_src

* rc.elv
:PROPERTIES:
:header-args:elvish+: :noweb-ref rc.elv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<rc.elv>>
#+end_src

#+begin_src elvish
# use epm
# epm:install github.com/tylerreckart/gondolin
# use github.com/tylerreckart/gondolin/gondolin
use direnv
eval (zoxide init elvish | slurp)
eval (starship init elvish)
#+end_src

* .xinitrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .xinitrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.xinitrc>>
#+end_src

#+begin_src shell
# exec emacs
exec emacsclient -a "" -c
#+end_src

* .direnvrc
:PROPERTIES:
:header-args:shell+: :noweb-ref .direnvrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.direnvrc>>
#+end_src

#+begin_src shell
source ~/resources/nix-direnv/direnvrc
source ~/.config/direnv/direnvrc

if [[ -f /run/current-system/sw/share/nix-direnv/direnvrc ]]; then
    source /run/current-system/sw/share/nix-direnv/direnvrc
fi
#+end_src

* .globalignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .globalignore
:END:

#+call: hash() :exports none

#+RESULTS:
: 20210601185925524999600

#+name: 20210601185925524999600
#+begin_src text :tangle (meq/tangle-path)
<<.globalignore>>
#+end_src

#+begin_src gitignore
_gsdata_
.boar
.git
.hg
**/__pycache__
**/_build
**/.vscode
**/*.!sync
**/*.bts
**/*.envrc
**/*.swp
**/*.sync
**/*.test.*
**/*.tmp
**/deprecated
**/dist
**/result
**/tests
**/unfinished
temp
#+end_src

* .gitconfig

#+begin_src conf :tangle (meq/tangle-path)
<<c635d49e-5f0e-4245-bc91-81e9f8de0a12>>
#+end_src

* .gitignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .gitignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.gitignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .hgignore
:PROPERTIES:
:header-args:gitignore+: :noweb-ref .hgignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.hgignore>>
#+end_src

#+begin_src gitignore
<<20210601185925524999600>>
#+end_src

* .zshrc
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshrc
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshrc>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshrc

# Adapted From:
# Comment: https://stackoverflow.com/questions/7110119/bash-history-without-line-numbers#comment8517296_7110197
# User: https://stackoverflow.com/users/827263/keith-thompson
rc () { eval $(history 0 | sed 's/^ *[0-9]* *//' | fzf-tmux); }

<<profile-all-together>>
alias s="source ~/.zshrc"
eval "$(direnv hook zsh)"
eval "$(zoxide init zsh)"
prompt off
eval "$(starship init zsh)"

bindkey -v

# From: https://leetschau.github.io/remove-duplicate-zsh-history.html
setopt EXTENDED_HISTORY
setopt HIST_EXPIRE_DUPS_FIRST
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_IGNORE_SPACE
setopt HIST_FIND_NO_DUPS
setopt HIST_SAVE_NO_DUPS

source ~/resources/zsh-autosuggestions/zsh-autosuggestions.zsh
# source ~/resources/zsh-autocomplete/zsh-autocomplete.plugin.zsh

# Adapted From: https://github.com/zsh-users/zsh-history-substring-search#usage
source ~/resources/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
source ~/resources/zsh-history-substring-search/zsh-history-substring-search.zsh
#+end_src

* .zshenv
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zshenv
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zshenv>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zshenv
skip_global_compinit=1
#+end_src

* .zprofile
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zprofile
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zprofile>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zprofile
#+end_src

* .zlogout
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogout
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogout>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogout
eval "$(direnv hook zsh)"
#+end_src

* .zlogin
:PROPERTIES:
:header-args:zsh+: :noweb-ref .zlogin
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.zlogin>>
#+end_src

#+begin_src zsh
source ~/resources/grml/etc/zsh/zlogin
eval "$(direnv hook zsh)"
#+end_src

* .stow-global-ignore
:PROPERTIES:
:header-args:conf+: :noweb-ref .stow-global-ignore
:END:

#+begin_src text :tangle (meq/tangle-path)
<<.stow-global-ignore>>
#+end_src

#+begin_src conf
\.git
#+end_src

* .termux
** termux.properties
:PROPERTIES:
:header-args:conf+: :noweb-ref termux.properties
:END:

#+begin_src text :tangle (meq/tangle-path)
<<termux.properties>>
#+end_src

#+begin_src conf
### After making changes and saving you need to run `termux-reload-settings`
### to update the terminal.  All information here can also be found on the
### wiki: https://wiki.termux.com/wiki/Terminal_Settings

###############
# Extra keys
###############

### Settings for choosing which set of symbols to use for illustrating keys.
### Choose between default, arrows-only, arrows-all, all and none
# extra-keys-style = default

### Default extra-key configuration
# extra-keys = [[ESC, TAB, CTRL, ALT, {key: '-', popup: '|'}, DOWN, UP]]

### Two rows with more keys
# extra-keys = [['ESC','/','-','HOME','UP','END','PGUP'], \
#               ['TAB','CTRL','ALT','LEFT','DOWN','RIGHT','PGDN']]

### Configuration with additional popup keys (swipe up from an extra key)
# extra-keys = [[ \
#   {key: ESC, popup: {macro: "CTRL f d", display: "tmux exit"}}, \
#   {key: CTRL, popup: {macro: "CTRL f BKSP", display: "tmux ←"}}, \
#   {key: ALT, popup: {macro: "CTRL f TAB", display: "tmux →"}}, \
#   {key: TAB, popup: {macro: "ALT a", display: A-a}}, \
#   {key: LEFT, popup: HOME}, \
#   {key: DOWN, popup: PGDN}, \
#   {key: UP, popup: PGUP}, \
#   {key: RIGHT, popup: END}, \
#   {macro: "ALT j", display: A-j, popup: {macro: "ALT g", display: A-g}}, \
#   {key: KEYBOARD, popup: {macro: "CTRL d", display: exit}} \
# ]]

###############
# Colors/themes
###############

### Force black colors for drawer and dialogs
# use-black-ui = true

###############
# Keyboard shortcuts
###############

### Open a new terminal with ctrl + t (volume down + t)
# shortcut.create-session = ctrl + t

### Go one session down with (for example) ctrl + 2
# shortcut.next-session = ctrl + 2

### Go one session up with (for example) ctrl + 1
# shortcut.previous-session = ctrl + 1

### Rename a session with (for example) ctrl + n
# shortcut.rename-session = ctrl + n

###############
# Bell key
###############

### Vibrate device (default).
# bell-character = vibrate

### Beep with a sound.
# bell-character = beep

### Ignore bell character.
# bell-character = ignore

###############
# Back key
###############

### Send the Escape key.
# back-key=escape

### Hide keyboard or leave app (default).
# back-key=back

###############
# Keyboard issue workarounds
###############

### Letters might not appear until enter is pressed on Samsung devices
# enforce-char-based-input = true

### ctrl+space (for marking text in emacs) does not work on some devices
# ctrl-space-workaround = true

allow-external-apps = true
#+end_src