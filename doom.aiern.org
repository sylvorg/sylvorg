#+setupfile: ./README.org
#+include: ./README.org

This can be used with =GNU Stow= as well! :D

The tangle functions are adapted from [[https://emacs.stackexchange.com/a/29884/31428][this answer on the emacs Stack Exchange]],
which was written by [[https://emacs.stackexchange.com/users/2710/andrew-swann][Andrew Swann]].

* home
** .doom.d
*** makefile

#+call: hash("github")

#+RESULTS:
: 13efb36a9b3eacd11a9f3b4b7385f96b

#+name: 13efb36a9b3eacd11a9f3b4b7385f96b
#+begin_src text
<<username>>/emacs-bankruptcy ~/<<username>>/home/.doom.d/emacs-bankruptcy
chenyanming/spacemacs_module_for_doom ~/<<username>>/home/.doom.d/modules/private/spacemacs
#+end_src

#+call: hash("gitlab")

#+RESULTS:
: 99d6a6f01dc482dc4142659f4b7a250a

#+name: 99d6a6f01dc482dc4142659f4b7a250a
#+begin_src text
picotech/use-package-hydra ~/<<username>>/home/.doom.d/use-package-hydra
picotech/use-package-hydra-plus ~/<<username>>/home/.doom.d/use-package-hydra-plus
<<username>>/use-package-hercules ~/<<username>>/home/.doom.d/use-package-hercules
#+end_src

#+call: hash("")

#+RESULTS:
: dd1688f9a6d0de76df5c19584fff233c

#+name: dd1688f9a6d0de76df5c19584fff233c
#+begin_src makefile :tangle (jr/tangle-path)
.RECIPEPREFIX := |

init:
|-git clone --recurse-submodule https://github.com/<<13efb36a9b3eacd11a9f3b4b7385f96b>>
|-git clone --recurse-submodule https://gitlab.com/<<99d6a6f01dc482dc4142659f4b7a250a>>
.DEFAULT_GOAL := init
#+end_src

*** init.el

#+call: hash("")

#+RESULTS:
: 773fad046a07f82864e6bab4be9aeb4a

#+name: 773fad046a07f82864e6bab4be9aeb4a
#+begin_src emacs-lisp :tangle (jr/tangle-path)
;;; init.el -*- lexical-binding: t; -*-

(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       company           ; the ultimate code completion backend
       helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy +fuzzy)               ; a search engine for love and life

       :ui
       deft              ; notational velocity for Emacs
       doom              ; what makes DOOM look the way it does
       doom-dashboard    ; a nifty splash screen for Emacs
       ;;doom-quit         ; DOOM quit-message prompts when you quit Emacs
       (emoji +unicode)  ; ðŸ™‚
       ;;fill-column       ; a `fill-column' indicator
       hl-todo           ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       hydra
       indent-guides     ; highlighted indent columns
       ligatures         ; ligatures and symbols to make your code pretty again
       minimap           ; show a map of the code on the side
       modeline          ; snazzy, Atom-inspired modeline, plus API
       nav-flash         ; blink cursor line after big motions
       neotree           ; a project drawer, like NERDTree for vim
       ophints           ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       tabs              ; a tab bar for Emacs
       treemacs          ; a project drawer, like neotree but cooler
       unicode           ; extended unicode support for various languages
       vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe   ; fringe tildes to mark beyond EOB
       (window-select +numbers)     ; visually switch windows
       workspaces        ; tab emulation, persistence & separate workspaces
       zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere); come to the dark side, we have cookies
       file-templates    ; auto-snippets for empty files
       fold              ; (nigh) universal code folding
       (format +onsave)  ; automated prettiness
       god               ; run Emacs commands without modifier keys
       lispy             ; vim for lisp, for people who don't like vim
       multiple-cursors  ; editing in many places at once


       ;; NOTE: This causes lines to be deleted after pressing enter and `i'; go through its documentation
       objed             ; text object editing for the innocent


       ;; NOTE: This will cause org-mode files with lisp to start in a sort-of org-edit-special mode
       ;; (parinfer +rust)          ; turn lisp into python, sort of

       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent

       :emacs
       dired             ; making dired pretty [functional]
       electric          ; smarter, keyword-based electric-indent
       ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell            ; the elisp shell that works everywhere
       ;;shell             ; simple shell REPL for Emacs
       ;;term              ; basic terminal emulator for Emacs
       ;;vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax              ; tasing you for every semicolon you forget
       spell             ; tasing you for misspelling mispelling
       grammar           ; tasing grammar mistake every you make

       :tools
       ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       direnv
       docker
       editorconfig      ; let someone else argue about tabs vs spaces
       ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       ;;lookup              ; navigate your code and its documentation
       (lsp +eglot)
       magit             ; a git porcelain for Emacs
       make              ; run make tasks from Emacs
       pass              ; password manager for nerds
       ;;pdf               ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       taskrunner        ; taskrunner for all your projects
       terraform         ; infrastructure as code
       tmux              ; an API for interacting with tmux
       upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       (cc +lsp)                ; C/C++/Obj-C madness
       (clojure +lsp)           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;(csharp +lsp)            ; unity, .NET, and mono shenanigans
       data              ; config/data formats
       ;;(dart +flutter +lsp)   ; paint ui and not much else
       ;;(elixir +lsp)            ; erlang done right
       ;;(elm +lsp)               ; care for a cup of TEA?
       (emacs-lisp +lsp)        ; drown in parentheses
       ;;(erlang +lsp)            ; an elegant language for a more civilized age
       ;;ess               ; emacs speaks statistics
       ;;faust             ; dsp, but you get to keep your soul
       ;;(fsharp +lsp)            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       ;;(go +lsp)         ; the hipster dialect
       ;;(haskell +dante +lsp)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       json              ; At least it ain't XML
       ;;(java +meghanada +lsp) ; the poster child for carpal tunnel syndrome
       ;;(javascript +lsp)        ; all(hope(abandon(ye(who(enter(here))))))
       ;;(julia +lsp)             ; a better, faster MATLAB
       ;;(kotlin +lsp)            ; a better, slicker Java(Script)
       (latex +lsp)             ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown          ; writing docs for people to ignore
       nim               ; python + lisp at the speed of c
       (nix +lsp)               ; I hereby declare "nix geht mehr!"
       ;;(ocaml +lsp)             ; an objective camel


       ;; TODO
       (org +roam)               ; organize your plain life in plain text
       ;;org               ; organize your plain life in plain text

       ;; org               ; organize your plain life in plain text
       ;;(php +lsp)               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;(purescript +lsp)        ; javascript, but functional
       (python +lsp)            ; beautiful is better than ugly
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails +lsp)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;(rust +lsp)              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;(scala +lsp)             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       (sh +lsp)                ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;(swift +lsp)             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       yaml              ; JSON, but readable

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       ;;(wanderlust +gmail)

       :app
       ;;calendar
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config

       ;; NOTE: I am manually tangling a README of the config-, init-, and package.el files instead
       ;;literate

       ;;(default +bindings +smartparens)
       (default +smartparens)

       ;; :private spacemacs
       )
#+end_src

*** config.el

#+call: hash("")

#+RESULTS:
: 5121f652dcfd6166521ed3ccb7fdb62c

#+name: 5121f652dcfd6166521ed3ccb7fdb62c
#+begin_src emacs-lisp :tangle (jr/tangle-path)
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

(load! "help+20")
;; (when (eq (find-font (font-spec :family "all-the-icons")) nil) (all-the-icons-install-fonts))

;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/26840/31428
;; User: https://emacs.stackexchange.com/users/253/dan
;; Adapted From: https://emacsredux.com/blog/2020/06/14/checking-the-major-mode-in-emacs-lisp/
(defun jr/outline-folded-p nil
    "Returns non-nil if point is on a folded headline or plain list
    item."
    (interactive)
    (and (if (eq major-mode 'org-mode)
            (or (org-at-heading-p)
                (org-at-item-p))
            outline-on-heading-p)
        (invisible-p (point-at-eol))))

;; use-package
<<e66c89b1b0b03e47821d84d6bdd4e30f>>

;; modal-modes
<<b8e289dc4201435230e95e4bc961eff8>>

;; org-mode
<<0f5b9694b164e724814320abc695bb5b>>

;; minibuffer
<<d265ec51e2ef69de5f99d16281d47afa>>

;; git
<<4027496311aaa540864858b0cc6d7781>>

;; buffer
<<0cbddafe342ce45b8c57c5feeb0a4237>>

;; terminal
<<60045541f36fe02d96c14630bbe3966a>>

;; window manager
<<8016354b1cb35e0587437e68baba41d8>>

;; system
<<58043a4011d978b07d42cdbe23366db4>>

;; etc
<<f6fbad3008b5eaa412ac27f2ba12bd42>>

;; Answer: https://stackoverflow.com/a/57075163
;; User: https://stackoverflow.com/users/2708138/tobias
(defun jr/eval-after-load-all (my-features form)
    "Run FORM after all MY-FEATURES are loaded.
    See `eval-after-load' for the possible formats of FORM."
    (if (null my-features)
        (if (functionp form)
        (funcall form)
    (eval form))
    (eval-after-load (car my-features)
        `(lambda nil
    (eval-after-load-all
        (quote ,(cdr my-features))
        (quote ,form))))))

;; Adapted From:
;; Answer: https://stackoverflow.com/a/57075163
;; User: https://stackoverflow.com/users/2708138/tobias
;; (defun jr/eval-after-load-some (my-features form)
;;     "Run FORM after all MY-FEATURES are loaded.
;;     See `eval-after-load' for the possible formats of FORM."
;;     (if (any my-features)
;;         (if (functionp form)
;;         (funcall form)
;;     (eval form))
;;     (eval-after-load (car my-features)
;;         `(lambda nil
;;     (eval-after-load-all
;;         (quote ,(cdr my-features))
;;         (quote ,form))))))

;; From: https://www.masteringemacs.org/article/speed-up-emacs-libjansson-native-elisp-compilation

(if (and (fboundp 'native-comp-available-p)
       (native-comp-available-p))
  (message "Native compilation is available")
(message "Native complation is *not* available"))
(if (functionp 'json-serialize)
  (message "Native JSON is available")
(message "Native JSON is *not* available"))

;; Adapted From:
;; From: https://emacs.stackexchange.com/a/19507
;; User: https://emacs.stackexchange.com/users/50/malabarba
;; (setq byte-compile-warnings (not t))
;; (setq byte-compile warnings (not obsolete))

;; From: https://emacsredux.com/blog/2014/07/25/configure-the-scratch-buffers-mode/
;; (setq initial-major-mode 'org-mode)

;; (add-to-list 'org-src-lang-modes '("nix-repl" . nix-mode))
;; (org-babel-do-load-languages 'org-babel-load-languages '((nix-mode . t)))
;; (json (if (assoc :json params) (nth (+ (cl-position :json params) 1) params) nil))
;; (optargs (if (assoc '-- params) (nthcdr (+ (cl-position '-- params) 1) params) nil))
;; (if (or (eq json nil) (<= json 0)) "" "--json")
;; (if optargs (format "%s" optargs) "")
;; (format "%s" (cdr params))

;; Follow symlinks
(setq vc-follow-symlinks t)

;; Use Python Syntax Highlighting for ".xonshrc" files
;; (setq auto-mode-alist 
;;       (append '(".*\\.xonshrc\\'" . python-mode)
;;               auto-mode-alist))
;; (setq auto-mode-alist 
;;       (append '(".*\\.xsh\\'" . python-mode)
;;              auto-mode-alist))

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; Adapted From: https://www.reddit.com/r/emacs/comments/8fz6x2/relative_number_with_line_folding/dy7lmh7?utm_source=share&utm_medium=web2x&context=3
;; (display-line-numbers-mode 1)
(setq display-line-numbers-type 'relative)

;; Adapted From:
;; Answer: https://unix.stackexchange.com/a/152151
;; User: https://unix.stackexchange.com/users/72170/ole
;; No more typing the whole yes or no. Just y or n will do.
;; Makes *scratch* empty.
(setq initial-scratch-message "")

;; Removes *scratch* from buffer after the mode has been set.
(defun jr/remove-scratch-buffer nil
  (if (get-buffer "*scratch*")
      (kill-buffer "*scratch*")))
(add-hook 'after-change-major-mode-hook 'jr/remove-scratch-buffer)

;; Removes *messages* from the buffer.
(setq-default message-log-max nil)
(kill-buffer "*Messages*")

;; Removes *Completions* from buffer after you've opened a file.
(add-hook 'minibuffer-exit-hook
      '(lambda nil
         (let ((buffer "*Completions*"))
           (and (get-buffer buffer)
                (kill-buffer buffer)))))

;; Don't show *Buffer list* when opening multiple files at the same time.
(setq inhibit-startup-buffer-menu t)

;; Show only one active window when opening multiple files at the same time.
(add-hook 'window-setup-hook 'delete-other-windows)

(fset 'yes-or-no-p 'y-or-n-p)

;; From: https://kundeveloper.com/blog/autorevert/
;; Auto revert files when they change
(global-auto-revert-mode t)
;; Also auto refresh dired, but be quiet about it
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;; Answer: https://emacs.stackexchange.com/a/51829
;; User: https://emacs.stackexchange.com/users/2370/tobias
;; (defun jr/set-buffer-save-without-query nil
;;     "Set `buffer-save-without-query' to t."
;;     (unless (variable-binding-locus 'buffer-save-without-query)
;;         (setq buffer-save-without-query t)))

;; (add-hook #'find-file-hook #'jr/set-buffer-save-without-query)

;; The following avoids being ask to allow the file local
;; setting of `buffer-save-without-query'.
;; IMHO it is not a big risk:
;; The malicious code that must not be saved
;; should never be allowed to enter Emacs in the first place.
;; (put 'buffer-save-without-query 'safe-local-variable #'booleanp)

;; (setq doom-theme 'exo-ui-red-dark)
(setq doom-theme 'dracula-orange-dark)
;; (setq doom-theme 'dracula-purple-dark)
;; (setq doom-theme 'doom-gruvbox)
;; (setq doom-theme nil)
;; From: https://github.com/hlissner/emacs-doom-themes#common-issues
;; (let ((height (face-attribute 'default :height)))
;;   ;; for all linum/nlinum users
;;   (set-face-attribute 'linum nil :height height)
;;   ;; only for `linum-relative' users:
;;   (set-face-attribute 'linum-relative-current-face nil :height height)
;;   ;; only for `nlinum-relative' users:
;;   ;; (set-face-attribute 'nlinum-relative-current-face nil :height height)
;; )

(setq user-full-name "Jeet Ray"
      user-mail-address "aiern@protonmail.com")

(setq doom-font (font-spec :family "Cartograph CF" :size 15 :weight 'light)
      doom-variable-pitch-font (font-spec :family "sans" :size 13))

;; (dump-emacs-portable "~/.emacs.d/garboder")
#+end_src

**** use-package

***** always defer package loading

Quoted from [[Use-Package's Loading packages in sequence
][https://github.com/jwiegley/use-package#loading-packages-in-sequence]]:

#+begin_quote
NOTE: pay attention if you set use-package-always-defer to t, and also use the :after keyword, as you will need to specify how the
declared package is to be loaded: e.g., by some :bind. If you're not using one of the mechanisms that registers autoloads, such as
:bind or :hook, and your package manager does not provide autoloads, it's possible that without adding :defer 2 to those declarations,
your package will never be loaded.
#+end_quote

Quoted from [[Use-Package's Notes about lazy loading][https://github.com/jwiegley/use-package#notes-about-lazy-loading]]:

#+begin_quote
In almost all cases you don't need to manually specify :defer t. This is implied whenever :bind or :mode or :interpreter is used.
Typically, you only need to specify :defer if you know for a fact that some other package will do something to cause your package to
load at the appropriate time, and thus you would like to defer loading even though use-package isn't creating any autoloads for you.
You can override package deferral with the :demand keyword. Thus, even if you use :bind, using :demand will force loading to occur
immediately and not establish an autoload for the bound key.
#+end_quote

Quoted from [[Use-Package's Modes and interpreters][https://github.com/jwiegley/use-package#modes-and-interpreters]]:

#+begin_quote
Similar to :bind, you can use :mode and :interpreter to establish a deferred binding within the auto-mode-alist and interpreter-mode-alist variables.
...
If you aren't using :commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, or :hook
(all of which imply :defer; see the docstring for use-package for a brief description of each), you can still defer loading with the :defer keyword...
#+end_quote

Quoted from [[Use-Package's Magic handlers][https://github.com/jwiegley/use-package#magic-handlers]]:

#+begin_quote
Similar to :mode and :interpreter, you can also use :magic and :magic-fallback to cause certain function to be run if the beginning of a file matches
a given regular expression.
...
This registers an autoloaded command for pdf-view-mode, defers loading of pdf-tools, and runs pdf-view-mode if the beginning of a buffer matches the string "%PDF".
#+end_quote

Quoted from [[RYO-Modal's Use-package keyword][https://github.com/Kungsgeten/ryo-modal#use-package-keyword]]:

#+begin_quote
Ryo-modal also provides a use-package keyword: :ryo, which is similar to :bind in that it implies :defer t and create autoloads for the bound commands.
The keyword is followed by one or more key-binding commands, using the same syntax as used by ryo-modal-keys...
#+end_quote

Quoted from [[General's Use-package Keywords][https://github.com/noctuid/general.el#use-package-keywords]]:

#+begin_quote
:general is similar to :bind in that it implies :defer t whenever there are bound commands that can be autoloaded
(e.g. it will not imply :defer t if the only bound command is to a lambda, for example). Whenever autoloadable commands are bound,
use-package will create autoloads for them (though this is usually not necessary).
#+end_quote

Quoted from [[General's :ghook Keyword][https://github.com/noctuid/general.el#ghook-keyword]]:

#+begin_quote
:ghook is intended to be used to add a packageâ€™s minor mode enabling function to a user-specified hook, so that when hook is run,
the package will be loaded and the mode enabled. This means that :ghook will usually imply :defer t. While it does not always imply :defer t,
it will add any non-lambda functions to :commands (this is the same behavior as :hook).
Though this is usually unnecessary (the commands probably already have autoloads), it will in turn imply :defer t.
#+end_quote

Quoted from [[General's :gfhook Keyword][https://github.com/noctuid/general.el#gfhook-keyword]]:

#+begin_quote
Unlike :ghook, :gfhook never adds functions to :commands and therefore never implies :defer t.
This is because the functions specified are ones that should be run when turning on (or toggling) the mode(s) the package provides.
The specified functions are external to the package, could be called elsewhere, and therefore should not trigger the package to load.
#+end_quote

Also see [[this comment][https://github.com/jwiegley/use-package/issues/738#issuecomment-447631609]].

Note that I assume that [[chords][https://github.com/jwiegley/use-package#use-package-chords]] also defer and create autoloads.

And in my experience... Not a good idea; much too confusing. Use
[[the arguments here][https://www.reddit.com/r/emacs/comments/j2xezg/usepackage_best_practices/]] to decide whether to use this or =:defer <n>= instead.

#+call: hash("ad")

#+RESULTS:
: 3bea610856c41a0d7902afd1c523b3fa

#+name: 3bea610856c41a0d7902afd1c523b3fa
#+begin_src emacs-lisp
(setq use-package-always-defer t)
#+end_src

#+call: hash("")

#+RESULTS:
: e66c89b1b0b03e47821d84d6bdd4e30f

#+name: e66c89b1b0b03e47821d84d6bdd4e30f
#+begin_src emacs-lisp
;; <<3bea610856c41a0d7902afd1c523b3fa>>

;; From: https://github.com/hartzell/straight.el/commit/882649137f73998d60741c7c8c993c7ebbe0f77a#diff-b335630551682c19a781afebcf4d07bf978fb1f8ac04c6bf87428ed5106870f5R1649
;; (setq straight-disable-byte-compilation t)

;; Adapted From: https://github.com/jwiegley/use-package#use-package-chords
;; Important: https://github.com/noctuid/general.el/issues/53#issuecomment-307262154
(use-package! use-package-chords
        :demand t
        :hook (after-init . key-chord-mode))
(load! "naked")

(use-package! use-package-hydra
        :demand t
        :load-path "use-package-hydra"
        :custom (hydra-hint-display-type 'lv))
(load! "use-package-hydra-plus/use-package-hydra+")
(load! "use-package-hercules/use-package-hercules")
#+end_src

**** org-mode

#+call: hash("")

#+RESULTS:
: 0f5b9694b164e724814320abc695bb5b

#+name: 0f5b9694b164e724814320abc695bb5b
#+begin_src emacs-lisp
(use-package! org
        :init
            ;; I'm using ox-pandoc
            ;; (setq org-export-backends '(md gfm latex odt org))
            (setq org-directory "/tmp")
            (setq org-roam-directory org-directory)
        :hook
            ((org-mode . 'jr/org-babel-tangle-append-setup)
            ;; (kill-emacs . 'org-babel-tangle)

            ;; Adapted From: https://www.reddit.com/r/emacs/comments/6klewl/org_cyclingto_go_from_folded_to_children_skipping/djniygy?utm_source=share&utm_medium=web2x&context=3
            (org-cycle . (lambda (state) (interactive) (when (eq state 'children) (setq org-cycle-subtree-status 'subtree)))))
        :config
            (org-babel-lob-ingest "/README.org")

            <<2d63732674461dc2b644efd020455882>>

            <<2797cdf9a536de59551ab5e470544e74>>

            <<d5f827b029c135ec0d04907f50c759b7>>

            ;; Adapted From:
            ;; Answer: https://emacs.stackexchange.com/a/37791/31428
            ;; User: https://emacs.stackexchange.com/users/12497/toothrot
            (defun jr/go-to-parent nil (interactive)
                (outline-up-heading (if (and (or (org-at-heading-p) (invisible-p (point))) (invisible-p (point-at-eol))
                        (>= (org-current-level) 2))
                    1 0)))

            (defun jr/evil-close-fold nil (interactive) (jr/go-to-parent) (evil-close-fold))

            (defun jr/org-cycle nil (interactive)
                (if (jr/outline-folded-p) (org-cycle) (jr/evil-close-fold)))

            (advice-add #'org-edit-special :after #'jr/src-mode-settings)

            <<ed55930dc36029c49a46d842fd0ffc1b>>
        :general
            <<3df3d7bde7eda0546c77ba9a5b2aa82d>>
            (:keymaps 'override
                (naked "backtab") 'jr/evil-close-fold)
        :ryo ("o" :hydra
            '(hydra-org (:color blue)
                  "A hydra for org-mode!"
                  ("o" org-babel-tangle "tangle")
                  ("a" jr/org-babel-tangle-append "tangle append")
                  ("f" org-babel-tangle-file "tangle file")
                  ("n" jr/narrow-or-widen-dwim "narrow")
                  ("s" org-edit-special "org edit special")
                  ("q" nil "cancel")))
        :custom
            (org-descriptive-links t)
            (org-confirm-babel-evaluate nil)
            (org-startup-folded t)
            (org-src-fontify-natively t)
            ;; (org-src-window-setup 'current-window)
            (org-cycle-emulate-tab 'whitestart))

(use-package! org-numbers-overlay
        :load-path "emacs-bankruptcy/site-lisp"
        :hook (org-mode . org-numbers-overlay-mode))
#+end_src

***** org-babel-tangle-append

This is adapted from
[[https://emacs.stackexchange.com/questions/28098/how-to-change-org-mode-babel-tangle-write-to-file-way-as-append-instead-of-overr/38898#38898][How to change Org-mode babel tangle write to file way as append instead of override by default?
]], by [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]]:

#+call: hash("")

#+RESULTS:
: 2d63732674461dc2b644efd020455882

#+name: 2d63732674461dc2b644efd020455882
#+begin_src emacs-lisp
(defun jr/org-babel-tangle-append nil
  "Append source code block at point to its tangle file.
The command works like `org-babel-tangle' with prefix arg
but `delete-file' is ignored."
  (interactive)
  (cl-letf (((symbol-function 'delete-file) #'ignore))
    (org-babel-tangle '(4))))

(defun jr/org-babel-tangle-append-setup nil
  "Add key-binding C-c C-v C-t for `jr/org-babel-tangle-append'."
  (org-defkey org-mode-map (kbd "C-c C-v +") 'jr/org-babel-tangle-append))
#+end_src

***** org-babel-tangle-multiple

This is from
[[https://emacs.stackexchange.com/questions/39032/tangle-the-same-src-block-to-different-files/39039#39039][tangle the same src block to different files
]], by [[https://emacs.stackexchange.com/users/2370/tobias][Tobias]]:

#+call: hash("")

#+RESULTS:
: 2797cdf9a536de59551ab5e470544e74

#+name: 2797cdf9a536de59551ab5e470544e74
#+begin_src emacs-lisp
(defun org-babel-tangle-collect-blocks-handle-tangle-list (&optional language tangle-file)
  "Can be used as :override advice for `org-babel-tangle-collect-blocks'.
Handles lists of :tangle files."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
         (org-with-wide-buffer
          (org-with-limited-levels (outline-previous-heading)))))
    (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
      (setq counter 1)
      (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
    (let* ((info (org-babel-get-src-block-info 'light))
           (src-lang (nth 0 info))
           (src-tfiles (cdr (assq :tangle (nth 2 info))))) ; Tobias: accept list for :tangle
      (unless (consp src-tfiles) ; Tobias: unify handling of strings and lists for :tangle
        (setq src-tfiles (list src-tfiles))) ; Tobias: unify handling
      (dolist (src-tfile src-tfiles) ; Tobias: iterate over list
        (unless (or (string= src-tfile "no")
            (and tangle-file (not (equal tangle-file src-tfile)))
            (and language (not (string= language src-lang))))
          ;; Add the spec for this block to blocks under its
          ;; language.
          (let ((by-lang (assoc src-lang blocks))
            (block (org-babel-tangle-single-block counter)))
        (setcdr (assoc :tangle (nth 4 block)) src-tfile) ; Tobias: 
        (if by-lang (setcdr by-lang (cons block (cdr by-lang)))
          (push (cons src-lang (list block)) blocks)))))))) ; Tobias: just ()
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))

(defun org-babel-tangle-single-block-handle-tangle-list (oldfun block-counter &optional only-this-block)
  "Can be used as :around advice for `org-babel-tangle-single-block'.
If the :tangle header arg is a list of files. Handle all files"
  (let* ((info (org-babel-get-src-block-info))
     (params (nth 2 info))
     (tfiles (cdr (assoc :tangle params))))
    (if (null (and only-this-block (consp tfiles)))
    (funcall oldfun block-counter only-this-block)
      (cl-assert (listp tfiles) nil
         ":tangle only allows a tangle file name or a list of tangle file names")
      (let ((ret (mapcar
          (lambda (tfile)
            (let (old-get-info)
              (cl-letf* (((symbol-function 'old-get-info) (symbol-function 'org-babel-get-src-block-info))
                 ((symbol-function 'org-babel-get-src-block-info)
                  `(lambda (&rest get-info-args)
                     (let* ((info (apply 'old-get-info get-info-args))
                        (params (nth 2 info))
                        (tfile-cons (assoc :tangle params)))
                       (setcdr tfile-cons ,tfile)
                       info))))
            (funcall oldfun block-counter only-this-block))))
          tfiles)))
    (if only-this-block
        (list (cons (cl-caaar ret) (mapcar #'cadar ret)))
      ret)))))

(advice-add 'org-babel-tangle-collect-blocks :override #'org-babel-tangle-collect-blocks-handle-tangle-list)
(advice-add 'org-babel-tangle-single-block :around #'org-babel-tangle-single-block-handle-tangle-list)
#+end_src

***** org-roam

Taken from [[Org-Roam's GitHub README][https://github.com/org-roam/org-roam#installation]], adapted by yours truely:

#+call: hash("")

#+RESULTS:
: 3df3d7bde7eda0546c77ba9a5b2aa82d

#+name: 3df3d7bde7eda0546c77ba9a5b2aa82d
#+begin_src emacs-lisp
(:keymaps 'org-roam-mode-map
      "C-c n" '(:ignore t :which-key "Org-Roam")
      "C-c n l" 'org-roam
      "C-c n f" 'org-roam-find-file
      "C-c n g" 'org-roam-graph)
(:keymaps 'org-mode-map
      "C-c n i" 'org-roam-insert
      "C-c n I" 'org-roam-insert-immediate)
#+end_src

***** languages

#+call: hash("")

#+RESULTS:
: d5f827b029c135ec0d04907f50c759b7

#+name: d5f827b029c135ec0d04907f50c759b7
#+begin_src emacs-lisp
<<04dbf8eb8aa0b8101102b13044392cc8>>

<<a9ce3aa0a02c096218d0bd9f8646d606>>

<<bc74035cf2335eb01654c90f7518def5>>

<<7bd7723280e47c56c1734e5ce06c5ecb>>
#+end_src

****** nix

#+call: hash("")

#+RESULTS:
: 04dbf8eb8aa0b8101102b13044392cc8

#+name: 04dbf8eb8aa0b8101102b13044392cc8
#+begin_src emacs-lisp
(use-package! nix-mode
    :commands (org-babel-execute:nix)
    :mode ("\\.nix\\'")
    :config
        ;; Adapted From:
        ;; Answer: https://emacs.stackexchange.com/a/61442
        ;; User: https://emacs.stackexchange.com/users/20061/zeta
        (defun org-babel-execute:nix (body params)
            "Execute a block of Nix code with org-babel."
            (message "executing Nix source code block")
            (let ((in-file (org-babel-temp-file "n" ".nix"))
                (json (or (cdr (assoc :json params)) nil))
                (opts (or (cdr (assoc :opts params)) nil))
                (args (or (cdr (assoc :args params)) nil))
                (read-write-mode (or (cdr (assoc :read-write-mode params)) nil))
                (eval (or (cdr (assoc :eval params)) nil))
                (show-trace (or (cdr (assoc :show-trace params)) nil)))
            (with-temp-file in-file
                (insert body))
            (org-babel-eval
                (format "nix-instantiate %s %s %s %s %s %s %s"
                    (if (xor (eq json nil) (<= json 0)) "" "--json")
                    (if (xor (eq show-trace nil) (<= show-trace 0)) "" "--show-trace")
                    (if (xor (eq read-write-mode nil) (<= read-write-mode 0)) "" "--read-write-mode")
                    (if (xor (eq eval nil) (<= eval 0)) "" "--eval")
                    (if (eq opts nil) "" opts)
                    (if (eq args nil) "" args)
                    (org-babel-process-file-name in-file))
            ""))))
#+end_src

****** xonsh

#+call: hash("")

#+RESULTS:
: a9ce3aa0a02c096218d0bd9f8646d606

#+name: a9ce3aa0a02c096218d0bd9f8646d606
#+begin_src emacs-lisp
(use-package! xonsh-mode
    :commands
        (org-babel-execute:xonsh
        org-babel-expand-body:xonsh)
    :mode ("\\.xonshrc\\'" "\\.xsh\\'")
    :config
        ;; Adapted From:
        ;; Answer: https://emacs.stackexchange.com/a/61442
        ;; User: https://emacs.stackexchange.com/users/20061/zeta
        (defun org-babel-execute:xonsh (body params)
            "Execute a block of Xonsh code with org-babel."
            (message "executing Xonsh source code block")
            (let ((in-file (org-babel-temp-file "x" ".xsh"))
                (opts (or (cdr (assoc :opts params)) nil))
                (args (or (cdr (assoc :args params)) nil)))
            (with-temp-file in-file
                (insert body))
            (org-babel-eval
                (format "xonsh %s %s %s"
                    (if (eq opts nil) "" opts)
                    (if (eq args nil) "" args)
                    (org-babel-process-file-name in-file))
            ""))))
#+end_src

****** dockerfile

#+call: hash("")

#+RESULTS:
: bc74035cf2335eb01654c90f7518def5

#+name: bc74035cf2335eb01654c90f7518def5
#+begin_src emacs-lisp
(use-package! dockerfile-mode
    :config
        (org-babel-do-load-languages 'org-babel-load-languages
            (append org-babel-load-languages
                '((Dockerfile . t))))
    :mode ("\\Dockerfile\\'"))
#+end_src

****** vimrc

#+call: hash("")

#+RESULTS:
: 7bd7723280e47c56c1734e5ce06c5ecb

#+name: 7bd7723280e47c56c1734e5ce06c5ecb
#+begin_src emacs-lisp
(use-package! vimrc-mode
    :commands
        (org-babel-execute:vimrc
        org-babel-expand-body:vimrc)
    :mode "\\.vim\\(rc\\)?\\'")
#+end_src

**** modal modes

#+call: hash("setup")

#+RESULTS:
: d3797553f252eabca75070bb3374df05

#+name: d3797553f252eabca75070bb3374df05
#+begin_src emacs-lisp :var map="" :var mode="" :var prefix=""
;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/7381/31428
;; User: https://emacs.stackexchange.com/users/719/adobe
(format-spec ":hercules
    (:show-funs #'jr/%p-hercules-show
    :hide-funs #'jr/%p-hercules-hide
    :toggle-funs #'jr/%p-hercules-toggle
    :keymap '%m
    ;; :transient t
    )
:config
    (defun jr/%p-hercules-toggle nil (interactive))
    (add-to-list 'modal-modes '%n)
    (add-to-list 'modal-prefixes \"%p\")

    (defun jr/toggle-%p nil (interactive)
        (funcall 'jr/toggle-inner '%n \"%p\" (bound-and-true-p %n) '%m))" `((?m . ,map) (?n . ,mode) (?p . ,prefix)))
#+end_src

#+call: hash("")

#+RESULTS:
: b8e289dc4201435230e95e4bc961eff8

#+name: b8e289dc4201435230e95e4bc961eff8
#+begin_src emacs-lisp

;; Adapted From:
;; Answer: https://emacs.stackexchange.com/a/42240
;; User: user12563

;; This list is prefilled with modal-modes that are also doom-emacs modules
(defvar modal-modes '(evil-mode god-local-mode objed-mode))
(defvar modal-prefixes (mapcar (lambda (mode) (interactive) (car (split-string (symbol-name mode) "-"))) modal-modes))
(defvar last-modal-mode nil)
(defvar hercules-map global-map)

(defun jr/any-popup-showing-p nil (interactive)
    (or hercules--popup-showing-p (which-key--popup-showing-p)))
(defun jr/which-key-show-top-level nil (interactive)
    (let* ((current-map (if hercules--popup-showing-p overriding-terminal-local-map global-map))
        (which-key-function
            ;; #'which-key-show-top-level
            ;; #'(lambda nil (interactive) (which-key-show-full-keymap 'global-map))
            ;; #'which-key-show-full-major-mode
            ;; #'which-key-show-major-mode

            ;; Adapted From:
            ;; https://github.com/justbur/emacs-which-key/blob/master/which-key.el#L2359
            ;; https://github.com/justbur/emacs-which-key/blob/master/which-key.el#L2666
            #'(lambda nil (interactive) (
                which-key--create-buffer-and-show nil current-map nil "Current bindings"))))
        (if (which-key--popup-showing-p)
            (when (member last-modal-mode modal-prefixes)
                (funcall which-key-function) (setq last-modal-mode nil))
            (funcall which-key-function))))
(defun jr/hercules-hide-all-modal-modes nil (interactive)
    (mapc #'(lambda (prefix) (interactive)
        (message (format "Hiding %s" prefix))
        (ignore-errors (funcall (intern (concat "jr/" prefix "-hercules-hide"))))
        ;; (internal-push-keymap 'global-map 'overriding-terminal-local-map)
        ;; (internal-push-keymap nil 'overriding-terminal-local-map)
        ) modal-prefixes)
    (jr/which-key-show-top-level))
(defun jr/disable-all-modal-modes nil (interactive)
    (mapc
        (lambda (mode-symbol)
            (message (format "Disabling %s" (symbol-name mode-symbol)))
            (when (functionp mode-symbol)
            ;; some symbols are functions which aren't normal mode functions
                (ignore-errors
                    (funcall mode-symbol -1))))
            modal-modes)
    (jr/hercules-hide-all-modal-modes))

;; Answer: https://stackoverflow.com/a/14490054/10827766
;; User: https://stackoverflow.com/users/1600898/user4815162342
(defun jr/keymap-symbol (keymap)
    "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
    (catch 'gotit
            (mapatoms (lambda (sym)
                (and (boundp sym)
                        (eq (symbol-value sym) keymap)
                        (not (eq sym 'keymap))
                        (throw 'gotit sym))))))

;; Adapted From: https://gitlab.com/jjzmajic/hercules.el/-/blob/master/hercules.el#L83
(defun jr/toggle-inner (mode prefix mode-on map) (interactive)
    (jr/disable-all-modal-modes)
    (unless mode-on
        (funcall mode 1)
        (ignore-errors (funcall (intern (concat "jr/" prefix "-hercules-show"))))
        (setq last-modal-mode prefix)))

<<e8fba38bca841d9f8d89cd15b15754bd>>
<<8c01d74b243996d2524244ea38efedf0>>
<<2b6c7dfafc16cb3749d9b011c718618c>>
<<e1785de4290e315a93e1f67553025f69>>
<<d34ff1a4219491ae3aee30b275fd9212>>
<<913cb77bdade14e8a517edbee7410b9a>>
<<c323d6a8a89df885749c42fd2a0bc858>>
<<452c54e1a8e466b834ef13df6b9e238c>>

(add-hook! doom-init-ui
    (jr/disable-all-modal-modes)
    ;; (run-at-time "1 sec" nil #'jr/which-key-show-top-level)
    (jr/which-key-show-top-level))
#+end_src

***** hercules

#+call: hash("")

#+RESULTS:
: e8fba38bca841d9f8d89cd15b15754bd

#+name: e8fba38bca841d9f8d89cd15b15754bd
#+begin_src emacs-lisp
(use-package! hercules
    :demand t
    :init
        (setq which-key-enable-extended-define-key t)
        (setq which-key-idle-delay 0.1)
        (setq which-key-idle-secondary-delay nil)
    :config
        (defun jr/hercules--hide (&optional keymap flatten &rest _)
                "Dismiss hercules.el.
            Pop KEYMAP from `overriding-terminal-local-map' when it is not
            nil.  If FLATTEN is t, `hercules--show' was called with the same
            argument.  Restore `which-key--update' after such a call."
                (setq hercules--popup-showing-p nil

                    ;; I like to dismiss the popups' myself
                    which-key-persistent-popup t)

                (which-key--hide-popup)
                (when keymap
                    (internal-pop-keymap (symbol-value keymap)
                        'overriding-terminal-local-map))
                (when flatten
                    (advice-remove #'which-key--update #'ignore))

                ;; Show the global popup, i.e. keep the popup
                (jr/which-key-show-top-level))
        (advice-add #'hercules--hide :override #'jr/hercules--hide)
    :custom

        ;; NOTE: When using the side window, this doesn't matter, apparently;
        ;; only the hercules transient property does
        (which-key-persistent-popup t)

        (which-key-allow-evil-operators t)

        ;; NOTE: This will cause the which-key maps for the operator states to show up,
        ;; breaking functionality such as `d 13 <arrow-down>', etc.
        ;; (which-key-show-operator-state-maps t)

        ;; TODO: Choose a fun one!
        (which-key-separator " Ã— ")
        ;; (which-key-separator " |-> ")

        (which-key-popup-type 'side-window)
        (which-key-side-window-location '(right bottom left top))

        ;; If this percentage is too small, the keybindings frame will appear at the bottom
        (which-key-side-window-max-width 0.5)

        (which-key-side-window-max-height 0.25))
#+end_src

***** ryo modal

#+call: hash("")

#+RESULTS:
: 8c01d74b243996d2524244ea38efedf0

#+name: 8c01d74b243996d2524244ea38efedf0
#+begin_src emacs-lisp
(use-package! ryo-modal
    :demand t
    :general (:keymaps 'override (general-chord "  ") 'jr/toggle-ryo)
    <<d3797553f252eabca75070bb3374df05(map="ryo-modal-mode-map", mode="ryo-modal-mode", prefix="ryo")>>
        ;; From: https://github.com/Kungsgeten/ryo-modal#which-key-integration
        (push '((nil . "ryo:.*:") . (nil . "")) which-key-replacement-alist))
#+end_src

***** evil

#+call: hash("")

#+RESULTS:
: 2b6c7dfafc16cb3749d9b011c718618c

#+name: 2b6c7dfafc16cb3749d9b011c718618c
#+begin_src emacs-lisp
(use-package! evil
    :init (setq-default evil-escape-key-sequence nil)
    :general (:keymaps 'override
        (general-chord "kk") 'jr/toggle-evil
        ":" 'evil-ex)
    <<d3797553f252eabca75070bb3374df05(map="evil-normal-state-map", mode="evil-mode", prefix="evil")>>
        (advice-add #'evil-insert-state :override #'jr/disable-all-modal-modes)

        ;; From: https://www.reddit.com/r/emacs/comments/lp45zd/help_requested_in_configuring_ryomodal/gp3rfx9?utm_source=share&utm_medium=web2x&context=3
        ;; Kept for documentation porpoises
        ;; (eval
        ;;       `(ryo-modal-keys
        ;;             ("l l" ,(general-simulate-key ":wq <RET>") :first '(evil-normal-state) :name "wq")
        ;;             ("l p" ,(general-simulate-key ":q <RET>") :first '(evil-normal-state) :name "q")
        ;;             ("l o" ,(general-simulate-key ":w <RET>") :first '(evil-normal-state) :name "w")
        ;;             ("l q" ,(general-simulate-key ":q! <RET>") :first '(evil-normal-state) :name "q!")))

        ;; Use to get command name:
        ;; Eg: (cdr (assoc "q" evil-ex-commands))
        ;; Then "C-x C-e" (eval-last-sexp)
    :ryo
        ("l" :hydra
                '(evil-exits (:color blue)
                    ;; From: https://gist.github.com/shadowrylander/46b81297d1d3edfbf1e2d72d5e29171e
                    "A hydra for getting the fuck outta' here!"
                    ("`" nil "cancel")
                    ("l" evil-save-and-quit ":wq")
                    ("p" evil-quit ":q")
                    ("o" evil-write ":w")
                    ("O" evil-write-all ":wa")
                    ;; ("q" (funcall (general-simulate-key ":q! <RET>")) ":q!"))
                    ("q" (funcall (evil-quit t)) ":q!"))
                :name "evil exits"))

;; Adapted From: https://github.com/mohsenil85/evil-evilified-state and https://github.com/syl20bnr/spacemacs
(use-package! evil-evilified-state :after evil)
#+end_src

***** god mode

#+call: hash("")

#+RESULTS:
: e1785de4290e315a93e1f67553025f69

#+name: e1785de4290e315a93e1f67553025f69
#+begin_src emacs-lisp
(use-package! god-mode
    :general
        (:keymaps 'override
            (general-chord "jj") 'jr/toggle-god
            (general-chord "';") 'god-execute-with-current-bindings)
    <<d3797553f252eabca75070bb3374df05(map="global-map", mode="god-local-mode", prefix="god")>>
        (which-key-enable-god-mode-support))
#+end_src

***** xah-fly-keys

#+call: hash("")

#+RESULTS:
: d34ff1a4219491ae3aee30b275fd9212

#+name: d34ff1a4219491ae3aee30b275fd9212
#+begin_src emacs-lisp
(use-package! xah-fly-keys
    :ryo
        ("m" :hydra
            '(modal-modes (:color blue)
                "A modal hydra!"
                ("`" nil "cancel")
                ("x" jr/toggle-xah "xah-fly-keys")) :name "modal modes")
    <<d3797553f252eabca75070bb3374df05(map="xah-fly-command-map", mode="xah-fly-keys", prefix="xah")>>)
#+end_src

***** objed

#+call: hash("")

#+RESULTS:
: 913cb77bdade14e8a517edbee7410b9a

#+name: 913cb77bdade14e8a517edbee7410b9a
#+begin_src emacs-lisp
(use-package! objed
    :general (:keymaps 'override (general-chord "ii") 'jr/toggle-objed)
    <<d3797553f252eabca75070bb3374df05(map="objed-map", mode="objed-mode", prefix="objed")>>)
#+end_src

***** kakoune

#+call: hash("")

#+RESULTS:
: c323d6a8a89df885749c42fd2a0bc858

#+name: c323d6a8a89df885749c42fd2a0bc858
#+begin_src emacs-lisp
(use-package! kakoune
    :hydra+ (modal-modes (:color blue) ("k" jr/toggle-kakoune "kakoune"))
    <<d3797553f252eabca75070bb3374df05(map="ryo-modal-mode-map", mode="ryo-modal-mode", prefix="kakoune")>>)
#+end_src

***** modalka

#+call: hash("")

#+RESULTS:
: 452c54e1a8e466b834ef13df6b9e238c

#+name: 452c54e1a8e466b834ef13df6b9e238c
#+begin_src emacs-lisp
(use-package! modalka
    :general (:keymaps 'override (general-chord "::") 'jr/toggle-modalka)
    <<d3797553f252eabca75070bb3374df05(map="modalka-mode-map", mode="modalka-mode", prefix="modalka")>>)
#+end_src

**** minibuffer

#+call: hash("")

#+RESULTS:
: d265ec51e2ef69de5f99d16281d47afa

#+name: d265ec51e2ef69de5f99d16281d47afa
#+begin_src emacs-lisp
<<b7ccdbd9b486c4c7b221f9a885c076dc>>

;; TODO: Split this into multiple `use-package!' instances using my new `hydra+' keyword
(ryo-modal-key "x" :hydra
      '(hydra-execute (:color blue)
            "A hydra for launching stuff!"
            ("c" counsel-M-x "counsel")
            ("h" helm-smex-major-mode-commands "helm smex major mode")
            ("s" helm-smex "helm smex")
            ("e" execute-extended-command "M-x")
            ("q" nil "cancel"))
            :name "execute order 65")

(defun jr/execute-order-65 nil (interactive)
    (jr/disable-all-modal-modes)
    (setq which-key-persistent-popup nil)
    (which-key--hide-popup))
(defun jr/after-quitting-minibuffer nil (interactive)
    (setq which-key-persistent-popup t)
    (jr/disable-all-modal-modes))
(advice-add #'counsel-M-x :before #'jr/execute-order-65)
(advice-add #'helm-smex-major-mode-commands :before #'jr/execute-order-65)
(advice-add #'helm-smex :before #'jr/execute-order-65)
(advice-add #'execute-extended-command :before #'jr/execute-order-65)
(advice-add #'doom-escape :after #'jr/after-quitting-minibuffer)
(advice-add #'keyboard-escape-quit :after #'jr/after-quitting-minibuffer)
(advice-add #'keyboard-quit :after #'jr/after-quitting-minibuffer)
(advice-add #'exit-minibuffer :after #'jr/after-quitting-minibuffer)

(general-def :keymaps '(
    minibuffer-local-keymap
    counsel-describe-map
    helm-buffer-map) "M-x" 'exit-minibuffer)
#+end_src

***** helm

#+call: hash("")

#+RESULTS:
: b7ccdbd9b486c4c7b221f9a885c076dc

#+name: helm
#+begin_src emacs-lisp
;; Adapted From: https://github.com/clemera/helm-ido-like-guide
(use-package! helm-ido-like
    :hook after-init
    :after
        (helm-swoop
        helm-flx
        helm-fuzzier
        helm-smex
        smex
        dash))
#+end_src

**** git

#+call: hash("")

#+RESULTS:
: 4027496311aaa540864858b0cc6d7781

#+name: 4027496311aaa540864858b0cc6d7781
#+begin_src emacs-lisp
<<d4938f230a99ce9f6c1fb2db970a897c>>
<<4fc4f48b4b076bf715c264568fa94979>>
;; (use-package! gitattributes-mode)
#+end_src

***** git-gutter

#+call: hash("")

#+RESULTS:
: d4938f230a99ce9f6c1fb2db970a897c

#+name: d4938f230a99ce9f6c1fb2db970a897c
#+begin_src emacs-lisp
(use-package! git-gutter
    :ryo ("g" :hydra
        '(hydra-git nil
            "A hydra for git!"
            ("`" nil "cancel" :color blue)
            ("j" git-gutter:next-hunk "next")
            ("k" git-gutter:previous-hunk "previous")
            ("d" git-gutter:popup-hunk "diff")
            ("s" git-gutter:stage-hunk "stage")
            ("r" git-gutter:revert-hunk "revert")
            ("m" git-gutter:mark-hunk "mark"))))
#+end_src

***** magit

#+call: hash("")

#+RESULTS:
: 4fc4f48b4b076bf715c264568fa94979

#+name: 4fc4f48b4b076bf715c264568fa94979
#+begin_src emacs-lisp
(use-package! magit
    :ryo ("g" :hydra+
        '(hydra-git nil
            "A hydra for git!"
            ("g" magit-status "magit" :color blue))))
#+end_src

**** buffer

#+call: hash("")

#+RESULTS:
: 0cbddafe342ce45b8c57c5feeb0a4237

#+name: 0cbddafe342ce45b8c57c5feeb0a4237
#+begin_src emacs-lisp
(remove-hook 'doom-first-buffer-hook #'global-hl-line-mode)

(defun display-startup-echo-area-message ()
  (jr/which-key-show-top-level))

(defun jr/src-mode-settings nil (interactive)
    (jr/disable-all-modal-modes)
    (focus-mode 1))

(defun jr/src-mode-exit nil (interactive)
    (winner-undo)
    (jr/disable-all-modal-modes))

;; Adapted From: http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
(defun jr/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or
defun, whichever applies first. Narrowing to
org-src-block actually calls `org-edit-src-code'.

With prefix P, don't widen, just narrow even if buffer
is already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning)
                           (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if
         ;; you don't want it.
         (cond ((ignore-errors (org-edit-src-code) t)
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun)))
    (jr/src-mode-settings))

;; Adapted From: https://github.com/syl20bnr/spacemacs/issues/13058#issuecomment-565741009
(advice-add #'org-edit-src-exit :after #'jr/src-mode-exit)
(advice-add #'org-edit-src-abort :after #'jr/src-mode-exit)

;; (use-package! writeroom-mode
;;     :general (:keymaps 'override (general-chord "zz") 'writeroom-mode)
;;     :custom (writeroom-fullscreen-effect t)
;;     :hook after-init)

(general-def
    :keymaps 'override
    (general-chord "zz") '+zen/toggle-fullscreen)

(use-package! focus
    ;; :hook (doom-init-ui . focus-mode)
    :custom
        (focus-mode-to-thing '(
            ;; (prog-mode . defun)
            (prog-mode . line)
            ;; (text-mode . sentence)
            (text-mode . line)
            (outline-mode . line))))

(use-package! rainbow-delimiters
    :hook ((prog-mode . rainbow-delimiters-mode)

        ;; Add more modes here
        ))

(when (featurep! :module parinfer) (use-package! parinfer-rust-mode
    :hook emacs-lisp-mode
    :init (setq parinfer-rust-auto-download t)
    :custom (parinfer-rust-check-before-enable nil)))

(use-package! yankpad
    :demand t
    :init
        (setq yankpad-file "./yankpad.org")
        (defun jr/yankpad-hercules-toggle nil (interactive))
    :general (:keymap 'override
        (general-chord "[[") 'jr/yankpad-hercules-toggle
        (general-chord "]]") 'yankpad-expand)
    :config (yankpad-map)
    :hercules
        (:show-funs #'jr/yankpad-hercules-show
            :hide-funs #'jr/yankpad-hercules-hide
            :toggle-funs #'jr/yankpad-hercules-toggle
            :keymap 'yankpad-keymap
            ;; :transient t
        ))

;; !!! THE ORDER HERE MATTERS! !!!
;; (add-hook! doom-init-ui
;;     (load! "fit-frame")
;;     (load! "autofit-frame")
;;     ;; (load! "buff-menu+")
;;     (load! "compile-")
;;     (load! "compile+")
;;     (load! "grep+")
;;     (load! "dired+")
;;     (load! "dired-details")
;;     (load! "dired-details+")
;;     (load! "doremi")
;;     (load! "hexrgb")
;;     (load! "frame-fns")
;;     (load! "faces+")
;;     (load! "doremi-frm")
;;     (load! "eyedropper")
;;     (load! "facemenu+")
;;     (load! "frame+")
;;     (load! "help+")
;;     (load! "info+")
;;     (load! "menu-bar+")
;;     (load! "mouse+")
;;     (load! "setup-keys")
;;     (load! "strings")
;;     ;; (load! "simple+")
;;     (load! "frame-cmds")
;;     (load! "thumb-frm")
;;     (load! "window+")
;;     (load! "zoom-frm")
;;     (load! "oneonone")
;;     (use-package! oneonone
;;         :demand t
;;         :hook (after-init . 1on1-emacs)
;;         :custom
;;             (1on1-minibuffer-frame-width 10000)
;;             (1on1-minibuffer-frame-height 10000)))
#+end_src

**** terminal

#+call: hash("")

#+RESULTS:
: 60045541f36fe02d96c14630bbe3966a

#+name: 60045541f36fe02d96c14630bbe3966a
#+begin_src emacs-lisp
;; <<4250ee7991caad7d0b372c862bb7ea60>>

;; (ansi-term-color-vector [unspecified "white" "red" "green" "yellow" "royal blue" "magenta" "cyan" "white"] t)
;; (ansi-color-names-vector [unspecified "white" "red" "green" "yellow" "royal blue" "magenta" "cyan" "white"] t)
;; (fringe-mode (quote (1 . 1)) nil (fringe))

;; <<89ad94f1851f27ff068c501e83a47f34>>

<<c10ad90226a9f6a574b7ceb93390d6e0>>

;; NOTE: Not working
;; <<4019311714fe7bab6950a6a8202833f6>>

;; <<cf7d26f4d252982b512c2d9108f5cb86>>

<<6703a9628cab6263b981af4274971ef2>>

#+end_src

***** term

#+call: hash("")

#+RESULTS:
: 4250ee7991caad7d0b372c862bb7ea60

#+name: 4250ee7991caad7d0b372c862bb7ea60
#+begin_src emacs-lisp
(use-package! term
    :general
        (:keymaps 'term-mode-map
            "C-c C-c" 'term-interrupt-subjob
            "C-m"     'term-send-raw
            "C-S-c"   'term-interrupt-subjob
            "M-,"     'term-send-input
            "M-b"     'term-send-backward-word
            "M-d"     'term-send-forward-kill-word
            "M-DEL"   'term-send-backward-kill-word
            "M-f"     'term-send-forward-word
            "M-o"     'term-send-backspace)
    :custom
        (term-unbind-key-list '("C-z" "C-x" "C-c" "C-h" "C-l" "<ESC>"))
        (term-buffer-maximum-size 16384)
        (term-default-bg-color "#000000") '(term-default-fg-color "#AAAAAA"))
#+end_src

***** vterm

#+call: hash("")

#+RESULTS:
: 89ad94f1851f27ff068c501e83a47f34

#+name: 89ad94f1851f27ff068c501e83a47f34
#+begin_src emacs-lisp
(use-package! vterm
    :custom
        (vterm-shell "/usr/bin/env xonsh")
        (vterm-always-compile-module t)
        (vterm-kill-buffer-on-exit t))
#+end_src

***** multi-term

#+call: hash("")

#+RESULTS:
: c10ad90226a9f6a574b7ceb93390d6e0

#+name: c10ad90226a9f6a574b7ceb93390d6e0
#+begin_src emacs-lisp
(use-package! multi-term
    :custom
        (multi-term-program "/usr/bin/env xonsh")
        (multi-term-scroll-show-maximum-output t))
#+end_src

***** emux

Mostly from [[Emux's After Installing Section][https://github.com/re5et/emux#after-installing]]:

#+call: hash("")

#+RESULTS:
: 4019311714fe7bab6950a6a8202833f6

#+name: 4019311714fe7bab6950a6a8202833f6
#+begin_src emacs-lisp
(use-package! emux-session
    :config
        (emux-completing-read-command (quote ido-completing-read))

        (defun jr/make-frame nil (interactive) (modify-frame-parameters (make-frame) ((name . "emux"))))
        (defun jr/select-emux nil (interactive) (select-frame-by-name "emux"))
    :general
        (:keymaps 'override
            ;; ""          'jr/make-frame
            ;; ""          'jr/select-emux
            "C-x c"     'emux-term-create
            "C-x P"     'emux-session-load-template)
        (:keymaps 'term-mode-map
            "C-S-p"     'previous-line
            "C-S-r"     'isearch-backward
            "C-S-s"     'isearch-forward
            "C-S-y"     'emux-term-yank
            "C-x -"     'emux-term-vsplit
            "C-x |"     'emux-term-hsplit
            "C-x B"     'emux-jump-to-buffer
            "C-x C-S-k" 'emux-session-destroy
            "C-x C"     'emux-screen-create
            "C-x c"     'emux-term-create
            "C-x K"     'emux-term-destroy
            "C-x M-s"   'emux-jump-to-screen
            "C-x P"     'emux-session-load-template
            "C-x R"     'emux-screen-rename
            "C-x r"     'emux-term-rename
            "C-x s"     'emux-screen-switch
            "C-x S"     'emux-session-switch
            "M-."       'comint-dynamic-complete

            ";" 'jr/emux-hercules-toggle)
    :hercules
        (:show-funs #'jr/emux-hercules-show
        :hide-funs #'jr/emux-hercules-hide
        :toggle-funs #'jr/emux-hercules-toggle
        :keymap 'term-mode-map
        ;; :transient t
        )
    ;; :hook (after-init . emux-mode)
        )
#+end_src

***** elscreen

#+call: hash("")

#+RESULTS:
: cf7d26f4d252982b512c2d9108f5cb86

#+name: cf7d26f4d252982b512c2d9108f5cb86
#+begin_src emacs-lisp
(use-package! elscreen
    :hook
        ;; (emacs-startup . elscreen-start)
        (after-init . elscreen-start)
    :custom
        ;; NOTE: Remember to escape the backslash
        (elscreen-prefix-key "C-S-\\")
    :hercules
        (:show-funs #'jr/elscreen-hercules-show
        :hide-funs #'jr/elscreen-hercules-hide
        :toggle-funs #'jr/elscreen-hercules-toggle
        :keymap 'elscreen-map
        ;; :transient t
        ))
#+end_src

***** escreen

#+call: hash("")

#+RESULTS:
: 6703a9628cab6263b981af4274971ef2

#+name: 6703a9628cab6263b981af4274971ef2
#+begin_src emacs-lisp
(load! "escreen")
(use-package! escreen
    :hook
        (after-init . escreen-install)
    :general
        (:keymaps 'override
            (general-chord "\\\\") 'jr/escreen-hercules-toggle)
    :config
        (defun jr/escreen-hercules-toggle nil(interactive))

        ;; Adapted From: https://tapoueh.org/blog/2009/09/escreen-integration/

        ;; add C-\ l to list screens with emphase for current one
        (defun escreen-get-active-screen-numbers-with-emphasis nil
        "what the name says"
        (interactive)
            (let ((escreens (escreen-get-active-screen-numbers))
                (emphased ""))

                (dolist (s escreens)
                    (setq emphased
                        (concat emphased (if (= escreen-current-screen-number s)
                            (propertize (number-to-string s)
                                ;;'face 'custom-variable-tag) " ")
                                'face 'info-title-3)
                                ;;'face 'font-lock-warning-face)
                                ;;'face 'secondary-selection)
                            (number-to-string s))
                        " ")))
                (message "escreen: active screens: %s" emphased)))

        ;; (global-set-key (kbd "C-\\ l") 'escreen-get-active-screen-numbers-with-emphasis)

        (defun dim:escreen-goto-last-screen nil (interactive)
            (escreen-goto-last-screen)
            (escreen-get-active-screen-numbers-with-emphasis))

        (defun dim:escreen-goto-prev-screen (&optional n) (interactive "p")
            (escreen-goto-prev-screen n)
            (escreen-get-active-screen-numbers-with-emphasis))

        (defun dim:escreen-goto-next-screen (&optional n) (interactive "p")
            (escreen-goto-next-screen n)
            (escreen-get-active-screen-numbers-with-emphasis))

        ;; (define-key escreen-map escreen-prefix-char 'dim:escreen-goto-last-screen)

        ;; (global-set-key (kbd "M-[") 'dim:escreen-goto-prev-screen)
        ;; (global-set-key (kbd "M-]") 'dim:escreen-goto-next-screen)
        ;; (global-set-key (kbd "C-\\ DEL") 'dim:escreen-goto-prev-screen)
        ;; (global-set-key (kbd "C-\\ SPC") 'dim:escreen-goto-next-screen)

        ;; (global-set-key '[s-mouse-4] 'dim:escreen-goto-prev-screen)
        ;; (global-set-key '[s-mouse-5] 'dim:escreen-goto-next-screen)

        ;; add support for C-\ from terms
        ;; (require 'term)
        ;; (define-key term-raw-map escreen-prefix-char escreen-map)
        ;; (define-key term-raw-map (kbd "M-[") 'dim:escreen-goto-prev-screen)
        ;; (define-key term-raw-map (kbd "M-]") 'dim:escreen-goto-next-screen)
    :hercules
        (:show-funs #'jr/escreen-hercules-show
        :hide-funs #'jr/escreen-hercules-hide
        :toggle-funs #'jr/escreen-hercules-toggle
        :keymap 'escreen-map
        ;; :transient t
        ))
#+end_src

**** window manager

#+call: hash("")

#+RESULTS:
: 8016354b1cb35e0587437e68baba41d8

#+name: 8016354b1cb35e0587437e68baba41d8
#+begin_src emacs-lisp
<<e77fd0ac138b6ad85673ea56d24b1cfe>>
#+end_src

***** exwm

#+call: hash("")

#+RESULTS:
: e77fd0ac138b6ad85673ea56d24b1cfe

#+name: e77fd0ac138b6ad85673ea56d24b1cfe
#+begin_src emacs-lisp
#+end_src

**** system

#+call: hash("")

#+RESULTS:
: 58043a4011d978b07d42cdbe23366db4

#+name: 58043a4011d978b07d42cdbe23366db4
#+begin_src emacs-lisp
<<8df0b63f0fd76eebb81255e9cb13e72f>>
<<a150a1120f94eead3d23c10b77f66dda>>
#+end_src

***** paths

Adapted from [[Ergoemacs' Emacs Lisp Code for Setting PATH and exec-path section][http://ergoemacs.org/emacs/emacs_env_var_paths.html]]:

# TODO: Combine the current `$PATH' with `exec-path'

#+call: hash("")

#+RESULTS:
: 8df0b63f0fd76eebb81255e9cb13e72f

#+name: 8df0b63f0fd76eebb81255e9cb13e72f
#+begin_src emacs-lisp
;; (eval `(let ((mypaths
;;     '(
;;         ,(concat "/home/" (getenv "USER") "/.nix-profile/bin")
;;         "/home/linuxbrew/.linuxbrew/bin"
;;         "/usr/bin"
;;         "/usr/sbin"
;;         ,(concat "/home/" (getenv "USER") "/.emacs.d/bin")
;;         ,(concat "/home/" (getenv "USER") "/.doom.d"))))
;;     ;; (setenv "PATH" (mapconcat 'identity mypaths ";") )
;;     (setq exec-path (append mypaths (list "." exec-directory)) )
;; ))
(use-package! exec-path-from-shell :demand t)
#+end_src

***** etc

#+call: hash("")

#+RESULTS:
: a150a1120f94eead3d23c10b77f66dda

#+name: a150a1120f94eead3d23c10b77f66dda
#+begin_src emacs-lisp
#+end_src

**** etc

#+call: hash("")

#+RESULTS:
: f6fbad3008b5eaa412ac27f2ba12bd42

#+name: f6fbad3008b5eaa412ac27f2ba12bd42
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)

;; From:
;; Answer: https://stackoverflow.com/questions/24832699/emacs-24-untabify-on-save-for-everything-except-makefiles
;; User: https://stackoverflow.com/users/2677392/ryan-m
(defun untabify-everything ()
  (untabify (point-min) (point-max)))
(defun untabify-everything-on-save ()
  (add-hook 'before-save-hook 'untabify-everything)
  nil)

;; Adapted From:
;; Answer: https://stackoverflow.com/a/24857101/10827766
;; User: https://stackoverflow.com/users/936762/dan
(defun untabify-except-makefiles nil
  "Replace tabs with spaces except in makefiles."
  (unless (derived-mode-p 'makefile-mode)
    (untabify-everything)))

(add-hook 'before-save-hook 'untabify-except-makefiles)

(general-auto-unbind-keys)
(when (featurep! :module spacemacs) (use-package! spacemacs
    :init (remove-hook 'org-load-hook #'+org-init-keybinds-h)
    :hook (doom-init-ui . spacemacs/home)))
#+end_src

*** packages.el

#+call: hash("")

#+RESULTS:
: c7d72604b58a79d5829fe508390b7d98

#+name: c7d72604b58a79d5829fe508390b7d98
#+begin_src emacs-lisp :tangle (jr/tangle-path)
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

(setq straight-disable-byte-compilation t)

;; From: https://github.com/clemera/helm-ido-like-guide
(package! helm-swoop)
(package! helm-flx)
(package! helm-fuzzier)
(package! helm-smex)
(package! smex)
(package! dash)
(package! s)

(package! help-macro+)
(package! help-fns+)
(package! help-mode+)

(package! use-package-chords)
(package! rainbow-delimiters)
(package! xah-fly-keys)
(package! multi-term)
(package! exwm)
(package! leaf)
(package! manage-minor-mode)
(package! kakoune)
(package! modalka)
(package! dockerfile-mode)
(package! ox-pandoc)
(package! focus)
(package! yankpad)

;; From: https://github.com/mohsenil85/evil-evilified-state and https://github.com/syl20bnr/spacemacs
(package! bind-map)

(package! hercules
    :recipe (:host gitlab :repo "jjzmajic/hercules.el" :branch "master"))
(package! vimrc-mode
    :recipe (:host github :repo "mcandre/vimrc-mode" :branch "master"))
(package! xonsh-mode
    :recipe (:host github :repo "seanfarley/xonsh-mode" :branch "master"))
(package! evil-evilified-state
    :recipe (:host github :repo "shadowrylander/evil-evilified-state" :branch "master"))
(package! helm-ido-like
    :recipe (:host github :repo "shadowrylander/helm-ido-like-guide" :branch "master"))
(package! ryo-modal
    :recipe (:host github :repo "kungsgeten/ryo-modal" :branch "master"))
(package! emux
    :recipe (:host github :repo "re5et/emux" :branch "master"))
(package! elscreen
    :recipe (:host github :repo "knu/elscreen" :branch "master"))
(package! exec-path-from-shell
    :recipe (:host github :repo "purcell/exec-path-from-shell" :branch "master"))
#+end_src

*** org-tangle

Adapted from: https://github.com/hlissner/doom-emacs/blob/develop/bin/org-tangle

#+call: hash("")

#+RESULTS:
: 83c3bfeb4ead1c7f196c8c263b4ba388

#+name: 83c3bfeb4ead1c7f196c8c263b4ba388
#+begin_src emacs-lisp :tangle (jr/tangle-path) :shebang "#!/usr/bin/env sh"
":"; exec emacs --quick --script "$0" -- "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-

(setq org-confirm-babel-evaluate nil)

(require 'cl-lib)
(require 'ox)
(require 'ob-tangle)

<<ed55930dc36029c49a46d842fd0ffc1b>>

(defun usage ()
  (with-temp-buffer
    (insert (format "%s %s [OPTIONS] [TARGETS...]\n"
                    "[1mUsage:[0m"
                    (file-name-nondirectory load-file-name))
            "\n"
            "A command line interface for tangling org-mode files. TARGETS can be\n"
            "files or folders (which are searched for org files recursively).\n"
            "\n"
            "This is useful for literate configs that rely on command line\n"
            "workflows to build it.\n"
            "\n"
            "[1mExample:[0m\n"
            "  org-tangle some-file.org\n"
            "  org-tangle literate/config/\n"
            "  org-tangle -p -l sh scripts.org > do_something.sh\n"
            "  org-tangle -p -l python -t tagA -t tagB file.org | python\n"
            "\n"
            "[1mOptions:[0m\n"
            "  -a --all\t\tTangle all blocks by default\n"
            "  -l --lang LANG\tOnly tangle blocks written in LANG\n"
            "  -p --print\t\tPrint tangled output to stdout than to files\n"
            "  -t --tag TAG\n"
            "     --and TAG\n"
            "     --or TAG\n"
            "    Lets you tangle org blocks by tag. You may have more than one\n"
            "    of these options.\n")
    (princ (buffer-string))))

(defun *org-babel-tangle (orig-fn &rest args)
  "Don't write tangled blocks to files, print them to stdout."
  (cl-letf (((symbol-function 'write-region)
             (lambda (start end filename &optional append visit lockname mustbenew)
               (princ (buffer-string)))))
    (apply orig-fn args)))

(defun *org-babel-tangle-collect-blocks (&optional language tangle-file)
  "Like `org-babel-tangle-collect-blocks', but will ignore blocks that are in
trees with the :notangle: tag."
  (let ((counter 0) last-heading-pos blocks)
    (org-babel-map-src-blocks (buffer-file-name)
      (let ((current-heading-pos
             (org-with-wide-buffer
              (org-with-limited-levels (outline-previous-heading)))))
        (if (eq last-heading-pos current-heading-pos) (cl-incf counter)
          (setq counter 1)
          (setq last-heading-pos current-heading-pos)))
      (unless (org-in-commented-heading-p)
        (require 'org)
        (let* ((tags (org-get-tags-at))
               (info (org-babel-get-src-block-info 'light))
               (src-lang (nth 0 info))
               (src-tfile (cdr (assq :tangle (nth 2 info)))))
          (cond ((member "notangle" tags))

                ((and (or or-tags and-tags)
                      (or (not and-tags)
                          (let ((a (cl-intersection and-tags tags :test #'string=))
                                (b and-tags))
                            (not (or (cl-set-difference a b :test #'equal)
                                     (cl-set-difference b a :test #'equal)))))
                      (or (not or-tags)
                          (cl-intersection or-tags tags :test #'string=))
                      t))

                ((or (not (or all-blocks src-tfile))
                     (string= src-tfile "no")  ; tangle blocks by default
                     (and tangle-file (not (equal tangle-file src-tfile)))
                     (and language (not (string= language src-lang)))))

                ;; Add the spec for this block to blocks under its language.
                ((let ((by-lang (assoc src-lang blocks))
                       (block (org-babel-tangle-single-block counter)))
                   (if by-lang
                       (setcdr by-lang (cons block (cdr by-lang)))
                     (push (cons src-lang (list block)) blocks))))))))
    ;; Ensure blocks are in the correct order.
    (mapcar (lambda (b) (cons (car b) (nreverse (cdr b)))) blocks)))
(advice-add #'org-babel-tangle-collect-blocks
            :override #'*org-babel-tangle-collect-blocks)

(defvar all-blocks nil)
(defvar and-tags nil)
(defvar or-tags nil)
(let (lang srcs and-tags or-tags)
  (pop argv)
  (while argv
    (let ((arg (pop argv)))
      (pcase arg
        ((or "-h" "--help")
         (usage)
         (error ""))
        ((or "-a" "--all")
         (setq all-blocks t))
        ((or "-l" "--lang")
         (setq lang (pop argv)))
        ((or "-p" "--print")
         (advice-add #'org-babel-tangle :around #'*org-babel-tangle))
        ((or "-t" "--tag" "--and")
         (push (pop argv) and-tags))
        ("--or"
         (push (pop argv) or-tags))
        ((guard (string-match-p "^--lang=" arg))
         (setq lang (cadr (split-string arg "=" t t))))
        ((guard (file-directory-p arg))
         (setq srcs
               (append (directory-files-recursively arg "\\.org$")
                       srcs)))
        ((guard (file-exists-p arg))
         (push arg srcs))
        (_ (error "Unknown option or file: %s" arg)))))

  (dolist (file srcs)
    (let ((backup (make-temp-file (file-name-base file) nil ".backup.org")))
      (unwind-protect
          ;; Prevent slow hooks from interfering
          (let (org-mode-hook)
            ;; We do the ol' switcheroo because `org-babel-tangle' writes
            ;; changes to the current file, which would be imposing on the user.
            (copy-file file backup t)
            (with-current-buffer (find-file-noselect file)
              ;; Tangling doesn't expand #+INCLUDE directives, so we do it
              ;; ourselves, since includes are so useful for literate configs!
              ;; (org-export-expand-include-keyword)
              (org-babel-tangle nil nil lang)))
        (ignore-errors (copy-file backup file t))
        (ignore-errors (delete-file backup)))))
  (kill-emacs 0))
#+end_src

*** org-tangle-functions.el

#+call: hash("")

#+RESULTS:
: ed55930dc36029c49a46d842fd0ffc1b

#+name: ed55930dc36029c49a46d842fd0ffc1b
#+begin_src emacs-lisp :tangle (jr/tangle-path)
(defun jr/get-header nil (interactive)
    (nth 4 (org-heading-components)))
(defun jr/tangle-path nil (interactive)
    (org-babel-lob-ingest "./README.org")
    (string-remove-prefix "/" (concat
        (org-format-outline-path (org-get-outline-path)) "/"
            (jr/get-header))))
(defun jr/tangle-oreo nil (interactive)
    (org-babel-lob-ingest "./strange.aiern.org")
    (jr/tangle-path))
(defun jr/get-theme-from-header nil (interactive)
    (string-remove-suffix "-theme.el" (jr/get-header)))
#+end_src
